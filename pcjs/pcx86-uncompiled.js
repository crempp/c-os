"use strict";

/**
 * @copyright https://www.pcjs.org/modules/shared/lib/defines.js (C) Jeff Parsons 2012-2018
 */

/**
 * @define {string}
 */
var APPVERSION = "";                    // this @define is overridden by the Closure Compiler with the version in machines.json

var XMLVERSION = null;                  // this is set in non-COMPILED builds by embedMachine() if a version number was found in the machine XML

var COPYRIGHT = "Copyright Â© 2012-2018 Jeff Parsons <Jeff@pcjs.org>";

var LICENSE = "License: GPL version 3 or later <http://gnu.org/licenses/gpl.html>";

var CSSCLASS = "pcjs";

/**
 * @define {string}
 */
var SITEURL = "http://localhost:8088";  // this @define is overridden by the Closure Compiler with "https://www.pcjs.org"

/**
 * @define {boolean}
 */
var COMPILED = false;                   // this @define is overridden by the Closure Compiler (to true)

/**
 * @define {boolean}
 */
var DEBUG = true;                       // this @define is overridden by the Closure Compiler (to false) to remove DEBUG-only code

/**
 * @define {boolean}
 */
var MAXDEBUG = false;                   // this @define is overridden by the Closure Compiler (to false) to remove MAXDEBUG-only code

/**
 * @define {boolean}
 */
var PRIVATE = false;                    // this @define is overridden by the Closure Compiler (to false) to enable PRIVATE code

/*
 * RS-232 DB-25 Pin Definitions, mapped to bits 1-25 in a 32-bit status value.
 *
 * SerialPorts in PCjs machines are considered DTE (Data Terminal Equipment), which means they should be "virtually"
 * connected to each other via a null-modem cable, which assumes the following cross-wiring:
 *
 *     G       1  <->  1        G       (Ground)
 *     TD      2  <->  3        RD      (Received Data)
 *     RD      3  <->  2        TD      (Transmitted Data)
 *     RTS     4  <->  5        CTS     (Clear To Send)
 *     CTS     5  <->  4        RTS     (Request To Send)
 *     DSR   6+8  <->  20       DTR     (Data Terminal Ready)
 *     SG      7  <->  7        SG      (Signal Ground)
 *     DTR    20  <->  6+8      DSR     (Data Set Ready + Carrier Detect)
 *     RI     22  <->  22       RI      (Ring Indicator)
 *
 * TODO: Move these definitions to a more appropriate shared file at some point.
 */
var RS232 = {
    RTS: {
        PIN:  4,
        MASK: 0x00000010
    },
    CTS: {
        PIN:  5,
        MASK: 0x00000020
    },
    DSR: {
        PIN:  6,
        MASK: 0x00000040
    },
    CD: {
        PIN:  8,
        MASK: 0x00000100
    },
    DTR: {
        PIN:  20,
        MASK: 0x00100000
    },
    RI: {
        PIN:  22,
        MASK: 0x00400000
    }
};

/*
 * NODE should be true if we're running under NodeJS (eg, command-line), false if not (eg, web browser)
 */
var NODE = false;


/**
 * @copyright https://www.pcjs.org/modules/shared/lib/diskapi.js (C) Jeff Parsons 2012-2018
 */

/*
 * Our "DiskIO API" looks like:
 *
 *      http://www.pcjs.org/api/v1/disk?action=open&volume=*10mb.img&mode=demandrw&chs=c:h:s&machine=xxx&user=yyy
 */
var DiskAPI = {
    ENDPOINT:       "/api/v1/disk",
    QUERY: {
        ACTION:     "action",   // value is one of DiskAPI.ACTION.*
        VOLUME:     "volume",   // value is path of a disk image
        MODE:       "mode",     // value is one of DiskAPI.MODE.*
        CHS:        "chs",      // value is cylinders:heads:sectors:bytes
        ADDR:       "addr",     // value is cylinder:head:sector:count
        MACHINE:    "machine",  // value is machine token
        USER:       "user",     // value is user ID
        DATA:       "data"      // value is data to be written
    },
    ACTION: {
        OPEN:       "open",
        READ:       "read",
        WRITE:      "write",
        CLOSE:      "close"
    },
    MODE: {
        LOCAL:      "local",    // this mode implies no API (at best, localStorage backing only)
        PRELOAD:    "preload",  // this mode implies use of the DumpAPI
        DEMANDRW:   "demandrw",
        DEMANDRO:   "demandro"
    },
    FAIL: {
        BADACTION:  "invalid action",
        BADUSER:    "invalid user",
        BADVOL:     "invalid volume",
        OPENVOL:    "unable to open volume",
        CREATEVOL:  "unable to create volume",
        WRITEVOL:   "unable to write volume",
        REVOKED:    "access revoked"
    }
};

/*
 * TODO: Eventually, our tools will need to support looking up disk formats by "model" rather than by raw disk size,
 * because obviously multiple disk geometries can yield the same raw disk size.  For each conflict that arises, I'll
 * probably create a fake (approximate) disk size entry above, and then create a mapping to that approximate size below.
 */
DiskAPI.MODELS = {
    "RL01": 5242880,
    "RL02": 10485760
};

DiskAPI.MBR = {
    PARTITIONS: {
        OFFSET:     0x1BE,
        ENTRY: {
            STATUS:         0x00,   // 1-byte (0x80 if active)
            CHS_FIRST:      0x01,   // 3-byte CHS specifier
            TYPE:           0x04,   // 1-byte TYPE (see below)
            CHS_LAST:       0x05,   // 3-byte CHS specifier
            LBA_FIRST:      0x08,   // 4-byte Logical Block Address
            LBA_TOTAL:      0x0C,   // 4-byte Logical Block Address
        },
        ENTRY_LENGTH:       0x10,
        STATUS: {
            ACTIVE:         0x80
        },
        TYPE: {
            EMPTY:          0x00,
            FAT12_PRIMARY:  0x01,   // DOS 2.0 and up (12-bit FAT)
            FAT16_PRIMARY:  0x04    // DOS 3.0 and up (16-bit FAT)
        }
    },
    SIG_OFFSET:     0x1FE,
    SIGNATURE:      0xAA55          // to be clear, the low byte (at offset 0x1FE) is 0x55 and the high byte (at offset 0x1FF) is 0xAA
};

/*
 * Boot sector offsets (and assorted constants) in DOS-compatible boot sectors (DOS 2.0 and up)
 *
 * WARNING: I've heard apocryphal stories about SIGNATURE being improperly reversed on some systems
 * (ie, 0x55AA instead 0xAA55) -- perhaps by a dyslexic programmer -- so be careful out there.
 */
DiskAPI.BOOT = {
    JMP_OPCODE:     0x000,      // 1 byte for a JMP opcode, followed by a 1 or 2-byte offset
    OEM_STRING:     0x003,      // 8 bytes
    SIG_OFFSET:     0x1FE,
    SIGNATURE:      0xAA55      // to be clear, the low byte (at offset 0x1FE) is 0x55 and the high byte (at offset 0x1FF) is 0xAA
};

/*
 * BIOS Parameter Block (BPB) offsets in DOS-compatible boot sectors (DOS 2.x and up)
 *
 * NOTE: DOS 2.x OEM documentation says that the words starting at offset 0x018 (TRACK_SECS, TOTAL_HEADS, and HIDDEN_SECS)
 * are optional, but even the DOS 2.0 FORMAT utility initializes all three of those words.  There may be some OEM media out
 * there with BPBs that are only valid up to offset 0x018, but I've not run across any media like that.
 *
 * DOS 3.20 added LARGE_SECS, but unfortunately, it was added as a 2-byte value at offset 0x01E.  DOS 3.31 decided
 * to make both HIDDEN_SECS and LARGE_SECS 4-byte values, which meant that LARGE_SECS had to move from 0x01E to 0x020.
 */
DiskAPI.BPB = {
    SECTOR_BYTES:   0x00B,      // 2 bytes: bytes per sector (eg, 0x200 or 512)
    CLUSTER_SECS:   0x00D,      // 1 byte: sectors per cluster (eg, 1)
    RESERVED_SECS:  0x00E,      // 2 bytes: reserved sectors; ie, # sectors preceding the first FAT--usually just the boot sector (eg, 1)
    TOTAL_FATS:     0x010,      // 1 byte: FAT copies (eg, 2)
    ROOT_DIRENTS:   0x011,      // 2 bytes: root directory entries (eg, 0x40 or 64) 0x40 * 0x20 = 0x800 (1 sector is 0x200 bytes, total of 4 sectors)
    TOTAL_SECS:     0x013,      // 2 bytes: number of sectors (eg, 0x140 or 320); if zero, refer to LARGE_SECS
    MEDIA_ID:       0x015,      // 1 byte: media ID (see DiskAPI.FAT.MEDIA_*); should also match the first byte of the FAT (aka FAT ID)
    FAT_SECS:       0x016,      // 2 bytes: sectors per FAT (eg, 1)
    TRACK_SECS:     0x018,      // 2 bytes: sectors per track (eg, 8)
    TOTAL_HEADS:    0x01A,      // 2 bytes: number of heads (eg, 1)
    HIDDEN_SECS:    0x01C,      // 2 bytes (DOS 2.x) or 4 bytes (DOS 3.31 and up): number of hidden sectors (always 0 for non-partitioned media)
    LARGE_SECS:     0x020       // 4 bytes (DOS 3.31 and up): number of sectors if TOTAL_SECS is zero
};

/*
 * Common (supported) diskette geometries.
 *
 * Each entry in GEOMETRIES is an array of values in "CHS" order:
 *
 *      [# cylinders, # heads, # sectors/track, # bytes/sector, media ID]
 *
 * If the 4th value is omitted, the sector size is assumed to be 512.  The order of these "geometric" values mirrors
 * the structure of our JSON-encoded disk images, which consist of an array of cylinders, each of which is an array of
 * heads, each of which is an array of sector objects.
 */
DiskAPI.GEOMETRIES = {
    163840:  [40,1,8,,0xFE],    // media ID 0xFE: 40 cylinders, 1 head (single-sided),   8 sectors/track, ( 320 total sectors x 512 bytes/sector ==  163840)
    184320:  [40,1,9,,0xFC],    // media ID 0xFC: 40 cylinders, 1 head (single-sided),   9 sectors/track, ( 360 total sectors x 512 bytes/sector ==  184320)
    327680:  [40,2,8,,0xFF],    // media ID 0xFF: 40 cylinders, 2 heads (double-sided),  8 sectors/track, ( 640 total sectors x 512 bytes/sector ==  327680)
    368640:  [40,2,9,,0xFD],    // media ID 0xFD: 40 cylinders, 2 heads (double-sided),  9 sectors/track, ( 720 total sectors x 512 bytes/sector ==  368640)
    737280:  [80,2,9,,0xF9],    // media ID 0xF9: 80 cylinders, 2 heads (double-sided),  9 sectors/track, (1440 total sectors x 512 bytes/sector ==  737280)
    1228800: [80,2,15,,0xF9],   // media ID 0xF9: 80 cylinders, 2 heads (double-sided), 15 sectors/track, (2400 total sectors x 512 bytes/sector == 1228800)
    1474560: [80,2,18,,0xF0],   // media ID 0xF0: 80 cylinders, 2 heads (double-sided), 18 sectors/track, (2880 total sectors x 512 bytes/sector == 1474560)
    2949120: [80,2,36,,0xF0],   // media ID 0xF0: 80 cylinders, 2 heads (double-sided), 36 sectors/track, (5760 total sectors x 512 bytes/sector == 2949120)
    /*
     * The following are some common disk sizes and their CHS values, since missing or bogus MBR and/or BPB values
     * might mislead us when attempting to determine the exact disk geometry.
     */
    10653696:[306,4,17],        // PC XT 10Mb hard drive (type 3)
    21411840:[615,4,17],        // PC AT 20Mb hard drive (type 2)
    /*
     * Assorted DEC disk formats.
     */
    256256:  [77, 1,26,128],    // RX01 single-platter diskette: 77 tracks, 1 head, 26 sectors/track, 128 bytes/sector, for a total of 256256 bytes
    2494464: [203,2,12,512],    // RK03 single-platter disk cartridge: 203 tracks, 2 heads, 12 sectors/track, 512 bytes/sector, for a total of 2494464 bytes
    5242880: [256,2,40,256],    // RL01K single-platter disk cartridge: 256 tracks, 2 heads, 40 sectors/track, 256 bytes/sector, for a total of 5242880 bytes
    10485760:[512,2,40,256]     // RL02K single-platter disk cartridge: 512 tracks, 2 heads, 40 sectors/track, 256 bytes/sector, for a total of 10485760 bytes
};

/*
 * Media ID (descriptor) bytes for DOS-compatible FAT-formatted disks (stored in the first byte of the FAT)
 */
DiskAPI.FAT = {
    MEDIA_160KB:    0xFE,       // 5.25-inch, 1-sided,  8-sector, 40-track
    MEDIA_180KB:    0xFC,       // 5.25-inch, 1-sided,  9-sector, 40-track
    MEDIA_320KB:    0xFF,       // 5.25-inch, 2-sided,  8-sector, 40-track
    MEDIA_360KB:    0xFD,       // 5.25-inch, 2-sided,  9-sector, 40-track
    MEDIA_720KB:    0xF9,       //  3.5-inch, 2-sided,  9-sector, 80-track
    MEDIA_1200KB:   0xF9,       //  3.5-inch, 2-sided, 15-sector, 80-track
    MEDIA_FIXED:    0xF8,       // fixed disk (aka hard drive)
    MEDIA_1440KB:   0xF0,       //  3.5-inch, 2-sided, 18-sector, 80-track
    MEDIA_2880KB:   0xF0        //  3.5-inch, 2-sided, 36-sector, 80-track
};

/*
 * Cluster constants for 12-bit FATs (CLUSNUM_FREE, CLUSNUM_RES and CLUSNUM_MIN are the same for all FATs)
 */
DiskAPI.FAT12 = {
    MAX_CLUSTERS:   4084,
    CLUSNUM_FREE:   0,          // this should NEVER appear in cluster chain (except at the start of an empty chain)
    CLUSNUM_RES:    1,          // reserved; this should NEVER appear in cluster chain
    CLUSNUM_MIN:    2,          // smallest valid cluster number
    CLUSNUM_MAX:    0xFF6,      // largest valid cluster number
    CLUSNUM_BAD:    0xFF7,      // bad cluster; this should NEVER appear in cluster chain
    CLUSNUM_EOC:    0xFF8       // end of chain (actually, anything from 0xFF8-0xFFF indicates EOC)
};

/*
 * Cluster constants for 16-bit FATs (CLUSNUM_FREE, CLUSNUM_RES and CLUSNUM_MIN are the same for all FATs)
 */
DiskAPI.FAT16 = {
    MAX_CLUSTERS:   65524,
    CLUSNUM_FREE:   0,          // this should NEVER appear in cluster chain (except at the start of an empty chain)
    CLUSNUM_RES:    1,          // reserved; this should NEVER appear in cluster chain
    CLUSNUM_MIN:    2,          // smallest valid cluster number
    CLUSNUM_MAX:    0xFFF6,     // largest valid cluster number
    CLUSNUM_BAD:    0xFFF7,     // bad cluster; this should NEVER appear in cluster chain
    CLUSNUM_EOC:    0xFFF8      // end of chain (actually, anything from 0xFFF8-0xFFFF indicates EOC)
};

/*
 * Directory Entry offsets (and assorted constants) in FAT disk images
 *
 * NOTE: Versions of DOS prior to 2.0 used INVALID exclusively to mark available directory entries; any entry marked
 * UNUSED was actually considered USED.  In DOS 2.0 and up, UNUSED was added to indicate that all remaining entries were
 * unused, relieving it from having to initialize the rest of the sectors in the directory cluster(s).  And in fact,
 * you will likely encounter garbage in subsequent directory sectors if you read beyond the first UNUSED entry.
 */
DiskAPI.DIRENT = {
    NAME:           0x000,      // 8 bytes
    EXT:            0x008,      // 3 bytes
    ATTR:           0x00B,      // 1 byte
    MODTIME:        0x016,      // 2 bytes
    MODDATE:        0x018,      // 2 bytes
    CLUSTER:        0x01A,      // 2 bytes
    SIZE:           0x01C,      // 4 bytes (typically zero for subdirectories)
    LENGTH:         0x20,       // 32 bytes total
    UNUSED:         0x00,       // indicates this and all subsequent directory entries are unused
    INVALID:        0xE5        // indicates this directory entry is unused
};

/*
 * Possible values for DIRENT.ATTR
 */
DiskAPI.ATTR = {
    READONLY:       0x01,       // PC-DOS 2.0 and up
    HIDDEN:         0x02,
    SYSTEM:         0x04,
    LABEL:          0x08,       // PC-DOS 2.0 and up
    SUBDIR:         0x10,       // PC-DOS 2.0 and up
    ARCHIVE:        0x20        // PC-DOS 2.0 and up
};



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/dumpapi.js (C) Jeff Parsons 2012-2018
 */

/*
 * Our "DiskDump API", such as it was, used to look like:
 *
 *      http://pcjs.org/bin/convdisk.php?disk=/disks/pc/dos/ibm/2.00/PCDOS200-DISK1.json&format=img
 *
 * To make it (a bit) more "REST-like", the above request now looks like:
 *
 *      https://www.pcjs.org/api/v1/dump?disk=/disks/pc/dos/ibm/2.00/PCDOS200-DISK1.json&format=img
 *
 * Similarly, our "FileDump API" used to look like:
 *
 *      http://pcjs.org/bin/convrom.php?rom=/devices/pc/rom/5150/1981-04-24/PCBIOS-REV1.rom&format=json
 *
 * and that request now looks like:
 *
 *      https://www.pcjs.org/api/v1/dump?file=/devices/pc/rom/5150/1981-04-24/PCBIOS-REV1.rom&format=json
 *
 * I don't think it makes sense to avoid "query" parameters, because blending the path of a disk image with the
 * the rest of the URL would be (a) confusing, and (b) more work to parse.
 */
var DumpAPI = {
    ENDPOINT:       "/api/v1/dump",
    QUERY: {
        DIR:        "dir",      // value is path of a directory (DiskDump only)
        DISK:       "disk",     // value is path of a disk image (DiskDump only)
        FILE:       "file",     // value is path of a ROM image file (FileDump only)
        IMG:        "img",      // alias for DISK
        PATH:       "path",     // value is path of a one or more files (DiskDump only)
        FORMAT:     "format",   // value is one of FORMAT values below
        COMMENTS:   "comments", // value is either "true" or "false"
        DECIMAL:    "decimal",  // value is either "true" to force all numbers to decimal, "false" or undefined otherwise
        MBHD:       "mbhd",     // value is hard drive size in Mb (formerly "mbsize") (DiskDump only) (DEPRECATED)
        SIZE:       "size"      // value is target disk size in Kb (supersedes "mbhd") (DiskDump only)
    },
    FORMAT: {
        JSON:       "json",     // default
        JSON_GZ:    "gz",       // gzip is currently used ONLY for compressed JSON
        DATA:       "data",     // same as "json", but built without JSON.stringify() (DiskDump only)
        HEX:        "hex",      // deprecated
        OCTAL:      "octal",    // displays data as octal words
        BYTES:      "bytes",    // displays data as hex bytes; normally used only when comments are enabled
        WORDS:      "words",    // displays data as hex words; normally used only when comments are enabled
        LONGS:      "longs",    // displays data as dwords
        IMG:        "img",      // returns the raw disk data (ie, using a Buffer object) (DiskDump only)
        ROM:        "rom"       // returns the raw file data (ie, using a Buffer object) (FileDump only)
    }
};

/*
 * Because we use an overloaded API endpoint (ie, one that's shared with the FileDump module), we must
 * also provide a list of commands which, when combined with the endpoint, define a unique request.
 */
DumpAPI.asDiskCommands = [DumpAPI.QUERY.DIR, DumpAPI.QUERY.DISK, DumpAPI.QUERY.PATH];
DumpAPI.asFileCommands = [DumpAPI.QUERY.FILE];



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/reportapi.js (C) Jeff Parsons 2012-2018
 */

var ReportAPI = {
    ENDPOINT:       "/api/v1/report",
    QUERY: {
        APP:        "app",
        VER:        "ver",
        URL:        "url",
        USER:       "user",
        TYPE:       "type",
        DATA:       "data"
    },
    TYPE: {
        BUG:        "bug"
    },
    RES: {
        OK:         "Thank you"
    }
};



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/userapi.js (C) Jeff Parsons 2012-2018
 */

/*
 * Examples of User API requests:
 *
 *      web.getHostOrigin() + UserAPI.ENDPOINT + '?' + UserAPI.QUERY.REQ + '=' + UserAPI.REQ.VERIFY + '&' + UserAPI.QUERY.USER + '=' + sUser;
 */
var UserAPI = {
    ENDPOINT:       "/api/v1/user",
    QUERY: {
        REQ:        "req",      // specifies a request
        USER:       "user",     // specifies a user ID
        STATE:      "state",    // specifies a state ID
        DATA:       "data"      // specifies state data
    },
    REQ: {
        CREATE:     "create",   // creates a user ID
        VERIFY:     "verify",   // requests verification of a user ID
        STORE:      "store",    // stores a machine state on the server
        LOAD:       "load"      // loads a machine state from the server
    },
    RES: {
        CODE:       "code",
        DATA:       "data"
    },
    CODE: {
        OK:         "ok",
        FAIL:       "error"
    },
    FAIL: {
        DUPLICATE:  "user already exists",
        VERIFY:     "unable to verify user",
        BADSTATE:   "invalid state parameter",
        NOSTATE:    "no machine state",
        BADLOAD:    "unable to load machine state",
        BADSTORE:   "unable to save machine state"
    }
};



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/keys.js (C) Jeff Parsons 2012-2018
 */

var Keys = {
    /*
     * Keys and/or key combinations that generate common ASCII codes.
     *
     * NOTE: If you're looking for a general-purpose ASCII code table, see Str.ASCII in strlib.js;
     * if something's missing, that's probably the more appropriate table to add it to.
     *
     * TODO: The Closure Compiler doesn't inline all references to these values, at least those with
     * quoted property names, which is why I've 'unquoted' as many of them as possible.  One solution
     * would be to add mnemonics for all of them, not just the non-printable ones (eg, SPACE instead
     * of ' ', AMP instead of '&', etc.)
     */
    ASCII: {
          BREAK:  0, CTRL_A:  1, CTRL_B:  2, CTRL_C:  3, CTRL_D:  4, CTRL_E:  5, CTRL_F:  6, CTRL_G:  7,
         CTRL_H:  8, CTRL_I:  9, CTRL_J: 10, CTRL_K: 11, CTRL_L: 12, CTRL_M: 13, CTRL_N: 14, CTRL_O: 15,
         CTRL_P: 16, CTRL_Q: 17, CTRL_R: 18, CTRL_S: 19, CTRL_T: 20, CTRL_U: 21, CTRL_V: 22, CTRL_W: 23,
         CTRL_X: 24, CTRL_Y: 25, CTRL_Z: 26, ESC:    27,
            ' ': 32,    '!': 33,    '"': 34,    '#': 35,    '$': 36,    '%': 37,    '&': 38,    "'": 39,
            '(': 40,    ')': 41,    '*': 42,    '+': 43,    ',': 44,    '-': 45,    '.': 46,    '/': 47,
            '0': 48,    '1': 49,    '2': 50,    '3': 51,    '4': 52,    '5': 53,    '6': 54,    '7': 55,
            '8': 56,    '9': 57,    ':': 58,    ';': 59,    '<': 60,    '=': 61,    '>': 62,    '?': 63,
            '@': 64,     A:  65,     B:  66,     C:  67,     D:  68,     E:  69,     F:  70,     G:  71,
             H:  72,     I:  73,     J:  74,     K:  75,     L:  76,     M:  77,     N:  78,     O:  79,
             P:  80,     Q:  81,     R:  82,     S:  83,     T:  84,     U:  85,     V:  86,     W:  87,
             X:  88,     Y:  89,     Z:  90,    '[': 91,    '\\':92,    ']': 93,    '^': 94,    '_': 95,
            '`': 96,     a:  97,     b:  98,     c:  99,     d: 100,     e: 101,     f: 102,     g: 103,
             h:  104,    i: 105,     j: 106,     k: 107,     l: 108,     m: 109,     n: 110,     o: 111,
             p:  112,    q: 113,     r: 114,     s: 115,     t: 116,     u: 117,     v: 118,     w: 119,
             x:  120,    y: 121,     z: 122,    '{':123,    '|':124,    '}':125,    '~':126,   DEL: 127
    },
    /*
     * Browser keyCodes we must pay particular attention to.  For the most part, these are non-alphanumeric
     * or function keys, some which may require special treatment (eg, preventDefault() if returning false on
     * the initial keyDown event is insufficient).
     *
     * keyCodes for most common ASCII keys can simply use the appropriate ASCII code above.
     *
     * Most of these represent non-ASCII keys (eg, the LEFT arrow key), yet for some reason, browsers defined
     * them using ASCII codes (eg, the LEFT arrow key uses the ASCII code for '%' or 37).
     */
    KEYCODE: {
        /* 0x08 */ BS:          8,          // BACKSPACE        (ASCII.CTRL_H)
        /* 0x09 */ TAB:         9,          // TAB              (ASCII.CTRL_I)
        /* 0x0A */ LF:          10,         // LINE-FEED        (ASCII.CTRL_J) (Some Windows-based browsers used to generate this via CTRL-ENTER)
        /* 0x0D */ CR:          13,         // CARRIAGE RETURN  (ASCII.CTRL_M)
        /* 0x10 */ SHIFT:       16,
        /* 0x11 */ CTRL:        17,
        /* 0x12 */ ALT:         18,
        /* 0x13 */ PAUSE:       19,         // PAUSE/BREAK
        /* 0x14 */ CAPS_LOCK:   20,
        /* 0x1B */ ESC:         27,
        /* 0x20 */ SPACE:       32,
        /* 0x21 */ PGUP:        33,
        /* 0x22 */ PGDN:        34,
        /* 0x23 */ END:         35,
        /* 0x24 */ HOME:        36,
        /* 0x25 */ LEFT:        37,
        /* 0x26 */ UP:          38,
        /* 0x27 */ RIGHT:       39,
        /* 0x27 */ FF_QUOTE:    39,
        /* 0x28 */ DOWN:        40,
        /* 0x2C */ FF_COMMA:    44,
        /* 0x2C */ PRTSC:       44,
        /* 0x2D */ INS:         45,
        /* 0x2E */ DEL:         46,
        /* 0x2E */ FF_PERIOD:   46,
        /* 0x2F */ FF_SLASH:    47,
        /* 0x30 */ ZERO:        48,
        /* 0x31 */ ONE:         49,
        /* 0x32 */ TWO:         50,
        /* 0x33 */ THREE:       51,
        /* 0x34 */ FOUR:        52,
        /* 0x35 */ FIVE:        53,
        /* 0x36 */ SIX:         54,
        /* 0x37 */ SEVEN:       55,
        /* 0x38 */ EIGHT:       56,
        /* 0x39 */ NINE:        57,
        /* 0x3B */ FF_SEMI:     59,
        /* 0x3D */ FF_EQUALS:   61,
        /* 0x5B */ CMD:         91,         // aka WIN
        /* 0x5B */ FF_LBRACK:   91,
        /* 0x5C */ FF_BSLASH:   92,
        /* 0x5D */ RCMD:        93,         // aka MENU
        /* 0x5D */ FF_RBRACK:   93,
        /* 0x60 */ NUM_0:       96,
        /* 0x60 */ NUM_INS:     96,
        /* 0x60 */ FF_BQUOTE:   96,
        /* 0x61 */ NUM_1:       97,
        /* 0x61 */ NUM_END:     97,
        /* 0x62 */ NUM_2:       98,
        /* 0x62 */ NUM_DOWN:    98,
        /* 0x63 */ NUM_3:       99,
        /* 0x63 */ NUM_PGDN:    99,
        /* 0x64 */ NUM_4:       100,
        /* 0x64 */ NUM_LEFT:    100,
        /* 0x65 */ NUM_5:       101,
        /* 0x65 */ NUM_CENTER:  101,
        /* 0x66 */ NUM_6:       102,
        /* 0x66 */ NUM_RIGHT:   102,
        /* 0x67 */ NUM_7:       103,
        /* 0x67 */ NUM_HOME:    103,
        /* 0x68 */ NUM_8:       104,
        /* 0x68 */ NUM_UP:      104,
        /* 0x69 */ NUM_9:       105,
        /* 0x69 */ NUM_PGUP:    105,
        /* 0x6A */ NUM_MUL:     106,
        /* 0x6B */ NUM_ADD:     107,
        /* 0x6D */ NUM_SUB:     109,
        /* 0x6E */ NUM_DEL:     110,        // aka PERIOD
        /* 0x6F */ NUM_DIV:     111,
        /* 0x70 */ F1:          112,
        /* 0x71 */ F2:          113,
        /* 0x72 */ F3:          114,
        /* 0x73 */ F4:          115,
        /* 0x74 */ F5:          116,
        /* 0x75 */ F6:          117,
        /* 0x76 */ F7:          118,
        /* 0x77 */ F8:          119,
        /* 0x78 */ F9:          120,
        /* 0x79 */ F10:         121,
        /* 0x7A */ F11:         122,
        /* 0x7B */ F12:         123,
        /* 0x90 */ NUM_LOCK:    144,
        /* 0x91 */ SCROLL_LOCK: 145,
        /* 0xAD */ FF_DASH:     173,
        /* 0xBA */ SEMI:        186,        // Firefox:  59 (FF_SEMI)
        /* 0xBB */ EQUALS:      187,        // Firefox:  61 (FF_EQUALS)
        /* 0xBC */ COMMA:       188,
        /* 0xBD */ DASH:        189,        // Firefox: 173 (FF_DASH)
        /* 0xBE */ PERIOD:      190,
        /* 0xBF */ SLASH:       191,
        /* 0xC0 */ BQUOTE:      192,
        /* 0xDB */ LBRACK:      219,
        /* 0xDC */ BSLASH:      220,
        /* 0xDD */ RBRACK:      221,
        /* 0xDE */ QUOTE:       222,
        /* 0xE0 */ FF_CMD:      224,        // Firefox only (used for both CMD and RCMD)
        //
        // The following biases use what I'll call Decimal Coded Binary or DCB (the opposite of BCD),
        // where the thousands digit is used to store the sum of "binary" digits 1 and/or 2 and/or 4.
        //
        // Technically, that makes it DCO (Decimal Coded Octal), but then again, BCD should have really
        // been called HCD (Hexadecimal Coded Decimal), so if "they" can take liberties, so can I.
        //
        // ONDOWN is a bias we add to browser keyCodes that we want to handle on "down" rather than on "press".
        //
        ONDOWN:                 1000,
        //
        // ONRIGHT is a bias we add to browser keyCodes that need to check for a "right" location (default is "left")
        //
        ONRIGHT:                2000,
        //
        // FAKE is a bias we add to signal these are fake keyCodes corresponding to internal keystroke combinations.
        // The actual values are for internal use only and merely need to be unique and used consistently.
        //
        FAKE:                   4000
    },
    /*
     * The set of values that a browser may store in the 'location' property of a keyboard event object
     * which we also support.
     */
    LOCATION: {
        LEFT:                   1,
        RIGHT:                  2,
        NUMPAD:                 3
    }
};

/*
 * Check the event object's 'location' property for a non-zero value for the following ONRIGHT keys.
 */
Keys.KEYCODE.NUM_CR = Keys.KEYCODE.CR + Keys.KEYCODE.ONRIGHT;


/*
 * Maps Firefox keyCodes to their more common keyCode counterparts; a number of entries in this table
 * are no longer valid (if indeed they ever were), so they've been commented out.  It's likely that I
 * simply extended this table to resolve additional differences in other browsers (ie, Opera), but without
 * browser-specific checks, it's not safe to perform all the mappings shown below.
 */
Keys.FF_KEYCODES = {};
Keys.FF_KEYCODES[Keys.KEYCODE.FF_SEMI]   = Keys.KEYCODE.SEMI;           //  59 -> 186
Keys.FF_KEYCODES[Keys.KEYCODE.FF_EQUALS] = Keys.KEYCODE.EQUALS;         //  61 -> 187
Keys.FF_KEYCODES[Keys.KEYCODE.FF_DASH]   = Keys.KEYCODE.DASH;           // 173 -> 189
Keys.FF_KEYCODES[Keys.KEYCODE.FF_CMD]    = Keys.KEYCODE.CMD;            // 224 -> 91
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_COMMA]  = Keys.KEYCODE.COMMA;       //  44 -> 188
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_PERIOD] = Keys.KEYCODE.PERIOD;      //  46 -> 190
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_SLASH]  = Keys.KEYCODE.SLASH;       //  47 -> 191
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_BQUOTE] = Keys.KEYCODE.BQUOTE;      //  96 -> 192
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_LBRACK  = Keys.KEYCODE.LBRACK;      //  91 -> 219
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_BSLASH] = Keys.KEYCODE.BSLASH;      //  92 -> 220
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_RBRACK] = Keys.KEYCODE.RBRACK;      //  93 -> 221
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_QUOTE]  = Keys.KEYCODE.QUOTE;       //  39 -> 222

/*
 * Maps non-ASCII keyCodes to their ASCII counterparts
 */
Keys.NONASCII_KEYCODES = {};
Keys.NONASCII_KEYCODES[Keys.KEYCODE.FF_DASH] = Keys.ASCII['-'];         // 173 -> 45
Keys.NONASCII_KEYCODES[Keys.KEYCODE.SEMI]    = Keys.ASCII[';'];         // 186 -> 59
Keys.NONASCII_KEYCODES[Keys.KEYCODE.EQUALS]  = Keys.ASCII['='];         // 187 -> 61
Keys.NONASCII_KEYCODES[Keys.KEYCODE.DASH]    = Keys.ASCII['-'];         // 189 -> 45
Keys.NONASCII_KEYCODES[Keys.KEYCODE.COMMA]   = Keys.ASCII[','];         // 188 -> 44
Keys.NONASCII_KEYCODES[Keys.KEYCODE.PERIOD]  = Keys.ASCII['.'];         // 190 -> 46
Keys.NONASCII_KEYCODES[Keys.KEYCODE.SLASH]   = Keys.ASCII['/'];         // 191 -> 47
Keys.NONASCII_KEYCODES[Keys.KEYCODE.BQUOTE]  = Keys.ASCII['`'];         // 192 -> 96
Keys.NONASCII_KEYCODES[Keys.KEYCODE.LBRACK]  = Keys.ASCII['['];         // 219 -> 91
Keys.NONASCII_KEYCODES[Keys.KEYCODE.BSLASH]  = Keys.ASCII['\\'];        // 220 -> 92
Keys.NONASCII_KEYCODES[Keys.KEYCODE.RBRACK]  = Keys.ASCII[']'];         // 221 -> 93
Keys.NONASCII_KEYCODES[Keys.KEYCODE.QUOTE]   = Keys.ASCII["'"];         // 222 -> 39

/*
 * Maps unshifted keyCodes to their shifted counterparts; to be used when a shift-key is down.
 * Alphabetic characters are handled in code, since they must also take CAPS_LOCK into consideration.
 */
Keys.SHIFTED_KEYCODES = {};
Keys.SHIFTED_KEYCODES[Keys.ASCII['1']]     = Keys.ASCII['!'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['2']]     = Keys.ASCII['@'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['3']]     = Keys.ASCII['#'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['4']]     = Keys.ASCII['$'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['5']]     = Keys.ASCII['%'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['6']]     = Keys.ASCII['^'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['7']]     = Keys.ASCII['&'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['8']]     = Keys.ASCII['*'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['9']]     = Keys.ASCII['('];
Keys.SHIFTED_KEYCODES[Keys.ASCII['0']]     = Keys.ASCII[')'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.SEMI]   = Keys.ASCII[':'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.EQUALS] = Keys.ASCII['+'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.COMMA]  = Keys.ASCII['<'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.DASH]   = Keys.ASCII['_'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.PERIOD] = Keys.ASCII['>'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.SLASH]  = Keys.ASCII['?'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.BQUOTE] = Keys.ASCII['~'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.LBRACK] = Keys.ASCII['{'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.BSLASH] = Keys.ASCII['|'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.RBRACK] = Keys.ASCII['}'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.QUOTE]  = Keys.ASCII['"'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.FF_DASH]   = Keys.ASCII['_'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.FF_EQUALS] = Keys.ASCII['+'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.FF_SEMI]   = Keys.ASCII[':'];



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/strlib.js (C) Jeff Parsons 2012-2018
 */

class Str {
    /**
     * isValidInt(s, base)
     *
     * The built-in parseInt() function has the annoying feature of returning a partial value (ie,
     * up to the point where it encounters an invalid character); eg, parseInt("foo", 16) returns 0xf.
     *
     * So it's best to use our own Str.parseInt() function, which will in turn use this function to
     * validate the entire string.
     *
     * @param {string} s is the string representation of some number
     * @param {number} [base] is the radix to use (default is 10); only 2, 8, 10 and 16 are supported
     * @return {boolean} true if valid, false if invalid (or the specified base isn't supported)
     */
    static isValidInt(s, base)
    {
        if (!base || base == 10) return s.match(/^-?[0-9]+$/) !== null;
        if (base == 16) return s.match(/^-?[0-9a-f]+$/i) !== null;
        if (base == 8) return s.match(/^-?[0-7]+$/) !== null;
        if (base == 2) return s.match(/^-?[01]+$/) !== null;
        return false;
    }

    /**
     * parseInt(s, base)
     *
     * This is a wrapper around the built-in parseInt() function.  Our wrapper recognizes certain prefixes
     * ('$' or "0x" for hex, '#' or "0o" for octal) and suffixes ('.' for decimal, 'h' for hex, 'y' for
     * binary), and then calls isValidInt() to ensure we don't convert strings that contain partial values;
     * see isValidInt() for details.
     *
     * The use of multiple prefix/suffix combinations is undefined (although for the record, we process
     * prefixes first).  We do NOT support the "0b" prefix to indicate binary UNLESS one or more commas are
     * also present (because "0b" is also a valid hex sequence), and we do NOT support a single leading zero
     * to indicate octal (because such a number could also be decimal or hex).  Any number of commas are
     * allowed; we remove them all before calling the built-in parseInt().
     *
     * More recently, we've added support for "^D", "^O", and "^B" prefixes to accommodate the base overrides
     * that the PDP-10's MACRO-10 assembly language supports (decimal, octal, and binary, respectively).
     * If this support turns out to adversely affect other debuggers, then it will have to be "conditionalized".
     * Similarly, we've added support for "K", "M", and "G" MACRO-10-style suffixes that add 3, 6, or 9 zeros
     * to the value to be parsed, respectively.
     *
     * @param {string} s is the string representation of some number
     * @param {number} [base] is the radix to use (default is 10); can be overridden by prefixes/suffixes
     * @return {number|undefined} corresponding value, or undefined if invalid
     */
    static parseInt(s, base)
    {
        let value;

        if (s) {
            if (!base) base = 10;

            let ch, chPrefix, chSuffix;
            let fCommas = (s.indexOf(',') > 0);
            if (fCommas) s = s.replace(/,/g, '');

            ch = chPrefix = s.charAt(0);
            if (chPrefix == '#') {
                base = 8;
                chPrefix = '';
            }
            else if (chPrefix == '$') {
                base = 16;
                chPrefix = '';
            }
            if (ch != chPrefix) {
                s = s.substr(1);
            }
            else {
                ch = chPrefix = s.substr(0, 2);
                if (chPrefix == '0b' && fCommas || chPrefix == '^B') {
                    base = 2;
                    chPrefix = '';
                }
                else if (chPrefix == '0o' || chPrefix == '^O') {
                    base = 8;
                    chPrefix = '';
                }
                else if (chPrefix == '^D') {
                    base = 10;
                    chPrefix = '';
                }
                else if (chPrefix == '0x') {
                    base = 16;
                    chPrefix = '';
                }
                if (ch != chPrefix) s = s.substr(2);
            }
            ch = chSuffix = s.slice(-1);
            if (chSuffix == 'Y' || chSuffix == 'y') {
                base = 2;
                chSuffix = '';
            }
            else if (chSuffix == '.') {
                base = 10;
                chSuffix = '';
            }
            else if (chSuffix == 'H' || chSuffix == 'h') {
                base = 16;
                chSuffix = '';
            }
            else if (chSuffix == 'K') {
                chSuffix = '000';
            }
            else if (chSuffix == 'M') {
                chSuffix = '000000';
            }
            else if (chSuffix == 'G') {
                chSuffix = '000000000';
            }
            if (ch != chSuffix) s = s.slice(0, -1) + chSuffix;
            /*
             * This adds support for the MACRO-10 binary shifting (Bn) suffix, which must be stripped from the
             * number before parsing, and then applied to the value after parsing.  If n is omitted, 35 is assumed,
             * which is a net shift of zero.  If n < 35, then a left shift of (35 - n) is required; if n > 35, then
             * a right shift of -(35 - n) is required.
             */
            let v, shift = 0;
            if (base <= 10) {
                let match = s.match(/(-?[0-9]+)B([0-9]*)/);
                if (match) {
                    s = match[1];
                    shift = 35 - ((match[2] || 35) & 0xff);
                }
            }
            if (Str.isValidInt(s, base) && !isNaN(v = parseInt(s, base))) {
                /*
                 * With the need to support larger (eg, 36-bit) integers, truncating to 32 bits is no longer helpful.
                 *
                 *      value = v|0;
                 */
                if (shift) {
                    /*
                     * Since binary shifting is a logical operation, and since shifting by division only works properly
                     * with positive numbers, we must convert a negative value to a positive value, by computing the two's
                     * complement.
                     */
                    if (v < 0) v += Math.pow(2, 36);
                    if (shift > 0) {
                        v *= Math.pow(2, shift);
                    } else {
                        v = Math.trunc(v / Math.pow(2, -shift));
                    }
                }
                value = v;
            }
        }
        return value;
    }

    /**
     * toBase(n, radix, cch, sPrefix, nGrouping)
     *
     * Displays the given number as an unsigned integer using the specified radix and number of digits.
     *
     * @param {number|*} n
     * @param {number} radix (ie, the base)
     * @param {number} cch (the desired number of digits)
     * @param {string} [sPrefix] (default is none)
     * @param {number} [nGrouping]
     * @return {string}
     */
    static toBase(n, radix, cch, sPrefix = "", nGrouping = 0)
    {
        /*
         * We can't rely entirely on isNaN(), because isNaN(null) returns false, and we can't rely
         * entirely on typeof either, because typeof Nan returns "number".  Sigh.
         *
         * Alternatively, we could mask and shift n regardless of whether it's null/undefined/NaN,
         * since JavaScript coerces such operands to zero, but I think there's "value" in seeing those
         * values displayed differently.
         */
        let s = "";
        if (isNaN(n) || typeof n != "number") {
            n = null;
        } else {
            /*
             * Callers that produced an input by dividing by a power of two rather than shifting (in order
             * to access more than 32 bits) may produce a fractional result, which ordinarily we would simply
             * ignore, but if the integer portion is zero and the sign is negative, we should probably treat
             * this value as a sign-extension.
             */
            if (n < 0 && n > -1) n = -1;
            /*
             * Negative values should be two's complemented according to the number of digits; for example,
             * 12 octal digits implies an upper limit 8^12.
             */
            if (n < 0) {
                n += Math.pow(radix, cch);
            }
            if (n >= Math.pow(radix, cch)) {
                cch = Math.ceil(Math.log(n) / Math.log(radix));
            }
        }
        let g = nGrouping || -1;
        while (cch-- > 0) {
            if (!g) {
                s = ',' + s;
                g = nGrouping;
            }
            if (n == null) {
                s = '?' + s;
            } else {
                let d = n % radix;
                d += (d >= 0 && d <= 9? 0x30 : 0x41 - 10);
                s = String.fromCharCode(d) + s;
                n = Math.trunc(n / radix);
            }
            g--;
        }
        return sPrefix + s;
    }

    /**
     * toBin(n, cch, nGrouping)
     *
     * Converts an integer to binary, with the specified number of digits (up to a maximum of 36).
     *
     * @param {number|*} n (supports integers up to 36 bits now)
     * @param {number} [cch] is the desired number of binary digits (0 or undefined for default of either 8, 18, or 36)
     * @param {number} [nGrouping]
     * @return {string} the binary representation of n
     */
    static toBin(n, cch, nGrouping)
    {
        if (!cch) {
            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.LN2) || 1;
            let v = Math.abs(n);
            if (v <= 0b11111111) {
                cch = 8;
            } else if (v <= 0b111111111111111111) {
                cch = 18;
            } else {
                cch = 36;
            }
        } else if (cch > 36) cch = 36;
        return Str.toBase(n, 2, cch, "", nGrouping);
    }

    /**
     * toBinBytes(n, cb, fPrefix)
     *
     * Converts an integer to binary, with the specified number of bytes (up to the default of 4).
     *
     * @param {number|null|undefined} n (interpreted as a 32-bit value)
     * @param {number} [cb] is the desired number of binary bytes (4 is both the default and the maximum)
     * @param {boolean} [fPrefix]
     * @return {string} the binary representation of n
     */
    static toBinBytes(n, cb, fPrefix)
    {
        let s = "";
        if (!cb || cb > 4) cb = 4;
        for (let i = 0; i < cb; i++) {
            if (s) s = ',' + s;
            s = Str.toBin(n & 0xff, 8) + s;
            n >>= 8;
        }
        return (fPrefix? "0b" : "") + s;
    }

    /**
     * toOct(n, cch, fPrefix)
     *
     * Converts an integer to octal, with the specified number of digits (default of 6; max of 12)
     *
     * You might be tempted to use the built-in n.toString(8) instead, but it doesn't zero-pad and it
     * doesn't properly convert negative values.  Moreover, if n is undefined, n.toString() will throw
     * an exception, whereas this function will return '?' characters.
     *
     * @param {number|*} n (supports integers up to 36 bits now)
     * @param {number} [cch] is the desired number of octal digits (0 or undefined for default of either 6, 8, or 12)
     * @param {boolean} [fPrefix]
     * @return {string} the octal representation of n
     */
    static toOct(n, cch, fPrefix)
    {
        if (!cch) {
            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.log(8)) || 1;
            let v = Math.abs(n);
            if (v <= 0o777777) {
                cch = 6;
            } else if (v <= 0o77777777) {
                cch = 8;
            } else {
                cch = 12;
            }
        } else if (cch > 12) cch = 12;
        return Str.toBase(n, 8, cch, fPrefix? "0o" : "");
    }

    /**
     * toDec(n, cch)
     *
     * Converts an integer to decimal, with the specified number of digits (default of 5; max of 11)
     *
     * You might be tempted to use the built-in n.toString(10) instead, but it doesn't zero-pad and it
     * doesn't properly convert negative values.  Moreover, if n is undefined, n.toString() will throw
     * an exception, whereas this function will return '?' characters.
     *
     * @param {number|*} n (supports integers up to 36 bits now)
     * @param {number} [cch] is the desired number of decimal digits (0 or undefined for default of either 5 or 11)
     * @return {string} the decimal representation of n
     */
    static toDec(n, cch)
    {
        if (!cch) {
            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.LN10) || 1;
            let v = Math.abs(n);
            if (v <= 99999) {
                cch = 5;
            } else {
                cch = 11;
            }
        } else if (cch > 11) cch = 11;
        return Str.toBase(n, 10, cch);
    }

    /**
     * toHex(n, cch, fPrefix)
     *
     * Converts an integer to hex, with the specified number of digits (default of 4 or 8, max of 9).
     *
     * You might be tempted to use the built-in n.toString(16) instead, but it doesn't zero-pad and it
     * doesn't properly convert negative values; for example, if n is -2147483647, then n.toString(16)
     * will return "-7fffffff" instead of "80000001".  Moreover, if n is undefined, n.toString() will
     * throw an exception, whereas this function will return '?' characters.
     *
     * NOTE: The following work-around (adapted from code found on StackOverflow) would be another solution,
     * taking care of negative values, zero-padding, and upper-casing, but not null/undefined/NaN values:
     *
     *      s = (n < 0? n + 0x100000000 : n).toString(16);
     *      s = "00000000".substr(0, 8 - s.length) + s;
     *      s = s.substr(0, cch).toUpperCase();
     *
     * @param {number|*} n (supports integers up to 36 bits now)
     * @param {number} [cch] is the desired number of hex digits (0 or undefined for default of either 4, 8, or 9)
     * @param {boolean} [fPrefix]
     * @return {string} the hex representation of n
     */
    static toHex(n, cch, fPrefix)
    {
        if (!cch) {
            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.log(16)) || 1;
            let v = Math.abs(n);
            if (v <= 0xffff) {
                cch = 4;
            } else if (v <= 0xffffffff) {
                cch = 8;
            } else {
                cch = 9;
            }
        } else if (cch > 9) cch = 9;
        return Str.toBase(n, 16, cch, fPrefix? "0x" : "");
    }

    /**
     * toHexByte(b)
     *
     * Alias for Str.toHex(b, 2, true)
     *
     * @param {number|null|undefined} b is a byte value
     * @return {string} the hex representation of b
     */
    static toHexByte(b)
    {
        return Str.toHex(b, 2, true);
    }

    /**
     * toHexWord(w)
     *
     * Alias for Str.toHex(w, 4, true)
     *
     * @param {number|null|undefined} w is a word (16-bit) value
     * @return {string} the hex representation of w
     */
    static toHexWord(w)
    {
        return Str.toHex(w, 4, true);
    }

    /**
     * toHexLong(l)
     *
     * Alias for Str.toHex(l, 8, true)
     *
     * @param {number|null|undefined} l is a dword (32-bit) value
     * @return {string} the hex representation of w
     */
    static toHexLong(l)
    {
        return Str.toHex(l, 8, true);
    }

    /**
     * getBaseName(sFileName, fStripExt)
     *
     * This is a poor-man's version of Node's path.basename(), which Node-only components should use instead.
     *
     * Note that if fStripExt is true, this strips ANY extension, whereas path.basename() strips the extension only
     * if it matches the second parameter (eg, path.basename("/foo/bar/baz/asdf/quux.html", ".html") returns "quux").
     *
     * @param {string} sFileName
     * @param {boolean} [fStripExt]
     * @return {string}
     */
    static getBaseName(sFileName, fStripExt)
    {
        let sBaseName = sFileName;

        let i = sFileName.lastIndexOf('/');
        if (i >= 0) sBaseName = sFileName.substr(i + 1);

        /*
         * This next bit is a kludge to clean up names that are part of a URL that includes unsightly query parameters.
         */
        i = sBaseName.indexOf('&');
        if (i > 0) sBaseName = sBaseName.substr(0, i);

        if (fStripExt) {
            i = sBaseName.lastIndexOf(".");
            if (i > 0) {
                sBaseName = sBaseName.substring(0, i);
            }
        }
        return sBaseName;
    }

    /**
     * getExtension(sFileName)
     *
     * This is a poor-man's version of Node's path.extname(), which Node-only components should use instead.
     *
     * Note that we EXCLUDE the period from the returned extension, whereas path.extname() includes it.
     *
     * @param {string} sFileName
     * @return {string} the filename's extension (in lower-case and EXCLUDING the "."), or an empty string
     */
    static getExtension(sFileName)
    {
        let sExtension = "";
        let i = sFileName.lastIndexOf(".");
        if (i >= 0) {
            sExtension = sFileName.substr(i + 1).toLowerCase();
        }
        return sExtension;
    }

    /**
     * endsWith(s, sSuffix)
     *
     * @param {string} s
     * @param {string} sSuffix
     * @return {boolean} true if s ends with sSuffix, false if not
     */
    static endsWith(s, sSuffix)
    {
        return s.indexOf(sSuffix, s.length - sSuffix.length) !== -1;
    }

    /**
     * escapeHTML(sHTML)
     *
     * @param {string} sHTML
     * @return {string} with HTML entities "escaped", similar to PHP's htmlspecialchars()
     */
    static escapeHTML(sHTML)
    {
        return sHTML.replace(/[&<>"']/g, function(m)
        {
            return Str.HTMLEscapeMap[m];
        });
    }

    /**
     * replace(sSearch, sReplace, s)
     *
     * The JavaScript replace() function ALWAYS interprets "$" specially in replacement strings, even when
     * the search string is NOT a RegExp; specifically:
     *
     *      $$  Inserts a "$"
     *      $&  Inserts the matched substring
     *      $`  Inserts the portion of the string that precedes the matched substring
     *      $'  Inserts the portion of the string that follows the matched substring
     *      $n  Where n is a positive integer less than 100, inserts the nth parenthesized sub-match string,
     *          provided the first argument was a RegExp object
     *
     * So, if a replacement string containing dollar signs passes through a series of replace() calls, untold
     * problems could result.  Hence, this function, which simply uses the replacement string as-is.
     *
     * Similar to the JavaScript replace() method (when sSearch is a string), this replaces only ONE occurrence
     * (ie, the FIRST occurrence); it might be nice to add options to replace the LAST occurrence and/or ALL
     * occurrences, but we'll revisit that later.
     *
     * @param {string} sSearch
     * @param {string} sReplace
     * @param {string} s
     * @return {string}
     */
    static replace(sSearch, sReplace, s)
    {
        let i = s.indexOf(sSearch);
        if (i >= 0) {
            s = s.substr(0, i) + sReplace + s.substr(i + sSearch.length);
        }
        return s;
    }

    /**
     * replaceAll(sSearch, sReplace, s)
     *
     * @param {string} sSearch
     * @param {string} sReplace
     * @param {string} s
     * @return {string}
     */
    static replaceAll(sSearch, sReplace, s)
    {
        let a = {};
        a[sSearch] = sReplace;
        return Str.replaceArray(a, s);
    }

    /**
     * replaceArray(a, s)
     *
     * @param {Object} a
     * @param {string} s
     * @return {string}
     */
    static replaceArray(a, s)
    {
        let sMatch = "";
        for (let k in a) {
            /*
             * As noted in:
             *
             *      http://www.regexguru.com/2008/04/escape-characters-only-when-necessary/
             *
             * inside character classes, only backslash, caret, hyphen and the closing bracket need to be
             * escaped.  And in fact, if you ensure that the closing bracket is first, the caret is not first,
             * and the hyphen is last, you can avoid escaping those as well.
             */
            k = k.replace(/([\\[\]*{}().+?|$])/g, "\\$1");
            sMatch += (sMatch? '|' : '') + k;
        }
        return s.replace(new RegExp('(' + sMatch + ')', "g"), function(m)
        {
            return a[m];
        });
    }

    /**
     * pad(s, cch, fPadLeft)
     *
     * NOTE: the maximum amount of padding currently supported is 40 spaces.
     *
     * @param {string} s is a string
     * @param {number} cch is desired length
     * @param {boolean} [fPadLeft] (default is padding on the right)
     * @return {string} the original string (s) with spaces padding it to the specified length
     */
    static pad(s, cch, fPadLeft)
    {
        let sPadding = "                                        ";
        return fPadLeft? (sPadding + s).slice(-cch) : (s + sPadding).slice(0, cch);
    }

    /**
     * sprintf(format, ...args)
     *
     * Copied from the CCjs project (https://github.com/jeffpar/ccjs/blob/master/lib/stdio.js) and extended.
     *
     * Far from complete, let alone sprintf-compatible, but it's adequate for the handful of sprintf-style format
     * specifiers that I use.
     *
     * TODO: The %c and %s specifiers support a negative width (for left-justified output), but the numeric specifiers
     * (eg, %d and %x) do not; they support only positive widths and right-justified output.  That's one of the more
     * glaring omissions at the moment.
     *
     * @param {string} format
     * @param {...} args
     * @return {string}
     */
    static sprintf(format, ...args)
    {
        let buffer = "";
        let aParts = format.split(/%([-+ 0#]*)([0-9]*|\*)(\.[0-9]+|)([hlL]?)([A-Za-z%])/);

        let iArg = 0, iPart;
        for (iPart = 0; iPart < aParts.length - 6; iPart += 6) {

            buffer += aParts[iPart];

            let arg = args[iArg++];
            let flags = aParts[iPart+1];
            let width = aParts[iPart+2];
            if (width == '*') {
                width = arg;
                arg = args[iArg++];
            } else {
                width = +width || 0;
            }
            let precision = aParts[iPart+3];
            precision = precision? +precision.substr(1) : -1;
            let prefix = aParts[iPart+4];
            let type = aParts[iPart+5];
            let ach = null, s;

            switch(type) {
            case 'd':
                /*
                 * We could use "arg |= 0", but there may be some value to supporting integers > 32 bits.
                 *
                 * Also, unlike the 'X' and 'x' hexadecimal cases, there's no need to explicitly check for a string
                 * arguments, because the call to trunc() automatically coerces any string value to a (decimal) number.
                 */
                arg = Math.trunc(arg);
                /* falls through */

            case 'f':
                s = Math.trunc(arg) + "";
                if (precision > 0) {
                    width -= (precision + 1);
                }
                if (s.length < width) {
                    if (flags.indexOf('0') >= 0) {
                        if (arg < 0) width--;
                        s = ("0000000000" + Math.abs(arg)).slice(-width);
                        if (arg < 0) s = '-' + s;
                    } else {
                        s = ("          " + s).slice(-width);
                    }
                }
                if (precision > 0) {
                    arg = Math.round((arg - Math.trunc(arg)) * Math.pow(10, precision));
                    s += '.' + ("0000000000" + Math.abs(arg)).slice(-precision);
                }
                buffer += s;
                break;

            case 'c':
                arg = String.fromCharCode(arg);
                /* falls through */

            case 's':
                if (typeof arg == "string") {
                    while (arg.length < width) {
                        if (flags.indexOf('-') >= 0) {
                            arg += ' ';
                        } else {
                            arg = ' ' + arg;
                        }
                    }
                }
                buffer += arg.toString();
                break;

            case 'X':
                ach = Str.HexUpperCase;
                /* falls through */

            case 'x':
                if (!ach) ach = Str.HexLowerCase;
                s = "";
                if (typeof arg == "string") {
                    /*
                     * Since we're advised to ALWAYS pass a radix to parseInt(), we must detect explicitly
                     * hex values ourselves, because using a radix of 10 with any "0x..." value always returns 0.
                     *
                     * And if the value CAN be interpreted as decimal, then we MUST interpret it as decimal, because
                     * we have sprintf() calls in /modules/pcx86/lib/testmon.js that depend on this code to perform
                     * decimal to hex conversion.  We're going to make our own rules here, since passing numbers in
                     * string form isn't part of the sprintf "spec".
                     */
                    arg = Number.parseInt(arg, arg.match(/(^0x|[a-f])/i)? 16 : 10);
                }
                do {
                    let d = arg & 0xf;
                    arg >>>= 4;
                    if (flags.indexOf('0') >= 0 || s == "" || d || arg) {
                        s = ach[d] + s;
                    } else if (width) {
                        s = ' ' + s;
                    }
                } while (--width > 0 || arg);
                buffer += s;
                break;

            default:
                /*
                 * The supported ANSI C set of types: "dioxXucsfeEgGpn%"
                 */
                buffer += "(unrecognized printf type %" + type + ")";
                break;
            }
        }

        buffer += aParts[iPart];
        return buffer;
    }

    /**
     * stripLeadingZeros(s, fPad)
     *
     * @param {string} s
     * @param {boolean} [fPad]
     * @return {string}
     */
    static stripLeadingZeros(s, fPad)
    {
        let cch = s.length;
        s = s.replace(/^0+([0-9A-F]+)$/i, "$1");
        if (fPad) s = Str.pad(s, cch, true);
        return s;
    }

    /**
     * trim(s)
     *
     * @param {string} s
     * @return {string}
     */
    static trim(s)
    {
        if (String.prototype.trim) {
            return s.trim();
        }
        return s.replace(/^\s+|\s+$/g, "");
    }

    /**
     * toASCIICode(b)
     *
     * @param {number} b
     * @return {string}
     */
    static toASCIICode(b)
    {
        let s;
        if (b != Str.ASCII.CR && b != Str.ASCII.LF) {
            s = Str.ASCIICodeMap[b];
        }
        if (s) {
            s = '<' + s + '>';
        } else {
            s = String.fromCharCode(b);
        }
        return s;
    }
}

/*
 * Map special characters to their HTML escape sequences.
 */
Str.HTMLEscapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
};

/*
 * Map "unprintable" ASCII codes to mnemonics, to more clearly see what's being printed.
 */
Str.ASCIICodeMap = {
    0x00:   "NUL",
    0x01:   "SOH",      // (CTRL_A) Start of Heading
    0x02:   "STX",      // (CTRL_B) Start of Text
    0x03:   "ETX",      // (CTRL_C) End of Text
    0x04:   "EOT",      // (CTRL_D) End of Transmission
    0x05:   "ENQ",      // (CTRL_E) Enquiry
    0x06:   "ACK",      // (CTRL_F) Acknowledge
    0x07:   "BEL",      // (CTRL_G) Bell
    0x08:   "BS",       // (CTRL_H) Backspace
    0x09:   "TAB",      // (CTRL_I) Horizontal Tab (aka HT)
    0x0A:   "LF",       // (CTRL_J) Line Feed (New Line)
    0x0B:   "VT",       // (CTRL_K) Vertical Tab
    0x0C:   "FF",       // (CTRL_L) Form Feed (New Page)
    0x0D:   "CR",       // (CTRL_M) Carriage Return
    0x0E:   "SO",       // (CTRL_N) Shift Out
    0x0F:   "SI",       // (CTRL_O) Shift In
    0x10:   "DLE",      // (CTRL_P) Data Link Escape
    0x11:   "XON",      // (CTRL_Q) Device Control 1 (aka DC1)
    0x12:   "DC2",      // (CTRL_R) Device Control 2
    0x13:   "XOFF",     // (CTRL_S) Device Control 3 (aka DC3)
    0x14:   "DC4",      // (CTRL_T) Device Control 4
    0x15:   "NAK",      // (CTRL_U) Negative Acknowledge
    0x16:   "SYN",      // (CTRL_V) Synchronous Idle
    0x17:   "ETB",      // (CTRL_W) End of Transmission Block
    0x18:   "CAN",      // (CTRL_X) Cancel
    0x19:   "EM",       // (CTRL_Y) End of Medium
    0x1A:   "SUB",      // (CTRL_Z) Substitute
    0x1B:   "ESC",      // Escape
    0x1C:   "FS",       // File Separator
    0x1D:   "GS",       // Group Separator
    0x1E:   "RS",       // Record Separator
    0x1F:   "US",       // Unit Separator
    0x7F:   "DEL"
};

/*
 * Refer to: https://en.wikipedia.org/wiki/Code_page_437
 */
Str.CP437ToUnicode = [
    '\u0000', '\u263A', '\u263B', '\u2665', '\u2666', '\u2663', '\u2660', '\u2022',
    '\u25D8', '\u25CB', '\u25D9', '\u2642', '\u2640', '\u266A', '\u266B', '\u263C',
    '\u25BA', '\u25C4', '\u2195', '\u203C', '\u00B6', '\u00A7', '\u25AC', '\u21A8',
    '\u2191', '\u2193', '\u2192', '\u2190', '\u221F', '\u2194', '\u25B2', '\u25BC',
    '\u0020', '\u0021', '\u0022', '\u0023', '\u0024', '\u0025', '\u0026', '\u0027',
    '\u0028', '\u0029', '\u002A', '\u002B', '\u002C', '\u002D', '\u002E', '\u002F',
    '\u0030', '\u0031', '\u0032', '\u0033', '\u0034', '\u0035', '\u0036', '\u0037',
    '\u0038', '\u0039', '\u003A', '\u003B', '\u003C', '\u003D', '\u003E', '\u003F',
    '\u0040', '\u0041', '\u0042', '\u0043', '\u0044', '\u0045', '\u0046', '\u0047',
    '\u0048', '\u0049', '\u004A', '\u004B', '\u004C', '\u004D', '\u004E', '\u004F',
    '\u0050', '\u0051', '\u0052', '\u0053', '\u0054', '\u0055', '\u0056', '\u0057',
    '\u0058', '\u0059', '\u005A', '\u005B', '\u005C', '\u005D', '\u005E', '\u005F',
    '\u0060', '\u0061', '\u0062', '\u0063', '\u0064', '\u0065', '\u0066', '\u0067',
    '\u0068', '\u0069', '\u006A', '\u006B', '\u006C', '\u006D', '\u006E', '\u006F',
    '\u0070', '\u0071', '\u0072', '\u0073', '\u0074', '\u0075', '\u0076', '\u0077',
    '\u0078', '\u0079', '\u007A', '\u007B', '\u007C', '\u007D', '\u007E', '\u2302',
    '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7',
    '\u00EA', '\u00EB', '\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5',
    '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
    '\u00FF', '\u00D6', '\u00DC', '\u00A2', '\u00A3', '\u00A5', '\u20A7', '\u0192',
    '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1', '\u00AA', '\u00BA',
    '\u00BF', '\u2310', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB',
    '\u2591', '\u2592', '\u2593', '\u2502', '\u2524', '\u2561', '\u2562', '\u2556',
    '\u2555', '\u2563', '\u2551', '\u2557', '\u255D', '\u255C', '\u255B', '\u2510',
    '\u2514', '\u2534', '\u252C', '\u251C', '\u2500', '\u253C', '\u255E', '\u255F',
    '\u255A', '\u2554', '\u2569', '\u2566', '\u2560', '\u2550', '\u256C', '\u2567',
    '\u2568', '\u2564', '\u2565', '\u2559', '\u2558', '\u2552', '\u2553', '\u256B',
    '\u256A', '\u2518', '\u250C', '\u2588', '\u2584', '\u258C', '\u2590', '\u2580',
    '\u03B1', '\u00DF', '\u0393', '\u03C0', '\u03A3', '\u03C3', '\u00B5', '\u03C4',
    '\u03A6', '\u0398', '\u03A9', '\u03B4', '\u221E', '\u03C6', '\u03B5', '\u2229',
    '\u2261', '\u00B1', '\u2265', '\u2264', '\u2320', '\u2321', '\u00F7', '\u2248',
    '\u00B0', '\u2219', '\u00B7', '\u221A', '\u207F', '\u00B2', '\u25A0', '\u00A0'
];

/*
 * TODO: Future home of a complete ASCII table.
 */
Str.ASCII = {
    LF:     0x0A,
    CR:     0x0D
};

Str.TYPES = {
    NULL:       0,
    BYTE:       1,
    WORD:       2,
    DWORD:      3,
    NUMBER:     4,
    STRING:     5,
    BOOLEAN:    6,
    OBJECT:     7,
    ARRAY:      8
};

Str.HexLowerCase = "0123456789abcdef";
Str.HexUpperCase = "0123456789ABCDEF";



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/usrlib.js (C) Jeff Parsons 2012-2018
 */

/**
 * @typedef {{
 *  mask:       number,
 *  shift:      number
 * }}
 */
var BitField;

/**
 * @typedef {Object.<BitField>}
 */
var BitFields;

class Usr {
    /**
     * binarySearch(a, v, fnCompare)
     *
     * @param {Array} a is an array
     * @param {number|string|Array|Object} v
     * @param {function((number|string|Array|Object), (number|string|Array|Object))} [fnCompare]
     * @return {number} the index of matching entry if non-negative, otherwise the index of the insertion point
     */
    static binarySearch(a, v, fnCompare)
    {
        let left = 0;
        let right = a.length;
        let found = 0;
        if (fnCompare === undefined) {
            fnCompare = function(a, b)
            {
                return a > b ? 1 : a < b ? -1 : 0;
            };
        }
        while (left < right) {
            let middle = (left + right) >> 1;
            let compareResult;
            compareResult = fnCompare(v, a[middle]);
            if (compareResult > 0) {
                left = middle + 1;
            } else {
                right = middle;
                found = !compareResult;
            }
        }
        return found ? left : ~left;
    }

    /**
     * binaryInsert(a, v, fnCompare)
     *
     * If element v already exists in array a, the array is unchanged (we don't allow duplicates); otherwise, the
     * element is inserted into the array at the appropriate index.
     *
     * @param {Array} a is an array
     * @param {number|string|Array|Object} v is the value to insert
     * @param {function((number|string|Array|Object), (number|string|Array|Object))} [fnCompare]
     */
    static binaryInsert(a, v, fnCompare)
    {
        let index = Usr.binarySearch(a, v, fnCompare);
        if (index < 0) {
            a.splice(-(index + 1), 0, v);
        }
    }

    /**
     * getTimestamp()
     *
     * @return {string} timestamp containing the current date and time ("yyyy-mm-dd hh:mm:ss")
     */
    static getTimestamp()
    {
        return Usr.formatDate("Y-m-d H:i:s");
    }

    /**
     * getMonthDays(nMonth, nYear)
     *
     * Note that if we're being called on behalf of the RTC, its year is always truncated to two digits (mod 100),
     * so we have no idea what century the year 0 might refer to.  When using the normal leap-year formula, 0 fails
     * the mod 100 test but passes the mod 400 test, so as far as the RTC is concerned, every century year is a leap
     * year.  Since we're most likely dealing with the year 2000, that's fine, since 2000 was also a leap year.
     *
     * TODO: There IS a separate CMOS byte that's supposed to be set to CMOS_ADDR.CENTURY_DATE; it's always BCD,
     * so theoretically it will contain values like 0x19 or 0x20 (for the 20th and 21st centuries, respectively), and
     * we could add that as another parameter to this function, to improve the accuracy, but that would go beyond what
     * a real RTC actually does.
     *
     * @param {number} nMonth (1-12)
     * @param {number} nYear (normally a 4-digit year, but it may also be mod 100)
     * @return {number} the maximum (1-based) day allowed for the specified month and year
     */
    static getMonthDays(nMonth, nYear)
    {
        let nDays = Usr.aMonthDays[nMonth - 1];
        if (nDays == 28) {
            if ((nYear % 4) === 0 && ((nYear % 100) || (nYear % 400) === 0)) {
                nDays++;
            }
        }
        return nDays;
    }

    /**
     * formatDate(sFormat, date)
     *
     * @param {string} sFormat (eg, "F j, Y", "Y-m-d H:i:s")
     * @param {Date} [date] (default is the current time)
     * @return {string}
     *
     * Supported identifiers in sFormat include:
     *
     *      a:  lowercase ante meridiem and post meridiem (am or pm)
     *      d:  day of the month, 2 digits with leading zeros (01,02,...,31)
     *      D:  3-letter day of the week ("Sun","Mon",...,"Sat")
     *      F:  month ("January","February",...,"December")
     *      g:  hour in 12-hour format, without leading zeros (1,2,...,12)
     *      h:  hour in 24-hour format, without leading zeros (0,1,...,23)
     *      H:  hour in 24-hour format, with leading zeros (00,01,...,23)
     *      i:  minutes, with leading zeros (00,01,...,59)
     *      j:  day of the month, without leading zeros (1,2,...,31)
     *      l:  day of the week ("Sunday","Monday",...,"Saturday")
     *      m:  month, with leading zeros (01,02,...,12)
     *      M:  3-letter month ("Jan","Feb",...,"Dec")
     *      n:  month, without leading zeros (1,2,...,12)
     *      s:  seconds, with leading zeros (00,01,...,59)
     *      y:  2-digit year (eg, 14)
     *      Y:  4-digit year (eg, 2014)
     *
     * For more inspiration, see: http://php.net/manual/en/function.date.php (of which we support ONLY a subset).
     */
    static formatDate(sFormat, date)
    {
        let sDate = "";
        if (!date) date = new Date();
        let iHour = date.getHours();
        let iDay = date.getDate();
        let iMonth = date.getMonth() + 1;
        for (let i = 0; i < sFormat.length; i++) {
            let ch;
            switch ((ch = sFormat.charAt(i))) {
            case 'a':
                sDate += (iHour < 12 ? "am" : "pm");
                break;
            case 'd':
                sDate += ('0' + iDay).slice(-2);
                break;
            case 'D':
                sDate += Usr.asDays[date.getDay()].substr(0, 3);
                break;
            case 'F':
                sDate += Usr.asMonths[iMonth - 1];
                break;
            case 'g':
                sDate += (!iHour ? 12 : (iHour > 12 ? iHour - 12 : iHour));
                break;
            case 'h':
                sDate += iHour;
                break;
            case 'H':
                sDate += ('0' + iHour).slice(-2);
                break;
            case 'i':
                sDate += ('0' + date.getMinutes()).slice(-2);
                break;
            case 'j':
                sDate += iDay;
                break;
            case 'l':
                sDate += Usr.asDays[date.getDay()];
                break;
            case 'm':
                sDate += ('0' + iMonth).slice(-2);
                break;
            case 'M':
                sDate += Usr.asMonths[iMonth - 1].substr(0, 3);
                break;
            case 'n':
                sDate += iMonth;
                break;
            case 's':
                sDate += ('0' + date.getSeconds()).slice(-2);
                break;
            case 'y':
                sDate += ("" + date.getFullYear()).slice(-2);
                break;
            case 'Y':
                sDate += date.getFullYear();
                break;
            default:
                sDate += ch;
                break;
            }
        }
        return sDate;
    }

    /**
     * defineBitFields(bfs)
     *
     * Prepares a bit field definition for use with getBitField() and setBitField(); eg:
     *
     *      let bfs = Usr.defineBitFields({num:20, count:8, btmod:1, type:3});
     *
     * The above defines a set of bit fields containing four fields: num (bits 0-19), count (bits 20-27), btmod (bit 28), and type (bits 29-31).
     *
     *      Usr.setBitField(bfs.num, n, 1);
     *
     * The above set bit field "bfs.num" in numeric variable "n" to the value 1.
     *
     * @param {Object} bfs
     * @return {BitFields}
     */
    static defineBitFields(bfs)
    {
        let bit = 0;
        for (let f in bfs) {
            let width = bfs[f];
            let mask = ((1 << width) - 1) << bit;
            bfs[f] = {mask: mask, shift: bit};
            bit += width;
        }
        return bfs;
    }

    /**
     * initBitFields(bfs, ...)
     *
     * @param {BitFields} bfs
     * @param {...number} var_args
     * @return {number} a value containing all supplied bit fields
     */
    static initBitFields(bfs, var_args)
    {
        let v = 0, i = 1;
        for (let f in bfs) {
            if (i >= arguments.length) break;
            v = Usr.setBitField(bfs[f], v, arguments[i++]);
        }
        return v;
    }

    /**
     * getBitField(bf, v)
     *
     * @param {BitField} bf
     * @param {number} v is a value containing bit fields
     * @return {number} the value of the bit field in v defined by bf
     */
    static getBitField(bf, v)
    {
        return (v & bf.mask) >> bf.shift;
    }

    /**
     * setBitField(bf, v, n)
     *
     * @param {BitField} bf
     * @param {number} v is a value containing bit fields
     * @param {number} n is a value to store in v in the bit field defined by bf
     * @return {number} updated v
     */
    static setBitField(bf, v, n)
    {
        return (v & ~bf.mask) | ((n << bf.shift) & bf.mask);
    }

    /**
     * indexOf(a, t, i)
     *
     * Use this instead of Array.prototype.indexOf() if you can't be sure the browser supports it.
     *
     * @param {Array} a
     * @param {*} t
     * @param {number} [i]
     * @returns {number}
     */
    static indexOf(a, t, i)
    {
        if (Array.prototype.indexOf) {
            return a.indexOf(t, i);
        }
        i = i || 0;
        if (i < 0) i += a.length;
        if (i < 0) i = 0;
        for (let n = a.length; i < n; i++) {
            if (i in a && a[i] === t) return i;
        }
        return -1;
    }
}

Usr.asDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
Usr.asMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
Usr.aMonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

/**
 * getTime()
 *
 * @return {number} the current time, in milliseconds
 */
Usr.getTime = Date.now || function() { return +new Date(); };



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/weblib.js (C) Jeff Parsons 2012-2018
 */


/*
 * According to http://www.w3schools.com/jsref/jsref_obj_global.asp, these are the *global* properties
 * and functions of JavaScript-in-the-Browser:
 *
 * Property             Description
 * ---
 * Infinity             A numeric value that represents positive/negative infinity
 * NaN                  "Not-a-Number" value
 * undefined            Indicates that a variable has not been assigned a value
 *
 * Function             Description
 * ---
 * decodeURI()          Decodes a URI
 * decodeURIComponent() Decodes a URI component
 * encodeURI()          Encodes a URI
 * encodeURIComponent() Encodes a URI component
 * escape()             Deprecated in version 1.5. Use encodeURI() or encodeURIComponent() instead
 * eval()               Evaluates a string and executes it as if it was script code
 * isFinite()           Determines whether a value is a finite, legal number
 * isNaN()              Determines whether a value is an illegal number
 * Number()             Converts an object's value to a number
 * parseFloat()         Parses a string and returns a floating point number
 * parseInt()           Parses a string and returns an integer
 * String()             Converts an object's value to a string
 * unescape()           Deprecated in version 1.5. Use decodeURI() or decodeURIComponent() instead
 *
 * And according to http://www.w3schools.com/jsref/obj_window.asp, these are the properties and functions
 * of the *window* object.
 *
 * Property             Description
 * ---
 * closed               Returns a Boolean value indicating whether a window has been closed or not
 * defaultStatus        Sets or returns the default text in the statusbar of a window
 * document             Returns the Document object for the window (See Document object)
 * frames               Returns an array of all the frames (including iframes) in the current window
 * history              Returns the History object for the window (See History object)
 * innerHeight          Returns the inner height of a window's content area
 * innerWidth           Returns the inner width of a window's content area
 * length               Returns the number of frames (including iframes) in a window
 * location             Returns the Location object for the window (See Location object)
 * name                 Sets or returns the name of a window
 * navigator            Returns the Navigator object for the window (See Navigator object)
 * opener               Returns a reference to the window that created the window
 * outerHeight          Returns the outer height of a window, including toolbars/scrollbars
 * outerWidth           Returns the outer width of a window, including toolbars/scrollbars
 * pageXOffset          Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window
 * pageYOffset          Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window
 * parent               Returns the parent window of the current window
 * screen               Returns the Screen object for the window (See Screen object)
 * screenLeft           Returns the x coordinate of the window relative to the screen
 * screenTop            Returns the y coordinate of the window relative to the screen
 * screenX              Returns the x coordinate of the window relative to the screen
 * screenY              Returns the y coordinate of the window relative to the screen
 * self                 Returns the current window
 * status               Sets or returns the text in the statusbar of a window
 * top                  Returns the topmost browser window
 *
 * Method               Description
 * ---
 * alert()              Displays an alert box with a message and an OK button
 * atob()               Decodes a base-64 encoded string
 * blur()               Removes focus from the current window
 * btoa()               Encodes a string in base-64
 * clearInterval()      Clears a timer set with setInterval()
 * clearTimeout()       Clears a timer set with setTimeout()
 * close()              Closes the current window
 * confirm()            Displays a dialog box with a message and an OK and a Cancel button
 * createPopup()        Creates a pop-up window
 * focus()              Sets focus to the current window
 * moveBy()             Moves a window relative to its current position
 * moveTo()             Moves a window to the specified position
 * open()               Opens a new browser window
 * print()              Prints the content of the current window
 * prompt()             Displays a dialog box that prompts the visitor for input
 * resizeBy()           Resizes the window by the specified pixels
 * resizeTo()           Resizes the window to the specified width and height
 * scroll()             This method has been replaced by the scrollTo() method.
 * scrollBy()           Scrolls the content by the specified number of pixels
 * scrollTo()           Scrolls the content to the specified coordinates
 * setInterval()        Calls a function or evaluates an expression at specified intervals (in milliseconds)
 * setTimeout()         Calls a function or evaluates an expression after a specified number of milliseconds
 * stop()               Stops the window from loading
 */

class Web {
    /**
     * log(s, type)
     *
     * For diagnostic output only.  DEBUG must be true (or "--debug" specified via the command-line)
     * for Component.log() to display anything.
     *
     * @param {string} [s] is the message text
     * @param {string} [type] is the message type
     */
    static log(s, type)
    {
        Component.log(s, type);
    }

    /**
     * notice(s, fPrintOnly, id)
     *
     * @param {string} s is the message text
     * @param {boolean} [fPrintOnly]
     * @param {string} [id] is the caller's ID, if any
     */
    static notice(s, fPrintOnly, id)
    {
        Component.notice(s, fPrintOnly, id);
    }

    /**
     * alertUser(sMessage)
     *
     * NOTE: Legacy function for older modules (eg, DiskDump); see Component.alertUser().
     *
     * @param {string} sMessage
     */
    static alertUser(sMessage)
    {
        if (window) {
            window.alert(sMessage);
        } else {
            Web.log(sMessage);
        }
    }

    /**
     * getResource(sURL, type, fAsync, done, progress)
     *
     * Request the specified resource (sURL), and once the request is complete, notify done().
     *
     * If fAsync is true, a done() callback should ALWAYS be supplied; otherwise, you'll have no
     * idea when the request is complete or what the response was.  done() is passed three parameters:
     *
     *      done(sURL, resource, nErrorCode)
     *
     * If nErrorCode is zero, resource should contain the requested data; otherwise, an error occurred.
     *
     * If type is set to a string, that string can be used to control the response format;
     * by default, the response format is plain text, but you can specify "arraybuffer" to request arbitrary
     * binary data, in which case the returned resource will be a ArrayBuffer rather than a string.
     *
     * @param {string} sURL
     * @param {string|Object|null} [type] (object for POST request, otherwise type of GET request)
     * @param {boolean} [fAsync] is true for an asynchronous request; false otherwise (MUST be set for IE)
     * @param {function(string,string,number)} [done]
     * @param {function(number)} [progress]
     * @return {Array|null} Array containing [resource, nErrorCode], or null if no response available (yet)
     */
    static getResource(sURL, type = "text", fAsync = false, done, progress)
    {
        let nErrorCode = 0, resource = null, response = null;

        if (typeof resources == 'object' && (resource = resources[sURL])) {
            if (done) done(sURL, resource, nErrorCode);
            return [resource, nErrorCode];
        }
        else if (fAsync && typeof resources == 'function') {
            resources(sURL, function(resource, nErrorCode)
            {
                if (done) done(sURL, resource, nErrorCode);
            });
            return response;
        }

        if (Web.getHost() == "pcjs:8088" || NODE) {
            /*
             * The larger resources that I've put on archive.pcjs.org are assumed to also be available locally
             * whenever the hostname is "pcjs" (or NODE is true); otherwise, use "localhost" when debugging locally.
             *
             * NOTE: http://archive.pcjs.org is currently redirected to https://s3-us-west-2.amazonaws.com/archive.pcjs.org
             */
            sURL = sURL.replace(/^(http:\/\/archive\.pcjs\.org|https:\/\/[a-z0-9-]+\.amazonaws\.com\/archive\.pcjs\.org)(\/.*)\/([^\/]*)$/, "$2/archive/$3");
            sURL = sURL.replace(/^https:\/\/jeffpar\.github\.io\/(pcjs-[a-z]+|private-[a-z]+)\/(.*)$/, "/$1/$2");
        }
        else {
            /*
             * TODO: Perhaps it's time for our code in netlib.js to finally add support for HTTPS; for now
             * though, it's just as well that the NODE environment assumes all resources are available locally.
             */
            sURL = sURL.replace(/^\/(pcjs-[a-z]+|private-[a-z]+)\//, "https://jeffpar.github.io/$1/");
        }


        let request = (window.XMLHttpRequest? new window.XMLHttpRequest() : new window.ActiveXObject("Microsoft.XMLHTTP"));
        let fArrayBuffer = false, fXHR2 = (typeof request.responseType === 'string');

        let callback = function() {
            if (request.readyState !== 4) {
                if (progress) progress(1);
                return null;
            }
            /*
             * The following line was recommended for WebKit, as a work-around to prevent the handler firing multiple
             * times when debugging.  Unfortunately, that's not the only XMLHttpRequest problem that occurs when
             * debugging, so I think the WebKit problem is deeper than that.  When we have multiple XMLHttpRequests
             * pending, any debugging activity means most of them simply get dropped on floor, so what may actually be
             * happening are mis-notifications rather than redundant notifications.
             *
             *      request.onreadystatechange = undefined;
             */
            /*
             * If the request failed due to, say, a CORS policy denial; eg:
             *
             *      Failed to load http://www.allbootdisks.com/downloads/Disks/Windows_95_Boot_Disk_Download48/Diskette%20Images/Windows95a.img:
             *      Redirect from 'http://www.allbootdisks.com/downloads/Disks/Windows_95_Boot_Disk_Download48/Diskette%20Images/Windows95a.img' to
             *      'http://www.allbootdisks.com/' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
             *      Origin 'http://pcjs:8088' is therefore not allowed access.
             *
             * and our request type was "arraybuffer", attempting to access responseText may trigger an exception; eg:
             *
             *      Uncaught DOMException: Failed to read the 'responseText' property from 'XMLHttpRequest': The value is only accessible if the object's
             *      'responseType' is '' or 'text' (was 'arraybuffer').
             *
             * We could tiptoe around these potential landmines, but the safest thing to do is wrap this code with try/catch.
             */
            try {
                resource = fArrayBuffer? request.response : request.responseText;
            } catch(err) {
                if (MAXDEBUG) Web.log("xmlHTTPRequest(" + sURL + ") exception: " + err.message);
            }
            /*
             * The normal "success" case is a non-null resource and an HTTP status code of 200, but when loading files from the
             * local file system (ie, when using the "file:" protocol), we have to be a bit more flexible.
             */
            if (resource != null && (request.status == 200 || !request.status && resource.length && Web.getHostProtocol() == "file:")) {
                if (MAXDEBUG) Web.log("xmlHTTPRequest(" + sURL + "): returned " + resource.length + " bytes");
            }
            else {
                nErrorCode = request.status || -1;
                Web.log("xmlHTTPRequest(" + sURL + "): error code " + nErrorCode);
            }
            if (progress) progress(2);
            if (done) done(sURL, resource, nErrorCode);
            return [resource, nErrorCode];
        };

        if (fAsync) {
            request.onreadystatechange = callback;
        }

        if (progress) progress(0);

        if (type && typeof type == "object") {
            let sPost = "";
            for (let p in type) {
                if (!type.hasOwnProperty(p)) continue;
                if (sPost) sPost += "&";
                sPost += p + '=' + encodeURIComponent(type[p]);
            }
            sPost = sPost.replace(/%20/g, '+');
            if (MAXDEBUG) Web.log("Web.getResource(POST " + sURL + "): " + sPost.length + " bytes");
            request.open("POST", sURL, fAsync);
            request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            request.send(sPost);
        } else {
            if (MAXDEBUG) Web.log("Web.getResource(GET " + sURL + ")");
            request.open("GET", sURL, fAsync);
            if (type == "arraybuffer") {
                if (fXHR2) {
                    fArrayBuffer = true;
                    request.responseType = type;
                } else {
                    request.overrideMimeType("text/plain; charset=x-user-defined");
                }
            }
            request.send();
        }

        if (!fAsync) {
            request.readyState = 4;     // this may already be set for synchronous requests, but I don't want to take any chances
            response = callback();
        }
        return response;
    }

    /**
     * parseMemoryResource(sURL, sData)
     *
     * This converts a variety of JSON-style data streams into an Object with the following properties:
     *
     *      aBytes
     *      aSymbols
     *      addrLoad
     *      addrExec
     *
     * If the source data contains a 'bytes' array, it's passed through to 'aBytes'; alternatively, if
     * it contains a 'words' array, the values are converted from 16-bit to 8-bit and stored in 'aBytes',
     * and if it contains a 'longs' array, the values are converted from 32-bit longs into bytes and
     * stored in 'aBytes'.
     *
     * Alternatively, if the source data contains a 'data' array, we simply pass that through to the output
     * object as:
     *
     *      aData
     *
     * @param {string} sURL
     * @param {string} sData
     * @return {Object|null} (resource)
     */
    static parseMemoryResource(sURL, sData)
    {
        let i;
        let resource = {
            aBytes: null,
            aSymbols: null,
            addrLoad: null,
            addrExec: null
        };

        if (sData.charAt(0) == "[" || sData.charAt(0) == "{") {
            try {
                let a, ib, data;

                if (sData.substr(0, 1) == "<") {    // if the "data" begins with a "<"...
                    /*
                     * Early server configs reported an error (via the nErrorCode parameter) if a tape URL was invalid,
                     * but more recent server configs now display a somewhat friendlier HTML error page.  The downside,
                     * however, is that the original error has been buried, and we've received "data" that isn't actually
                     * tape data.  So if the data we've received appears to be "HTML-like", we treat it as an error message.
                     */
                    throw new Error(sData);
                }

                /*
                 * TODO: IE9 is rather unfriendly and restrictive with regard to how much data it's willing to
                 * eval().  In particular, the 10Mb disk image we use for the Windows 1.01 demo config fails in
                 * IE9 with an "Out of memory" exception.  One work-around would be to chop the data into chunks
                 * (perhaps one track per chunk, using regular expressions) and then manually re-assemble it.
                 *
                 * However, it turns out that using JSON.parse(sDiskData) instead of eval("(" + sDiskData + ")")
                 * is a much easier fix. The only drawback is that we must first quote any unquoted property names
                 * and remove any comments, because while eval() was cool with them, JSON.parse() is more particular;
                 * the following RegExp replacements take care of those requirements.
                 *
                 * The use of hex values is something else that eval() was OK with, but JSON.parse() is not, and
                 * while I've stopped using hex values in DumpAPI responses (at least when "format=json" is specified),
                 * I can't guarantee they won't show up in "legacy" images, and there's no simple RegExp replacement
                 * for transforming hex values into decimal values, so I cop out and fall back to eval() if I detect
                 * any hex prefixes ("0x") in the sequence.  Ditto for error messages, which appear like so:
                 *
                 *      ["unrecognized disk path: test.img"]
                 */
                if (sData.indexOf("0x") < 0 && sData.indexOf("0o") < 0 && sData.substr(0, 2) != '["') {
                    data = JSON.parse(sData.replace(/([a-z]+):/gm, '"$1":').replace(/\/\/[^\n]*/gm, ""));
                } else {
                    data = eval("(" + sData + ")");
                }

                resource.addrLoad = data['load'];
                resource.addrExec = data['exec'];

                if (a = data['bytes']) {
                    resource.aBytes = a;
                }
                else if (a = data['words']) {
                    /*
                     * Convert all words into bytes
                     */
                    resource.aBytes = new Array(a.length * 2);
                    for (i = 0, ib = 0; i < a.length; i++) {
                        resource.aBytes[ib++] = a[i] & 0xff;
                        resource.aBytes[ib++] = (a[i] >> 8) & 0xff;

                    }
                }
                else if (a = data['longs']) {
                    /*
                     * Convert all dwords (longs) into bytes
                     */
                    resource.aBytes = new Array(a.length * 4);
                    for (i = 0, ib = 0; i < a.length; i++) {
                        resource.aBytes[ib++] = a[i] & 0xff;
                        resource.aBytes[ib++] = (a[i] >> 8) & 0xff;
                        resource.aBytes[ib++] = (a[i] >> 16) & 0xff;
                        resource.aBytes[ib++] = (a[i] >> 24) & 0xff;
                    }
                }
                else if (a = data['data']) {
                    resource.aData = a;
                }
                else {
                    resource.aBytes = data;
                }

                if (resource.aBytes) {
                    if (!resource.aBytes.length) {
                        Component.error("Empty resource: " + sURL);
                        resource = null;
                    }
                    else if (resource.aBytes.length == 1) {
                        Component.error(resource.aBytes[0]);
                        resource = null;
                    }
                }
                resource.aSymbols = data['symbols'];

            } catch (e) {
                Component.error("Resource data error (" + sURL + "): " + e.message);
                resource = null;
            }
        }
        else {
            /*
             * Parse the data manually; we assume it's a series of hex byte-values separated by whitespace.
             */
            let ab = [];
            let sHexData = sData.replace(/\n/gm, " ").replace(/ +$/, "");
            let asHexData = sHexData.split(" ");
            for (i = 0; i < asHexData.length; i++) {
                let n = parseInt(asHexData[i], 16);
                if (isNaN(n)) {
                    Component.error("Resource data error (" + sURL + "): invalid hex byte (" + asHexData[i] + ")");
                    break;
                }
                ab.push(n & 0xff);
            }
            if (i == asHexData.length) resource.aBytes = ab;
        }
        return resource;
    }

    /**
     * sendReport(sApp, sVer, sURL, sUser, sType, sReport, sHostName)
     *
     * Send a report (eg, bug report) to the server.
     *
     * @param {string} sApp (eg, "PCjs")
     * @param {string} sVer (eg, "1.02")
     * @param {string} sURL (eg, "/devices/pc/machine/5150/mda/64kb/machine.xml")
     * @param {string} sUser (ie, the user key, if any)
     * @param {string} sType (eg, "bug"); one of ReportAPI.TYPE.*
     * @param {string} sReport (eg, unparsed state data)
     * @param {string} [sHostName] (default is SITEURL)
     */
    static sendReport(sApp, sVer, sURL, sUser, sType, sReport, sHostName)
    {
        let dataPost = {};
        dataPost[ReportAPI.QUERY.APP] = sApp;
        dataPost[ReportAPI.QUERY.VER] = sVer;
        dataPost[ReportAPI.QUERY.URL] = sURL;
        dataPost[ReportAPI.QUERY.USER] = sUser;
        dataPost[ReportAPI.QUERY.TYPE] = sType;
        dataPost[ReportAPI.QUERY.DATA] = sReport;
        let sReportURL = (sHostName? sHostName : SITEURL) + ReportAPI.ENDPOINT;
        Web.getResource(sReportURL, dataPost, true);
    }

    /**
     * getHost()
     *
     * This is like getHostName() but with the port number, if any.
     *
     * @return {string}
     */
    static getHost()
    {
        return (window? window.location.host : "localhost");
    }

    /**
     * getHostName()
     *
     * @return {string}
     */
    static getHostName()
    {
        return (window? window.location.hostname : "localhost");
    }

    /**
     * getHostOrigin()
     *
     * This could also be implemented with window.location.origin, but that wasn't originally available in all browsers.
     *
     * @return {string}
     */
    static getHostOrigin()
    {
        return (window? window.location.protocol + "//" + window.location.host : SITEURL);
    }

    /**
     * getHostProtocol()
     *
     * @return {string}
     */
    static getHostProtocol()
    {
        return (window? window.location.protocol : "file:");
    }

    /**
     * getHostURL()
     *
     * @return {string|null}
     */
    static getHostURL()
    {
        return (window? window.location.href : null);
    }

    /**
     * getUserAgent()
     *
     * @return {string}
     */
    static getUserAgent()
    {
        return (window? window.navigator.userAgent : "");
    }

    /**
     * hasLocalStorage
     *
     * true if localStorage support exists, is enabled, and works; false otherwise
     *
     * @return {boolean}
     */
    static hasLocalStorage()
    {
        if (Web.fLocalStorage == null) {
            let f = false;
            if (window) {
                try {
                    window.localStorage.setItem(Web.sLocalStorageTest, Web.sLocalStorageTest);
                    f = (window.localStorage.getItem(Web.sLocalStorageTest) == Web.sLocalStorageTest);
                    window.localStorage.removeItem(Web.sLocalStorageTest);
                } catch (e) {
                    Web.logLocalStorageError(e);
                    f = false;
                }
            }
            Web.fLocalStorage = f;
        }
        return Web.fLocalStorage;
    }

    /**
     * logLocalStorageError(e)
     *
     * @param {Error} e is an exception
     */
    static logLocalStorageError(e)
    {
        Web.log(e.message, "localStorage error");
    }

    /**
     * getLocalStorageItem(sKey)
     *
     * Returns the requested key value, or null if the key does not exist, or undefined if localStorage is not available
     *
     * @param {string} sKey
     * @return {string|null|undefined} sValue
     */
    static getLocalStorageItem(sKey)
    {
        let sValue;
        if (window) {
            try {
                sValue = window.localStorage.getItem(sKey);
            } catch (e) {
                Web.logLocalStorageError(e);
            }
        }
        return sValue;
    }

    /**
     * setLocalStorageItem(sKey, sValue)
     *
     * @param {string} sKey
     * @param {string} sValue
     * @return {boolean} true if localStorage is available, false if not
     */
    static setLocalStorageItem(sKey, sValue)
    {
        try {
            window.localStorage.setItem(sKey, sValue);
            return true;
        } catch (e) {
            Web.logLocalStorageError(e);
        }
        return false;
    }

    /**
     * removeLocalStorageItem(sKey)
     *
     * @param {string} sKey
     */
    static removeLocalStorageItem(sKey)
    {
        try {
            window.localStorage.removeItem(sKey);
        } catch (e) {
            Web.logLocalStorageError(e);
        }
    }

    /**
     * getLocalStorageKeys()
     *
     * @return {Array}
     */
    static getLocalStorageKeys()
    {
        let a = [];
        try {
            for (let i = 0, c = window.localStorage.length; i < c; i++) {
                a.push(window.localStorage.key(i));
            }
        } catch (e) {
            Web.logLocalStorageError(e);
        }
        return a;
    }

    /**
     * reloadPage()
     */
    static reloadPage()
    {
        if (window) window.location.reload();
    }

    /**
     * isUserAgent(s)
     *
     * Check the browser's user-agent string for the given substring; "iOS" and "MSIE" are special values you can
     * use that will match any iOS or MSIE browser, respectively (even IE11, in the case of "MSIE").
     *
     * 2013-11-06: In a questionable move, MSFT changed the user-agent reported by IE11 on Windows 8.1, eliminating
     * the "MSIE" string (which MSDN calls a "version token"; see http://msdn.microsoft.com/library/ms537503.aspx);
     * they say "public websites should rely on feature detection, rather than browser detection, in order to design
     * their sites for browsers that don't support the features used by the website." So, in IE11, we get a user-agent
     * that tries to fool apps into thinking the browser is more like WebKit or Gecko:
     *
     *      Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko
     *
     * That's a nice idea, but in the meantime, they hosed the XSL transform code in embed.js, which contained
     * some very critical browser-specific code; turning on IE's "Compatibility Mode" didn't help either, because
     * that's a sledgehammer solution which restores the old user-agent string but also disables other features like
     * HTML5 canvas support. As an interim solution, I'm treating any "MSIE" check as a check for either "MSIE" or
     * "Trident".
     *
     * UPDATE: I've since found ways to make the code in embed.js more browser-agnostic, so for now, there's isn't
     * any code that cares about "MSIE", but I've left the change in place, because I wouldn't be surprised if I'll
     * need more IE-specific code in the future, perhaps for things like copy/paste functionality, or mouse capture.
     *
     * @param {string} s is a substring to search for in the user-agent; as noted above, "iOS" and "MSIE" are special values
     * @return {boolean} is true if the string was found, false if not
     */
    static isUserAgent(s)
    {
        if (window) {
            let userAgent = Web.getUserAgent();
            /*
             * Here's one case where we have to be careful with Component, because when isUserAgent() is called by
             * the init code below, component.js hasn't been loaded yet.  The simple solution for now is to remove the call.
             *
             *      Web.log("agent: " + userAgent);
             *
             * And yes, it would be pointless to use the conditional (?) operator below, if not for the Google Closure
             * Compiler (v20130823) failing to detect the entire expression as a boolean.
             */
            return s == "iOS" && !!userAgent.match(/(iPod|iPhone|iPad)/) && !!userAgent.match(/AppleWebKit/) || s == "MSIE" && !!userAgent.match(/(MSIE|Trident)/) || (userAgent.indexOf(s) >= 0);
        }
        return false;
    }

    /**
     * isMobile(sDevice)
     *
     * Checks the URL for a "mobile" parameter, and failing that, checks the browser's user-agent string for the
     * substring "Mobi", as per Mozilla recommendation:
     *
     *      https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent
     *
     * @param {string} [sDevice] (eg, "iPad" to check for iPad, or "!iPad" to specifically exclude it)
     * @return {boolean} is true if the browser appears to be a mobile (ie, non-desktop) web browser, false if not
     */
    static isMobile(sDevice)
    {
        let sMobile = Web.getURLParm("mobile");
        if (sMobile) return sMobile == "true";
        if (Web.isUserAgent("Mobi")) {
            if (!sDevice) return true;
            let fInvert = sDevice[0] == '!';
            if (fInvert) sDevice = sDevice.substr(1);
            return Web.isUserAgent(sDevice) != fInvert;
        }
        return false;
    }

    /**
     * findProperty(obj, sProp, sSuffix)
     *
     * If both sProp and sSuffix are set, then any browser-specific prefixes are inserted between sProp and sSuffix,
     * and if a match is found, it is returned without sProp.
     *
     * For example, if findProperty(document, 'on', 'fullscreenchange') discovers that 'onwebkitfullscreenchange' exists,
     * it will return 'webkitfullscreenchange', in preparation for an addEventListener() call.
     *
     * More commonly, sSuffix is not used, so whatever property is found is returned as-is.
     *
     * @param {Object|null|undefined} obj
     * @param {string} sProp
     * @param {string} [sSuffix]
     * @return {string|null}
     */
    static findProperty(obj, sProp, sSuffix)
    {
        if (obj) {
            for (let i = 0; i < Web.asBrowserPrefixes.length; i++) {
                let sName = Web.asBrowserPrefixes[i];
                if (sSuffix) {
                    sName += sSuffix;
                    let sEvent = sProp + sName;
                    if (sEvent in obj) return sName;
                } else {
                    if (!sName) {
                        sName = sProp[0];
                    } else {
                        sName += sProp[0].toUpperCase();
                    }
                    sName += sProp.substr(1);
                    if (sName in obj) return sName;
                }
            }
        }
        return null;
    }

    /**
     * getURLParm(sParm)
     *
     * First looks for sParm exactly as specified, then looks for the lower-case version.
     *
     * @param {string} sParm
     * @return {string|undefined}
     */
    static getURLParm(sParm)
    {
        if (!Web.parmsURL) {
            Web.parmsURL = Web.parseURLParms();
        }
        return Web.parmsURL[sParm] || Web.parmsURL[sParm.toLowerCase()];
    }

    /**
     * parseURLParms(sParms)
     *
     * @param {string} [sParms] containing the parameter portion of a URL (ie, after the '?')
     * @return {Object} containing properties for each parameter found
     */
    static parseURLParms(sParms)
    {
        let aParms = {};
        if (window) {       // an alternative to "if (typeof module === 'undefined')" if require("defines") was used
            if (!sParms) {
                /*
                 * Note that window.location.href returns the entire URL, whereas window.location.search
                 * returns only the parameters, if any (starting with the '?', which we skip over with a substr() call).
                 */
                sParms = window.location.search.substr(1);
            }
            let match;
            let pl = /\+/g; // RegExp for replacing addition symbol with a space
            let search = /([^&=]+)=?([^&]*)/g;
            let decode = function(s)
            {
                return decodeURIComponent(s.replace(pl, " "));
            };

            while ((match = search.exec(sParms))) {
                aParms[decode(match[1])] = decode(match[2]);
            }
        }
        return aParms;
    }

    /**
     * downloadFile(sData, sType, fBase64, sFileName)
     *
     * @param {string} sData
     * @param {string} sType
     * @param {boolean} [fBase64]
     * @param {string} [sFileName]
     */
    static downloadFile(sData, sType, fBase64, sFileName)
    {
        let link = null, sAlert;
        let sURI = "data:application/" + sType + (fBase64? ";base64" : "") + ",";

        if (typeof sData != 'string'
            && typeof Blob == 'function' && typeof URL != 'undefined' && URL && typeof URL.createObjectURL == 'function') {
            let blob = new Blob([sData], { type: 'application/octet-stream' });
            sURI = URL.createObjectURL(blob);
        }
        else if (!Web.isUserAgent("Firefox")) {
            sURI += (fBase64? sData : encodeURI(sData));
        } else {
            sURI += (fBase64? sData : encodeURIComponent(sData));
        }
        if (sFileName) {
            link = document.createElement('a');
            if (typeof link.download != 'string') link = null;
        }
        if (link) {
            link.href = sURI;
            link.download = sFileName;
            document.body.appendChild(link);    // Firefox allegedly requires the link to be in the body
            link.click();
            document.body.removeChild(link);
            sAlert = 'Check your Downloads folder for ' + sFileName + '.';
            // if (Web.isUserAgent("Chrome")) {
            //     sAlert += '\n\nIn Chrome, after clicking OK, you may ALSO have to select the "Window" menu, choose "Downloads", and then locate this download and select "Keep".';
            //     sAlert += '\n\nThis is part of Chrome\'s "Security By Jumping Through Extra Hoops" technology, which is much easier for Google to implement than actually checking for something malicious.';
            //     sAlert += '\n\nAnd for the record, there is nothing malicious on the PCjs website.';
            // }
        } else {
            window.open(sURI);
            sAlert = 'Check your browser for a new window/tab containing the requested data' + (sFileName? (' (' + sFileName + ')') : '') + '.';
        }
        return sAlert;
    }

    /**
     * onCountRepeat(n, fnRepeat, fnComplete, msDelay)
     *
     * Call fnRepeat() n times with an msDelay millisecond delay between calls,
     * then call fnComplete() when n has been exhausted OR fnRepeat() returns false.
     *
     * @param {number} n
     * @param {function()} fnRepeat
     * @param {function()} fnComplete
     * @param {number} [msDelay]
     */
    static onCountRepeat(n, fnRepeat, fnComplete, msDelay)
    {
        let fnTimeout = function doCountRepeat()
        {
            n -= 1;
            if (n >= 0) {
                if (!fnRepeat()) n = 0;
            }
            if (n > 0) {
                setTimeout(fnTimeout, msDelay || 0);
                return;
            }
            fnComplete();
        };
        fnTimeout();
    }

    /**
     * onClickRepeat(e, msDelay, msRepeat, fn)
     *
     * Repeatedly call fn() with an initial msDelay, and an msRepeat delay thereafter,
     * as long as HTML control Object e has an active "down" event and fn() returns true.
     *
     * @param {Object} e
     * @param {number} msDelay
     * @param {number} msRepeat
     * @param {function(boolean)} fn is passed false on the first call, true on all repeated calls
     */
    static onClickRepeat(e, msDelay, msRepeat, fn)
    {
        let ms = 0, timer = null, fIgnoreMouseEvents = false;

        let fnRepeat = function doClickRepeat()
        {
            if (fn(ms === msRepeat)) {
                timer = setTimeout(fnRepeat, ms);
                ms = msRepeat;
            }
        };
        e.onmousedown = function()
        {
            // Web.log("onMouseDown()");
            if (!fIgnoreMouseEvents) {
                if (!timer) {
                    ms = msDelay;
                    fnRepeat();
                }
            }
        };
        e.ontouchstart = function()
        {
            // Web.log("onTouchStart()");
            if (!timer) {
                ms = msDelay;
                fnRepeat();
            }
        };
        e.onmouseup = e.onmouseout = function()
        {
            // Web.log("onMouseUp()/onMouseOut()");
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
        };
        e.ontouchend = e.ontouchcancel = function()
        {
            // Web.log("onTouchEnd()/onTouchCancel()");
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            /*
             * Devices that generate ontouch* events ALSO generate onmouse* events,
             * and generally do so immediately after all the touch events are complete,
             * so unless we want double the action, we need to ignore mouse events.
             */
            fIgnoreMouseEvents = true;
        };
    }

    /**
     * onPageEvent(sName, fn)
     *
     * For 'onload', 'onunload', and 'onpageshow' events, most callers should NOT use this function, but
     * instead use Web.onInit(), Web.onShow(), and Web.onExit(), respectively.
     *
     * The only components that should still use onPageEvent() are THIS component (see the bottom of this file)
     * and components that need to capture other events (eg, the 'onresize' event in the Video component).
     *
     * This function creates a chain of callbacks, allowing multiple JavaScript modules to define handlers
     * for the same event, which wouldn't be possible if everyone modified window['onload'], window['onunload'],
     * etc, themselves.  However, that's less of a concern now, because assuming everyone else is now using
     * onInit(), onExit(), etc, then there really IS only one component setting the window callback: this one.
     *
     * NOTE: It's risky to refer to obscure event handlers with "dot" names, because the Closure Compiler may
     * erroneously replace them (eg, window.onpageshow is a good example).
     *
     * @param {string} sFunc
     * @param {function()} fn
     */
    static onPageEvent(sFunc, fn)
    {
        if (window) {
            let fnPrev = window[sFunc];
            if (typeof fnPrev !== 'function') {
                window[sFunc] = fn;
            } else {
                /*
                 * TODO: Determine whether there's any value in receiving/sending the Event object that the
                 * browser provides when it generates the original event.
                 */
                window[sFunc] = function onWindowEvent()
                {
                    if (fnPrev) fnPrev();
                    fn();
                };
            }
        }
    };

    /**
     * onInit(fn)
     *
     * Use this instead of setting window.onload.  Allows multiple JavaScript modules to define their own 'onload' event handler.
     *
     * @param {function()} fn
     */
    static onInit(fn)
    {
        Web.aPageEventHandlers['init'].push(fn);
    };

    /**
     * onShow(fn)
     *
     * @param {function()} fn
     *
     * Use this instead of setting window.onpageshow.  Allows multiple JavaScript modules to define their own 'onpageshow' event handler.
     */
    static onShow(fn)
    {
        Web.aPageEventHandlers['show'].push(fn);
    };

    /**
     * onError(sMessage)
     *
     * @param {string} sMessage
     */
    static onError(sMessage)
    {
        Web.notice(sMessage + "\n\nIf it happens again, please send the URL to support@pcjs.org. Thanks.");
    }

    /**
     * onExit(fn)
     *
     * @param {function()} fn
     *
     * Use this instead of setting window.onunload.  Allows multiple JavaScript modules to define their own 'onunload' event handler.
     */
    static onExit(fn)
    {
        Web.aPageEventHandlers['exit'].push(fn);
    };

    /**
     * doPageEvent(afn)
     *
     * @param {Array.<function()>} afn
     */
    static doPageEvent(afn)
    {
        if (Web.fPageEventsEnabled) {
            try {
                for (let i = 0; i < afn.length; i++) {
                    afn[i]();
                }
            } catch (e) {
                Web.onError("An unexpected error occurred: " + e.message);
            }
        }
    };

    /**
     * enablePageEvents(fEnable)
     *
     * @param {boolean} fEnable is true to enable page events, false to disable (they're enabled by default)
     */
    static enablePageEvents(fEnable)
    {
        if (!Web.fPageEventsEnabled && fEnable) {
            Web.fPageEventsEnabled = true;
            if (Web.fPageLoaded) Web.sendPageEvent('init');
            if (Web.fPageShowed) Web.sendPageEvent('show');
            return;
        }
        Web.fPageEventsEnabled = fEnable;
    }

    /**
     * sendPageEvent(sEvent)
     *
     * This allows us to manually trigger page events.
     *
     * @param {string} sEvent (one of 'init', 'show' or 'exit')
     */
    static sendPageEvent(sEvent)
    {
        if (Web.aPageEventHandlers[sEvent]) {
            Web.doPageEvent(Web.aPageEventHandlers[sEvent]);
        }
    }
}

Web.parmsURL = null;            // initialized on first call to parseURLParms()

Web.aPageEventHandlers = {
    'init': [],                 // list of window 'onload' handlers
    'show': [],                 // list of window 'onpageshow' handlers
    'exit': []                  // list of window 'onunload' handlers (although we prefer to use 'onbeforeunload' if possible)
};

Web.asBrowserPrefixes = ['', 'moz', 'ms', 'webkit'];

Web.fPageLoaded = false;        // set once the page's first 'onload' event has occurred
Web.fPageShowed = false;        // set once the page's first 'onpageshow' event has occurred
Web.fPageEventsEnabled = true;  // default is true, set to false (or true) by enablePageEvents()

/**
 * fLocalStorage
 *
 * true if localStorage support exists, is enabled, and works; "falsey" otherwise
 *
 * @type {boolean|null}
 */
Web.fLocalStorage = null;

/**
 * TODO: Is there any way to get the Closure Compiler to stop inlining this string?  This isn't cutting it.
 *
 * @const {string}
 */
Web.sLocalStorageTest = "PCjs.localStorage";

Web.onPageEvent('onload', function onPageLoad() {
    Web.fPageLoaded = true;
    Web.doPageEvent(Web.aPageEventHandlers['init']);
});

Web.onPageEvent('onpageshow', function onPageShow() {
    Web.fPageShowed = true;
    Web.doPageEvent(Web.aPageEventHandlers['show']);
});

Web.onPageEvent(Web.isUserAgent("iOS")? 'onpagehide' : (Web.isUserAgent("Opera")? 'onunload' : 'onbeforeunload'), function onPageUnload() {
    Web.doPageEvent(Web.aPageEventHandlers['exit']);
});

/*
 * If this is DEBUG (eg, un-COMPILED) code, then allow the user to override DEBUG with a "debug=false" embedded in
 * the URL; note that the Closure Compiler won't let us alter the DEBUG variable, because it's defined as a @define, which
 * implies @const as well, so we must resort to modifying it indirectly, using the global window object.
 *
 * TODO: Consider yet another embedXXX() parameter that would also allow DEBUG to be turned off on a page-by-page basis;
 * it's low priority, because it would only affect machines that explicitly request un-COMPILED code, and there are very
 * few such machines (eg, /_posts/2015-01-17-pcjs-uncompiled.md).
 *
 * Deal with Web.getURLParm("backtrack") in /modules/pcx86/lib/defines.js at the same time.
 */
if (DEBUG && window) {
    let sDebug = Web.getURLParm("debug");
    if (sDebug == "false") {
        window['DEBUG'] = false;
    }
}



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/component.js (C) Jeff Parsons 2012-2018
 */

/*
 * All PCjs components now use JSDoc types, primarily so that Google's Closure Compiler will compile
 * everything with zero warnings when ADVANCED_OPTIMIZATIONS are enabled.  For more information about
 * the JSDoc types supported by the Closure Compiler:
 *
 *      https://developers.google.com/closure/compiler/docs/js-for-compiler#types
 *
 * I also attempted to validate this code with JSLint, but it complained too much; eg, it didn't like
 * "while (true)", a tried and "true" programming convention for decades, and it wanted me to replace
 * all "++" and "--" operators with "+= 1" and "-= 1", use "(s || '')" instead of "(s? s : '')", etc.
 *
 * I prefer sticking with traditional C-style idioms, in part because they are more portable.  That
 * does NOT mean I'm trying to write "portable JavaScript," but some of this code was ported from C code
 * I'd written long ago, so portability is good, and I'm not going to throw that away if there's no need.
 *
 * UPDATE: I've since switched from JSLint to JSHint, which seems to have more reasonable defaults.
 * And for new code, I have adopted some popular JavaScript idioms, like "(s || '')", although the need
 * for those kinds of expressions will be reduced as I also start adopting some ES6 features, like
 * default parameters.
 */



/**
 * Since the Closure Compiler treats ES6 classes as @struct rather than @dict by default,
 * it deters us from defining named properties on our components; eg:
 *
 *      this['exports'] = {...}
 *
 * results in an error:
 *
 *      Cannot do '[]' access on a struct
 *
 * So, in order to define 'exports', we must override the @struct assumption by annotating
 * the class as @unrestricted (or @dict).  Note that this must be done both here and in the
 * subclass (eg, SerialPort), because otherwise the Compiler won't allow us to *reference*
 * the named property either.
 *
 * TODO: Consider marking ALL our classes unrestricted, because otherwise it forces us to
 * define every single property the class uses in its constructor, which results in a fair
 * bit of redundant initialization, since many properties aren't (and don't need to be) fully
 * initialized until the appropriate init(), reset(), restore(), etc. function is called.
 *
 * The upside, however, may be that since the structure of the class is completely defined by
 * the constructor, JavaScript engines may be able to optimize and run more efficiently.
 *
 * @unrestricted
 */
class Component {
    /**
     * Component(type, parms, bitsMessage)
     *
     * A Component object requires:
     *
     *      type: a user-defined type name (eg, "CPU")
     *
     * and accepts any or all of the following (parms) properties:
     *
     *      id: component ID (default is "")
     *      name: component name (default is ""; if blank, toString() will use the type name only)
     *      comment: component comment string (default is undefined)
     *
     * Component subclasses will usually have additional (parms) properties.
     *
     * @param {string} type
     * @param {Object} [parms]
     * @param {number} [bitsMessage] selects message(s) that the component wants to enable (default is 0)
     */
    constructor(type, parms, bitsMessage)
    {
        this.type = type;

        if (!parms) parms = {'id': "", 'name': ""};

        this.id = parms['id'] || "";
        this.name = parms['name'];
        this.comment = parms['comment'];
        this.parms = parms;

        /*
         * The following Component properties need to be accessible by other machines and/or command scripts;
         * well, OK, or we could have exported some new functions to walk the contents of these properties, as we
         * did with findMachineComponent(), but this works just as well.
         *
         * Also, while the double-assignment looks silly (ie, using both dot and bracket property notation), it
         * resolves a complaint from the Closure Compiler, because if we use ONLY bracket notation here, then the
         * Compiler wants us to change all the other references to bracket notation as well.
         */
        this.exports = this['exports'] = {};
        this.bindings = this['bindings'] = {};

        let i = this.id.indexOf('.');
        if (i < 0) {
            this.idMachine = "PCjs";
            this.idComponent = this.id;
        } else {
            this.idMachine = this.id.substr(0, i);
            this.idComponent = this.id.substr(i + 1);
        }

        /*
         * Gather all the various component flags (booleans) into a single "flags" object, and encourage
         * subclasses to do the same, to reduce the property clutter we have to wade through while debugging.
         */
        this.flags = {
            ready:      false,
            busy:       false,
            busyCancel: false,
            initDone:   false,
            powered:    false,
            unloading:  false,
            error:      false
        };

        this.fnReady = null;
        this.clearError();
        this.bitsMessage = bitsMessage || 0;

        this.cmp = null;
        this.bus = null;
        this.cpu = null;
        this.dbg = null;

        /*
         * TODO: Consider adding another parameter to the Component() constructor that allows components to tell
         * us if they support single or multiple instances per machine.  For example, there can be multiple SerialPort
         * components per machine, but only one CPU component (some machines also support an FPU, but that component
         * is considered separate from the CPU).
         *
         * It's not critical, but it would help catch machine configuration errors; for example, a machine that mistakenly
         * includes two CPU components may, aside from wasting memory, end up with odd side-effects, like unresponsive
         * CPU controls.
         */
        Component.add(this);
    }

    /**
     * Component.add(component)
     *
     * @param {Component} component
     */
    static add(component)
    {
        /*
         * This just generates a lot of useless noise, handy in the early days, not so much these days....
         *
         *      if (DEBUG) Component.log("Component.add(" + component.type + "," + component.id + ")");
         */
        Component.components.push(component);
    }

    /**
     * Component.addMachine(idMachine)
     *
     * @param {string} idMachine
     */
    static addMachine(idMachine)
    {
        Component.machines[idMachine] = {};
    }

    /**
     * Component.getMachines()
     *
     * @return {Array.<string>}
     */
    static getMachines()
    {
        return Object.keys(Component.machines);
    }

    /**
     * Component.addMachineResource(idMachine, sName, data)
     *
     * @param {string} idMachine
     * @param {string|null} sName (name of the resource)
     * @param {*} data
     */
    static addMachineResource(idMachine, sName, data)
    {
        /*
         * I used to assert(Component.machines[idMachine]), but when we're running as a Node app, embed.js is not used,
         * so addMachine() is never called, so resources do not need to be recorded.
         */
        if (Component.machines[idMachine] && sName) {
            Component.machines[idMachine][sName] = data;
        }
    }

    /**
     * Component.getMachineResources(idMachine)
     *
     * @param {string} idMachine
     * @return {Object|undefined}
     */
    static getMachineResources(idMachine)
    {
        return Component.machines[idMachine];
    }

    /**
     * Component.getTime()
     *
     * @return {number} the current time, in milliseconds
     */
    static getTime()
    {
        return Date.now() || +new Date();
    }

    /**
     * Component.log(s, type)
     *
     * For diagnostic output only.
     *
     * @param {string} [s] is the message text
     * @param {string} [type] is the message type
     */
    static log(s, type)
    {
        if (!COMPILED) {
            if (s) {
                let sElapsed = "", sMsg = (type? (type + ": ") : "") + s;
                if (typeof Usr != "undefined") {
                    if (Component.msStart === undefined) {
                        Component.msStart = Component.getTime();
                    }
                    sElapsed = (Component.getTime() - Component.msStart) + "ms: ";
                }
                sMsg = sMsg.replace(/\r/g, '\\r').replace(/\n/g, ' ');
                if (window && window.console) console.log(sElapsed + sMsg);
            }
        }
    }

    /**
     * Component.assert(f, s)
     *
     * Verifies conditions that must be true (for DEBUG builds only).
     *
     * The Closure Compiler should automatically remove all references to Component.assert() in non-DEBUG builds.
     * TODO: Add a task to the build process that "asserts" there are no instances of "assertion failure" in RELEASE builds.
     *
     * @param {boolean} f is the expression we are asserting to be true
     * @param {string} [s] is description of the assertion on failure
     */
    static assert(f, s)
    {
        if (DEBUG) {
            if (!f) {
                if (!s) s = "assertion failure";
                Component.log(s);
                throw new Error(s);
            }
        }
    }

    /**
     * Component.print(s)
     *
     * Components that inherit from this class should use this.print(), rather than Component.print(), because
     * if a Control Panel is loaded, it will override only the instance method, not the class method (overriding the
     * class method would improperly affect any other machines loaded on the same page).
     *
     * @this {Component}
     * @param {string} s
     */
    static print(s)
    {
        if (!COMPILED) {
            let i = s.lastIndexOf('\n');
            if (i >= 0) {
                Component.println(s.substr(0, i));
                s = s.substr(i + 1);
            }
            Component.printBuffer += s;
        }
    }

    /**
     * Component.println(s, type, id)
     *
     * Components that inherit from this class should use this.println(), rather than Component.println(), because
     * if a Control Panel is loaded, it will override only the instance method, not the class method (overriding the
     * class method would improperly affect any other machines loaded on the same page).
     *
     * @param {string} [s] is the message text
     * @param {string} [type] is the message type
     * @param {string} [id] is the caller's ID, if any
     */
    static println(s, type, id)
    {
        if (!COMPILED) {
            s = Component.printBuffer + (s || "");
            Component.log((id? (id + ": ") : "") + (s? ("\"" + s + "\"") : ""), type);
            Component.printBuffer = "";
        }
    }

    /**
     * Component.notice(s, fPrintOnly, id)
     *
     * notice() is like println() but implies a need for user notification, so we alert() as well.
     *
     * @param {string} s is the message text
     * @param {boolean} [fPrintOnly]
     * @param {string} [id] is the caller's ID, if any
     * @return {boolean}
     */
    static notice(s, fPrintOnly, id)
    {
        if (!COMPILED) {
            Component.println(s, Component.PRINT.NOTICE, id);
        }
        if (!fPrintOnly) Component.alertUser((id? (id + ": ") : "") + s);
        return true;
    }

    /**
     * Component.warning(s)
     *
     * @param {string} s describes the warning
     */
    static warning(s)
    {
        if (!COMPILED) {
            Component.println(s, Component.PRINT.WARNING);
        }
        Component.alertUser(s);
    }

    /**
     * Component.error(s)
     *
     * @param {string} s describes the error; an alert() is displayed as well
     */
    static error(s)
    {
        if (!COMPILED) {
            Component.println(s, Component.PRINT.ERROR);
        }
        Component.alertUser(s);
    }

    /**
     * Component.alertUser(sMessage)
     *
     * @param {string} sMessage
     */
    static alertUser(sMessage)
    {
        if (window) {
            window.alert(sMessage);
        } else {
            Component.log(sMessage);
        }
    }

    /**
     * Component.confirmUser(sPrompt)
     *
     * @param {string} sPrompt
     * @returns {boolean} true if the user clicked OK, false if Cancel/Close
     */
    static confirmUser(sPrompt)
    {
        let fResponse = false;
        if (window) {
            fResponse = window.confirm(sPrompt);
        }
        return fResponse;
    }

    /**
     * Component.promptUser()
     *
     * @param {string} sPrompt
     * @param {string} [sDefault]
     * @returns {string|null}
     */
    static promptUser(sPrompt, sDefault)
    {
        let sResponse = null;
        if (window) {
            sResponse = window.prompt(sPrompt, sDefault === undefined? "" : sDefault);
        }
        return sResponse;
    }

    /**
     * Component.appendControl(control, sText)
     *
     * @param {Object} control
     * @param {string} sText
     */
    static appendControl(control, sText)
    {
        control.value += sText;
        /*
         * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.
         */
        if (COMPILED) {
            sText = control.value;
            if (sText.length > 8192) control.value = sText.substr(sText.length - 4096);
        }
        control.scrollTop = control.scrollHeight;
    }

    /**
     * Component.replaceControl(control, sSearch, sReplace)
     *
     * @param {Object} control
     * @param {string} sSearch
     * @param {string} sReplace
     */
    static replaceControl(control, sSearch, sReplace)
    {
        let sText = control.value;
        let i = sText.lastIndexOf(sSearch);
        if (i < 0) {
            sText += sSearch + '\n';
        } else {
            sText = sText.substr(0, i) + sReplace + sText.substr(i + sSearch.length);
        }
        /*
         * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.
         */
        if (COMPILED && sText.length > 8192) sText = sText.substr(sText.length - 4096);
        control.value = sText;
        control.scrollTop = control.scrollHeight;
    }

    /**
     * Component.bindExternalControl(component, sBinding, sType)
     *
     * @param {Component} component
     * @param {string} sBinding
     * @param {string} [sType] is the external component type (default is "Panel")
     */
    static bindExternalControl(component, sBinding, sType = "Panel")
    {
        if (sBinding) {
            let target = Component.getComponentByType(sType, component.id);
            if (target) {
                let control = target.bindings[sBinding];
                if (control) {
                    component.setBinding("", sBinding, control);
                }
            }
        }
    }

    /**
     * Component.bindComponentControls(component, element, sAppClass)
     *
     * @param {Component} component
     * @param {HTMLElement} element from the DOM
     * @param {string} sAppClass
     */
    static bindComponentControls(component, element, sAppClass)
    {
        let aeControls = Component.getElementsByClass(element.parentNode, sAppClass + "-control");

        for (let iControl = 0; iControl < aeControls.length; iControl++) {

            let aeChildNodes = aeControls[iControl].childNodes;

            for (let iNode = 0; iNode < aeChildNodes.length; iNode++) {
                let control = aeChildNodes[iNode];
                if (control.nodeType !== 1 /* document.ELEMENT_NODE */) {
                    continue;
                }
                let sClass = control.getAttribute("class");
                if (!sClass) continue;
                let aClasses = sClass.split(" ");
                for (let iClass = 0; iClass < aClasses.length; iClass++) {
                    let parms;
                    sClass = aClasses[iClass];
                    switch (sClass) {
                        case sAppClass + "-binding":
                            parms = Component.getComponentParms(/** @type {HTMLElement} */(control));
                            if (parms && parms['binding'] !== undefined) {
                                component.setBinding(parms['type'], parms['binding'], /** @type {HTMLElement} */(control), parms['value']);
                            } else if (!parms || parms['type'] != "description") {
                                Component.log("Component '" + component.toString() + "' missing binding" + (parms? " for " + parms['type'] : ""), "warning");
                            }
                            iClass = aClasses.length;
                            break;
                        default:
                            // if (DEBUG) Component.log("Component.bindComponentControls(" + component.toString() + "): unrecognized control class \"" + sClass + "\"", "warning");
                            break;
                    }
                }
            }
        }
    }

    /**
     * Component.getComponents(idRelated)
     *
     * We could store components as properties, using the component's ID, and change
     * this linear lookup into a property lookup, but some components may have no ID.
     *
     * @param {string} [idRelated] of related component
     * @return {Array} of components
     */
    static getComponents(idRelated)
    {
        let i;
        let aComponents = [];
        /*
         * getComponentByID(id, idRelated)
         *
         * If idRelated is provided, we check it for a machine prefix, and use any
         * existing prefix to constrain matches to IDs with the same prefix, in order to
         * avoid matching components belonging to other machines.
         */
        if (idRelated) {
            if ((i = idRelated.indexOf('.')) > 0)
                idRelated = idRelated.substr(0, i + 1);
            else
                idRelated = "";
        }
        for (i = 0; i < Component.components.length; i++) {
            let component = Component.components[i];
            if (!idRelated || !component.id.indexOf(idRelated)) {
                aComponents.push(component);
            }
        }
        return aComponents;
    }

    /**
     * Component.getComponentByID(id, idRelated)
     *
     * We could store components as properties, using the component's ID, and change
     * this linear lookup into a property lookup, but some components may have no ID.
     *
     * @param {string} id of the desired component
     * @param {string} [idRelated] of related component
     * @return {Component|null}
     */
    static getComponentByID(id, idRelated)
    {
        if (id !== undefined) {
            let i;
            /*
             * If idRelated is provided, we check it for a machine prefix, and use any
             * existing prefix to constrain matches to IDs with the same prefix, in order to
             * avoid matching components belonging to other machines.
             */
            if (idRelated && (i = idRelated.indexOf('.')) > 0) {
                id = idRelated.substr(0, i + 1) + id;
            }
            for (i = 0; i < Component.components.length; i++) {
                if (Component.components[i].id === id) {
                    return Component.components[i];
                }
            }
            if (Component.components.length) {
                Component.log("Component ID '" + id + "' not found", "warning");
            }
        }
        return null;
    }

    /**
     * Component.getComponentByType(sType, idRelated, componentPrev)
     *
     * @param {string} sType of the desired component
     * @param {string} [idRelated] of related component
     * @param {Component|null} [componentPrev] of previously returned component, if any
     * @return {Component|null}
     */
    static getComponentByType(sType, idRelated, componentPrev)
    {
        if (sType !== undefined) {
            let i;
            /*
             * If idRelated is provided, we check it for a machine prefix, and use any
             * existing prefix to constrain matches to IDs with the same prefix, in order to
             * avoid matching components belonging to other machines.
             */
            if (idRelated) {
                if ((i = idRelated.indexOf('.')) > 0) {
                    idRelated = idRelated.substr(0, i + 1);
                } else {
                    idRelated = "";
                }
            }
            for (i = 0; i < Component.components.length; i++) {
                if (componentPrev) {
                    if (componentPrev == Component.components[i]) componentPrev = null;
                    continue;
                }
                if (sType == Component.components[i].type && (!idRelated || !Component.components[i].id.indexOf(idRelated))) {
                    return Component.components[i];
                }
            }
            Component.log("Component type '" + sType + "' not found", "warning");
        }
        return null;
    }

    /**
     * Component.getComponentParms(element)
     *
     * @param {HTMLElement} element from the DOM
     */
    static getComponentParms(element)
    {
        let parms = null;
        let sParms = element.getAttribute("data-value");
        if (sParms) {
            try {
                parms = eval('(' + sParms + ')');   // jshint ignore:line
                /*
                 * We can no longer invoke removeAttribute() because some components (eg, Panel) need
                 * to run their initXXX() code more than once, to avoid initialization-order dependencies.
                 *
                 *      if (!DEBUG) {
                 *          element.removeAttribute("data-value");
                 *      }
                 */
            } catch(e) {
                Component.error(e.message + " (" + sParms + ")");
            }
        }
        return parms;
    }

    /**
     * Component.getElementsByClass(element, sClass, sObjClass)
     *
     * This is a cross-browser helper function, since not all browser's support getElementsByClassName()
     *
     * TODO: This should probably be moved into weblib.js at some point, along with the control binding functions above,
     * to keep all the browser-related code together.
     *
     * @param {HTMLDocument|HTMLElement|Node} element from the DOM
     * @param {string} sClass
     * @param {string} [sObjClass]
     * @return {Array|NodeList}
     */
    static getElementsByClass(element, sClass, sObjClass)
    {
        if (sObjClass) sClass += '-' + sObjClass + "-object";
        /*
         * Use the browser's built-in getElementsByClassName() if it appears to be available
         * (for example, it's not available in IE8, but it should be available in IE9 and up)
         */
        if (element.getElementsByClassName) {
            return element.getElementsByClassName(sClass);
        }
        let i, j, ae = [];
        let aeAll = element.getElementsByTagName("*");
        let re = new RegExp('(^| )' + sClass + '( |$)');
        for (i = 0, j = aeAll.length; i < j; i++) {
            if (re.test(aeAll[i].className)) {
                ae.push(aeAll[i]);
            }
        }
        if (!ae.length) {
            Component.log('No elements of class "' + sClass + '" found');
        }
        return ae;
    }

    /**
     * Component.getScriptCommands(sScript)
     *
     * This is a simple parser that breaks sScript into an array of commands, where each command
     * is an array of tokens, where tokens are sequences of characters separated by any of: tab, space,
     * carriage-return (CR), line-feed (LF), semicolon, single-quote, or double-quote; if a quote is
     * used, all characters up to the next matching quote become part of the token, allowing any of the
     * other separators to be part of the token.  CR, LF and semicolon also serve to terminate a command,
     * with semicolon being preferred, because it's 1) more visible, and 2) essential when the entire
     * script is a multi-line string where all CR/LF were replaced by spaces (which is what Jekyll does,
     * and since we can't change Jekyll, it's what our own MarkDown Front Matter parser does as well;
     * see convertMD() in markout.js, where the aCommandDefs array is built).
     *
     * Backslash sequences like \n, \r, and \\ have already been converted to LF, CR and backslash
     * characters, since the entire script string is injected into a JavaScript function call, so any
     * backslash sequence that JavaScript supports is automatically converted:
     *
     *      \0  \'  \"  \\  \n  \r  \v  \t  \b  \f  \uXXXX \xXX
     *                      ^J  ^M  ^K  ^I  ^H  ^L
     *
     * To support any other non-printable 8-bit character, such as ESC, you should use \xXX, where XX
     * is the ASCII code in hex.  For ESC, that would be \x1B.
     *
     * @param {string} sScript
     * @return {Array}
     */
    static getScriptCommands(sScript)
    {
        let cch = sScript.length;
        let aCommands = [], aTokens = [], sToken = "", chQuote = null;
        for (let i = 0; i < cch; i++) {
            let ch = sScript[i];
            if (ch == '"' || ch == "'") {
                if (chQuote && ch != chQuote) {
                    sToken += ch;
                    continue;
                }
                if (!chQuote) {
                    chQuote = ch;
                } else {
                    chQuote = null;
                }
                if (sToken) {
                    aTokens.push(sToken);
                    sToken = "";
                }
                continue;
            }
            if (!chQuote) {
                if (ch == '\r' || ch == '\n') {
                    ch = ';';
                }
                if (ch == ' ' || ch == '\t' || ch == ';') {
                    if (sToken) {
                        aTokens.push(sToken);
                        sToken = "";
                    }
                    if (ch == ';' && aTokens.length) {
                        aCommands.push(aTokens);
                        aTokens = [];
                    }
                    continue;
                }
            }
            sToken += ch;
        }
        if (sToken) {
            aTokens.push(sToken);
        }
        if (aTokens.length) {
            aCommands.push(aTokens);
        }
        return aCommands;
    }

    /**
     * Component.processScript(idMachine, sScript)
     *
     * @param {string} idMachine
     * @param {string} [sScript]
     * @return {boolean}
     */
    static processScript(idMachine, sScript)
    {
        let fSuccess = false;
        idMachine += ".machine";
        if (!sScript) {
            delete Component.commands[idMachine];
            fSuccess = true;
        }
        else if (typeof sScript == "string" && !Component.commands[idMachine]) {
            fSuccess = true;
            Component.commands[idMachine] = Component.getScriptCommands(sScript);
            if (!Component.processCommands(idMachine)) {
                fSuccess = false;
            }
        }
        return fSuccess;
    }

    /**
     * Component.processCommands(idMachine)
     *
     * @param {string} idMachine
     * @return {boolean}
     */
    static processCommands(idMachine)
    {
        let fSuccess = true;
        let aCommands = Component.commands[idMachine];

     // let dbg = Component.getComponentByType("Debugger", idMachine);

        while (aCommands && aCommands.length) {

            let aTokens = aCommands.splice(0, 1)[0];
            let sCommand = aTokens[0];

            /*
             * It's possible to route this output to the Debugger window with dbg.println()
             * instead, but it's a bit too confusing mingling script output in a window that
             * already mingles Debugger and machine output.
             */
            Component.println(aTokens.join(' '), Component.PRINT.SCRIPT);

            let fnCallReady = null;
            if (Component.asyncCommands.indexOf(sCommand) >= 0) {
                fnCallReady = function processNextCommand() {
                    return function() {
                        Component.processCommands(idMachine);
                    }
                }();
            }

            let fnCommand = Component.globalCommands[sCommand];
            if (fnCommand) {
                if (!fnCallReady) {
                    fSuccess = fnCommand(aTokens[1], aTokens[2], aTokens[3]);
                } else {
                    if (!fnCommand(fnCallReady, aTokens[1], aTokens[2], aTokens[3])) break;
                }
            }
            else {
                fSuccess = false;
                let component = Component.getComponentByType(aTokens[1], idMachine);
                if (component) {
                    fnCommand = Component.componentCommands[sCommand];
                    if (fnCommand) {
                        fSuccess = fnCommand(component, aTokens[2], aTokens[3]);
                    }
                    else {
                        let exports = component['exports'];
                        if (exports) {
                            fnCommand = exports[sCommand];
                            if (fnCommand) {
                                fSuccess = true;
                                if (!fnCallReady) {
                                    fSuccess = fnCommand.call(component, aTokens[2], aTokens[3]);
                                } else {
                                    if (!fnCommand.call(component, fnCallReady, aTokens[2], aTokens[3])) break;
                                }
                            }
                        }
                    }
                }
            }

            if (!fSuccess) {
                Component.alertUser("Script error: '" + sCommand + "' command " + (fnCommand? " failed" : " not recognized"));
                break;
            }
        }

        if (aCommands && !aCommands.length) {
            delete Component.commands[idMachine];
        }

        return fSuccess;
    }

    /**
     * Component.scriptAlert(sMessage)
     *
     * @param {string} sMessage
     * @return {boolean}
     */
    static scriptAlert(sMessage)
    {
        Component.alertUser(sMessage);
        return true;
    }

    /**
     * Component.scriptSelect(component, sBinding, sValue)
     *
     * @param {Component} component
     * @param {string} sBinding
     * @param {string} sValue
     * @return {boolean}
     */
    static scriptSelect(component, sBinding, sValue)
    {
        let fSuccess = false;
        let aBindings = component['bindings'];
        let control = aBindings[sBinding];
        if (control) {
            for (let i = 0; i < control.options.length; i++) {
                if (control.options[i].textContent == sValue) {
                    if (control.selectedIndex != i) {
                        control.selectedIndex = i;
                    }
                    fSuccess = true;
                    break;
                }
            }
        }
        return fSuccess;
    }

    /**
     * Component.scriptSleep(fnCallback, sDelay)
     *
     * @param {function()} fnCallback
     * @param {string} sDelay (in milliseconds)
     * @return {boolean}
     */
    static scriptSleep(fnCallback, sDelay)
    {
        setTimeout(fnCallback, +sDelay);
        return false;
    }

    /**
     * toString()
     *
     * @this {Component}
     * @return {string}
     */
    toString()
    {
        return (this.name? this.name : (this.id || this.type));
    }

    /**
     * getMachineNum()
     *
     * @this {Component}
     * @return {number} unique machine number
     */
    getMachineNum()
    {
        let nMachine = 1;
        if (this.idMachine) {
            let aDigits = this.idMachine.match(/\d+/);
            if (aDigits !== null)
                nMachine = parseInt(aDigits[0], 10);
        }
        return nMachine;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * Component's setBinding() method is intended to be overridden by subclasses.
     *
     * @this {Component}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, 'print')
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        switch (sBinding) {

        case 'clear':
            if (!this.bindings[sBinding]) {
                this.bindings[sBinding] = control;
                control.onclick = (function(component) {
                    return function clearControl() {
                        if (component.bindings['print']) {
                            component.bindings['print'].value = "";
                        }
                    };
                }(this));
            }
            return true;

        case 'print':
            if (!this.bindings[sBinding]) {
                let controlTextArea = /** @type {HTMLTextAreaElement} */(control);
                this.bindings[sBinding] = controlTextArea;
                /**
                 * Override this.notice() with a replacement function that eliminates the Component.alertUser() call.
                 *
                 * @this {Component}
                 * @param {string} s
                 * @return {boolean}
                 */
                this.notice = function noticeControl(s /*, fPrintOnly, id*/) {
                    this.println(s, this.type);
                    return true;
                };
                /*
                 * This was added for Firefox (Safari will clear the <textarea> on a page reload, but Firefox does not).
                 */
                controlTextArea.value = "";
                this.print = function(control) {
                    return function printControl(s) {
                        Component.appendControl(control, s);
                    };
                }(controlTextArea);
                this.println = function(component, control) {
                    return function printlnControl(s, type, id) {
                        if (!s) s = "";
                        if (type != Component.PRINT.PROGRESS || s.slice(-3) != "...") {
                            if (type) s = type + ": " + s;
                            Component.appendControl(control, s + '\n');
                        } else {
                            Component.replaceControl(control, s, s + '.');
                        }
                        if (!COMPILED && window && window.console) Component.println(s, type, id);
                    };
                }(this, controlTextArea);
            }
            return true;

        default:
            return false;
        }
    }

    /**
     * log(s, type)
     *
     * For diagnostic output only.
     *
     * WARNING: Even though this function's body is completely wrapped in DEBUG, that won't prevent the Closure Compiler
     * from including it, so all calls must still be prefixed with "if (DEBUG) ....".  For this reason, the class method,
     * Component.log(), is preferred, because the compiler IS smart enough to remove those calls.
     *
     * @this {Component}
     * @param {string} [s] is the message text
     * @param {string} [type] is the message type
     */
    log(s, type)
    {
        if (!COMPILED) {
            Component.log(s, type || this.id || this.type);
        }
    }

    /**
     * assert(f, s)
     *
     * Verifies conditions that must be true (for DEBUG builds only).
     *
     * WARNING: Make sure you preface all calls to this.assert() with "if (DEBUG)", because unlike Component.assert(),
     * the Closure Compiler can't be sure that this instance method hasn't been overridden, so it refuses to treat it as
     * dead code in non-DEBUG builds.
     *
     * TODO: Add a task to the build process that "asserts" there are no instances of "assertion failure" in RELEASE builds.
     *
     * @this {Component}
     * @param {boolean|number} f is the expression asserted to be true
     * @param {string} [s] is a description of the assertion to be displayed or logged on failure
     */
    assert(f, s)
    {
        if (DEBUG) {
            if (!f) {
                s = "assertion failure in " + (this.id || this.type) + (s? ": " + s : "");
                if (DEBUGGER && this.dbg) {
                    this.dbg.stopCPU();
                    /*
                     * Why do we throw an Error only to immediately catch and ignore it?  Simply to give
                     * any IDE the opportunity to inspect the application's state.  Even when the IDE has
                     * control, you should still be able to invoke Debugger commands from the IDE's REPL,
                     * using the global function that the Debugger constructor defines; eg:
                     *
                     *      pcx86('r')
                     *      pcx86('dw 0:0')
                     *      pcx86('h')
                     *      ...
                     *
                     * If you have no desire to stop on assertions, consider this a no-op.  However, another
                     * potential benefit of creating an Error object is that, for browsers like Chrome, we get
                     * a stack trace, too.
                     */
                    try {
                        throw new Error(s);
                    } catch(e) {
                        this.println(e.stack || e.message);
                    }
                    return;
                }
                this.log(s);
                throw new Error(s);
            }
        }
    }

    /**
     * print(s)
     *
     * Components using this.print() should wait until after their constructor has run to display any messages, because
     * if a Control Panel has been loaded, its override will not take effect until its own constructor has run.
     *
     * @this {Component}
     * @param {string} s
     */
    print(s)
    {
        Component.print(s);
    }

    /**
     * println(s, type, id)
     *
     * Components using this.println() should wait until after their constructor has run to display any messages, because
     * if a Control Panel has been loaded, its override will not take effect until its own constructor has run.
     *
     * @this {Component}
     * @param {string} [s] is the message text
     * @param {string} [type] is the message type
     * @param {string} [id] is the caller's ID, if any
     */
    println(s, type, id)
    {
        Component.println(s, type, id || this.id);
    }

    /**
     * status(s)
     *
     * status() is like println() but it also includes information about the component (ie, the component type),
     * which is why there is no corresponding Component.status() function.
     *
     * @this {Component}
     * @param {string} s is the message text
     */
    status(s)
    {
        this.println(this.type + ": " + s);
    }

    /**
     * notice(s, fPrintOnly, id)
     *
     * notice() is like println() but implies a need for user notification, so we alert() as well; however, if this.println()
     * is overridden, this.notice will be replaced with a similar override, on the assumption that the override is taking care
     * of alerting the user.
     *
     * @this {Component}
     * @param {string} s is the message text
     * @param {boolean} [fPrintOnly]
     * @param {string} [id] is the caller's ID, if any
     * @return {boolean}
     */
    notice(s, fPrintOnly, id)
    {
        if (!fPrintOnly) {
            /*
             * See if the associated computer, if any, is "unloading"....
             */
            let computer = Component.getComponentByType("Computer", this.id);
            if (computer && computer.flags.unloading) {
                console.log("ignoring notice during unload: " + s);
                return false;
            }
        }
        Component.notice(s, fPrintOnly, id || this.type);
        return true;
    }

    /**
     * setError(s)
     *
     * Set a fatal error condition
     *
     * @this {Component}
     * @param {string} s describes a fatal error condition
     */
    setError(s)
    {
        this.flags.error = true;
        this.notice(s);         // TODO: Any cases where we should still prefix this string with "Fatal error: "?
    }

    /**
     * clearError()
     *
     * Clear any fatal error condition
     *
     * @this {Component}
     */
    clearError() {
        this.flags.error = false;
    }

    /**
     * isError()
     *
     * Report any fatal error condition
     *
     * @this {Component}
     * @return {boolean} true if a fatal error condition exists, false if not
     */
    isError()
    {
        if (this.flags.error) {
            this.println(this.toString() + " error");
            return true;
        }
        return false;
    }

    /**
     * isReady(fnReady)
     *
     * Return the "ready" state of the component; if the component is not ready, it will queue the optional
     * notification function, otherwise it will immediately call the notification function, if any, without queuing it.
     *
     * NOTE: Since only the Computer component actually cares about the "readiness" of other components, the so-called
     * "queue" of notification functions supports exactly one function.  This keeps things nice and simple.
     *
     * @this {Component}
     * @param {function()} [fnReady]
     * @return {boolean} true if the component is in a "ready" state, false if not
     */
    isReady(fnReady)
    {
        if (fnReady) {
            if (this.flags.ready) {
                fnReady();
            } else {
                if (MAXDEBUG) this.log("NOT ready");
                this.fnReady = fnReady;
            }
        }
        return this.flags.ready;
    }

    /**
     * setReady(fReady)
     *
     * Set the "ready" state of the component to true, and call any queued notification functions.
     *
     * @this {Component}
     * @param {boolean} [fReady] is assumed to indicate "ready" unless EXPLICITLY set to false
     */
    setReady(fReady)
    {
        if (!this.flags.error) {
            this.flags.ready = (fReady !== false);
            if (this.flags.ready) {
                if (MAXDEBUG /* || this.name */) this.log("ready");
                let fnReady = this.fnReady;
                this.fnReady = null;
                if (fnReady) fnReady();
            }
        }
    }

    /**
     * isBusy(fCancel)
     *
     * Return the "busy" state of the component
     *
     * @this {Component}
     * @param {boolean} [fCancel] is set to true to cancel a "busy" state
     * @return {boolean} true if "busy", false if not
     */
    isBusy(fCancel)
    {
        if (this.flags.busy) {
            if (fCancel) {
                this.flags.busyCancel = true;
            } else if (fCancel === undefined) {
                this.println(this.toString() + " busy");
            }
        }
        return this.flags.busy;
    }

    /**
     * setBusy(fBusy)
     *
     * Update the current busy state; if a busyCancel request is pending, it will be honored now.
     *
     * @this {Component}
     * @param {boolean} fBusy
     * @return {boolean}
     */
    setBusy(fBusy)
    {
        if (this.flags.busyCancel) {
            this.flags.busy = false;
            this.flags.busyCancel = false;
            return false;
        }
        if (this.flags.error) {
            this.println(this.toString() + " error");
            return false;
        }
        this.flags.busy = fBusy;
        return this.flags.busy;
    }

    /**
     * powerUp(fSave)
     *
     * @this {Component}
     * @param {Object|null} data
     * @param {boolean} [fRepower] is true if this is "repower" notification
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        this.flags.powered = true;
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Component}
     * @param {boolean} fSave
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        if (fShutdown) this.flags.powered = false;
        return true;
    }

    /**
     * messageEnabled(bitsMessage)
     *
     * If bitsMessage is not specified, the component's MESSAGE category is used.
     *
     * @this {Component}
     * @param {number} [bitsMessage] is zero or more MESSAGE_* category flag(s)
     * @return {boolean} true if all specified message enabled, false if not
     */
    messageEnabled(bitsMessage = 0)
    {
        if (DEBUGGER && this.dbg) {
            if (this !== this.dbg) {
                bitsMessage = bitsMessage || this.bitsMessage;
            }
            let bitsEnabled = this.dbg.bitsMessage & bitsMessage;
            /*
             * This next "bit" of logic is for PCx86 and any other machine where we've expanded the set of
             * messages by reusing bits in the low nibbles in combination with different bits in the high nibble.
             * If the input bits adhere to that format, then the mask we just produced must adhere to it as well,
             * and if it doesn't, zero the mask, ensuring that the test will return false.
             */
            if ((bitsMessage & 0xf0000000) && (bitsMessage & 0x0fffffff)) {
                if (!(bitsEnabled & 0xf0000000) || !(bitsEnabled & 0x0fffffff)) bitsEnabled = 0;
            }
            if (bitsMessage && bitsEnabled === bitsMessage) {
                return true;
            }
        }
        return false;
    }

    /**
     * printf(format, ...args)
     *
     * @this {Component}
     * @param {string} format
     * @param {...} args
     */
    printf(format, ...args)
    {
        if (DEBUGGER && this.dbg) {
            if (this.messageEnabled()) {
                let s = Str.sprintf(format, ...args);
                /*
                 * Since dbg.message() calls println(), we strip any ending linefeed.
                 *
                 * We could bypass the Debugger and go straight to this.print(), but we would lose
                 * the benefits of debugger messages (eg, automatic buffering, halting, yielding, etc).
                 */
                if (s.slice(-1) == '\n') s = s.slice(0, -1);
                this.dbg.message(s);
            }
        }
    }

    /**
     * printMessage(sMessage, bitsMessage, fAddress)
     *
     * If bitsMessage is not specified, the component's MESSAGE category is used.
     * If bitsMessage is true, the message is displayed regardless.
     *
     * @this {Component}
     * @param {string} sMessage is any caller-defined message string
     * @param {number|boolean} [bitsMessage] is zero or more MESSAGE_* category flag(s)
     * @param {boolean} [fAddress] is true to display the current address
     */
    printMessage(sMessage, bitsMessage, fAddress)
    {
        if (DEBUGGER && this.dbg) {
            if (bitsMessage === true || this.messageEnabled(bitsMessage | 0)) {
                this.dbg.message(sMessage, fAddress);
            }
        }
    }

    /**
     * printMessageIO(port, bOut, addrFrom, name, bIn, bitsMessage)
     *
     * If bitsMessage is not specified, the component's MESSAGE category is used.
     * If bitsMessage is true, the message is displayed as long as MESSAGE.PORT is enabled.
     *
     * @this {Component}
     * @param {number} port
     * @param {number} [bOut] if an output operation
     * @param {number} [addrFrom]
     * @param {string} [name] of the port, if any
     * @param {number} [bIn] is the input value, if known, on an input operation
     * @param {number|boolean} [bitsMessage] is zero or more MESSAGE_* category flag(s)
     */
    printMessageIO(port, bOut, addrFrom, name, bIn, bitsMessage)
    {
        if (DEBUGGER && this.dbg) {
            if (bitsMessage === true) {
                bitsMessage = 0;
            } else if (bitsMessage == undefined) {
                bitsMessage = this.bitsMessage;
            }
            this.dbg.messageIO(this, port, bOut, addrFrom, name, bIn, bitsMessage);
        }
    }
}

/*
 * Types recognized and supported by selected functions (eg, Computer.getMachineParm())
 */
Component.TYPE = {
    NUMBER:     "number",
    OBJECT:     "object",
    STRING:     "string"
};

/*
 * These are the standard PRINT values you can pass as an optional argument to println(); in reality,
 * you can pass anything you want, because they are simply prepended to the message, although PROGRESS
 * messages may also be merged with earlier similar messages to keep the output buffer under control.
 */
Component.PRINT = {
    ERROR:      "error",
    NOTICE:     "notice",
    PROGRESS:   "progress",
    SCRIPT:     "script",
    WARNING:    "warning"
};

/*
 * Every component created on the current page is recorded in this array (see Component.add()),
 * enabling any component to locate another component by ID (see Component.getComponentByID())
 * or by type (see Component.getComponentByType()).
 *
 * Every machine on the page are now recorded as well, by their machine ID.  We then record the
 * various resources used by that machine.
 *
 * Includes a fallback for non-browser-based environments (ie, Node).  TODO: This will need to be
 * tailored to Node, probably using the global object instead of the window object, if we ever want
 * to support multi-machine configs in that environment.
 */
if (window) {
    if (!window['PCjs']) window['PCjs'] = {};
    if (!window['PCjs']['Machines']) window['PCjs']['Machines'] = {};
    if (!window['PCjs']['Components']) window['PCjs']['Components'] = [];
    if (!window['PCjs']['Commands']) window['PCjs']['Commands'] = {};
}
Component.machines = window? window['PCjs']['Machines'] : {};
Component.components = window? window['PCjs']['Components'] : [];
Component.commands = window? window['PCjs']['Commands'] : {};

Component.asyncCommands = [
    'hold', 'sleep', 'wait'
];
Component.globalCommands = {
    'alert': Component.scriptAlert,
    'sleep': Component.scriptSleep
};
Component.componentCommands = {
    'select':   Component.scriptSelect
};
Component.printBuffer = "";

/*
 * The following polyfills provide ES5 functionality that's missing in older browsers (eg, IE8),
 * allowing PCjs apps to run without slamming into exceptions; however, due to the lack of HTML5 canvas
 * support in those browsers, all you're likely to see are "soft" errors (eg, "Missing <canvas> support").
 *
 * Perhaps we can implement a text-only faux video display for a fun retro-browser experience someday.
 *
 * TODO: Come up with a better place to put these polyfills.  We will likely have more if we decide to
 * make the leap from ES5 to ES6 features.
 */

/*
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
 */
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(obj, start) {
        for (let i = (start || 0), j = this.length; i < j; i++) {
            if (this[i] === obj) { return i; }
        }
        return -1;
    }
}

/*
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
 */
if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/*
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
 */
if (!Function.prototype.bind) {
    Function.prototype.bind = function(obj) {
        if (typeof this != "function") {
            // Closest thing possible to the ECMAScript 5 internal IsCallable function
            throw new TypeError("Function.prototype.bind: non-callable object");
        }
        let args = Array.prototype.slice.call(arguments, 1);
        let fToBind = this;
        let fnNOP = /** @constructor */ (function() {});
        let fnBound = function() {
            return fToBind.apply(this instanceof fnNOP && obj? this : obj, args.concat(/** @type {Array} */(Array.prototype.slice.call(arguments))));
        };
        fnNOP.prototype = this.prototype;
        fnBound.prototype = new fnNOP();
        return fnBound;
    };
}



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/defines.js (C) Jeff Parsons 2012-2018
 */

/**
 * @define {string}
 */
var APPCLASS = "pcx86";         // this @define is the default application class (eg, "pcx86", "c1pjs")

/**
 * @define {string}
 */
var APPNAME = "PCx86";          // this @define is the default application name (eg, "PCx86", "C1Pjs")

/**
 * @define {boolean}
 *
 * WARNING: DEBUGGER needs to accurately reflect whether or not the Debugger component is (or will be) loaded.
 * In the compiled case, we rely on the Closure Compiler to override DEBUGGER as appropriate.  When it's *false*,
 * nearly all of debugger.js will be conditionally removed by the compiler, reducing it to little more than a
 * "type skeleton", which also solves some type-related warnings we would otherwise have if we tried to remove
 * debugger.js from the compilation process altogether.
 *
 * However, when we're in "development mode" and running uncompiled code in debugger-less configurations,
 * I would like to skip loading debugger.js altogether.  When doing that, we must ALSO arrange for an additional file
 * (nodebugger.js) to be loaded immediately after this file, which *explicitly* overrides DEBUGGER with *false*.
 */
var DEBUGGER = true;            // this @define is overridden by the Closure Compiler to remove Debugger-related support

/**
 * @define {boolean}
 *
 * PREFETCH enables the use of a prefetch queue.  As of v1.20.0, PREFETCH support has been updated and retested,
 * but as currently implemented, it does not yield as much improvement as I'd hoped when paging is enabled, so PREFETCH
 * is still off by default.
 */
var PREFETCH = false;

/**
 * @define {boolean}
 *
 * BYTEARRAYS is a Closure Compiler compile-time option that allocates an Array of numbers for every Memory block,
 * where each a number represents ONE byte; very wasteful, but potentially slightly faster.
 *
 * See the Memory component for details.
 */
var BYTEARRAYS = false;

/**
 * TYPEDARRAYS enables use of typed arrays for Memory blocks.  This used to be a compile-time-only option, but I've
 * added Memory access functions for typed arrays (see Memory.afnTypedArray), so support can be enabled dynamically now.
 *
 * See the Memory component for details.
 */
var TYPEDARRAYS = (typeof ArrayBuffer !== 'undefined');

/**
 * @define {boolean}
 *
 * BACKTRACK enables backtracking: a mechanism that allows us to tag every byte of incoming data and follow the
 * flow of that data.
 *
 * It is enabled only if DEBUG is set (implying an un-COMPILED build) and the DEBUGGER is enabled (since it's
 * really only of use to someone using the built-in debugger).
 *
 * TODO: BACKTRACK support may need to be disabled until we have a chance to investigate the problem discussed in
 * Bus.addBackTrackObject(); BACKTRACK support also needs to be updated for the 80386 at some point.
 */
var BACKTRACK = DEBUG && DEBUGGER;

/**
 * @define {boolean}
 *
 * SYMBOLS enables automatic symbol generation from known DLL, EXE and VXD file formats.  It's currently
 * enabled whenever DEBUGGER support is enabled.
 */
var SYMBOLS = DEBUGGER;

/**
 * @define {boolean}
 *
 * BUGS_8086 enables support for known 8086 bugs.  It's turned off by default, because 1) it adds overhead, and
 * 2) it's hard to imagine any software actually being dependent on any of the bugs covered by this (eg, the failure
 * to inhibit hardware interrupts following SS segment loads).
 *
 * This does NOT enable what must be regarded as 8086 "features", such as failing to properly restart string
 * instructions with multiple prefixes after a hardware interrupt, which we simulate regardless, because some software
 * (eg, Central Point Software's PC Tools) uses that to differentiate processors (eg, the Intel 8088 from the NEC V20).
 */
var BUGS_8086 = false;

/**
 * @define {boolean}
 *
 * I386 enables 80386 support.  My preference continues to be one "binary" that supports all implemented CPUs, but
 * I'm providing this to enable a slimmed-down binary, at least until 80386 support is actually finished; at the
 * moment, there's just a lot of scaffolding that bloats the compiled version without adding any real functionality.
 */
var I386 = true;

/**
 * @define {boolean}
 *
 * DESKPRO386 enables COMPAQ DeskPro 386 support.  Requires I386 support as well (duh).
 */
var DESKPRO386 = I386;

/**
 * @define {boolean}
 *
 * PAGEBLOCKS enables 80386 paging support with assistance from the Bus component.  This affects how the Bus component
 * defines physical memory parameters for a 32-bit bus.  With the 8086 and 80286 processors, the Bus component was free
 * to choose any block size for physical memory allocations that made sense for the bus width (eg, 4Kb blocks for a
 * 20-bit bus, or 16Kb blocks for a 24-bit bus).
 *
 * However, for the 80386 processor, it makes more sense to choose a block size that matches the page size (ie, 4Kb),
 * because then we have the option of altering the address-to-memory mapping for any block to match whatever page table
 * mapping is in effect for that address, if any, without requiring another layer of address translation.
 */
var PAGEBLOCKS = I386;

/*
 * If this is DEBUG (eg, un-COMPILED) code, then allow the user to override BACKTRACK with a "backtrack=false" embedded in
 * the URL; note that the Closure Compiler won't let us alter the BACKTRACK variable, because it's defined as a @define, which
 * implies @const as well, so we must resort to modifying it indirectly, using the global window object.
 *
 * TODO: Consider yet another embedXXX() parameter that would also allow BACKTRACK to be turned off on a page-by-page basis.
 *
 * Deal with Web.getURLParm("debug") in /modules/shared/lib/weblib.js at the same time.
 */
if (DEBUG && window) {
    let sBackTrack = Web.getURLParm("backtrack");
    if (sBackTrack == "false") {
        window['BACKTRACK'] = false;
    }
}

/*
 * Combine all the shared globals and machine-specific globals into one machine-specific global object,
 * which all machine components should start using; eg: "if (PCX86.DEBUG) ..." instead of "if (DEBUG) ...".
 */
var PCX86 = {
    APPCLASS:    APPCLASS,
    APPNAME:     APPNAME,
    APPVERSION:  APPVERSION,    // shared
    BACKTRACK:   BACKTRACK,
    BUGS_8086:   BUGS_8086,
    BYTEARRAYS:  BYTEARRAYS,
    COMPILED:    COMPILED,      // shared
    CSSCLASS:    CSSCLASS,      // shared
    DEBUG:       DEBUG,         // shared
    DEBUGGER:    DEBUGGER,
    DESKPRO386:  DESKPRO386,
    I386:        I386,
    MAXDEBUG:    MAXDEBUG,      // shared
    PAGEBLOCKS:  PAGEBLOCKS,
    PREFETCH:    PREFETCH,
    PRIVATE:     PRIVATE,       // shared
    TYPEDARRAYS: TYPEDARRAYS,
    SITEURL:     SITEURL,       // shared
    SYMBOLS:     SYMBOLS,
    XMLVERSION:  XMLVERSION     // shared
};


/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/x86.js (C) Jeff Parsons 2012-2018
 */

var X86 = {
    /*
     * CPU model numbers (supported)
     */
    MODEL_8086:     8086,
    MODEL_8088:     8088,
    MODEL_80186:    80186,
    MODEL_80188:    80188,
    MODEL_80286:    80286,
    MODEL_80386:    80386,

    /*
     * 80386 CPU stepping identifiers (supported)
     */
    STEPPING_80386_A0: (80386+0xA0),    // we have very little information about this stepping...
    STEPPING_80386_A1: (80386+0xA1),    // we know much more about the A1 stepping (see /blog/2015/02/23/README.md)
    STEPPING_80386_B0: (80386+0xB0),    // for now, the only B0 difference in PCx86 is support for XBTS and IBTS
    STEPPING_80386_B1: (80386+0xB1),    // our implementation of the B1 stepping also includes the infamous 32-bit multiplication bug
    STEPPING_80386_B2: (80386+0xB2),    // this is an imaginary stepping that simply means "B1 without the 32-bit multiplication bug" (ie, a B1 with the "double sigma" stamp)
    STEPPING_80386_C0: (80386+0xC0),    // this presumably fixed lots of B1 issues, but it seems to have been quickly superseded by the D0
    STEPPING_80386_D0: (80386+0xD0),    // we don't have any detailed information (eg, errata) for these later steppings
    STEPPING_80386_D1: (80386+0xD1),
    STEPPING_80386_D2: (80386+0xD2),

    /*
     * This constant is used to mark points in the code where the physical address being returned
     * is invalid and should not be used.  TODO: There are still functions that will use an invalid
     * address, which is why we've tried to choose a value that causes the least harm, but ultimately,
     * we must add checks to those functions or throw special JavaScript exceptions to bypass them.
     *
     * This value is also used to indicate non-existent EA address calculations, which are usually
     * detected with "regEA === ADDR_INVALID" and "regEAWrite === ADDR_INVALID" tests.  In a 32-bit
     * CPU, -1 (ie, 0xffffffff) could actually be a valid address, so consider changing ADDR_INVALID
     * to NaN or null (which is also why all ADDR_INVALID tests should use strict equality operators).
     *
     * The main reason I'm NOT using NaN or null now is my concern that, by mixing non-numbers
     * (specifically, values outside the range of signed 32-bit integers), performance may suffer.
     *
     * WARNING: Like many of the properties defined here, ADDR_INVALID is a common constant, which the
     * Closure Compiler will happily inline (with or without @const annotations; in fact, I've yet to
     * see a @const annotation EVER improve automatic inlining).  However, if you don't make ABSOLUTELY
     * certain that this file is included BEFORE the first reference to any of these properties, that
     * automatic inlining will no longer occur.
     */
    ADDR_INVALID: -1,

    /*
     * Processor Exception Interrupts
     *
     * Of the following exceptions, all are designed to be restartable, except for 0x08 and 0x09 (and 0x0D
     * after an attempt to write to a read-only segment).
     *
     * Error codes are pushed onto the stack for 0x08 (always 0) and 0x0A through 0x0E.
     *
     * Priority: Instruction exception, TRAP, NMI, Processor Extension Segment Overrun, and finally INTR.
     *
     * All exceptions can also occur in real-mode, except where noted.  A GP_FAULT in real-mode can be triggered
     * by "any memory reference instruction that attempts to reference [a] 16-bit word at offset 0xFFFF".
     *
     * Interrupts beyond 0x10 (up through 0x1F) are reserved for future exceptions.
     *
     * Implementation Detail: For any opcode we know must generate a UD_FAULT interrupt, we invoke opInvalid(),
     * NOT opUndefined().  UD_FAULT is for INVALID opcodes, Intel's choice of term "undefined" notwithstanding.
     *
     * We reserve the term "undefined" for opcodes that require more investigation, and we invoke opUndefined()
     * ONLY until an opcode's behavior has finally been defined, at which point it becomes either valid or invalid.
     * The term "illegal" seems completely superfluous; we don't need a third way of describing invalid opcodes.
     *
     * The term "undocumented" should be limited to operations that are valid but Intel simply never documented.
     */
    EXCEPTION: {
        DE_EXC:     0x00,       // Divide Error Exception                   (#DE: fault, no error code)
        DB_EXC:     0x01,       // Debug (aka Single Step Trap) Exception   (#DB: fault or trap)
        NMI:        0x02,       // Non-Maskable Interrupt
        BP_TRAP:    0x03,       // Breakpoint Exception                     (#BP: trap)
        OF_TRAP:    0x04,       // INTO Overflow Exception                  (#OF: trap)
        BR_FAULT:   0x05,       // BOUND Error Exception                    (#BR: fault, no error code)
        UD_FAULT:   0x06,       // Invalid (aka Undefined/Illegal) Opcode   (#UD: fault, no error code)
        NM_FAULT:   0x07,       // No Math Unit Available; see ESC or WAIT  (#NM: fault, no error code)
        DF_FAULT:   0x08,       // Double Fault; see LIDT                   (#DF: fault, with error code)
        MP_FAULT:   0x09,       // Math Unit Protection Fault; see ESC      (#MP: fault, no error code)
        TS_FAULT:   0x0A,       // Invalid Task State Segment Fault         (#TS: fault, with error code; protected-mode only)
        NP_FAULT:   0x0B,       // Not Present Fault                        (#NP: fault, with error code; protected-mode only)
        SS_FAULT:   0x0C,       // Stack Fault                              (#SS: fault, with error code; protected-mode only)
        GP_FAULT:   0x0D,       // General Protection Fault                 (#GP: fault, with error code)
        PF_FAULT:   0x0E,       // Page Fault                               (#PF: fault, with error code)
        MF_FAULT:   0x10        // Math Fault; see ESC or WAIT              (#MF: fault, no error code)
    },
    /*
     * Processor Status flag definitions (stored in regPS)
     */
    PS: {
        CF:     0x0001,     // bit 0: Carry flag
        BIT1:   0x0002,     // bit 1: reserved, always set
        PF:     0x0004,     // bit 2: Parity flag
        BIT3:   0x0008,     // bit 3: reserved, always clear
        AF:     0x0010,     // bit 4: Auxiliary Carry flag (aka Arithmetic flag)
        BIT5:   0x0020,     // bit 5: reserved, always clear
        ZF:     0x0040,     // bit 6: Zero flag
        SF:     0x0080,     // bit 7: Sign flag
        TF:     0x0100,     // bit 8: Trap flag
        IF:     0x0200,     // bit 9: Interrupt flag
        DF:     0x0400,     // bit 10: Direction flag
        OF:     0x0800,     // bit 11: Overflow flag
        IOPL: {
         MASK:  0x3000,     // bits 12-13: I/O Privilege Level (always set on 8086/80186; clear on 80286 reset)
         SHIFT: 12
        },
        NT:     0x4000,     // bit 14: Nested Task flag (always set on 8086/80186; clear on 80286 reset)
        BIT15:  0x8000,     // bit 15: reserved (always set on 8086/80186; clear otherwise)
        RF:    0x10000,     // bit 16: Resume Flag (temporarily disables debug exceptions; 80386 only)
        VM:    0x20000      // bit 17: Virtual 8086 Mode (80386 only)
    },
    CR0: {
        /*
         * Machine Status Word (MSW) bit definitions
         */
        MSW: {
            PE:     0x0001, // protected-mode enabled
            MP:     0x0002, // monitor processor extension (ie, coprocessor)
            EM:     0x0004, // emulate processor extension
            TS:     0x0008, // task switch indicator
            ON:     0xFFF0, // on the 80286, these bits are always on (TODO: Verify)
            MASK:   0xFFFF  // these are the only (MSW) bits that the 80286 can access (within CR0)
        },
        ET: 0x00000010,     // coprocessor type (80287 or 80387); always 1 on post-80386 CPUs
        ON: 0x7FFFFFE0,     // CR0 bits that are always on
        PG: 0x80000000|0,   // 0: paging disabled
    },
    DR7: {                  // Debug Control Register
        L0:     0x00000001,
        G0:     0x00000002,
        L1:     0x00000004,
        G1:     0x00000008,
        L2:     0x00000010,
        G2:     0x00000020,
        L3:     0x00000040,
        G3:     0x00000080,
        ENABLE: 0x000000FF,
        LE:     0x00000100,
        GE:     0x00000200,
        RW0:    0x00030000, // 00: exec-only  01: write-only  10: undefined  11: read/write-only
        LEN0:   0x000C0000, // 00: one-byte,  01: two-byte,   10: undefined  11: four-byte
        RW1:    0x00300000, // 00: exec-only  01: write-only  10: undefined  11: read/write-only
        LEN1:   0x00C00000, // 00: one-byte,  01: two-byte,   10: undefined  11: four-byte
        RW2:    0x03000000, // 00: exec-only  01: write-only  10: undefined  11: read/write-only
        LEN2:   0x0C000000, // 00: one-byte,  01: two-byte,   10: undefined  11: four-byte
        RW3:    0x30000000, // 00: exec-only  01: write-only  10: undefined  11: read/write-only
        LEN3:   0xC0000000|0// 00: one-byte,  01: two-byte,   10: undefined  11: four-byte
    },
    DR6: {                  // Debug Status Register
        B0:     0x00000001,
        B1:     0x00000002,
        B2:     0x00000004,
        B3:     0x00000008,
        BD:     0x00002000, // set if the next instruction will read or write one of the eight debug registers and ICE-386 is also using them
        BS:     0x00004000, // set if the debug handler is entered due to the TF (trap flag) bit set in the EFLAGS register
        BT:     0x00008000  // set before entering the DEBUG handler if a task switch has occurred and the T-bit of the new TSS is set
    },
    SEL: {
        RPL:    0x0003,     // requested privilege level (0-3)
        LDT:    0x0004,     // table indicator (0: GDT, 1: LDT)
        MASK:   0xFFF8      // table offset
    },
    DESC: {                 // Descriptor Table Entry
        LIMIT: {            // LIMIT bits 0-15 (or OFFSET if this is an INTERRUPT or TRAP gate)
            OFFSET:     0x0
        },
        BASE: {             // BASE bits 0-15 (or SELECTOR if this is a TASK, INTERRUPT or TRAP gate)
            OFFSET:     0x2
        },
        ACC: {              // bit definitions for the access word (offset 0x4)
            OFFSET:     0x4,
            BASE1623:                       0x00FF,     // (not used if this a TASK, INTERRUPT or TRAP gate; bits 0-5 are parm count for CALL gates)
            TYPE: {
                OFFSET: 0x5,
                MASK:                       0x1F00,
                SEG:                        0x1000,
                NONSEG:                     0x0F00,
                /*
                 * The following bits apply only when SEG is set
                 */
                CODE:                       0x0800,     // set for CODE, clear for DATA
                ACCESSED:                   0x0100,     // set if accessed, clear if not accessed
                READABLE:                   0x0200,     // CODE: set if readable, clear if exec-only
                WRITABLE:                   0x0200,     // DATA: set if writable, clear if read-only
                CONFORMING:                 0x0400,     // CODE: set if conforming, clear if not
                EXPDOWN:                    0x0400,     // DATA: set if expand-down, clear if not
                /*
                 * Assorted bits that apply only within NONSEG values
                 */
                TSS_BUSY:                   0x0200,
                NONSEG_386:                 0x0800,     // 80386 and up
                /*
                 * The following are all the possible (valid) types (well, except for the variations
                 * of DATA and CODE where the ACCESSED bit (0x0100) may also be set)
                 */
                TSS286:                     0x0100,
                LDT:                        0x0200,
                TSS286_BUSY:                0x0300,
                GATE_CALL:                  0x0400,
                GATE_TASK:                  0x0500,
                GATE286_INT:                0x0600,
                GATE286_TRAP:               0x0700,
                TSS386:                     0x0900,     // 80386 and up
                TSS386_BUSY:                0x0B00,     // 80386 and up
                GATE386_CALL:               0x0C00,     // 80386 and up
                GATE386_INT:                0x0E00,     // 80386 and up
                GATE386_TRAP:               0x0F00,     // 80386 and up
                CODE_OR_DATA:               0x1E00,
                DATA_READONLY:              0x1000,
                DATA_WRITABLE:              0x1200,
                DATA_EXPDOWN:               0x1400,
                DATA_EXPDOWN_WRITABLE:      0x1600,
                CODE_EXECONLY:              0x1800,
                CODE_READABLE:              0x1A00,
                CODE_CONFORMING:            0x1C00,
                CODE_CONFORMING_READABLE:   0x1E00
            },
            DPL: {
                MASK:                       0x6000,
                SHIFT:                      13
            },
            PRESENT:                        0x8000,
            INVALID:    0   // use X86.DESC.ACC.INVALID for invalid ACC values
        },
        EXT: {              // descriptor extension word (reserved on the 80286; "must be zero")
            OFFSET:     0x6,
            LIMIT1619:                      0x000F,
            AVAIL:                          0x0010,     // NOTE: set in various descriptors in OS/2
            /*
             * The BIG bit is known as the D bit for code segments; when set, all addresses and operands
             * in that code segment are assumed to be 32-bit.
             *
             * The BIG bit is known as the B bit for data segments; when set, it indicates: 1) all pushes,
             * pops, calls and returns use ESP instead of SP, and 2) the upper bound of an expand-down segment
             * is 0xffffffff instead of 0xffff.
             */
            BIG:                            0x0040,     // clear if default operand/address size is 16-bit, set if 32-bit
            LIMITPAGES:                     0x0080,     // clear if limit granularity is bytes, set if limit granularity is 4Kb pages
            BASE2431:                       0xFF00
        },
        INVALID: 0          // use X86.DESC.INVALID for invalid DESC values
    },
    LADDR: {                // linear address
        PDE: {              // index of page directory entry
            MASK:   0xFFC00000|0,
            SHIFT:  20      // (addr & DIR.MASK) >>> DIR.SHIFT yields a page directory offset (ie, index * 4)
        },
        PTE: {              // index of page table entry
            MASK:   0x003FF000,
            SHIFT:  10      // (addr & PAGE.MASK) >>> PAGE.SHIFT yields a page table offset (ie, index * 4)
        },
        OFFSET:     0x00000FFF
    },
    PTE: {
        FRAME:      0xFFFFF000|0,
        DIRTY:      0x00000040,         // page has been modified
        ACCESSED:   0x00000020,         // page has been accessed
        USER:       0x00000004,         // set for user level (CPL 3), clear for supervisor level (CPL 0-2)
        READWRITE:  0x00000002,         // set for read/write, clear for read-only (affects CPL 3 only)
        PRESENT:    0x00000001          // set for present page, clear for not-present page
    },
    TSS286: {
        PREV_TSS:   0x00,
        CPL0_SP:    0x02,   // start of values altered by task switches
        CPL0_SS:    0x04,
        CPL1_SP:    0x06,
        CPL1_SS:    0x08,
        CPL2_SP:    0x0A,
        CPL2_SS:    0x0C,
        TASK_IP:    0x0E,
        TASK_PS:    0x10,
        TASK_AX:    0x12,
        TASK_CX:    0x14,
        TASK_DX:    0x16,
        TASK_BX:    0x18,
        TASK_SP:    0x1A,
        TASK_BP:    0x1C,
        TASK_SI:    0x1E,
        TASK_DI:    0x20,
        TASK_ES:    0x22,
        TASK_CS:    0x24,
        TASK_SS:    0x26,
        TASK_DS:    0x28,   // end of values altered by task switches
        TASK_LDT:   0x2A
    },
    TSS386: {
        PREV_TSS:   0x00,
        CPL0_ESP:   0x04,   // start of values altered by task switches
        CPL0_SS:    0x08,
        CPL1_ESP:   0x0c,
        CPL1_SS:    0x10,
        CPL2_ESP:   0x14,
        CPL2_SS:    0x18,
        TASK_CR3:   0x1C,   // (not in TSS286)
        TASK_EIP:   0x20,
        TASK_PS:    0x24,
        TASK_EAX:   0x28,
        TASK_ECX:   0x2C,
        TASK_EDX:   0x30,
        TASK_EBX:   0x34,
        TASK_ESP:   0x38,
        TASK_EBP:   0x3C,
        TASK_ESI:   0x40,
        TASK_EDI:   0x44,
        TASK_ES:    0x48,
        TASK_CS:    0x4C,
        TASK_SS:    0x50,
        TASK_DS:    0x54,
        TASK_FS:    0x58,   // (not in TSS286)
        TASK_GS:    0x5C,   // (not in TSS286) end of values altered by task switches
        TASK_LDT:   0x60,
        TASK_IOPM:  0x64    // (not in TSS286)
    },
    ERRCODE: {
        EXT:        0x0001,
        IDT:        0x0002,
        LDT:        0x0004,
        SELMASK:    0xFFFC
    },
    RESULT: {
        /*
         * Flags were originally computed using 16-bit result registers:
         *
         *      CF: resultZeroCarry & resultSize (ie, 0x100 or 0x10000)
         *      PF: resultParitySign & 0xff
         *      AF: (resultParitySign ^ resultAuxOverflow) & 0x0010
         *      ZF: resultZeroCarry & (resultSize - 1)
         *      SF: resultParitySign & (resultSize >> 1)
         *      OF: (resultParitySign ^ resultAuxOverflow ^ (resultParitySign >> 1)) & (resultSize >> 1)
         *
         * I386 support requires that we now rely on 32-bit result registers:
         *
         *      resultDst, resultSrc, resultArith, resultLogic and resultType
         *
         * and flags are now computed as follows:
         *
         *      CF: ((resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))) & resultType)
         *      PF: (resultLogic & 0xff)
         *      AF: ((resultArith ^ (resultDst ^ resultSrc)) & 0x0010)
         *      ZF: (resultLogic & ((resultType - 1) | resultType))
         *      SF: (resultLogic & resultType)
         *      OF: (((resultDst ^ resultArith) & (resultSrc ^ resultArith)) & resultType)
         *
         * where resultType contains both a size, which must be one of BYTE (0x80), WORD (0x8000),
         * or DWORD (0x80000000), along with bits for each of the arithmetic and/or logical flags that
         * are currently "cached" in the result registers (eg, X86.RESULT.CF for carry, X86.RESULT.OF
         * for overflow, etc).
         *
         * WARNING: Do not confuse these RESULT flag definitions with the PS flag definitions.  RESULT
         * flags are used only as "cached" flag indicators, packed into bits 0-5 of resultType; they do
         * not match the actual flag bit definitions within the Processor Status (PS) register.
         *
         * Arithmetic operations should call:
         *
         *      setArithResult(dst, src, value, type)
         * eg:
         *      setArithResult(dst, src, dst+src, X86.RESULT.BYTE | X86.RESULT.ALL)
         *
         * and logical operations should call:
         *
         *      setLogicResult(value, type [, carry [, overflow]])
         *
         * Since most logical operations clear both CF and OF, most calls to setLogicResult() can omit the
         * last two optional parameters.
         *
         * The type parameter of these methods indicates both the size of the result (BYTE, WORD or DWORD)
         * and which of the flags should now be considered "cached" by the result registers.  If the previous
         * resultType specifies any flags not present in the new type parameter, then those flags are
         * calculated and written to the appropriate regPS bit(s) *before* the result registers are updated.
         *
         * Arithmetic operations are assumed to represent an "added" result; if a "subtracted" result is
         * provided instead (eg, from CMP, DEC, SUB, etc), then setArithResult() must include a 5th parameter
         * (fSubtract); eg:
         *
         *      setArithResult(dst, src, dst-src, X86.RESULT.BYTE | X86.RESULT.ALL, true)
         *
         * TODO: Consider separating setArithResult() into two functions: setAddResult() and setSubResult().
         */
        BYTE:       0x80,       // result is byte value
        WORD:       0x8000,     // result is word value
        DWORD:      0x80000000|0,
        TYPE:       0x80008080|0,
        CF:         0x01,       // carry flag is cached
        PF:         0x02,       // parity flag is cached
        AF:         0x04,       // aux carry flag is cached
        ZF:         0x08,       // zero flag is cached
        SF:         0x10,       // sign flag is cached
        OF:         0x20,       // overflow flag is cached
        ALL:        0x3F,       // all result flags are cached
        LOGIC:      0x1A,       // all logical flags are cached; see setLogicResult()
        NOTCF:      0x3E        // all result flags EXCEPT carry are cached
    },
    /*
     * Bit values for opFlags, which are all reset to zero prior to each instruction
     */
    OPFLAG: {
        NOREAD:     0x0001,     // disable memory reads for the remainder of the current instruction
        NOWRITE:    0x0002,     // disable memory writes for the remainder of the current instruction
        NOINTR:     0x0004,     // a segreg has been set, or a prefix, or an STI (delay INTR acknowledgement)
        WRAP:       0x0008,     // a segment wrap-around has occurred (relevant to 8086/8088 only)
        SEG:        0x0010,     // segment override
        LOCK:       0x0020,     // lock prefix
        REPZ:       0x0040,     // repeat while Z (NOTE: this value MUST match PS.ZF; see opCMPSb/opCMPSw/opSCASb/opSCASw)
        REPNZ:      0x0080,     // repeat while NZ
        REPEAT:     0x0100,     // an instruction is being repeated (ie, some iteration AFTER the first)
        PUSHSP:     0x0200,     // the SP register is potentially being referenced by a PUSH SP opcode, adjustment may be required
        DATASIZE:   0x0400,     // data size override
        ADDRSIZE:   0x0800,     // address size override
        FAULT:      0x1000,     // a fault occurred during the current instruction
        DBEXC:      0x2000,     // a DB_EXC exception occurred during the current instruction
        REPSEG:     0x4000      // an instruction is being repeated with a segment prefix (used for 8086/8088 "feature" simulation)
    },
    /*
     * Bit values for intFlags
     */
    INTFLAG: {
        NONE:       0x00,
        INTR:       0x01,       // h/w interrupt requested
        TRAP:       0x02,       // trap (INT 0x01) requested
        HALT:       0x04,       // halt (HLT) requested
        DMA:        0x08        // async DMA operation in progress
    },
    /*
     * Common opcodes (and/or any opcodes we need to refer to explicitly)
     */
    OPCODE: {
        ES:         0x26,       // opES()
        CS:         0x2E,       // opCS()
        SS:         0x36,       // opSS()
        DS:         0x3E,       // opDS()
        PUSHSP:     0x54,       // opPUSHSP()
        PUSHA:      0x60,       // opPUSHA()    (80186 and up)
        POPA:       0x61,       // opPOPA()     (80186 and up)
        BOUND:      0x62,       // opBOUND()    (80186 and up)
        ARPL:       0x63,       // opARPL()     (80286 and up)
        FS:         0x64,       // opFS()       (80386 and up)
        GS:         0x65,       // opGS()       (80386 and up)
        OS:         0x66,       // opOS()       (80386 and up)
        AS:         0x67,       // opAS()       (80386 and up)
        PUSHN:      0x68,       // opPUSHn()    (80186 and up)
        IMULN:      0x69,       // opIMULn()    (80186 and up)
        PUSH8:      0x6A,       // opPUSH8()    (80186 and up)
        IMUL8:      0x6B,       // opIMUL8()    (80186 and up)
        INSB:       0x6C,       // opINSb()     (80186 and up)
        INSW:       0x6D,       // opINSw()     (80186 and up)
        OUTSB:      0x6E,       // opOUTSb()    (80186 and up)
        OUTSW:      0x6F,       // opOUTSw()    (80186 and up)
        ENTER:      0xC8,       // opENTER()    (80186 and up)
        LEAVE:      0xC9,       // opLEAVE()    (80186 and up)
        CALLF:      0x9A,       // opCALLF()
        MOVSB:      0xA4,       // opMOVSb()
        MOVSW:      0xA5,       // opMOVSw()
        CMPSB:      0xA6,       // opCMPSb()
        CMPSW:      0xA7,       // opCMPSw()
        STOSB:      0xAA,       // opSTOSb()
        STOSW:      0xAB,       // opSTOSw()
        LODSB:      0xAC,       // opLODSb()
        LODSW:      0xAD,       // opLODSw()
        SCASB:      0xAE,       // opSCASb()
        SCASW:      0xAF,       // opSCASw()
        INT3:       0xCC,       // opINT3()
        INTN:       0xCD,       // opINTn()
        INTO:       0xCE,       // opINTO()
        IRET:       0xCF,       // opIRET()
        ESC0:       0xD8,       // opESC0()
        ESC1:       0xD9,       // opESC1()
        ESC2:       0xDA,       // opESC2()
        ESC3:       0xDB,       // opESC3()
        ESC4:       0xDC,       // opESC4()
        ESC5:       0xDD,       // opESC5()
        ESC6:       0xDE,       // opESC6()
        ESC7:       0xDF,       // opESC7()
        LOOPNZ:     0xE0,       // opLOOPNZ()
        LOOPZ:      0xE1,       // opLOOPZ()
        LOOP:       0xE2,       // opLOOP()
        CALL:       0xE8,       // opCALL()
        JMP:        0xE9,       // opJMP()      (2-byte displacement)
        JMPF:       0xEA,       // opJMPF()
        JMPS:       0xEB,       // opJMPs()     (1-byte displacement)
        LOCK:       0xF0,       // opLOCK()
        INT1:       0xF1,       // opINT1()
        REPNZ:      0xF2,       // opREPNZ()
        REPZ:       0xF3,       // opREPZ()
        GRP4W:      0xFF,
        CALLW:      0x10FF,     // GRP4W: fnCALLw()
        CALLFDW:    0x18FF,     // GRP4W: fnCALLFdw()
        CALLMASK:   0x38FF,     // mask 2-byte GRP4W opcodes with this before comparing to CALLW or CALLFDW
        UD2:        0x0B0F      // UD2 (invalid opcode "guaranteed" to generate UD_FAULT on all post-8086 processors)
    },
    /*
     * Floating Point Unit (FPU), aka Numeric Data Processor (NDP), aka Numeric Processor Extension (NPX), aka Coprocessor definitions
     */
    FPU: {
        MODEL_8087:     8087,
        MODEL_80287:    80287,
        MODEL_80287XL:  80387,  // internally, the 80287XL was an 80387SX, so generally, we treat this as MODEL_80387
        MODEL_80387:    80387,
        CONTROL: {              // FPU Control Word
            IM:     0x0001,     // bit 0: Invalid Operation Mask
            DM:     0x0002,     // bit 1: Denormalized Operand Mask
            ZM:     0x0004,     // bit 2: Zero Divide Mask
            OM:     0x0008,     // bit 3: Overflow Mask
            UM:     0x0010,     // bit 4: Underflow Mask
            PM:     0x0020,     // bit 5: Precision Mask
            EXC:    0x003F,     // all of the above exceptions
            IEM:    0x0080,     // bit 7: Interrupt Enable Mask (0 enables interrupts, 1 masks them; 8087 only)
            PC:     0x0300,     // bits 8-9: Precision Control
            RC: {               // bits 10-11: Rounding Control
              NEAR: 0x0000,
              DOWN: 0x0400,
              UP:   0x0800,
              CHOP: 0x0C00,
              MASK: 0x0C00
            },
            IC:     0x1000,     // bit 12: Infinity Control (0 for Projective, 1 for Affine)
            UNUSED: 0xE040,     // bits 6,13-15: unused
            INIT:   0x03BF      // X86.FPU.CONTROL.IM | X86.FPU.CONTROL.DM | X86.FPU.CONTROL.ZM | X86.FPU.CONTROL.OM | X86.FPU.CONTROL.UM | X86.FPU.CONTROL.PM | X86.FPU.CONTROL.IEM | X86.FPU.CONTROL.PC
        },
        STATUS: {               // FPU Status Word
            IE:     0x0001,     // bit 0: Invalid Operation
            DE:     0x0002,     // bit 1: Denormalized Operand
            ZE:     0x0004,     // bit 2: Zero Divide
            OE:     0x0008,     // bit 3: Overflow
            UE:     0x0010,     // bit 4: Underflow
            PE:     0x0020,     // bit 5: Precision
            SF:     0x0040,     // bit 6: Stack Fault (80387 and later; triggers an Invalid Operation exception)
            EXC:    0x007F,     // all of the above exceptions
            ES:     0x0080,     // bit 7: Error/Exception Status/Summary (Interrupt Request on 8087)
            C0:     0x0100,     // bit 8: Condition Code 0
            C1:     0x0200,     // bit 9: Condition Code 1
            C2:     0x0400,     // bit 10: Condition Code 2
            ST:     0x3800,     // bits 11-13: Stack Top
            ST_SHIFT: 11,
            C3:     0x4000,     // bit 14: Condition Code 3
            CC:     0x4700,     // all condition code bits
            BUSY:   0x8000      // bit 15: Busy
        },
        TAGS: {
            VALID:  0x0,
            ZERO:   0x1,
            SPECIAL:0x2,
            EMPTY:  0x3,
            MASK:   0x3
        }
        /*
            C3 C2 C1 C0     Condition Code (CC) values following an Examine

            0  0  0  0      Valid, positive unnormalized (+Unnormal)
            0  0  0  1      Invalid, positive, exponent=0 (+NaN)
            0  0  1  0      Valid, negative, unnormalized (-Unnormal)
            0  0  1  1      Invalid, negative, exponent=0 (-NaN)
            0  1  0  0      Valid, positive, normalized (+Normal)
            0  1  0  1      Infinity, positive (+Infinity)
            0  1  1  0      Valid, negative, normalized (-Normal)
            0  1  1  1      Infinity, negative (-Infinity)
            1  0  0  0      Zero, positive (+0)
            1  0  0  1      Empty
            1  0  1  0      Zero, negative (-0)
            1  0  1  1      Empty
            1  1  0  0      Invalid, positive, exponent=0 (+Denormal)
            1  1  0  1      Empty
            1  1  1  0      Invalid, negative, exponent=0 (-Denormal)
            1  1  1  1      Empty

                            Condition Code (CC) values following an FCOM or FTST

            0  0  ?  0      ST > source operand (FCOM); ST > 0 (FTST)
            0  0  ?  1      ST < source operand (FCOM); ST < 0 (FTST)
            1  0  ?  0      ST = source operand (FCOM); ST = 0 (FTST)
            1  1  ?  1      ST is not comparable

                            Condition Code (CC) values following a Remainder

            Q1 0  Q0 Q2     Complete reduction (he three low bits of the quotient stored in C0, C3, and C1)
            ?  1  ?  ?      Incomplete reduction
         */
    },
    CYCLES_8088: {
        nWordCyclePenalty:          4,      // NOTE: accurate for the 8088/80188 only (on the 8086/80186, it applies to odd addresses only)
        nEACyclesBase:              5,      // base or index only (BX, BP, SI or DI)
        nEACyclesDisp:              6,      // displacement only
        nEACyclesBaseIndex:         7,      // base + index (BP+DI and BX+SI)
        nEACyclesBaseIndexExtra:    8,      // base + index (BP+SI and BX+DI require an extra cycle)
        nEACyclesBaseDisp:          9,      // base or index + displacement
        nEACyclesBaseIndexDisp:     11,     // base + index + displacement (BP+DI+n and BX+SI+n)
        nEACyclesBaseIndexDispExtra:12,     // base + index + displacement (BP+SI+n and BX+DI+n require an extra cycle)
        nOpCyclesAAA:               4,      // AAA, AAS, DAA, DAS, TEST acc,imm
        nOpCyclesAAD:               60,
        nOpCyclesAAM:               83,
        nOpCyclesArithRR:           3,      // ADC, ADD, AND, OR, SBB, SUB, XOR and CMP reg,reg cycle time
        nOpCyclesArithRM:           9,      // ADC, ADD, AND, OR, SBB, SUB, and XOR reg,mem (and CMP mem,reg) cycle time
        nOpCyclesArithMR:           16,     // ADC, ADD, AND, OR, SBB, SUB, and XOR mem,reg cycle time
        nOpCyclesArithMID:          1,      // ADC, ADD, AND, OR, SBB, SUB, XOR and CMP mem,imm cycle delta
        nOpCyclesCall:              19,
        nOpCyclesCallF:             28,
        nOpCyclesCallWR:            16,
        nOpCyclesCallWM:            21,
        nOpCyclesCallDM:            37,
        nOpCyclesCLI:               2,
        nOpCyclesCompareRM:         9,      // CMP reg,mem cycle time (same as nOpCyclesArithRM on an 8086 but not on a 80286)
        nOpCyclesCWD:               5,
        nOpCyclesBound:             33,     // N/A if 8086/8088, 33-35 if 80186/80188 (TODO: Determine what the range means for an 80186/80188)
        nOpCyclesInP:               10,
        nOpCyclesInDX:              8,
        nOpCyclesIncR:              3,      // INC reg, DEC reg
        nOpCyclesIncM:              15,     // INC mem, DEC mem
        nOpCyclesInt:               51,
        nOpCyclesInt3D:             1,
        nOpCyclesIntOD:             2,
        nOpCyclesIntOFall:          4,
        nOpCyclesIRet:              32,
        nOpCyclesJmp:               15,
        nOpCyclesJmpF:              15,
        nOpCyclesJmpC:              16,
        nOpCyclesJmpCFall:          4,
        nOpCyclesJmpWR:             11,
        nOpCyclesJmpWM:             18,
        nOpCyclesJmpDM:             24,
        nOpCyclesLAHF:              4,      // LAHF, SAHF, MOV reg,imm
        nOpCyclesLEA:               2,
        nOpCyclesLS:                16,     // LDS, LES
        nOpCyclesLoop:              17,     // LOOP, LOOPNZ
        nOpCyclesLoopZ:             18,     // LOOPZ, JCXZ
        nOpCyclesLoopNZ:            19,     // LOOPNZ
        nOpCyclesLoopFall:          5,      // LOOP
        nOpCyclesLoopZFall:         6,      // LOOPZ, JCXZ
        nOpCyclesMovRR:             2,
        nOpCyclesMovRM:             8,
        nOpCyclesMovMR:             9,
        nOpCyclesMovRI:             10,
        nOpCyclesMovMI:             10,
        nOpCyclesMovAM:             10,
        nOpCyclesMovMA:             10,
        nOpCyclesDivBR:             80,     // range of 80-90
        nOpCyclesDivWR:             144,    // range of 144-162
        nOpCyclesDivBM:             86,     // range of 86-96
        nOpCyclesDivWM:             154,    // range of 154-172
        nOpCyclesIDivBR:            101,    // range of 101-112
        nOpCyclesIDivWR:            165,    // range of 165-184
        nOpCyclesIDivBM:            107,    // range of 107-118
        nOpCyclesIDivWM:            171,    // range of 171-190
        nOpCyclesMulBR:             70,     // range of 70-77
        nOpCyclesMulWR:             113,    // range of 113-118
        nOpCyclesMulBM:             76,     // range of 76-83
        nOpCyclesMulWM:             124,    // range of 124-139
        nOpCyclesIMulBR:            80,     // range of 80-98
        nOpCyclesIMulWR:            128,    // range of 128-154
        nOpCyclesIMulBM:            86,     // range of 86-104
        nOpCyclesIMulWM:            134,    // range of 134-160
        nOpCyclesNegR:              3,      // NEG reg, NOT reg
        nOpCyclesNegM:              16,     // NEG mem, NOT mem
        nOpCyclesOutP:              10,
        nOpCyclesOutDX:             8,
        nOpCyclesPopAll:            51,     // N/A if 8086/8088, 51 if 80186, 83 if 80188 (TODO: Verify)
        nOpCyclesPopReg:            8,
        nOpCyclesPopMem:            17,
        nOpCyclesPushAll:           36,     // N/A if 8086/8088, 36 if 80186, 68 if 80188 (TODO: Verify)
        nOpCyclesPushReg:           11,     // NOTE: "The 8086 Book" claims this is 10, but it's an outlier....
        nOpCyclesPushMem:           16,
        nOpCyclesPushSeg:           10,
        nOpCyclesPrefix:            2,
        nOpCyclesCmpS:              18,
        nOpCyclesCmpSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesCmpSrn:            17-2,   // reduced by nOpCyclesPrefix
        nOpCyclesLodS:              12,
        nOpCyclesLodSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesLodSrn:            13-2,   // reduced by nOpCyclesPrefix
        nOpCyclesMovS:              18,
        nOpCyclesMovSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesMovSrn:            17-2,   // reduced by nOpCyclesPrefix
        nOpCyclesScaS:              15,
        nOpCyclesScaSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesScaSrn:            15-2,   // reduced by nOpCyclesPrefix
        nOpCyclesStoS:              11,
        nOpCyclesStoSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesStoSrn:            10-2,   // reduced by nOpCyclesPrefix
        nOpCyclesRet:               8,
        nOpCyclesRetn:              12,
        nOpCyclesRetF:              18,
        nOpCyclesRetFn:             17,
        nOpCyclesShift1M:           15,     // ROL/ROR/RCL/RCR/SHL/SHR/SAR reg,1
        nOpCyclesShiftCR:           8,      // ROL/ROR/RCL/RCR/SHL/SHR/SAR reg,CL
        nOpCyclesShiftCM:           20,     // ROL/ROR/RCL/RCR/SHL/SHR/SAR mem,CL
        nOpCyclesShiftCS:           2,      // this is the left-shift value used to convert the count to the cycle cost
        nOpCyclesTestRR:            3,
        nOpCyclesTestRM:            9,
        nOpCyclesTestRI:            5,
        nOpCyclesTestMI:            11,
        nOpCyclesXchgRR:            4,
        nOpCyclesXchgRM:            17,
        nOpCyclesXLAT:              11
    },
    CYCLES_80286: {
        nWordCyclePenalty:          0,
        nEACyclesBase:              0,
        nEACyclesDisp:              0,
        nEACyclesBaseIndex:         0,
        nEACyclesBaseIndexExtra:    0,
        nEACyclesBaseDisp:          0,
        nEACyclesBaseIndexDisp:     1,
        nEACyclesBaseIndexDispExtra:1,
        nOpCyclesAAA:               3,
        nOpCyclesAAD:               14,
        nOpCyclesAAM:               16,
        nOpCyclesArithRR:           2,
        nOpCyclesArithRM:           7,
        nOpCyclesArithMR:           7,
        nOpCyclesArithMID:          0,
        nOpCyclesCall:              7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCallF:             13,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCallWR:            7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCallWM:            11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCallDM:            16,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCLI:               3,
        nOpCyclesCompareRM:         6,
        nOpCyclesCWD:               2,
        nOpCyclesBound:             13,
        nOpCyclesInP:               5,
        nOpCyclesInDX:              5,
        nOpCyclesIncR:              2,
        nOpCyclesIncM:              7,
        nOpCyclesInt:               23,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesInt3D:             0,
        nOpCyclesIntOD:             1,
        nOpCyclesIntOFall:          3,
        nOpCyclesIRet:              17,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmp:               7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpF:              11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpC:              7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpCFall:          3,
        nOpCyclesJmpWR:             7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpWM:             11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpDM:             15,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesLAHF:              2,
        nOpCyclesLEA:               3,
        nOpCyclesLS:                7,
        nOpCyclesLoop:              8,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesLoopZ:             8,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesLoopNZ:            8,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesLoopFall:          4,
        nOpCyclesLoopZFall:         4,
        nOpCyclesMovRR:             2,      // this is actually the same as the 8086...
        nOpCyclesMovRM:             3,
        nOpCyclesMovMR:             5,
        nOpCyclesMovRI:             2,
        nOpCyclesMovMI:             3,
        nOpCyclesMovAM:             5,      // this is actually slower than the MOD/RM form of MOV AX,mem (see nOpCyclesMovRM)
        nOpCyclesMovMA:             3,
        nOpCyclesDivBR:             14,
        nOpCyclesDivWR:             22,
        nOpCyclesDivBM:             17,
        nOpCyclesDivWM:             25,
        nOpCyclesIDivBR:            17,
        nOpCyclesIDivWR:            25,
        nOpCyclesIDivBM:            20,
        nOpCyclesIDivWM:            28,
        nOpCyclesMulBR:             13,
        nOpCyclesMulWR:             21,
        nOpCyclesMulBM:             16,
        nOpCyclesMulWM:             24,
        nOpCyclesIMulBR:            13,
        nOpCyclesIMulWR:            21,
        nOpCyclesIMulBM:            16,
        nOpCyclesIMulWM:            24,
        nOpCyclesNegR:              2,
        nOpCyclesNegM:              7,
        nOpCyclesOutP:              5,
        nOpCyclesOutDX:             5,
        nOpCyclesPopAll:            19,
        nOpCyclesPopReg:            5,
        nOpCyclesPopMem:            5,
        nOpCyclesPushAll:           17,
        nOpCyclesPushReg:           3,
        nOpCyclesPushMem:           5,
        nOpCyclesPushSeg:           3,
        nOpCyclesPrefix:            0,
        nOpCyclesCmpS:              8,
        nOpCyclesCmpSr0:            5,
        nOpCyclesCmpSrn:            9,
        nOpCyclesLodS:              5,
        nOpCyclesLodSr0:            5,
        nOpCyclesLodSrn:            4,
        nOpCyclesMovS:              5,
        nOpCyclesMovSr0:            5,
        nOpCyclesMovSrn:            4,
        nOpCyclesScaS:              7,
        nOpCyclesScaSr0:            5,
        nOpCyclesScaSrn:            8,
        nOpCyclesStoS:              3,
        nOpCyclesStoSr0:            4,
        nOpCyclesStoSrn:            3,
        nOpCyclesRet:               11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesRetn:              11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesRetF:              15,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesRetFn:             15,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesShift1M:           7,
        nOpCyclesShiftCR:           5,
        nOpCyclesShiftCM:           8,
        nOpCyclesShiftCS:           0,
        nOpCyclesTestRR:            2,
        nOpCyclesTestRM:            6,
        nOpCyclesTestRI:            3,
        nOpCyclesTestMI:            6,
        nOpCyclesXchgRR:            3,
        nOpCyclesXchgRM:            5,
        nOpCyclesXLAT:              5
    },
    /*
     * TODO: All 80386 cycle counts are based on 80286 counts until I have time to hand-generate an 80386-specific table;
     * the values below are used by selected 32-bit opcode handlers only.
     */
    CYCLES_80386: {
        nEACyclesBase:              0,
        nEACyclesDisp:              0,
        nEACyclesBaseIndex:         0,
        nEACyclesBaseIndexExtra:    0,
        nEACyclesBaseDisp:          0,
        nEACyclesBaseIndexDisp:     1,
        nEACyclesBaseIndexDispExtra:1
    }
};

/*
 * BACKTRACK-related definitions (used only if BACKTRACK is defined)
 */
X86.BTINFO = {
    SP_LO:  0,
    SP_HI:  0
};

/*
 * These PS flags are always stored directly in regPS for the 8086/8088, hence the
 * "direct" designation; other processors must adjust these bits accordingly.  The final
 * adjusted value is stored in PS_DIRECT (ie, 80286 and up also include PS.IOPL.MASK and
 * PS.NT in PS_DIRECT).
 */
X86.PS_DIRECT_8086 = (X86.PS.TF | X86.PS.IF | X86.PS.DF);

/*
 * These are the default "always set" PS bits for the 8086/8088; other processors must
 * adjust these bits accordingly.  The final adjusted value is stored in PS_SET.
 */
X86.PS_SET_8086 = (X86.PS.BIT1 | X86.PS.IOPL.MASK | X86.PS.NT | X86.PS.BIT15);

/*
 * These PS arithmetic and logical flags may be "cached" across several result registers;
 * whether or not they're currently cached depends on the RESULT bits in resultType.
 */
X86.PS_CACHED = (X86.PS.CF | X86.PS.PF | X86.PS.AF | X86.PS.ZF | X86.PS.SF | X86.PS.OF);

/*
 * PS_SAHF is a subset of the arithmetic flags, and refers only to those flags that the
 * SAHF and LAHF "8080 legacy" opcodes affect.
 */
X86.PS_SAHF = (X86.PS.CF | X86.PS.PF | X86.PS.AF | X86.PS.ZF | X86.PS.SF);

/*
 * Before we zero opFlags, we first see if any of the following PREFIX bits were set.  If any were set,
 * they are OR'ed into opPrefixes; otherwise, opPrefixes is zeroed as well.  This gives prefix-conscious
 * instructions like LODS, MOVS, STOS, CMPS, etc, a way of determining which prefixes, if any, immediately
 * preceded them.
 */
X86.OPFLAG_PREFIXES = (X86.OPFLAG.SEG | X86.OPFLAG.LOCK | X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ | X86.OPFLAG.DATASIZE | X86.OPFLAG.ADDRSIZE);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/interrupts.js (C) Jeff Parsons 2012-2018
 */

var Interrupts = {
    /*
     * The original ROM BIOS defined vectors 0x08-0x1F with a table at F000:FEF3 (VECTOR_TABLE).
     */
    VIDEO:      0x10,
    EQUIPMENT:  0x11,
    MEM_SIZE:   0x12,
    DISK:       0x13,
    SERIAL:     0x14,
    CASSETTE:   0x15,
    KEYBOARD:   0x16,
    PARALLEL:   0x17,
    BASIC:      0x18,               // normally F600:0000
    BOOTSTRAP:  0x19,
    TIMER:      0x1A,
    KBD_BREAK:  0x1B,
    TMR_BREAK:  0x1C,               // invoked by the BIOS timer interrupt handler (normally vector 0x08)
    VID_PARMS:  0x1D,
    DSK_PARMS:  0x1E,
    /*
     * For characters 0x00-0x7F, the original ROM BIOS used a built-in table at F000:FA6E (CRT_CHAR_GEN),
     * since the MDA/CGA font ROM was not CPU-addressable, but presumably there wasn't enough room in the
     * ROM BIOS for all 256 characters, so if software wanted to draw any characters 0x80-0xFF in graphics
     * mode, it was up to software to provide the font data and set the VID_EXT vector to point to it.
     */
    VID_EXT:    0x1F,               // graphics characters 0x80-0xFF (aka EXT_PTR)
    DOS:        0x21,
    DOS_IDLE:   0x28,
    DOS_NETBIOS:0x2A,
    MOUSE:      0x33,
    ALT_DISK:   0x40,               // HDC ROM saves original FDC vector here
    HD0_PARMS:  0x41,               // parameter table for hard drive 0
    VID_PLANAR: 0x42,               // EGA ROM saves original VIDEO ("planar ROM") vector here
    EGA_GRX:    0x43,               // EGA ROM provides a complete set of mode-appropriate font data here (0000:010C)
    HD1_PARMS:  0x46,               // parameter table for hard drive 1
    HD_PARMS: {
        MAX_CYL:    0x00,           // maximum cylinders (2 bytes)
        MAX_HEADS:  0x02,           // maximum heads (1 byte)
        WP_CYL:     0x05,           // write precompensation cylinder (2 bytes)
        MAX_ECC:    0x07,           // max ECC burst (1 byte)
        DRIVE_CTRL: 0x08,           // drive control (1 byte)
        PARK_CYL:   0x0C,           // landing zone cylinder (2 bytes)
        SEC_TRACK:  0x0E            // sectors per track (1 byte)
    },
    ALT_VIDEO:  0x6D,               // VGA ROM saves original VIDEO vector here (one wonders what was wrong with VID_PLANAR)
    WINCB: {
        VECTOR:     0x30            // Windows PM call-back interface (aka Transfer Space Fault)
    },
    WINDBG: {                       // Windows Debugger protected-mode interface
        VECTOR:     0x41,           // (AX==command)
        IS_LOADED:  0x004F,         // DS_DebLoaded
        LOADED:     0xF386,         // DS_DebPresent (returned in AX if Windows Debugger loaded)
        LOADSEG:    0x0050,         // DS_LoadSeg (SI==0 if code, 1 if data; BX==segnum-1; CX==selector; ES:[E]DI->module name)
        FREESEG:    0x0052,         // DS_FreeSeg (BX==segment)
        KRNLVARS:   0x005A,         // DS_Kernel_Vars
        RELSEG:     0x005C,         // DS_ReleaseSeg (same as DS_FreeSeg but "restores any breakpoints first")
        LOADHIGH:   0x005D,         // D386_LoadCodeDataHigh
        EXITCALL:   0x0062,         // DS_EXITCALL
        LOADDLL:    0x0064,         // DS_LOADDLL
        DELMODULE:  0x0065,         // DS_DELMODULE
        UNKNOWN66:  0x0066,         // Unknown (but I suspect it isn't good)
        UNKNOWN67:  0x0067,         // Unknown (but I suspect it isn't good)
        REGDOTCMD:  0x0070,         // DS_RegisterDotCommand
        CHECKFAULT: 0x007F,         // DS_CheckFault (BX==fault #, CX==FAULTTYPE bits; return AX=0 to handle fault normally, 1 to issue TRAPFAULT)
        FAULTTYPE: {
            V86:    0x0001,
            PM:     0x0002,
            RING0:  0x0004,
            FIRST:  0x0008,
            LAST:   0x0010
        },
        TRAPFAULT:  0x0083,         // DS_TrapFault (BX==fault #, CX==faulting CS, EDX==faulting EIP, ESI==fault error, EDI==fault flags)
        GETSYMBOL:  0x008D,         // DS_GetSymbol (DS:ESI->symbol; return AX=0 if success, 1 if not found, 2 if memory not loaded yet)
        LOADSEG32:  0x0150,         // DS_LoadSeg_32 (SI==0 if code, 1 if data; DX:EBX->D386_Device_Params)
        FREESEG32:  0x0152,         // DS_FreeSeg_32 (BX==segment, DX:EDI->module name)
        CONDBP:     0xF001,         // DS_CondBP (break here if WDEB386 was run with /B; ESI -> string to display)
        ENABLED:    true            // support for WINDBG interrupts can be disabled (but NOT if WINDBGRM is enabled)
    },
    WINDBGRM: {                     // Windows Debugger real-mode interface
        VECTOR:     0x68,           // (AH==command)
        IS_LOADED:  0x43,           // D386_Identify
        LOADED:     0xF386,         // D386_Id (returned in AX if Windows Debugger loaded)
        PREP_PMODE: 0x44,           // D386_Prepare_PMode (must return a 16:32 address in ES:EDI to a "PMinit" handler)
        FREESEG:    0x48,           // D386_Free_Segment (BX==real-mode segment)
        REMOVESEGS: 0x4F,           // D386_Remove_Segs (remove any undefined segments from the named module at ES:DI)
        LOADSEG:    0x50,           // D386_Load_Segment (AL=segment type, ES:DI->D386_Device_Params)
        ENABLED:    true            // support for WINDBGRM interrupts can be disabled
    },
    FUNCS: {}                       // filled in only if DEBUGGER is true
};

if (DEBUGGER) {
    Interrupts.BIOS_DATA = {
        0x400:  ["RS232_BASE",8],       // BASE ADDRESSES OF RS232 ADAPTERS
        0x408:  ["PRINTER_BASE",8],     // BASE ADDRESSES OF PRINTER ADAPTERS
        0x410:  ["EQUIP_FLAG",2],       // INSTALLED HARDWARE FLAGS
        0x412:  ["MFG_TST",1],          // INITIALIZATION FLAGS
        0x413:  ["MEMORY_SIZE",2],      // BASE MEMORY SIZE IN K BYTES  (X 1024)
        0x415:  ["MFG_ERR_FLAG",2],     // SCRATCHPAD FOR MANUFACTURING ERROR CODES
        0x417:  ["KB_FLAG",1],          // KEYBOARD SHIFT STATE AND STATUS FLAGS
        0x418:  ["KB_FLAG_1",1],        // SECOND BYTE OF KEYBOARD STATUS
        0x419:  ["ALT_INPUT",1],        // STORAGE FOR ALTERNATE KEY PAD ENTRY
        0x41A:  ["BUFFER_HEAD",2],      // POINTER TO HEAD OF KEYBOARD BUFFER
        0x41C:  ["BUFFER_TAIL",2],      // POINTER TO TAIL OF KEYBOARD BUFFER
        0x41E:  ["KB_BUFFER",32],       // ROOM FOR 15 SCAN CODE ENTRIES
        0x43E:  ["SEEK_STATUS",1],      // DRIVE RECALIBRATION STATUS (BIT 3-0 = DRIVE 3-0 RECALIBRATION BEFORE NEXT SEEK IF BIT IS = 0)
        0x43F:  ["MOTOR_STATUS",1],     // MOTOR STATUS (BIT 3-0 = DRIVE 3-0 CURRENTLY RUNNING, BIT 7 = CURRENT OPERATION IS A WRITE)
        0x440:  ["MOTOR_COUNT",1],      // TIME OUT COUNTER FOR MOTOR(S) TURN OFF
        0x441:  ["DISKETTE_STATUS",1],  // RETURN CODE STATUS BYTE
        0x442:  ["NEC_STATUS",7],       // STATUS BYTES FROM DISKETTE OPERATION
        0x449:  ["CRT_MODE",1],         // CURRENT DISPLAY MODE (TYPE)
        0x44A:  ["CRT_COLS",2],         // NUMBER OF COLUMNS ON SCREEN
        0x44C:  ["CRT_LEN",2],          // LENGTH OF REGEN BUFFER IN BYTES
        0x44E:  ["CRT_START",2],        // STARTING ADDRESS IN REGEN BUFFER
        0x450:  ["CURSOR_POSN",16],     // CURSOR FOR EACH OF UP TO 8 PAGES
        0x460:  ["CURSOR_MODE",2],      // CURRENT CURSOR MODE SETTING
        0x462:  ["ACTIVE_PAGE",1],      // CURRENT PAGE BEING DISPLAYED
        0x463:  ["ADDR_6845",2],        // BASE ADDRESS FOR ACTIVE DISPLAY CARD
        0x465:  ["CRT_MODE_SET",1],     // CURRENT SETTING OF THE 3X8 REGISTER
        0x466:  ["CRT_PALETTE",1],      // CURRENT PALETTE SETTING - COLOR CARD
        0x467:  ["IO_ROM_INIT",2],      // POINTER TO ROM INITIALIZATION ROUTINE
        0x469:  ["IO_ROM_SEG",2],       // POINTER TO I/O ROM SEGMENT
        0x46B:  ["INTR_FLAG",1],        // FLAG INDICATING AN INTERRUPT HAPPENED
        0x46C:  ["TIMER_LOW",2],        // LOW WORD OF TIMER COUNT
        0x46E:  ["TIMER_HIGH",2],       // HIGH WORD OF TIMER COUNT
        0x470:  ["TIMER_OFL",1],        // TIMER HAS ROLLED OVER SINCE LAST READ
        0x471:  ["BIOS_BREAK",1],       // BIT 7=1 IF BREAK KEY HAS BEEN PRESSED
        0x472:  ["RESET_FLAG",2],       // WORD=1234H IF KEYBOARD RESET UNDERWAY
        0x474:  ["DISK_STATUS1",1],     // FIXED DISK STATUS
        0x475:  ["HF_NUM",1],           // COUNT OF FIXED DISK DRIVES
        0x476:  ["CONTROL_BYTE",1],     // HEAD CONTROL BYTE
        0x477:  ["PORT_OFF",1],         // RESERVED (PORT OFFSET)
        0x478:  ["PRINT_TIM_OUT",4],    // TIME OUT COUNTERS FOR PRINTER RESPONSE
        0x47C:  ["RS232_TIM_OUT",4],    // TIME OUT COUNTERS FOR RS232 RESPONSE
        0x480:  ["BUFFER_START",2],     // OFFSET OF KEYBOARD BUFFER START
        0x482:  ["BUFFER_END",2],       // OFFSET OF END OF BUFFER
        0x484:  ["ROWS",1],             // ROWS ON THE ACTIVE SCREEN (LESS 1)
        0x485:  ["POINTS",2],           // BYTES PER CHARACTER
        0x487:  ["INFO",1],             // MODE OPTIONS
        0x488:  ["INFO_3",3],           // FEATURE BIT SWITCHES
        0x48B:  ["LASTRATE",1],         // LAST DISKETTE DATA RATE SELECTED
        0x48C:  ["HF_STATUS",1],        // STATUS REGISTER
        0x48D:  ["HF_ERROR",1],         // ERROR REGISTER
        0x48E:  ["HF_INT_FLAG",1],      // FIXED DISK INTERRUPT FLAG
        0x48F:  ["HF_CNTRL",1],         // COMBO FIXED DISK/DISKETTE CARD BIT 0=1
        0x490:  ["DSK_STATE",4],        // DRIVE 0 MEDIA STATE, DRIVE 1 MEDIA STATE, DRIVE 0 OPERATION START STATE, DRIVE 1 OPERATION START STATE
        0x494:  ["DSK_TRK",2],          // DRIVE 0 PRESENT CYLINDER, DRIVE 1 PRESENT CYLINDER
        0x496:  ["KB_FLAG_3",1],        // KEYBOARD MODE STATE AND TYPE FLAGS
        0x497:  ["KB_FLAG_2",1],        // KEYBOARD LED FLAGS
        0x498:  ["USER_FLAG",2],        // OFFSET ADDRESS OF USERS WAIT FLAG
        0x49A:  ["USER_FLAG_SEG",2],    // SEGMENT ADDRESS OF USER WAIT FLAG
        0x49C:  ["RTC_LOW",2],          // LOW WORD OF USER WAIT FLAG
        0x49E:  ["RTC_HIGH",2],         // HIGH WORD OF USER WAIT FLAG
        0x4A0:  ["RTC_WAIT_FLAG",1],    // WAIT ACTIVE FLAG (01=BUSY, 80=POSTED) (00=POST ACKNOWLEDGED)
        0x4A1:  ["NET",7],              // RESERVED FOR NETWORK ADAPTERS
        0x4A8:  ["SAVE_PTR",4]          // POINTER TO EGA PARAMETER CONTROL BLOCK
    };

    /*
     * See DebuggerX86.prototype.replaceRegs() for the rules governing how register contents are replaced in the strings below.
     *
     * Replacements occur in the following order:
     *
     *      Replace every @XX (or @XXX), where XX (or XXX) is a register, with the register's value.
     *      Replace every #XX, where XX is a hex byte value, with the corresponding ASCII character (if printable).
     *      Replace every $XXXX:XXXX, where XXXX:XXXX is a segmented address, with the zero-terminated string at that address.
     *      Replace every ^XXXX:XXXX, where XXXX:XXXX is a segmented address, with the FCB filename stored at that address.
     *
     * The last replacement is obviously DOS-specific, since FCBs are DOS constructs.
     */
    Interrupts.FUNCS[Interrupts.VIDEO] = {
        0x00: "set mode (@AL)",
        0x01: "set cursor type (start=@CH,end=@CL)",
        0x02: "set cursor pos (row=@DH,col=@DL,page=@BH)",
        0x03: "read cursor pos (page=@BH)",
        0x04: "read light pen",
        0x05: "set display page (@AL)",
        0x06: "scroll up (lines=@AL)",
        0x07: "scroll down (lines=@AL)",
        0x08: "read character (page=@BH)",
        0x09: "write char/attr (@AL,attr=@BL,count=@CX)",
        0x0A: "write char (@AL,count=@CX)",
        0x0B: "set palette (id=@BH,color=@BL)",
        0x0C: "write dot (row=@DX,col=@CX)",
        0x0D: "read dot (row=@DX,col=@CX)",
        0x0E: "write tty (@AL)"
    };

    Interrupts.FUNCS[Interrupts.DISK] = {
        0x00: "disk reset",
        0x01: "get status",
        0x02: "read drive @DL (@CH:@DH:@CL,@AL) into @ES:@BX",
        0x03: "write drive @DL (@CH:@DH:@CL,@AL) from @ES:@BX",
        0x04: "verify drive @DL (@CH:@DH:@CL,@AL)",
        0x05: "format drive @DL using @ES:@BX",
        0x08: "read drive @DL parameters",
        0x15: "get drive @DL DASD type",
        0x16: "get drive @DL change line status",
        0x17: "set drive @DL DASD type",
        0x18: "set drive @DL media type"
        /*
         * Here's an additional function reference, previously in the HDC component, but moved here
         * because our components are hardware emulations, not BIOS emulations, so this information is
         * really only of interest to the Debugger (or the casual observer).
         *
         *      RESET:          0x00,
         *      GET_STATUS:     0x01,
         *      READ_SECTORS:   0x02,
         *      WRITE_SECTORS:  0x03,
         *      VERIFY_SECTORS: 0x04,
         *      FORMAT_TRK:     0x05,
         *      FORMAT_BAD:     0x06,
         *      FORMAT_DRIVE:   0x07,
         *      GET_DRIVEPARMS: 0x08,
         *      SET_DRIVEPARMS: 0x09,
         *      READ_LONG:      0x0A,
         *      WRITE_LONG:     0x0B,
         *      SEEK:           0x0C,
         *      ALT_RESET:      0x0D,
         *      READ_BUFFER:    0x0E,
         *      WRITE_BUFFER:   0x0F,
         *      TEST_READY:     0x10,
         *      RECALIBRATE:    0x11,
         *      RAM_DIAGNOSTIC: 0x12,
         *      DRV_DIAGNOSTIC: 0x13,
         *      CTL_DIAGNOSTIC: 0x14
         */
    };

    Interrupts.FUNCS[Interrupts.CASSETTE] = {
        0x80: "open device",
        0x81: "close device",
        0x82: "program termination",
        0x83: "wait @CX:@DXus for event",
        0x84: "joystick support",
        0x85: "SYSREQ pressed",
        0x86: "wait @CX:@DXus",
        0x87: "move block (@CX words)",
        0x88: "get extended memory size",
        0x89: "processor to virtual mode",
        0x90: "device busy loop",
        0x91: "interrupt complete flag set"
    };

    Interrupts.FUNCS[Interrupts.DOS] = {
        0x00: "terminate program",
        0x01: "read character (AL) from stdin with echo",
        0x02: "write character #@DL to stdout",
        0x03: "read character (AL) from stdaux",                                // eg, COM1
        0x04: "write character #@DL to stdaux",                                 // eg, COM1
        0x05: "write character #@DL to stdprn",                                 // eg, LPT1
        0x06: "direct console output (input if @DL=FF)",
        0x07: "direct console input without echo",
        0x08: "read character (AL) from stdin without echo",
        0x09: "write string $@DS:@DX to stdout",
        0x0A: "buffered input (DS:DX)",                                         // byte 0 is maximum chars, byte 1 is number of previous characters, byte 2 is number of characters read
        0x0B: "get stdin status",
        0x0C: "flush buffer and read stdin",                                    // AL is a function # (0x01, 0x06, 0x07, 0x08, or 0x0A)
        0x0D: "disk reset",
        0x0E: "select default drive @DL",                                       // returns # of available drives in AL
        0x0F: "open file using FCB ^@DS:@DX",                                   // DS:DX -> unopened File Control Block
        0x10: "close file using FCB ^@DS:@DX",
        0x11: "find first matching file using FCB ^@DS:@DX",
        0x12: "find next matching file using FCB ^@DS:@DX",
        0x13: "delete file using FCB ^@DS:@DX",
        0x14: "sequential read from file using FCB ^@DS:@DX",
        0x15: "sequential write to file using FCB ^@DS:@DX",
        0x16: "create or truncate file using FCB ^@DS:@DX",
        0x17: "rename file using FCB ^@DS:@DX",
        0x19: "get current default drive (AL)",
        0x1A: "set disk transfer area (DTA=@DS:@DX)",
        0x1B: "get allocation information for default drive",
        0x1C: "get allocation information for specific drive @DL",
        0x1F: "get drive parameter block for default drive",
        0x21: "read random record from file using FCB ^@DS:@DX",
        0x22: "write random record to file using FCB ^@DS:@DX",
        0x23: "get file size using FCB ^@DS:@DX",
        0x24: "set random record number for FCB ^@DS:@DX",
        0x25: "set address @DS:@DX of interrupt vector @AL",
        0x26: "create new PSP at segment @DX",
        0x27: "random block read from file using FCB ^@DS:@DX",
        0x28: "random block write to file using FCB ^@DS:@DX",
        0x29: "parse filename $@DS:@SI into FCB @ES:@DI using @AL",
        0x2A: "get system date (year=CX, mon=DH, day=DL)",
        0x2B: "set system date (year=@CX, mon=@DH, day=@DL)",
        0x2C: "get system time (hour=CH, min=CL, sec=DH, 100ths=DL)",
        0x2D: "set system time (hour=@CH, min=@CL, sec=@DH, 100ths=@DL)",
        0x2E: "set verify flag @AL",
        0x2F: "get disk transfer area (DTA=ES:BX)",                             // DOS 2.00+
        0x30: "get DOS version (AL=major, AH=minor)",
        0x31: "terminate and stay resident",
        0x32: "get drive parameter block (DPB=DS:BX) for drive @DL",
        0x33: "extended break check",
        0x34: "get address (ES:BX) of InDOS flag",
        0x35: "get address (ES:BX) of interrupt vector @AL",
        0x36: "get free disk space of drive @DL",
        0x37: "get(0)/set(1) switch character @DL (@AL)",
        0x38: "get country-specific information",
        0x39: "create subdirectory $@DS:@DX",
        0x3A: "remove subdirectory $@DS:@DX",
        0x3B: "set current directory $@DS:@DX",
        0x3C: "create or truncate file $@DS:@DX with attributes @CX",
        0x3D: "open file $@DS:@DX with mode @AL",
        0x3E: "close file @BX",
        0x3F: "read @CX bytes from file @BX into buffer @DS:@DX",
        0x40: "write @CX bytes to file @BX from buffer @DS:@DX",
        0x41: "delete file $@DS:@DX",
        0x42: "set position @CX:@DX of file @BX relative to @AL",
        0x43: "get(0)/set(1) attributes @CX of file $@DS:@DX (@AL)",
        0x44: "get device information (IOCTL)",
        0x45: "duplicate file handle @BX",
        0x46: "force file handle @CX to duplicate file handle @BX",
        0x47: "get current directory (DS:SI) for drive @DL",
        0x48: "allocate memory segment with @BX paragraphs",
        0x49: "free memory segment @ES",
        0x4A: "resize memory segment @ES to @BX paragraphs",
        0x4B: "load program $@DS:@DX using parameter block @ES:@BX",
        0x4C: "terminate with return code @AL",
        0x4D: "get return code (AL)",
        0x4E: "find first matching file $@DS:@DX with attributes @CX",
        0x4F: "find next matching file",
        0x50: "set current PSP @BX",
        0x51: "get current PSP (bx)",
        0x52: "get system variables (ES:BX)",
        0x53: "translate BPB @DS:@SI to DPB (ES:BP)",
        0x54: "get verify flag (AL)",
        0x55: "create child PSP at segment @DX",
        0x56: "rename file $@DS:@DX to $@ES:@DI",
        0x57: "get(0)/set(1) file @BX date @DX and time @CX (@AL)",
        0x58: "get(0)/set(1) memory allocation strategy (@AL)",                 // DOS 2.11+
        0x59: "get extended error information",                                 // DOS 3.00+
        0x5A: "create temporary file $@DS:@DX with attributes @CX",             // DOS 3.00+
        0x5B: "create file $@DS:@DX with attributes @CX",                       // DOS 3.00+ (doesn't truncate existing files like 0x3C)
        0x5C: "lock(0)/unlock(1) file @BX region @CX:@DX length @SI:@DI (@AL)", // DOS 3.00+
        0x5D: "critical error information (@AL)",                               // DOS 3.00+ (undocumented)
        0x60: "get fully-qualified filename from $@DS:@SI",                     // DOS 3.00+ (undocumented)
        0x63: "get lead byte table (@AL)",                                      // DOS 2.25 and 3.20+
        0x6C: "extended open file $@DS:@SI"                                     // DOS 4.00+
    };

    Interrupts.FUNCS[Interrupts.WINDBG.VECTOR] = {
        0x004F: "check debugger loaded"         // WINDBG.IS_LOADED returns WINDBG.LOADED (0xF386) if debugger loaded
    };
}

/*
 * DOS function reference (from https://sites.google.com/site/pcdosretro/dosfuncs)
 *
 *      INT 20 Program terminate (1.0+)
 *      Entry: CS=PSP
 *      Exit:  Does not return to caller
 *
 *      INT 21 Execute DOS function
 *      00 Program terminate (1.0+)
 *         Entry: CS=PSP
 *         Exit:  Does not return to caller
 *      01 Character input (1.0+)
 *         Entry: None
 *         Exit:  AL=character
 *      02 Character output (1.0+)
 *         Entry: DL=character
 *         Exit:  None
 *      03 Auxiliary input (1.0+)
 *         Entry: None
 *         Exit:  AL=character
 *      04 Auxiliary output (1.0+)
 *         Entry: DL=character
 *         Exit:  None
 *      05 Printer output (1.0+)
 *         Entry: DL=character
 *         Exit:  None
 *      06 Direct console I/O (1.0+)
 *         Entry: DL=FF for console input
 *                DL=character for console output
 *         Exit:  ZF=0 if a character is ready, AL=character
 *                ZF=1 if no character is ready
 *      07 Direct console input without echo (1.0+)
 *         Entry: None
 *         Exit:  AL=character
 *      08 Console input without echo (1.0+)
 *         Entry: None
 *         Exit:  AL=character
 *      09 Display string (1.0+)
 *         Entry: DS:DX-&gt;string ending with $
 *         Exit:  None
 *      0A Buffered keyboard input (1.0+)
 *         Entry: DS:DX-&gt;input buffer (first byte of buffer=maximum input length)
 *         Exit:  second byte of buffer=actual input length
 *      0B Get input status (1.0+)
 *         Entry: None
 *         Exit:  AL=00 no character available
 *                AL=FF character available
 *      0C Flush input buffer and input (1.0+)
 *         Entry: AL=function number (01,06,07,08,or 0A otherwise flush only)
 *                DS:DX-&gt;input buffer if function 0A
 *         Exit:  AL=character unless function 0A
 *      0D Disk reset (1.0+)
 *         Entry: None
 *         Exit:  None
 *      0E Set default drive (1.0+)
 *         Entry: DL=drive code (0=A)
 *         Exit:  AL=number of logical drives
 *      0F Open file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 file opened
 *                AL=FF file not found
 *      10 Close file (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file closed
 *                AL=FF file not found
 *      11 Find first file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 matching filename found
 *                      buffer at DTA receives an unopened FCB and directory entry
 *                      original FCB contents:
 *                      FCB    search drive code (1=A)
 *                      FCB+1  specified filespec
 *                      FCB+12 search attribute byte
 *                      FCB+13 directory entry offset
 *                      FCB+15 directory cluster (0=root)
 *                      FCB+17 unused
 *                      FCB+21 actual drive code (1=A)
 *                AL=FF matching filename not found
 *         Note:  The file's directory entry is returned after the FCB drive code.
 *                If a character device is found then the directory attribute byte
 *                is set to 40h.
 *      12 Find next file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB from previous 11 or 12 call
 *         Exit:  AL=00 matching filename found
 *                      buffer at DTA receives an unopened FCB and directory entry
 *                AL=FF matching filename not found
 *         Note:  The file's directory entry is returned after the FCB drive code.
 *      13 Delete file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 file deleted
 *                AL=FF matching filename not found or files are read-only
 *      14 Sequential read (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file was read
 *                AL=01 EOF (no data read)
 *                AL=02 segment wrap
 *                AL=03 EOF (partial read)
 *      15 Sequential write (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file was written
 *                AL=01 disk full
 *                AL=02 segment wrap
 *      16 Create or truncate file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 file created
 *                AL=FF directory full
 *      17 Rename file (1.0+)
 *         Entry: DS:DX-&gt;rename FCB (FCB+11h-&gt;new filename)
 *         Exit:  AL=00 file renamed
 *                AL=FF no matching files found or new filename already exists
 *      18 Reserved
 *      19 Get default drive (1.0+)
 *         Entry: None
 *         Exit:  AL=drive code (0=A)
 *      1A Set disk transfer address (1.0+)
 *         Entry: DS:DX=new DTA
 *         Exit:  None
 *      1B Get allocation info for default drive (1.0+)
 *         Entry: None
 *         Exit:  AL=sectors per cluster
 *                CX=bytes per sector
 *                DX=clusters per drive
 *                DS:BX-&gt;media descriptor byte
 *                AL=FF invalid drive
 *      1C Get allocation info for specified drive (1.1+)
 *         Entry: DL=drive code (0=default)
 *         Exit:  Same as function 1B
 *      1D Reserved
 *      1E Reserved
 *      1F Get disk parameter block for default drive (1.1+)
 *         Entry: None
 *         Exit:  AL=00 drive valid
 *                DS:BX-&gt;disk parameter block
 *                   0 drive code (0=A)             13 maximum cluster number
 *                   1 unit code                    15 sectors per FAT
 *                   2 bytes per sector             17 first directory sector
 *                   4 sectors per cluster-1        19 pointer to device driver
 *                   5 cluster shift factor         23 media descriptor byte
 *                   6 first FAT sector             24 access flag (0=accessed)
 *                   8 number of FATs               25 pointer to next DPB
 *                   9 number of directory entries  29 last cluster allocated
 *                  11 first data sector            31 free clusters (-1=unknown)
 *                AL=FF drive invalid
 *         Note:  (3.x) The sectors per FAT field is one byte and all following
 *                fields are moved back one byte.
 *      20 Reserved
 *      21 Random read (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file was read
 *                AL=01 EOF (no data read)
 *                AL=02 segment wrap
 *                AL=03 EOF (partial read)
 *      22 Random write (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file was written
 *                AL=01 disk full
 *                AL=02 segment wrap
 *      23 Get file size in records (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 random record field is set by dividing the file size by the
 *                      specified record size
 *                AL=FF file not found
 *      24 Set random record number (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  random record field is set based on record size, current record,
 *                and current block
 *      25 Set interrupt vector (1.0+)
 *         Entry: DS:DX=new address
 *                AL=interrupt number
 *         Exit:  None
 *      26 Create PSP (1.0+)
 *         Entry: CS=PSP
 *                DX=segment for new PSP
 *         Exit:  None
 *      27 Random block read (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *                CX=number of records to read
 *         Exit:  AL=00 file was read
 *                AL=01 EOF (no data read)
 *                AL=02 segment wrap
 *                AL=03 EOF (partial read)
 *                CX=actual number of records read
 *      28 Random block write (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *                CX=number of records to write
 *         Exit:  AL=00 file was written
 *                AL=01 disk full
 *                AL=02 segment wrap
 *                CX=actual number of records written
 *      29 Parse filename (1.0+)
 *         Entry: DS:SI-&gt;string to parse
 *                ES:DI-&gt;buffer for unopened FCB
 *                AL=flags
 *                   Bit 0 1=ignore leading separators
 *                       1 1=modify FCB drive code byte only if a drive is specified
 *                       2 1=modify FCB filename only if a filename is specified
 *                       3 1=modify FCB extension only if an extension is specified
 *         Exit:  DS:SI-&gt;first character after parsed filename
 *                AL=00 no wildcard characters in string
 *                AL=01 wildcard characters in string
 *                AL=FF invalid drive
 *      2A Get date (1.0+)
 *         Entry: None
 *         Exit:  AL=weekday (0=Sunday)
 *                CX=year
 *                DH=month
 *                DL=day
 *      2B Set date (1.0+)
 *         Entry: CX=year
 *                DH=month
 *                DL=day
 *         Exit:  AL=00 date set
 *                AL=FF invalid date
 *      2C Get time (1.0+)
 *         Entry: None
 *         Exit:  CH=hours
 *                CL=minutes
 *                DH=seconds
 *                DL=hundredths
 *      2D Set time (1.0+)
 *         Entry: CH=hours
 *                CL=minutes
 *                DH=seconds
 *                DL=hundredths
 *         Exit:  AL=00 time set
 *                AL=FF invalid time
 *      2E Set verify flag (1.1+)
 *         Entry: AL=verify flag (0=off,1=on)
 *         Exit:  None
 *      2F Get disk transfer address (2.0+)
 *         Entry: None
 *         Exit:  ES:BX=DTA
 *      30 Get DOS version (2.0+)
 *         Entry: AL=0 return OEM number (5.0+)
 *                AL=1 return version flag (5.0+)
 *         Exit:  AL=major version number
 *                AH=minor version number
 *                BH=OEM number or version flag (00=RAM,08=ROM)
 *                BL:CX=24-bit serial number or 0
 *      31 Terminate and stay resident (2.0+)
 *         Entry: AL=return code
 *                DX=memory size in paragraphs (minimum 6)
 *         Exit:  Does not return to caller
 *      32 Get disk parameter block for specified drive (2.0+)
 *         Entry: DL=drive code (0=default)
 *         Exit:  Same as function 1F
 *      33 Get or set Ctrl-Break (2.0+)
 *         Entry: AL=0 get break
 *                AL=1 set break
 *                AL=2 swap break (*) (3.1+)
 *                AL=5 get boot drive (4.0+)
 *                AL=6 get DOS version (5.0+)
 *                DL=break flag if set or swap (0=off,1=on)
 *         Exit:  if function 00 or 02:
 *                   DL=break flag
 *                if function 05:
 *                   DL=boot drive code (1=A)
 *                if function 06:
 *                   BL=major version
 *                   BH=minor version
 *                   DL=revision (0=A)
 *                   DH=version flag (00=low,08=ROM,10=HMA)
 *      34 Get InDOS flag pointer (2.0+)
 *         Entry: None
 *         Exit:  ES:BX-&gt;InDOS flag
 *         Note:  The DOS critical error flag immediately precedes this byte.
 *      35 Get interrupt vector (2.0+)
 *         Entry: AL=interrupt number
 *         Exit:  ES:BX=interrupt address
 *      36 Get free disk space (2.0+)
 *         Entry: DL=drive code (0=default)
 *         Exit:  AX=sectors per cluster
 *                BX=free clusters
 *                CX=bytes per sector
 *                DX=clusters per drive
 *                AX=FFFF if drive invalid
 *      37 Get or set switch character (*) (2.0+)
 *         Entry: AL=0 get switch character
 *                AL=1 set switch character
 *                DL=switch character if set
 *         Exit:  DL=switch character if get
 *         Note:  (5.0+) Function 3701 has been disabled.
 *      38 Get or set country info (2.0+)
 *         Entry: AL=country code (0=default)
 *                BX=country code if AL=FF (3.0+)
 *                DX=FFFF if set request (2.11+)
 *                DS:DX-&gt;buffer if get request
 *         Exit:  CF=0 BX=country code if get request (3.0+)
 *                     buffer format:
 *                      0 date format (0=USA,1=Europe,2=Japan)
 *                      2 currency symbol string
 *                      7 thousands separator
 *                      9 decimal separator
 *                     11 date separator
 *                     13 time separator
 *                     15 currency format
 *                        0 symbol before amount, no space between
 *                        1 symbol after amount, no space between
 *                        2 symbol before amount, 1 space between
 *                        3 symbol after amount, 1 space between
 *                        4 symbol replaces decimal separator
 *                     16 digits after decimal in currency
 *                     17 time format (0=12-hour,1=24-hour)
 *                     18 case map call address
 *                     22 data list separator
 *                     24 reserved (10 bytes)
 *                CF=1 AX=error code
 *      39 Create directory (2.0+)
 *         Entry: DS:DX-&gt;directory name
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      3A Remove directory (2.0+)
 *         Entry: DS:DX-&gt;directory name
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      3B Change current directory (2.0+)
 *         Entry: DS:DX-&gt;directory name
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      3C Create or truncate file (2.0+)
 *         Entry: DS:DX-&gt;filename
 *                CX=file attributes
 *         Exit:  CF=0 AX=file handle
 *                CF=1 AX=error code
 *      3D Open file (2.0+)
 *         Entry: DS:DX-&gt;filename
 *                AL=open mode
 *                   Bit 0-2 access mode
 *                           000=read
 *                           001=write
 *                           010=read/write
 *                       4-6 sharing mode (3.0+)
 *                           000=compatibility
 *                           001=deny read/write access
 *                           010=deny write access
 *                           011=deny read access
 *                           100=deny none access
 *                         7 inheritance flag
 *                           0=file inherited by EXECed programs
 *                           1=file not inherited by EXECed programs
 *         Exit:  CF=0 AX=file handle
 *                CF=1 AX=error code
 *      3E Close file (2.0+)
 *         Entry: BX=file handle
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      3F Read file or device (2.0+)
 *         Entry: BX=file handle
 *                CX=bytes to read
 *                DS:DX-&gt;input buffer
 *         Exit:  CF=0 AX=number of bytes read (0=EOF)
 *                CF=1 AX=error code
 *      40 Write file or device (2.0+)
 *         Entry: BX=file handle
 *                CX=bytes to write (0=truncate file)
 *                DS:DX-&gt;output buffer
 *         Exit:  CF=0 AX=number of bytes written (0=disk full)
 *                CF=1 AX=error code
 *      41 Delete file (2.0+)
 *         Entry: DS:DX-&gt;filename
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      42 Move file pointer (2.0+)
 *         Entry: AL=code (0=absolute,1=relative,2=relative to EOF)
 *                BX=file handle
 *                CX:DX=offset
 *         Exit:  CF=0 DX:AX=new pointer
 *                CF=1 AX=error code
 *      43 Get or set file attributes (2.0+)
 *         Entry: AL=0 get attributes
 *                AL=1 set attributes
 *                CX=file attributes if set
 *                   Bit 0 1=read-only
 *                       1 1=hidden
 *                       2 1=system
 *                       4 1=directory (get only)
 *                       5 1=archive
 *                DS:DX-&gt;filename
 *         Exit:  CF=0 CX=file attributes if get
 *                CF=1 AX=error code
 *      44 I/O control for devices (2.0+)
 *         Notes: 1) Functions 02-05 work only if bit 14 of the device driver
 *                   attribute word is set.
 *                2) Function 08 works only if bit 11 of the device driver
 *                   attribute word is set.
 *                3) Functions 0C-0F work only if bit 6 of the device driver
 *                   attribute word is set.
 *                4) Functions 10-11 work only if bit 7 of the device driver
 *                   attribute word is set.
 *         00 Get device attributes (2.0+)
 *            Entry: BX=file handle
 *            Exit:  CF=0 DX=device attributes
 *                        Character devices:
 *                        Bit 0 1=console input
 *                            1 1=console output
 *                            2 1=NUL device
 *                            3 1=CLOCK device
 *                            4 1=INT 29 output (CON)
 *                            5 0=ASCII,1=binary
 *                            6 0=EOF on input
 *                            7 1=character device
 *                           11 1=open/close supported
 *                           13 1=output until busy supported
 *                           14 1=IOCTL supported
 *                        Block devices:
 *                        Bit 0-5 drive code (0=A)
 *                              6 0=file has been written
 *                              7 0=block device
 *                   CF=1 AX=error code
 *         01 Set device attributes (2.0+)
 *            Entry: BX=file handle (character devices only)
 *                   DX=device attributes (DH must be 0)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         02 Read from character device (2.0+)
 *         03 Write to character device (2.0+)
 *            Entry: BX=file handle
 *                   CX=number of bytes
 *                   DS:DX-&gt;buffer
 *            Exit:  CF=0 AX=number of bytes transferred
 *                   CF=1 AX=error code
 *         04 Read from block device (2.0+)
 *         05 Write to block device (2.0+)
 *            Entry: BL=drive code (0=default)
 *                   CX=number of bytes
 *                   DS:DX-&gt;buffer
 *            Exit:  CF=0 AX=number of bytes transferred
 *                   CF=1 AX=error code
 *         06 Get input status (2.0+)
 *         07 Get output status (2.0+)
 *            Entry: BX=file handle
 *            Exit:  CF=0 AL=status (00=not ready,FF=ready)
 *                   CF=1 AX=error code
 *         08 Removable media check (3.0+)
 *            Entry: BL=drive code (0=default)
 *            Exit:  CF=0 AX=value (0=removable,1=fixed)
 *                   CF=1 AX=error code
 *         09 Local/remote drive check (3.0+)
 *            Entry: BL=drive code (0=default)
 *            Exit:  CF=0 DX=device attributes
 *                        Bit 1 1=32-bit sectors supported
 *                            6 1=generic IOCTL calls supported
 *                            7 1=query IOCTL call supported
 *                            9 1=shared drive; direct I/O not allowed
 *                           11 1=removable media call supported
 *                           12 1=remote drive
 *                           13 1=media descriptor in FAT required
 *                           14 1=IOCTL calls supported
 *                           15 1=SUBSTed
 *                   CF=1 AX=error code
 *         0A Local/remote handle check (3.0+)
 *            Entry: BX=file handle
 *            Exit:  CF=0 DX=device attributes from SFT
 *                        Character devices:
 *                        Bit 0 1=console input
 *                            1 1=console output
 *                            2 1=NUL device
 *                            3 1=CLOCK device
 *                            4 1=INT 29 output (CON)
 *                            5 0=ASCII,1=binary
 *                            6 0=EOF on input
 *                            7 1=character device
 *                           11 1=network spooler
 *                           12 1=no inherit
 *                           13 1=named pipe
 *                           15 1=remote
 *                        Block devices:
 *                        Bit 0-5 drive code (0=A)
 *                              6 0=file has been written
 *                              7 0=block device
 *                             12 1=no inherit
 *                             14 1=date/time set
 *                             15 1=remote
 *                   CF=1 AX=error code
 *         0B Change sharing retry count (3.0+)
 *            Entry: CX=delay loop count
 *                   DX=retry count
 *            Exit:  None
 *         0C Generic IOCTL for handles (3.2+)
 *            Entry: BX=file handle
 *                   CH=category code (01=AUX,03=CON,05=PRN)
 *                   CL=function code
 *                      45 set printer retry count
 *                      4A set code page (3.3+)
 *                      4C prepare start (3.3+)
 *                      4D prepare end (3.3+)
 *                      5F set display info (4.0+)
 *                      65 get printer retry count
 *                      6A get code page (3.3+)
 *                      6B get prepare list (3.3+)
 *                      7F get display info (4.0+)
 *                   DS:DX-&gt;parameter block or retry count word
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *            Get/set code page and prepare end parameter block format:
 *               0 length (2)
 *               2 code page
 *            Prepare start parameter block format:
 *               0 flags (device specific)
 *               2 data length
 *               4 number of code pages
 *               6 code pages (-1=perform a refresh operation)
 *            Get prepare list parameter block format:
 *               0 data length
 *               2 number of hardware code pages
 *               4 hardware code pages
 *               n number of prepared code pages
 *             n+2 prepared code pages
 *            Display info parameter block format:
 *               0 info level (must be 0)
 *               1 reserved
 *               2 data length (14)
 *               4 flags
 *                 Bit 0 (0=blink,1=intensity)
 *               6 mode (1=text,2=graphics)
 *               7 reserved
 *               8 colors
 *              10 pixel columns
 *              12 pixel rows
 *              14 character columns
 *              16 character rows
 *         0D Generic IOCTL for drives (3.2+)
 *            Entry: BL=drive code (0=default)
 *                   CH=category code (08=disk)
 *                   CL=function code
 *                      40 set device parameters
 *                      41 write track
 *                      42 format track
 *                      46 set media info (4.0+)
 *                      47 set access flag (4.0+)
 *                      60 get device parameters
 *                      61 read track
 *                      62 verify track
 *                      66 get media info (4.0+)
 *                      67 get access flag (4.0+)
 *                      68 sense media type (5.0+)
 *                   DS:DX-&gt;parameter block
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *            Get/set device parameter block format:
 *               0 flags (only bit 0 is used by get)
 *                 Bit 0 0=return default BPB/build new BPB
 *                       1=return build BPB/use device BPB
 *                     1 0=read all fields
 *                       1=read track layout only
 *                     2 0=sector sizes vary
 *                       1=sector sizes equal
 *               1 drive type
 *                 0=360K             5=fixed
 *                 1=1.2M             6=tape
 *                 2=720K             7=1.44M
 *                 3=8" single sided  8=read/write optical
 *                 4=8" double sided  9=2.88M
 *               2 attributes
 *                 Bit 0 1=non-removable
 *                     1 1=changeline supported
 *               4 cylinders
 *               6 density (0=high,1=double)
 *               7 BIOS parameter block
 *              32 reserved
 *              38 track layout count
 *              40 track layout words (sector number,sector size)
 *              Note: Track layout fields are used by set only.
 *            Read/write parameter block format:
 *               0 reserved
 *               1 head
 *               3 cylinder
 *               5 sector
 *               7 number of sectors
 *               9 buffer address
 *            Format/verify parameter block format:
 *               0 reserved
 *               1 head
 *               3 cylinder
 *            Get/set media info parameter block format:
 *               0 info level (must be 0)
 *               2 volume serial number
 *               6 volume label
 *              17 8-byte file system type
 *            Get/set access flag parameter block format:
 *               0 reserved
 *               1 access flag (0=disallow disk access,1=allow disk access)
 *            Sense media type parameter block format:
 *               0 media type flag (0=other,1=default)
 *               1 media type (2=720K,7=1.44M,9=2.88M)
 *         0E Get logical drive map (3.2+)
 *         0F Set logical drive map (3.2+)
 *            Entry: BL=logical drive code (0=default)
 *            Exit:  CF=0 AL=physical drive code (0=only 1 logical drive mapped)
 *                   CF=1 AX=error code
 *         10 Query IOCTL for handles (5.0+)
 *            Entry: BX=file handle
 *                   CH=category code (01=AUX,03=CON,05=PRN)
 *                   CL=function code
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         11 Query IOCTL for drives (5.0+)
 *            Entry: BL=drive code (0=default)
 *                   CH=category code (08=disk)
 *                   CL=function code
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *      45 Duplicate handle (2.0+)
 *         Entry: BX=file handle
 *         Exit:  CF=0 AX=new file handle
 *                CF=1 AX=error code
 *      46 Redirect handle (2.0+)
 *         Entry: BX=file handle
 *                CX=file handle to redirect
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *         Note:  If the handle to redirect is opened then it is closed before
 *                being redirected.
 *      47 Get current directory (2.0+)
 *         Entry: DS:SI-&gt;64-byte buffer for pathname
 *                DL=drive code (0=default)
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      48 Allocate memory (2.0+)
 *         Entry: BX=number of paragraphs to allocate
 *         Exit:  CF=0 AX=segment of allocated block
 *                CF=1 AX=error code
 *                     BX=size of largest available block
 *      49 Release memory (2.0+)
 *         Entry: ES=segment of block to release
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      4A Reallocate memory (2.0+)
 *         Entry: BX=number of paragraphs to allocate
 *                ES=segment of block to reallocate
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *                     BX=size of largest available block
 *      4B Execute program (2.0+)
 *         Entry: AL=0 execute program
 *                AL=1 load program
 *                AL=3 load overlay
 *                AL=5 enter exec state (5.0+)
 *                DS:DX-&gt;filename or exec state parameter block
 *                ES:BX-&gt;parameter block (unused by enter exec state)
 *                   if function 00 or 01:
 *                      0 environment block segment or 0
 *                      2 command tail pointer
 *                      6 FCB1 pointer
 *                     10 FCB2 pointer
 *                   if function 03:
 *                      0 segment where file will be loaded
 *                      2 relocation factor
 *                   if function 05:
 *                      0 reserved
 *                      2 flags (0=COM,1=EXE,2=overlay)
 *                      4 program name pointer
 *                      8 PSP
 *                     10 program CS:IP
 *                     14 doubleword program size
 *         Exit:  CF=0 BX and DX may be destroyed
 *                     parameter block if load only:
 *                       14 SS:SP of loaded program
 *                       18 CS:IP of loaded program
 *                CF=1 AX=error code
 *         Note:  After calling function 4B01 the current PSP is set to that of
 *                the loaded program. Before executing the program, DS and ES
 *                should be set to the program's PSP and the INT 22 vector in the
 *                program's PSP should be set to a valid return address.
 *      4C Terminate with return code (2.0+)
 *         Entry: AL=return code
 *         Exit:  Does not return to caller
 *      4D Get program return code (2.0+)
 *         Entry: None
 *         Exit:  AL=return code
 *                AH=exit type (0=normal,1=Ctrl-C,2=critical error,3=TSR)
 *      4E Find first file (2.0+)
 *         Entry: DS:DX-&gt;filespec
 *                CX=file attributes
 *         Exit:  CF=0 DTA    search drive code (1=A)
 *                     DTA+1  search filespec
 *                     DTA+12 search attribute byte
 *                     DTA+13 directory entry offset
 *                     DTA+15 directory cluster (0=root)
 *                     DTA+17 unused
 *                     DTA+21 attribute byte (40h=character device)
 *                     DTA+22 file time
 *                     DTA+24 file date
 *                     DTA+26 file size
 *                     DTA+30 filename
 *                CF=1 AX=error code
 *      4F Find next file (2.0+)
 *         Entry: Bytes 0-20 of buffer at DTA must be set from previous 4E or 4F call
 *         Exit:  Same as function 4E
 *      50 Set current PSP (2.0+)
 *         Entry: BX=PSP segment
 *         Exit:  None
 *      51 Get current PSP (2.0+)
 *         Entry: None
 *         Exit:  BX=PSP segment
 *      52 Get DOS internal pointers (*) (2.0+)
 *         Entry: None
 *         Exit:  ES:BX-&gt;DOS internal pointers
 *                  -02h memory chain anchor
 *                  +00h pointer to disk parameter blocks
 *                  +04h pointer to system file tables
 *                  +08h pointer to CLOCK$ device header
 *                  +0Ch pointer to CON device header
 *                  +10h disk buffer size
 *                  +12h pointer to disk buffer chain (3.x)
 *                       pointer to disk buffer control block (4.0+)
 *                  +16h pointer to current directory structures
 *                  +1Ah pointer to FCB system file tables
 *                  +1Eh FCB keep count
 *                  +20h number of actual drives
 *                  +21h number of logical drives
 *                  +22h NUL device header
 *      53 Create disk parameter block (*) (2.0+)
 *         Entry: DS:SI-&gt;BIOS parameter block
 *                   0 bytes per sector
 *                   2 sectors per cluster
 *                   3 number of reserved sectors
 *                   5 number of FATs
 *                   6 number of root directory entries
 *                   8 total number of sectors
 *                  10 media descriptor byte
 *                  11 sectors per FAT
 *                  13 sectors per track
 *                  15 number of heads
 *                  17 number of hidden sectors
 *                  21 32-bit number of sectors if word at 8=0
 *                ES:BP-&gt;buffer for disk parameter block
 *         Exit:  None
 *      54 Get verify flag (2.0+)
 *         Entry: None
 *         Exit:  AL=verify flag (0=off,1=on)
 *      55 Create program PSP (*) (2.0+)
 *         Entry: DX=segment for new PSP
 *                SI=new end of allocation
 *         Exit:  None
 *         Note:  After calling function 55 the current PSP is set to the new PSP.
 *      56 Rename file (2.0+)
 *         Entry: DS:DX-&gt;old filename
 *                ES:DI-&gt;new filename
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *         Note:  This function can also rename a directory or move a file from
 *                one directory to another.
 *      57 Get or set file date and time (2.0+)
 *         Entry: AL=0 get date and time
 *                AL=1 set date and time
 *                BX=file handle
 *                CX=time if set
 *                   Bits 0-4 seconds/2 (0-29)
 *                       5-10 minutes (0-59)
 *                      11-15 hours (0-23)
 *                DX=date if set
 *                   Bits 0-4 day (1-31)
 *                        5-8 month (1-12)
 *                       9-15 year-1980
 *         Exit:  CF=0 CX=time if get
 *                     DX=date if get
 *                CF=1 AX=error code
 *      58 Get or set allocation strategy (2.11+)
 *         Entry: AL=0 get strategy
 *                AL=1 set strategy
 *                AL=2 get UMB link state (5.0+)
 *                AL=3 set UMB link state (5.0+)
 *                BX=strategy code or UMB link state (0=unlink,1=link)
 *                   00=first fit
 *                   01=best fit
 *                   02=last fit
 *                   40=first fit, high only (5.0+)
 *                   41=best fit, high only (5.0+)
 *                   42=last fit, high only (5.0+)
 *                   80=first fit, high first (5.0+)
 *                   81=best fit, high first (5.0+)
 *                   82=last fit, high first (5.0+)
 *         Exit:  CF=0 AX=strategy code or UMB link state if get
 *                CF=1 AX=error code
 *      59 Get extended error info (3.0+)
 *         Entry: None
 *         Exit:  AX=extended error code
 *                BH=error class
 *                BL=suggested action
 *                CH=locus
 *                ES:DI-&gt;volume label for invalid disk change error or 0
 *      5A Create unique file (3.0+)
 *         Entry: DS:DX-&gt;pathname ending with \
 *                CX=file attributes
 *         Exit:  CF=0 AX=file handle (filename is appended to pathname)
 *                CF=1 AX=error code
 *      5B Create new file (3.0+)
 *         Entry: DS:DX-&gt;filename
 *                CX=file attributes
 *         Exit:  CF=0 AX=file handle
 *                CF=1 AX=error code
 *      5C Lock or unlock file (3.0+)
 *         Entry: AL=0 lock
 *                AL=1 unlock
 *                BX=file handle
 *                CX:DX=region offset
 *                SI:DI=region length
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *         Note:  File sharing (SHARE.EXE) must be loaded to use this function.
 *      5D File sharing functions (*) (3.0+)
 *         Notes: 1) Some functions use a parameter block with the following format:
 *                   AX,BX,CX,DX,SI,DI,DS,ES,reserved,machine #,process (PSP)
 *                2) Functions 02-05 work only if file sharing (SHARE.EXE) is loaded.
 *                3) Functions 07-09 work only if the redirector (REDIR.EXE) is loaded.
 *         00 Server DOS call (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (AX,BX,CX,DX,SI,DI,DS,ES,machine #,process)
 *            Exit:  Depends on called function
 *         01 Commit all local files (*) (3.0+)
 *            Entry: None
 *            Exit:  None
 *         02 Close all occurrences of file (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (DS:DX-&gt;qualified filespec)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         03 Close all files for machine (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (machine #)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         04 Close all files for machine and process (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (machine #,process)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         05 Get shared file info (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (BX=share file table index,CX=SFT index)
 *            Exit:  CF=0 AX=device info from SFT
 *                        BX=machine #
 *                        CX=lock count
 *                        ES:DI-&gt;qualified filename
 *                   CF=1 AX=error code
 *         06 Get DOS swappable data area (*) (3.0+)
 *            Entry: None
 *            Exit:  DS:SI-&gt;DOS swappable data area
 *                   CX=DOS swappable data area length
 *                   DX=DOS critical data area length
 *            Note:  The first byte of the data area is the critical error flag.
 *         07 Get print stream state (*) (3.1+)
 *            Entry: None
 *            Exit:  DL=state (0=truncate off,1=truncate on)
 *         08 Set print stream state (*) (3.1+)
 *            Entry  DL=state (0=truncate off,1=truncate on)
 *            Exit:  None
 *         09 Truncate print stream (*) (3.1+)
 *            Entry  None
 *            Exit:  None
 *         0A Set extended error info (3.1+)
 *            Entry: DS:DX-&gt;parameter block (see function 59 for affected registers)
 *            Exit:  None
 *      5E Network functions (3.0+)
 *         Note: Functions 02-05 work only if the redirector (REDIR.EXE) is loaded.
 *         00 Get machine name (3.0+)
 *            Entry: DS:DX-&gt;buffer for machine name
 *            Exit:  CH=validity flag (0=invalid,1=valid)
 *                   CL=netbios number
 *         01 Set machine name (*) (3.0+)
 *            Entry: DS:DX-&gt;machine name
 *                   CH=validity flag (0=invalid,1=valid)
 *                   CL=netbios number
 *            Exit:  None
 *         02 Set printer string (3.1+)
 *            Entry: DS:SI-&gt;printer setup string
 *                   BX=redirection list index
 *                   CX=printer setup string length
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         03 Get printer string (3.1+)
 *            Entry: ES:DI-&gt;buffer for printer setup string
 *                   BX=redirection list index
 *            Exit:  CF=0 CX=printer setup string length
 *                   CF=1 AX=error code
 *         04 Set print mode (*) (3.1+)
 *            Entry: BX=redirection list index
 *                   DX=print mode (0=text,1=binary)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         05 Get print mode (*) (3.1+)
 *            Entry: BX=redirection list index
 *            Exit:  CF=0 DX=print mode (0=text,1=binary)
 *                   CF=1 AX=error code
 *      5F Network redirection functions (3.1+)
 *         Notes: 1) Functions 00-05 work only if the redirector (REDIR.EXE) is loaded.
 *                2) Functions 07-08 work only on builtin drives.
 *         00 Get redirection mode (*) (3.1+)
 *            Entry: BL=device type (3=printer,4=disk)
 *            Exit:  CF=0 BH=redirection mode (0=off,1=on)
 *                   CF=1 AX=error code
 *         01 Set redirection mode (*) (3.1+)
 *            Entry: BL=device type (3=printer,4=disk)
 *                   BH=redirection mode (0=off,1=on)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         02 Get redirection list entry (3.1+)
 *            Entry: DS:SI-&gt;16-byte buffer for local device name
 *                   ES:DI-&gt;128-byte buffer for remote device name
 *                   BX=redirection list index
 *            Exit:  CF=0 BH=status (0=valid,1=invalid)
 *                        BL=device type (3=printer,4=disk)
 *                        CX=user word
 *                   CF=1 AX=error code
 *         03 Set redirection list entry (3.1+)
 *            Entry: DS:SI-&gt;local device name
 *                   ES:DI-&gt;remote device name
 *                   BL=device type (3=printer,4=disk)
 *                   CX=user word
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         04 Cancel redirection list entry (3.1+)
 *            Entry: DS:SI-&gt;local device name
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         05 Get redirection list entry extended (*) (4.0+)
 *            Entry: DS:SI-&gt;16-byte buffer for local device name
 *                   ES:DI-&gt;128-byte buffer for remote device name
 *                   BX=redirection list index
 *            Exit:  CF=0 BH=status (0=valid,1=invalid)
 *                        BL=device type (3=printer,4=disk)
 *                        CX=user word
 *                        BP=netbios session number
 *                   CF=1 AX=error code
 *         07 Enable drive (*) (4.0+)
 *            Entry: DL=drive code (0=default)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         08 Disable drive (*) (4.0+)
 *            Entry: DL=drive code (0=default)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *      60 Qualify filename (*) (3.0+)
 *         Entry: DS:SI-&gt;filespec
 *                ES:DI-&gt;buffer for qualified filespec
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      61 Reserved
 *      62 Get current PSP (3.0+)
 *         Entry: None
 *         Exit:  BX=PSP segment
 *      63 Get DBCS lead byte table pointer (*) (3.0+)
 *         Entry: AL must be 0
 *         Exit:  DS:SI-&gt;DBCS lead byte table
 *      64 Set wait for external event flag (*) (3.2+)
 *         Entry: AL=flag (0=enable,&gt;0=disable)
 *         Exit:  None
 *         Note:  This function affects the PC Convertible only.
 *                If enabled and the default console driver is being used then
 *                INT 15 function 41 is issued while waiting for console input
 *                during functions 01,08,0A,and 3F.
 *      65 Get extended country info (3.3+)
 *         Entry: AL=01 get extended country info
 *                   02 get country uppercase table
 *                   03 get country lowercase table (reserved until 6.2)
 *                   04 get country filename uppercase table
 *                   05 get country filename character table
 *                   06 get country collating table
 *                   07 get DBCS vector table (4.0+)
 *                   20 uppercase character (4.0+)
 *                   21 uppercase string (4.0+)
 *                   22 uppercase ASCIIZ string (4.0+)
 *                   23 yes/no check (*) (4.0+)
 *                   A0 uppercase filename character (*) (4.0+)
 *                   A1 uppercase filename string (*) (4.0+)
 *                   A2 uppercase filename ASCIIZ string (*) (4.0+)
 *                   A3 yes/no check (*) (4.0+)
 *                if function 01-07:
 *                   BX=code page (-1=active code page)
 *                   CX=length to return (must be at least 5)
 *                   DX=country code (-1=default)
 *                   ES:DI-&gt;return buffer
 *                if function 20,23,A0,A3:
 *                   DL=character
 *                if function 21,A1:
 *                   DS:DX-&gt;string
 *                   CX=string length
 *                if function 22,A2:
 *                   DS:DX-&gt;string
 *         Exit:  CF=0 CX=data length if function 01-07
 *                     DL=character if function 20
 *                     AX=code if function 23,A3 (0=no,1=yes,2=neither)
 *                CF=1 AX=error code
 *                buffer format if function 01:
 *                 0 info ID
 *                 1 length
 *                 3 country code
 *                 5 code page
 *                 7 country info (same format as function 38)
 *                buffer format if function 02-07:
 *                 0 info ID
 *                 1 pointer to requested table (word length followed by data)
 *      66 Get or set code page (3.3+)
 *         Entry: AL=1 get code page
 *                AL=2 set code page
 *                BX=active code page if set
 *         Exit:  CF=0 BX=active code page if get
 *                     DX=default code page if get
 *                CF=1 AX=error code
 *      67 Set handle count (3.3+)
 *         Entry: BX=handle count
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      68 Commit file (3.3+)
 *         Entry: BX=file handle
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      69 Get or set media info (*) (4.0+)
 *         Entry: AL=0 get media info
 *                AL=1 set media info
 *                BL=drive code (0=default)
 *                DS:DX-&gt;media info
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *         Media info format:
 *            0 info level (must be 0)
 *            2 volume serial number
 *            6 volume label
 *           17 8-byte file system type
 *      6A Commit file (*) (4.0+)
 *         Entry: Same as function 68
 *         Exit:  Same as function 68
 *      6B Reserved
 *      6C Extended open/create file (4.0+)
 *         Entry: DS:SI-&gt;filename
 *                BX=open mode
 *                   Bit 0-2 access mode
 *                           000=read
 *                           001=write
 *                           010=read/write
 *                       4-6 sharing mode
 *                           000=compatibility
 *                           001=deny read/write access
 *                           010=deny write access
 *                           011=deny read access
 *                           100=deny none access
 *                         7 inheritance flag
 *                           0=file inherited by EXECed programs
 *                           1=file not inherited by EXECed programs
 *                        13 critical error handling
 *                           0=execute INT 24
 *                           1=return error code
 *                        14 buffering
 *                           0=buffer writes
 *                           1=don't buffer writes
 *                CX=file attributes
 *                DX=open flags
 *                   Bit 0-3 0000=fail if exists
 *                           0001=open if exists
 *                           0010=truncate if exists
 *                       4-7 0000=fail if doesn't exist
 *                           0001=create if doesn't exist
 *         Exit:  CF=0 AX=file handle
 *                     CX=action code (1=file opened,2=file created,3=file truncated)
 *                CF=1 AX=error code
 *
 *      INT 22 Terminate address (1.0+)
 *             This is the address that DOS returns to after program termination.
 *             It is set during execute program (function 4B) processing.
 *
 *      INT 23 Ctrl-Break handler address (1.0+)
 *             This routine is entered when Ctrl-Break is detected by DOS.
 *             On entry the registers are set to the values they had at the start
 *             of the interrupted function call. Control may be returned via
 *             IRET or FAR RET, if FAR RET is used and the carry flag is set
 *             then the program is aborted otherwise the function is restarted.
 *      Note:  Any DOS function may be issued from an INT 23 handler.
 *
 *      INT 24 Critical error handler address (1.0+)
 *      Entry: AH=error indicator
 *                Bit 0 0=read error
 *                      1=write error
 *                  1-2 disk area
 *                      00=DOS area
 *                      01=FAT
 *                      10=directory
 *                      11=data area
 *                    3 1=fail allowed
 *                    4 1=retry allowed
 *                    5 1=ignore allowed
 *                    7 0=block device error
 *                      1=character device error
 *             AL=drive code (0=A)
 *             DI=error code (lower half of DI)
 *                00=write-protect error           07=unknown media type
 *                01=unknown unit                  08=sector not found
 *                02=drive not ready               09=printer out of paper
 *                03=unknown command               0A=write fault
 *                04=data error (CRC)              0B=read fault
 *                05=bad request structure length  0C=general failure
 *                06=seek error                    0F=invalid disk change
 *             BP:SI=pointer to device driver header
 *      Exit:  Control may be returned to DOS via IRET with an action code in AL
 *                0=ignore error (fail if ignore is unallowed)
 *                1=retry function (fail if retry is unallowed)
 *                2=abort program
 *                3=fail system call (abort if fail is unallowed)
 *             Control may be returned directly to the program by removing the
 *             INT 24 registers (IP,CS,flags) from the stack, restoring the
 *             program's registers (AX,BX,CX,DX,SI,DI,BP,DS,ES) and issuing
 *             an IRET. This will leave DOS in an unstable state because the
 *             critical error flag is set until a DOS function other than 01-0C,
 *             33,50,51,59,62,or 64 is issued.
 *      Note:  Only DOS functions 01-0C,33,50,51,59,62,or 64 should be issued from
 *             an INT 24 handler.
 *
 *      INT 25 Absolute disk read (1.0+)
 *      Entry: AL=drive number (0=A)
 *             CX=number of sectors or -1 if &gt;32M partition
 *             DX=starting sector number
 *             DS:BX-&gt;data buffer or parameter block
 *               parameter block (3.31+)
 *                 0 starting sector number
 *                 4 number of sectors
 *                 6 data buffer
 *      Exit:  CF=0 None
 *             CF=1 AH=error code
 *                     01=bad command
 *                     02=bad address mark
 *                     03=write-protect error
 *                     04=sector not found
 *                     08=DMA overrun
 *                     10=data error (bad CRC)
 *                     20=controller error
 *                     40=seek error
 *                     80=timed-out
 *                  AL=device error code (same as lower byte of DI for INT 24)
 *      Notes: 1) The CPU flags are still on the stack after an INT 25 or INT 26.
 *             2) All registers except the segment registers and SP may be destroyed.
 *
 *      INT 26 Absolute disk write (1.0+)
 *      Entry: Same as INT 25
 *      Exit:  Same as INT 25
 *
 *      INT 27 Terminate and stay resident (1.0+)
 *      Entry: CS=PSP
 *             DX=number of bytes to stay resident (minimum 96)
 *      Exit:  Does not return to caller
 *
 *      INT 28 Idle handler (2.0+)
 *             This interrupt is issued by DOS during functions 01-0C to indicate
 *             that a TSR program may safely issue a non-character I/O DOS
 *             function even though the InDOS flag is not zero.
 *             DOS functions 01-0C should not be issued from a INT 28 handler
 *             unless the critical error flag is set first.
 *
 *      INT 29 Character output (2.0+)
 *      Entry: AL=character
 *      Exit:  None
 *      Note:  This interrupt is called for character output if the console
 *             device has bit 4 in the device attribute word set.
 *
 *      INT 2A Network/critical section (*) (3.0+)
 *      00 Network installation check (3.0+)
 *         Entry: None
 *         Exit:  AH=00 not installed
 *                AH=FF installed
 *      01 Execute NETBIOS request with no error retry (*) (3.0+)
 *         Entry: ES:BX-&gt;network control block
 *         Exit:  AH=0 no error
 *                AH=1 AL=error code
 *      02 Set network printer parameters (*) (3.0+)
 *         Entry: DS:SI-&gt;16-byte buffer for local device name
 *                BX=characters per line (-1=use current)
 *                CX=lines per inch (-1=use current)
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      03 Check direct I/O (3.0+)
 *         Entry: DS:SI-&gt;ASCIIZ disk name (d:)
 *         Exit:  CF=0 direct I/O allowed
 *                CF=1 direct I/O not allowed
 *      04 Execute NETBIOS request (3.0+)
 *         Entry: AL=error retry flag (0=retry,1=no retry)
 *                ES:BX-&gt;network control block
 *         Exit:  AH=0 no error
 *                AH=1 AL=error code
 *      05 Get network resource information (3.0+)
 *         Entry: None
 *         Exit:  BX=available network name count
 *                CX=available network control block count
 *                DX=available network session count
 *      06 Network print stream control (3.0+)
 *         Entry: AL=mode (1=concatenation,2=truncation,3=truncate stream)
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      80 Begin critical section (*) (3.0+)
 *         Entry: AL=critical section number
 *         Exit:  None
 *      81 End critical section (*) (3.0+)
 *         Entry: AL=critical section number
 *         Exit:  None
 *      82 End all critical sections (*) (3.0+)
 *         Entry: None
 *         Exit:  None
 *      84 Keyboard idle loop (*) (3.0+)
 *         Entry: None
 *         Exit:  None
 *
 *      INT 2E Execute command (*) (2.0+)
 *      Entry: DS:SI-&gt;command string-1 followed by a carriage return
 *      Exit:  All registers except CS and IP are destroyed
 *      Note:  This function is not re-entrant and should not be issued from a
 *             batch file.
 *
 *      INT 2F Multiplex (3.0+)
 *      Entry: AH=program identifier
 *             AL=function code
 *             Other registers depend on the function
 *      Exit:  Depends on the function
 *
 *      Program identifier codes:
 *      01 Print queueing (PRINT) (3.0+)
 *      02 Network printer control (REDIR) (3.1+)
 *      05 Network error message lookup (REDIR) (3.0+)
 *      06 ASSIGN (3.1+)
 *      08 IBMBIO drive services (used by DRIVER.SYS) (3.2+)
 *      10 File sharing (SHARE) (3.0+)
 *      11 Redirector services (REDIR and MSCDEX) (3.0+)
 *      12 DOS internal services (used by REDIR and MSCDEX) (3.0+)
 *      13 Swap INT 13 vector (3.2+)
 *      14 NLS support (NLSFUNC) (3.3+)
 *      15 CD-ROM extensions (MSCDEX)
 *      16 Windows services
 *      17 Windows clipboard services
 *      1A ANSI.SYS (4.0+)
 *      43 XMS services (HIMEM.SYS)
 *      46 Windows support
 *      48 DOSKEY (5.0+)
 *      4A DOS services (HMA, RPL), SMARTDRV (5.0+)
 *      53 POWER (APM events broadcast) (5.02+)
 *      54 POWER (main API) (5.02+)
 *      55 COMMAND.COM (5.0+)
 *      56 INTERLNK (5.02+)
 *      AC GRAPHICS (5.0+)
 *      AD DISPLAY.SYS, KEYB (3.3+)
 *      AE Installable command support (APPEND) (3.3+)
 *      B0 GRAFTABL (3.3+)
 *      B7 APPEND (3.2+)
 *
 *      DOS extended error information:
 *
 *      Extended error code:                    Error class:
 *      01 Invalid function number              01 Out of resource
 *      02 File not found                       02 Temporary situation
 *      03 Path not found                       03 Authorization error
 *      04 Too many open files                  04 Internal DOS error
 *      05 Access denied                        05 Hardware failure
 *      06 Invalid handle                       06 System software failure
 *      07 Memory control blocks destroyed      07 Application program error
 *      08 Insufficient memory                  08 Not found
 *      09 Invalid memory block address         09 Invalid format
 *      0A Invalid environment                  0A File locked
 *      0B Invalid format                       0B Media error
 *      0C Invalid access code                  0C Already exists
 *      0D Invalid data                         0D Unknown
 *      0E Reserved
 *      0F Invalid drive                        Suggested action:
 *      10 Attempt to remove current directory  01 Retry
 *      11 Not same device                      02 Delay and retry
 *      12 No more files                        03 Get corrected user input
 *      13 Write-protect error                  04 Exit with cleanup
 *      14 Unknown unit                         05 Exit without cleanup
 *      15 Drive not ready                      06 Ignore error
 *      16 Unknown command                      07 Retry after user intervention
 *      17 Data error (CRC)
 *      18 Bad request structure length         Error locus:
 *      19 Seek error                           01 Unknown
 *      1A Unknown medium type                  02 Block device error
 *      1B Sector not found                     03 Network error
 *      1C Printer out of paper                 04 Character device error
 *      1D Write fault                          05 Memory error
 *      1E Read fault
 *      1F General failure
 *      20 Sharing violation
 *      21 Lock violation
 *      22 Invalid disk change
 *      23 FCB unavailable
 *      24 Sharing buffer overflow
 *      25 Code page mismatch (4.0+)
 *      26 Out of input (4.0+)
 *      27 Insufficient disk space (4.0+)
 *      32 Function not supported
 *      41 Network access denied
 *      50 File exists
 *      51 Reserved
 *      52 Cannot make directory entry
 *      53 Fail on INT 24
 *
 * DOS table and structure reference (from https://sites.google.com/site/pcdosretro/dostables)
 *
 *      Program Segment Prefix (100h bytes)
 *      00 INT 20
 *      02 End of allocation segment
 *      04 Reserved
 *      05 Far call to DOS
 *      0A Saved INT 22 vector
 *      0E Saved INT 23 vector
 *      12 Saved INT 24 vector (1.1+)
 *      16 Caller PSP segment (2.0+)
 *      18 File table (2.0+)
 *      2C Environment segment (2.0+)
 *      2E Stack pointer after last DOS call (2.0+)
 *      32 File table size (3.0+)
 *      34 Pointer to file table (3.0+)
 *      38 Pointer to next PSP (SHARE only) (3.0+)
 *      3C Reserved
 *      40 DOS version (4.0+)
 *      42 Reserved
 *      50 INT 21,RETF (2.0+)
 *      53 Reserved
 *      5C FCB 1
 *      6C FCB 2
 *      7C Unused
 *      80 Command tail
 *
 *      File Control Block (25h bytes)
 *      00 Drive code (1=A)
 *      01 Filename
 *      09 Extension
 *      0C Current block number
 *      0E Record size
 *      10 File size
 *      14 Date
 *      16 Time
 *      18 Reserved
 *      20 Current record number
 *      21 Random record number
 *
 *      Extended FCB (2Ch bytes)
 *      00 FF (Extended FCB indicator)
 *      01 Reserved
 *      06 Attribute byte
 *      07 Standard FCB
 *
 *      Disk partition table entry (10h bytes)
 *      00 Status (00=non-bootable,80=bootable)
 *      01 Starting head
 *      02 Starting cylinder and sector (INT 13 format)
 *      04 Type (0=unknown,1=FAT12,4=FAT16,5=extended,6=BIGDOS)
 *      05 Ending head
 *      06 Ending cylinder and sector (INT 13 format)
 *      08 Starting absolute sector
 *      0C Number of sectors
 *      Note: There are 4 entries starting at offset 1BE
 *
 *      Disk boot sector (200h bytes)
 *      00 Jump to boot code
 *      03 OEM name
 *      0B Bytes per sector
 *      0D Sectors per cluster
 *      0E Number of reserved sectors
 *      10 Number of FATs
 *      11 Number of root directory entries
 *      13 Total number of sectors
 *      15 Media descriptor byte
 *         F0 1.44M (2 sides,18 sectors/track,80 tracks)
 *            2.88M (2 sides,36 sectors/track,80 tracks)
 *         F8 fixed disk
 *         F9 720K (2 sides,9 sectors/track,80 tracks)
 *            1.2M (2 sides,15 sectors/track,80 tracks)
 *         FC 180K (1 side,9 sectors/track,40 tracks)
 *         FD 360K (2 sides,9 sectors/track,40 tracks)
 *         FE 160K (1 side,8 sectors/track,40 tracks)
 *         FF 320K (2 sides,8 sectors/track,40 tracks)
 *      16 Sectors per FAT
 *      18 Sectors per track
 *      1A Number of heads
 *      1C Number of hidden sectors
 *      20 32-bit number of sectors if word at 13=0 (3.31+)
 *      24 Drive number (4.0+)
 *      25 Reserved (4.0+)
 *      26 Extended boot record ID (29) (4.0+)
 *      27 Serial number (4.0+)
 *      2B Volume label (4.0+)
 *      36 8-byte file system name (4.0+)
 *      Note: Bytes 0B-23 are the BIOS parameter block
 *
 *      Directory entry (20h bytes)
 *      00 Filename
 *      08 Extension
 *      0B Attribute byte
 *         01=Read-only
 *         02=Hidden
 *         04=System
 *         08=Volume label (2.0+)
 *         10=Directory (2.0+)
 *         20=Archive (2.0+)
 *      0C Reserved
 *      16 Time
 *         Bits 0-4 Seconds/2 (0-29)
 *             5-10 Minutes (0-59)
 *            11-15 Hours (0-23)
 *      18 Date
 *         Bits 0-4 Day (1-31)
 *              5-8 Month (1-12)
 *             9-15 Year-1980
 *      1A Starting cluster number
 *      1C File size
 *
 *      Disk parameter block (20h bytes in 3.x, 21h bytes in 4.0+)
 *      00 Drive code (0=A)
 *      01 Unit code
 *      02 Bytes per sector
 *      04 Sectors per cluster-1
 *      05 Cluster shift factor (2**n sectors per cluster)
 *      06 First FAT sector
 *      08 Number of FATs
 *      09 Number of directory entries
 *      0B First data sector
 *      0D Maximum cluster number
 *      0F Sectors per FAT
 *      11 First directory sector
 *      13 Pointer to device driver
 *      17 Media descriptor byte
 *      18 Access flag (00=accessed,FF=not accessed)
 *      19 Pointer to next DPB
 *      1D Last cluster allocated
 *      1F Number of free clusters (-1 if unknown)
 *      Note: (3.x) The sectors per FAT field is one byte and all following
 *            fields are moved back one byte.
 *
 *      System file table (35h bytes in 3.x, 3Bh bytes in 4.0+)
 *      00 Open count
 *      02 Open mode
 *         Bit 0-2 access mode
 *                 000=read
 *                 001=write
 *                 010=read/write
 *             4-6 sharing mode
 *                 000=compatibility
 *                 001=deny read/write
 *                 010=deny write
 *                 011=deny read
 *                 100=deny none
 *              13 critical error handling
 *                 0=execute INT 24
 *                 1=return error code
 *              14 buffering
 *                 0=buffer writes
 *                 1=don't buffer writes
 *              15 1=FCB SFT
 *      04 Attribute byte
 *      05 Device info
 *         Character devices:          Block devices:
 *         Bit 0 1=console input       Bit 0-5 drive code (0=A)
 *             1 1=console output            6 0=file has been written
 *             2 1=NUL device                7 0=block device
 *             3 1=CLOCK device             12 1=no inherit
 *             4 1=INT 29 output (CON)      14 1=date/time set
 *             5 0=ASCII,1=binary           15 1=redirected file
 *             6 0=EOF on input
 *             7 1=character device
 *            11 1=network spooler
 *            12 1=no inherit
 *            13 1=named pipe
 *            15 1=redirected device
 *      07 Pointer to device driver or disk parameter block
 *      0B First cluster number
 *      0D Time
 *      0F Date
 *      11 File size
 *      15 File pointer
 *      19 Current relative cluster number
 *      1B 32-bit directory entry sector (4.0+)
 *      1B Current absolute cluster number (3.x)
 *      1D Directory entry sector (3.x)
 *      1F Directory entry position in sector
 *      20 Filename
 *      28 Extension
 *      2B Pointer to next SFT for the same file (SHARE only)
 *      2F Machine number
 *      31 PSP of owner
 *      33 SHARE file table offset
 *      35 Current absolute cluster number (4.0+)
 *      37 Reserved (4.0+)
 *
 *      SHARE file table
 *      00 Entry flag (1=open,0=unused,-1=end of list)
 *      01 Entry length
 *      03 Filespec checksum
 *      04 First lock table offset
 *      06 Pointer to system file table
 *      0A SHARE file number
 *      0C Filespec
 *
 *      SHARE lock table (10h bytes)
 *      00 Offset to next lock table for file
 *      02 Start of lock region
 *      06 End of lock region
 *      0A Pointer to system file table
 *      0E PSP of owner
 *
 *      Current directory structure (51h bytes in 3.x, 58h bytes in 4.0+)
 *      00 Current directory
 *      43 Drive type
 *         1000=SUBSTed drive
 *         2000=JOINed drive
 *         4000=valid drive
 *         8000=redirected drive
 *      45 Pointer to disk parameter block
 *      49 Cluster number of current directory (0=root)
 *      4B Reserved
 *      4F Length of root directory name starting at offset 0
 *      51 Reserved (4.0+)
 *
 *      Disk buffer header (10h bytes) (3.x)
 *      00 Pointer to next buffer
 *      04 Drive code (0=A,FF=unused)
 *      05 Flags
 *         Bit 0 reserved
 *             1 1=FAT sector
 *             2 1=directory sector
 *             3 1=data sector
 *             4 reserved
 *             5 1=buffer read
 *             6 1=buffer written
 *             7 reserved
 *      06 Sector number
 *      08 Number of FATs (if FAT) or 1
 *      09 Sectors per FAT (if FAT) or 0
 *      0A Pointer to DPB
 *      0E Reserved
 *      10 Buffered sector
 *
 *      Disk buffer header (14h bytes) (4.0+)
 *      00 Pointer to next buffer
 *      02 Pointer to previous buffer
 *      04 Drive code (0=A,FF=unused)
 *      05 Flags
 *         Bit 0 reserved
 *             1 1=FAT sector
 *             2 1=directory sector
 *             3 1=data sector
 *             4 reserved
 *             5 1=buffer read (4.0)
 *             6 1=buffer written
 *             7 reserved
 *      06 Sector number
 *      0A Number of FATs (if FAT) or 1
 *      0B Sectors per FAT (if FAT) or 0
 *      0D Pointer to DPB
 *      11 Reserved
 *      14 Buffered sector
 *
 *      Disk buffer control block (4.0)
 *      00 Pointer to buffer chain array
 *      04 Number of chains
 *      06 Pointer to sector lookahead buffers
 *      0A Number of sector lookahead buffers
 *      0C Unknown
 *
 *      Disk buffer control block (5.0+)
 *      00 Pointer to buffer chain
 *      04 Number of modified buffers
 *      06 Pointer to sector lookahead buffers
 *      0A Number of sector lookahead buffers
 *      0C HMA flag (1=buffers in HMA)
 *      0D Pointer to HMA transfer buffer
 *
 *      Disk buffer chain array entry (8 bytes) (4.0)
 *      00 Reserved
 *      02 Pointer to last accessed buffer
 *      06 Number of modified buffers
 *      07 Reserved
 *
 *      Stacks block header (12h bytes)
 *      00 Reserved
 *      02 Number of stacks
 *      04 Offset of stacks
 *      06 Stack size
 *      08 Pointer to stacks table (descriptors followed by stacks)
 *      0C Offset of first stacks descriptor
 *      0E Offset of last stacks descriptor
 *      10 Offset of current stacks descriptor
 *
 *      Stacks descriptor (8 bytes)
 *      00 Flag (0=free,1=in use)
 *      02 Save area for SS:SP
 *      06 Offset of end of stack
 *
 *      Device driver header (12h bytes)
 *      00 Pointer to next device driver or -1
 *      04 Attribute word
 *         Bit 0 1=console input
 *             1 1=console output (character devices)
 *               1=32-bit sectors supported (block devices) (3.31+)
 *             2 1=NUL device
 *             3 1=CLOCK device
 *             4 1=INT 29 output (CON)
 *             6 1=extended functions supported (13,17,18) (3.2+)
 *             7 1=query IOCTL function supported (19) (5.0+)
 *            11 1=open/close/removable media supported (3.0+)
 *            13 1=output until busy supported (character devices) (3.0+)
 *               1=media descriptor in FAT required (block devices)
 *            14 1=IOCTL supported
 *            15 0=block device
 *               1=character device
 *      06 Strategy address
 *      08 Interrupt address
 *      0A Device name or number of units
 *
 *      Device driver request header (common fields)
 *      00 Request header length
 *      01 Unit number
 *      02 Command code
 *         00=Init                   0B=Flush output buffers
 *         01=Media check            0C=I/O control write
 *         02=Build BPB              0D=Open (3.0+)
 *         03=I/O control read       0E=Close (3.0+)
 *         04=Read                   0F=Removable media check (3.0+)
 *         05=Non-destructive read   10=Output until busy (3.0+)
 *         06=Input status           13=Generic I/O control (3.2+)
 *         07=Flush input buffers    17=Get drive map (3.2+)
 *         08=Write                  18=Set drive map (3.2+)
 *         09=Write with verify      19=Query I/O control (5.0+)
 *         0A=Output status
 *      03 Return status word
 *         Bit 0-7 if error
 *                 00=write-protect error  07=unknown medium
 *                 01=unknown unit         08=sector not found
 *                 02=drive not ready      09=printer out of paper
 *                 03=unknown command      0A=write fault
 *                 04=data error (CRC)     0B=read fault
 *                 05=bad request length   0C=general failure
 *                 06=seek error           0F=invalid disk change
 *               8 1=done
 *               9 1=busy
 *              15 1=error
 *      05 Reserved (8 bytes)
 *
 *      Device driver request headers:
 *      Init
 *      00 Common (length=17h in 3.x, 19h in 4.0+)
 *      0D Number of units (set by driver)
 *      0E End of available memory (5.0+)
 *         End of resident code (set by driver)
 *      12 Pointer to string after DEVICE=
 *         BPB array pointer (set by driver)
 *      16 Drive code of first unit (0=A)
 *      17 Error message flag (1=display message) (4.0+)
 *
 *      Media check
 *      00 Common (length=13h)
 *      0D Media descriptor byte
 *      0E Status (set by driver: 1=unchanged,0=unknown,-1=changed)
 *      0F Pointer to previous disk label (set by driver if disk changed)
 *
 *      Build BPB
 *      00 Common (length=16h)
 *      0D Media descriptor byte
 *      0E Pointer to sector buffer
 *      12 Pointer to BPB (set by driver)
 *      Note: The sector buffer contains the first sector of the FAT if bit 13 in the
 *            device attribute word is zero otherwise it may be used as scratch space.
 *
 *      IOCTL read, Read, Write, Write with verify, IOCTL write, Output until busy
 *      00 Common (length=14h)
 *      0D Unused
 *      0E Pointer to data buffer
 *      12 Byte count (set by driver to number of bytes transferred)
 *      Notes: 1) The IOCTL functions are called only if bit 14 in the device
 *                attribute word is set.
 *             2) The output until busy function is called only if bit 13 in the
 *                device attribute word is set.
 *
 *      Read, Write, Write with verify
 *      00 Common (length=16h-1Eh)
 *      0D Media descriptor byte
 *      0E Pointer to data buffer
 *      12 Sector count (set by driver to number of sectors transferred)
 *      14 Starting sector number (-1=if 32-bit sectors)
 *      16 Pointer to previous disk label (set by driver if error 0F)
 *      1A 32-bit starting sector number
 *      Note: The 32-bit starting sector number is used only if bit 1 in the
 *            device attribute word is set.
 *
 *      Non-destructive read
 *      00 Common (length=0Eh)
 *      0D Character (set by driver)
 *      Note: This function sets the busy bit (bit 9) in the request header
 *            if no character is ready.
 *
 *      Input status, Output status
 *      00 Common (length=0Dh)
 *      Note: These functions set the busy bit (bit 9) in the request header
 *            to indicate device status.
 *
 *      Flush input buffers, Flush output buffers
 *      00 Common (length=0Dh)
 *
 *      Open, Close, Removable media check
 *      00 Common (length=0Dh)
 *      Notes: 1) These functions are called only if bit 11 in the device
 *                attribute word is set.
 *             2) The removable media check function sets bit 9 in the status word
 *                if the device is non-removable.
 *
 *      Generic IOCTL, Query IOCTL
 *      00 Common (length=17h)
 *      0D Category code
 *      0E Function code
 *      0F Unused
 *      13 Parameter buffer pointer
 *      Notes: 1) The Generic IOCTL function is called only if bit 6 in the device
 *                attribute word is set.
 *             2) The Query IOCTL function is called only if bit 7 in the device
 *                attribute word is set.
 *
 *      Get drive map, Set drive map
 *      00 Common (length=0Dh)
 *      Notes: 1) These functions are called only if bit 6 in the device
 *                attribute word is set.
 *             2) These functions set the unit field (byte 1) in the request
 *                header to the physical drive code.
 *
 *      Clock device info (6 bytes)
 *      00 Days since 1/1/80
 *      02 Minutes
 *      03 Hours
 *      04 Hundredths
 *      05 Seconds
 *
 *      Memory Control Block (10h bytes)
 *      00 Type ('M' or 'Z' if last)
 *      01 PSP segment of owner (0=free,8=DOS)
 *      03 Size (paragraphs)
 *      05 Unused
 *      08 Program name (4.0+)
 *
 *      EXE file header
 *      00 'MZ'
 *      02 Size of last page
 *      04 File size in 512-byte pages
 *      06 Relocation table count
 *      08 Header size (paragraphs)
 *      0A Minimum allocation (paragraphs)
 *      0C Maximum allocation (paragraphs)
 *      0E Initial SS
 *      10 Initial SP
 *      12 Checksum
 *      14 Initial IP
 *      16 Initial CS
 *      18 Offset of relocation table
 *         Table entry format:
 *         0 offset of relocation
 *         2 segment of relocation
 *      1A Overlay number
 *
 *      EXEPACK header
 *      00 Actual IP
 *      02 Actual CS
 *      04 0 (set to PSP+10h by unpack code)
 *      06 Unpack code and data size (including relocation table)
 *      08 Actual SP
 *      0A Actual SS
 *      0C Actual code and data size
 *
 *      Note: If an EXE file is packed then CS:IP-2 points to 'RB' and CS:0
 *            points to the EXEPACK header, this is followed by the unpack code
 *            and a relocation table containing a word count and relocation
 *            entries for 16 segments.
 */



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/messages.js (C) Jeff Parsons 2012-2018
 */

var Messages = {
    NONE:       0x00000000,
    CPU:        0x10000001,
    SEG:        0x10000002,
    DESC:       0x10000003,
    TSS:        0x10000004,
    PORT:       0x10000008,
    IOPM:       0x10000009,
    NMI:        0x10000010,
    TRAP:       0x10000020,
    FAULT:      0x10000030,
    INT:        0x10000040,
    IRQ:        0x20000080,
    BUS:        0x20000100,
    MEM:        0x20000200,
    DMA:        0x20000400,
    FDC:        0x20000800,
    HDC:        0x20001000,
    DISK:       0x20002000,
    PIC:        0x20004000,
    TIMER:      0x20008000,
    CMOS:       0x20010000,
    RTC:        0x20020000,
    C8042:      0x20040000,
    KBD:        0x20080000,
    PARALLEL:   0x20100000,
    SERIAL:     0x20200000,
    MOUSE:      0x20400000,
    SPEAKER:    0x20800000,
    CHIPSET:    0x21000000,
    VIDEO:      0x22000000,
    COMPUTER:   0x24000000,
    DATA:       0x40000001,
    DOS:        0x40000002,
    EVENT:      0x40000004,
    KEY:        0x40000010,
    WARN:       0x40000020,
    HALT:       0x84000000|0,
    BUFFER:     0x88000000|0
};

/*
 * Message categories supported by the messageEnabled() function and other assorted message
 * functions. Each category has a corresponding bit value that can be combined (ie, OR'ed) as
 * needed.  The Debugger's message command ("m") is used to turn message categories on and off,
 * like so:
 *
 *      m port on
 *      m port off
 *      ...
 *
 * NOTE: The order of these categories can be rearranged, alphabetized, etc, as desired; just be
 * aware that changing the bit values could break saved Debugger states (not a huge concern, just
 * something to be aware of).
 */
Messages.CATEGORIES = {
    "cpu":      Messages.CPU,
    "seg":      Messages.SEG,
    "desc":     Messages.DESC,
    "port":     Messages.PORT,
    "tss":      Messages.TSS,
    "iopm":     Messages.IOPM,
    "int":      Messages.INT,
    "nmi":      Messages.NMI,
    "fault":    Messages.FAULT,
    "trap":     Messages.TRAP,
    "bus":      Messages.BUS,
    "irq":      Messages.IRQ,
    "mem":      Messages.MEM,
    "dma":      Messages.DMA,
    "fdc":      Messages.FDC,
    "hdc":      Messages.HDC,
    "disk":     Messages.DISK,
    "pic":      Messages.PIC,
    "timer":    Messages.TIMER,
    "cmos":     Messages.CMOS,
    "rtc":      Messages.RTC,
    "8042":     Messages.C8042,
    "kbd":      Messages.KBD,
    "parallel": Messages.PARALLEL,
    "serial":   Messages.SERIAL,
    "mouse":    Messages.MOUSE,
    "speaker":  Messages.SPEAKER,
    "chipset":  Messages.CHIPSET,
    "video":    Messages.VIDEO,
    "computer": Messages.COMPUTER,
    "dos":      Messages.DOS,
    "data":     Messages.DATA,
    "event":    Messages.EVENT,
    "key":      Messages.KEY,
    "warn":     Messages.WARN,
    /*
     * Now we turn to message actions rather than message types; for example, setting "halt"
     * on or off doesn't enable "halt" messages, but rather halts the CPU on any message above.
     *
     * Similarly, "m buffer on" turns on message buffering, deferring the display of all messages
     * until "m buffer off" is issued.
     */
    "halt":     Messages.HALT,
    "buffer":   Messages.BUFFER
};



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/panel.js (C) Jeff Parsons 2012-2018
 */


/**
 * Region object definition
 *
 *  iBlock:     starting block number
 *  cBlocks:    number of blocks spanned by region
 *  type:       type of all blocks in the region (see Memory.TYPE.*)
 *
 * @typedef {{
 *  iBlock:     number,
 *  cBlocks:    number,
 *  type:       number
 * }} Region
 */
var Region;

class Color {
    /**
     * Color(r, g, b, a)
     *
     * @this {Color}
     * @param {number} [r]
     * @param {number} [g]
     * @param {number} [b]
     * @param {number} [a]
     */
    constructor(r, g, b, a)
    {
        this.rgb = [r, g, b, a];
        this.sValue = null;
        if (r === undefined) this.randomize();
    }

    /**
     * getRandom(nLimit)
     *
     * @this {Color}
     * @param {number} [nLimit]
     */
    getRandom(nLimit)
    {
        return (Math.random() * (nLimit || 0x100)) | 0;
    }

    /**
     * randomize()
     *
     * @this {Color}
     */
    randomize()
    {
        this.rgb[0] = this.getRandom(); this.rgb[1] = this.getRandom(); this.rgb[2] = this.getRandom(); this.rgb[3] = 0xff;
        this.sValue = null;
    }

    /**
     * toString()
     *
     * @this {Color}
     * @return {string}
     */
    toString()
    {
        if (!this.sValue) this.sValue = '#' + Str.toHex(this.rgb[0], 2) + Str.toHex(this.rgb[1], 2) + Str.toHex(this.rgb[2], 2);
        return this.sValue;
    }
}

class Rectangle {
    /**
     * Rectangle(x, y, cx, cy)
     *
     * @this {Rectangle}
     * @param {number} x
     * @param {number} y
     * @param {number} cx
     * @param {number} cy
     */
    constructor(x, y, cx, cy)
    {
        this.x = x;
        this.y = y;
        this.cx = cx;
        this.cy = cy;
    }

    /**
     * contains(x, y)
     *
     * @this {Rectangle}
     * @param {number} x
     * @param {number} y
     * @return {boolean} true if (x,y) lies within the rectangle, false if not
     */
    contains(x, y)
    {
        return (x >= this.x && x < this.x + this.cx && y >= this.y && y < this.y + this.cy);
    }

    /**
     * subDivide(units, unitsTotal, fHorizontal)
     *
     * Return a new rectangle that is a subset of the current rectangle, based on the ratio of
     * units to unitsTotal, and then update the dimensions of the current rectangle.  Whether the
     * original rectangle is divided horizontally or vertically is entirely arbitrary; currently,
     * the criteria is horizontal if the ratio is 1/4 or more, vertical otherwise.
     *
     * @this {Rectangle}
     * @param {number} units
     * @param {number} unitsTotal
     * @param {boolean} [fHorizontal]
     * @return {Rectangle}
     */
    subDivide(units, unitsTotal, fHorizontal)
    {
        let rect;
        if (fHorizontal === undefined) {
            fHorizontal = units >= (unitsTotal >> 2);
        }
        if (fHorizontal) {
            rect = new Rectangle(this.x, this.y, this.cx, ((this.cy * units) / unitsTotal) | 0);
            this.y += rect.cy;
            this.cy -= rect.cy;

        } else {
            rect = new Rectangle(this.x, this.y, ((this.cx * units) / unitsTotal) | 0, this.cy);
            this.x += rect.cx;
            this.cx -= rect.cx;

        }
        return rect;
    }

    /**
     * drawWith(context, color)
     *
     * @this {Rectangle}
     * @param {Object} context
     * @param {Color|string} [color]
     */
    drawWith(context, color)
    {
        if (!color) color = new Color();
        context.strokeStyle = "black";
        context.strokeRect(this.x, this.y, this.cx, this.cy);
        context.fillStyle = (typeof color == "string"? color : color.toString());
        context.fillRect(this.x, this.y, this.cx, this.cy);
    }
}

class LED {
    /**
     * LED(control, color)
     *
     * @this {LED}
     * @param {HTMLElement} control
     * @param {string} [color]
     */
    constructor(control, color)
    {
        this.active = false;
        this.control = control;
        this.colorActive = null;
        this.color = control.style.backgroundColor;
        this.setColor(color);
        this.draw();
    }

    /**
     * draw()
     *
     * @this {LED}
     */
    draw()
    {
        if (this.colorActive != this.color) {
            this.colorActive = this.color;
            this.control.style.backgroundColor = this.color || Panel.COLOR.BLACK;
        }
        else if (!this.active) {
            this.color = null;
        }
    }

    /**
     * setColor(color)
     *
     * Components are allowed to call this, via Panel.setLED(), as frequently as they like; we
     *
     * @this {LED}
     * @param {string} [color] (omit to turn LED "off")
     */
    setColor(color)
    {
        if (color) {
            this.color = color;
            this.active = true;
        } else {
            this.active = false;
        }
    }
}

/**
 * class Panel
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Panel extends Component {
    /**
     * Panel(parmsPanel)
     *
     * The Panel component has no required (parmsPanel) properties.
     *
     * @this {Panel}
     * @param {Object} [parmsPanel]
     */
    constructor(parmsPanel)
    {
        super("Panel", parmsPanel);

        this.leds = {};
        this.cLEDs = 0;
        this.canvas = null;
        this.lockMouse = -1;
        this.fMouseDown = false;
        this.xMouse = this.yMouse = -1;
        this.timer = -1;
        this.busInfo = null;
        this.fVisual = false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {Panel}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.kbd = cmp.getMachineComponent("Keyboard");
        this.startTimer();
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * Most panel layouts don't have bindings of their own, so we pass along all binding requests to the
     * Computer, CPU, Keyboard and Debugger components first.  The order shouldn't matter, since any component
     * that doesn't recognize the specified binding should simply ignore it.
     *
     * @this {Panel}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "reset")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        if (this.cmp && this.cmp.setBinding(sHTMLType, sBinding, control, sValue)) return true;
        if (this.cpu && this.cpu.setBinding(sHTMLType, sBinding, control, sValue)) return true;
        if (this.kbd && this.kbd.setBinding(sHTMLType, sBinding, control, sValue)) return true;
        if (DEBUGGER && this.dbg && this.dbg.setBinding(sHTMLType, sBinding, control, sValue)) return true;

        if (sHTMLType.substr(-3, 3) == "led") {
            this.leds[sBinding] = new LED(control, sValue);
            this.cLEDs++;
            this.startTimer();
            return true;
        }

        if (!this.canvas && sHTMLType == "canvas") {

            this.fVisual = true;
            this.canvas = /** @type {HTMLCanvasElement} */ (control);
            this.context = /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext("2d"));

            /*
             * Employ the same gross onresize() hack for IE9/IE10 that we had to use for the Video canvas
             */
            if (Web.getUserAgent().indexOf("MSIE") >= 0) {
                this.canvas.onresize = function(canvas, cx, cy) {
                    return function onResizeVideo() {
                        canvas.style.height = (((canvas.clientWidth * cy) / cx) | 0) + "px";
                    };
                }(this.canvas, this.canvas.width, this.canvas.height);
                this.canvas.onresize(null);
            }

            this.xMem = this.yMem = 0;
            this.cxMem = ((this.canvas.width * Panel.LIVEMEM.CX) / Panel.LIVECANVAS.CX) | 0;
            this.cyMem = this.canvas.height;

            this.xReg = this.cxMem;
            this.yReg = 0;
            this.cxReg = this.canvas.width - this.cxMem;
            this.cyReg = this.canvas.height;

            this.xDump = this.xReg;
            this.yDump = ((this.canvas.height * (Panel.LIVEREGS.CY - Panel.LIVEDUMP.CY)) / Panel.LIVECANVAS.CY) | 0;
            this.cxDump = this.cxReg;
            this.cyDump = ((this.canvas.height * Panel.LIVEDUMP.CY) / Panel.LIVECANVAS.CY) | 0;

            this.canvasLiveMem = document.createElement("canvas");
            this.canvasLiveMem.width = Panel.LIVEMEM.CX;
            this.canvasLiveMem.height = Panel.LIVEMEM.CY;
            this.contextLiveMem = this.canvasLiveMem.getContext("2d");
            this.imageLiveMem = this.contextLiveMem.createImageData(this.canvasLiveMem.width, this.canvasLiveMem.height);

            this.canvasLiveRegs = document.createElement("canvas");
            this.canvasLiveRegs.width = Panel.LIVEREGS.CX;
            this.canvasLiveRegs.height = Panel.LIVEREGS.CY;
            this.contextLiveRegs = this.canvasLiveRegs.getContext("2d");

            let panel = this;
            this.canvas.addEventListener(
                'mousemove',
                function onMouseMove(event) {
                    panel.moveMouse(event);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            this.canvas.addEventListener(
                'mousedown',
                function onMouseDown(event) {
                    panel.clickMouse(event, true);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            this.canvas.addEventListener(
                'mouseup',
                function onMouseUp(event) {
                    panel.clickMouse(event, false);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );

            this.fRedraw = true;
            this.startTimer();
            return true;
        }
        return super.setBinding(sHTMLType, sBinding, control, sValue);
    }

    /**
     * setLED(sBinding, color)
     *
     * @this {Panel}
     * @param {string} sBinding
     * @param {string} [color] (omit to turn LED "off")
     */
    setLED(sBinding, color)
    {
        let led = this.leds[sBinding];
        if (led) led.setColor(color);
    }

    /**
     * startTimer()
     *
     * This timer replaces the CPU's old dedicated VIDEO_UPDATES_PER_SECOND logic, which periodically called
     * the Computer's updateVideo() function, which in turn called our updateAnimation() function; periodic
     * animation updates are now our own responsibility.
     *
     * @this {Panel}
     */
    startTimer()
    {
        if (this.timer < 0 && (this.cLEDs || this.canvas) && this.cpu) {
            let panel = this;
            this.timer = this.cpu.addTimer(this.id, function updateAnimationTimer() {
                panel.updateAnimation();
            }, 1000 / Panel.UPDATES_PER_SECOND);
        }
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Panel}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) Panel.init();
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Panel}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return true;
    }

    /**
     * clickMouse(event, fDown)
     *
     * @this {Panel}
     * @param {Object} event object from a 'mousedown' or 'mouseup' event
     * @param {boolean} fDown
     */
    clickMouse(event, fDown)
    {
        /*
         * event.button is 0 for the LEFT button and 2 for the RIGHT button
         */
        if (!event.button) {
            this.lockMouse = fDown? 0 : -1;
            this.fMouseDown = fDown;
            this.updateMouse(event, fDown);
        }
    }

    /**
     * moveMouse(event)
     *
     * @this {Panel}
     * @param {Object} event object from a 'mousemove' event
     */
    moveMouse(event)
    {
        this.updateMouse(event);
    }

    /**
     * updateMouse(event, fDown)
     *
     * MouseEvent objects contain, among other things, the following properties:
     *
     *      clientX
     *      clientY
     *
     * I've selected the above properties because they're widely supported, not because I need
     * client-area coordinates.  In fact, layerX and layerY are probably closer to what I really want,
     * but I don't think they're available in all browsers.  screenX and screenY would work as well.
     *
     * @this {Panel}
     * @param {Object} event object from a mouse event (specifically, a MouseEvent object)
     * @param {boolean} [fDown] is true or false if this was a click event, otherwise it's just a move event
     */
    updateMouse(event, fDown)
    {
        /*
         * Due to the responsive nature of our pages, the displayed size of the canvas may be smaller than the
         * allocated size, and the coordinates we receive from mouse events are based on the currently displayed size.
         */
        let xScale = Panel.LIVECANVAS.CX / this.canvas.offsetWidth;
        let yScale = Panel.LIVECANVAS.CY / this.canvas.offsetHeight;

        let rect = this.canvas.getBoundingClientRect();
        let x = ((event.clientX - rect.left) * xScale) | 0;
        let y = ((event.clientY - rect.top) * yScale) | 0;

        if (fDown == null) {
            if (!this.lockMouse) {
                this.lockMouse = Math.abs(this.xMouse - x) > Math.abs(this.yMouse - y)? 1 : 2;
            }
            if (this.lockMouse == 1) {
                y = this.yMouse;
            } else if (this.lockMouse == 2) {
                x = this.xMouse;
            }
        }

        this.xMouse = x;
        this.yMouse = y;

        if (MAXDEBUG) this.log("Panel.moveMouse(" + x + "," + y + ")");

        if (x >= 0 && x < Panel.LIVECANVAS.CX && y >= 0 && y < Panel.LIVECANVAS.CY) {
            /*
             * Convert the mouse position into the corresponding memory address, assuming it's over the live memory area
             */
            let addr = this.findAddress(x, y);
            if (addr !== X86.ADDR_INVALID) {
                addr &= ~0xf;
                if (addr != this.addrDumpLast) {
                    this.dumpMemory(addr, true);
                    this.addrDumpLast = addr;
                }
            }
        }
    }

    /**
     * findAddress(x, y)
     *
     * @this {Panel}
     * @param {number} x
     * @param {number} y
     * @return {number} address corresponding to (x,y) canvas coordinates, or ADDR_INVALID if none
     */
    findAddress(x, y)
    {
        if (x < Panel.LIVEMEM.CX && this.busInfo && this.busInfo.aRects) {
            let i, rect;
            for (i = 0; i < this.busInfo.aRects.length; i++) {
                rect = this.busInfo.aRects[i];
                if (rect.contains(x, y)) {
                    x -= rect.x;
                    y -= rect.y;
                    let region = this.busInfo.aRegions[i];
                    let iBlock = Usr.getBitField(/** @type {BitField} */ (Bus.BlockInfo.num), this.busInfo.aBlocks[region.iBlock]);
                    let addr = iBlock * this.bus.nBlockSize;
                    let addrLimit = (iBlock + region.cBlocks) * this.bus.nBlockSize - 1;

                    /*
                     * If you want memory to be arranged "vertically" instead of "horizontally", do this:
                     *
                     *      if (x > 0) addr += rect.cy * (x - 1) * this.ratioMemoryToPixels;
                     *      addr += (y * this.ratioMemoryToPixels);
                     */
                    if (y > 0) addr += rect.cx * (y - 1) * this.ratioMemoryToPixels;
                    addr += (x * this.ratioMemoryToPixels);

                    addr |= 0;
                    if (addr > addrLimit) addr = addrLimit;
                    if (MAXDEBUG) this.log("Panel.findAddress(" + x + "," + y + ") found type " + Memory.TYPE.NAMES[region.type] + ", address %" + Str.toHex(addr));
                    return addr;
                }
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * updateAnimation()
     *
     * If the given Control Panel contains a canvas requiring animation (eg, "vpanel"), then this is where that happens.
     *
     * @this {Panel}
     */
    updateAnimation()
    {
        for (let s in this.leds ) {
            let led = this.leds[s];
            led.draw();
        }

        if (this.fRedraw) {

            this.initPen(10, Panel.LIVECANVAS.FONT.CY, this.canvasLiveMem, this.contextLiveMem, this.canvas.style.color);

            if (this.fVisual) {
                if (DEBUG) this.log("begin scanMemory()");
                this.busInfo = this.bus.scanMemory(this.busInfo);
                /*
                 * Calculate the pixel-to-memory-address ratio
                 */
                this.ratioMemoryToPixels = (this.busInfo.cBlocks * this.bus.nBlockSize) / (Panel.LIVEMEM.CX * Panel.LIVEMEM.CY);
                /*
                 * Update the BusInfo object with region information (cRegions and aRegions); return true if region
                 * information has changed since the last call.
                 */
                if (this.findRegions()) {
                    /*
                     * For each region, I choose a slice of the LiveMem canvas and record the corresponding rectangle
                     * within an aRects array (parallel to the aRegions array) in the BusInfo object.
                     *
                     * I don't need a sophisticated Treemap algorithm, because at this level, the data is not hierarchical.
                     * subDivide() makes a simple horizontal or vertical slicing decision based on the ratio of region blocks
                     * to remaining blocks.
                     */
                    let i, rect;
                    let rectAvail = new Rectangle(0, 0, this.canvasLiveMem.width, this.canvasLiveMem.height);
                    this.busInfo.aRects = [];
                    let cBlocksRemaining = this.busInfo.cBlocks;

                    for (i = 0; i < this.busInfo.cRegions; i++) {
                        let cBlocksRegion = this.busInfo.aRegions[i].cBlocks;
                        this.busInfo.aRects.push(rect = rectAvail.subDivide(cBlocksRegion, cBlocksRemaining, !i));
                        if (MAXDEBUG) this.log("region " + i + " rectangle: (" + rect.x + "," + rect.y + " " + rect.cx + "," + rect.cy + ")");
                        cBlocksRemaining -= cBlocksRegion;
                    }

                    /*
                     * Assert that not only did all the specified regions account for all the specified blocks, but also that
                     * the series of subDivide() calls exhausted the original rectangle to one of either zero width or zero height.
                     */


                    /*
                     * Now draw all the rectangles produced by the series of subDivide() calls.
                     */
                    for (i = 0; i < this.busInfo.aRects.length; i++) {
                        let region = this.busInfo.aRegions[i];
                        rect = this.busInfo.aRects[i];
                        rect.drawWith(this.contextLiveMem, Memory.TYPE.COLORS[region.type]);
                        this.centerPen(rect);
                        this.centerText(Memory.TYPE.NAMES[region.type] + " (" + (((region.cBlocks * this.bus.nBlockSize) / 1024) | 0) + "Kb)");
                    }
                }
                if (DEBUG) this.log("end scanMemory(): total bytes: " + this.busInfo.cbTotal + ", total blocks: " + this.busInfo.cBlocks + ", total regions: " + this.busInfo.cRegions);
            } else {
                this.drawText("This space intentionally left blank");
            }
            this.context.drawImage(this.canvasLiveMem, 0, 0, this.canvasLiveMem.width, this.canvasLiveMem.height, this.xMem, this.yMem, this.cxMem, this.cyMem);
            this.fRedraw = false;
        }
    }

    /**
     * updateStatus(fForce)
     *
     * Update function for Panels containing elements with high-frequency display requirements.
     *
     * For older (and slower) DOM-based display elements, those are sill being managed by the CPUX86 component,
     * so it has its own updateStatus() handler.
     *
     * The Computer's updateStatus() handler is currently responsible for calling both our handler and the CPU's handler.
     *
     * @this {Panel}
     * @param {boolean} [fForce] (true will display registers even if the CPU is running and "live" registers are not enabled)
     */
    updateStatus(fForce)
    {
        if (this.canvas) {
            this.dumpRegisters();
            this.updateAnimation();
        }
    }

    /**
     * findRegions()
     *
     * This takes the BusInfo object produced by scanMemory() and adds the following:
     *
     *      cRegions:   number of contiguous memory regions
     *      aRegions:   array of aBlocks [index, count, type] objects
     *
     * It calls addRegion() for each discrete region (set of contiguous blocks with the same type) that it finds.
     *
     * @this {Panel}
     * @return {boolean} true if current region checksum differed from previous checksum (ie, one or more regions changed)
     */
    findRegions()
    {
        let checksum = 0;
        this.busInfo.cRegions = 0;
        if (!this.busInfo.aRegions) this.busInfo.aRegions = [];

        let typeRegion = -1, iBlock = 0, iBlockRegion = 0, addrRegion = 0, nBlockPrev = -1;

        for (; iBlock < this.busInfo.cBlocks; iBlock++) {
            let blockInfo = this.busInfo.aBlocks[iBlock];
            let typeBlock = Usr.getBitField(/** @type {BitField} */ (Bus.BlockInfo.type), blockInfo);
            let nBlockCurr = Usr.getBitField(/** @type {BitField} */ (Bus.BlockInfo.num), blockInfo);
            if (typeBlock != typeRegion || nBlockCurr != nBlockPrev + 1) {
                let cBlocks = iBlock - iBlockRegion;
                if (cBlocks) {
                    checksum += this.addRegion(addrRegion, iBlockRegion, cBlocks, typeRegion);
                }
                typeRegion = typeBlock;
                iBlockRegion = iBlock;
                addrRegion = nBlockCurr << this.bus.nBlockShift;
            }
            nBlockPrev = nBlockCurr;
        }

        checksum += this.addRegion(addrRegion, iBlockRegion, iBlock - iBlockRegion, typeRegion);

        let fChanged = (this.busInfo.checksumRegions != checksum);
        this.busInfo.checksumRegions = checksum;
        return fChanged;
    }

    /**
     * addRegion(addr, iBlock, cBlocks, type)
     *
     * @this {Panel}
     * @param {number} addr
     * @param {number} iBlock
     * @param {number} cBlocks
     * @param {number} type
     * @return {number} bitfield containing the above values (used for checksum)
     */
    addRegion(addr, iBlock, cBlocks, type)
    {
        if (DEBUG) this.log("region " + this.busInfo.cRegions + " (addr " + Str.toHexLong(addr) + ", type " + Memory.TYPE.NAMES[type] + ") contains " + cBlocks + " blocks");
        this.busInfo.aRegions[this.busInfo.cRegions++] = {iBlock: iBlock, cBlocks: cBlocks, type: type};
        return Usr.initBitFields(Bus.BlockInfo, iBlock, cBlocks, 0, type);
    }

    /**
     * dumpRegisters()
     *
     * Updates the live register portion of the panel.
     *
     * @this {Panel}
     */
    dumpRegisters()
    {
        if (this.context && this.canvasLiveRegs && this.contextLiveRegs) {

            let cpu = this.cpu;
            let x = 0, y = 0, cx = this.canvasLiveRegs.width, cy = this.canvasLiveRegs.height;

            this.contextLiveRegs.fillStyle = Panel.LIVEREGS.COLOR;
            this.contextLiveRegs.fillRect(x, y, cx, cy);

            this.initPen(x + 10, y + Panel.LIVECANVAS.FONT.CY, this.canvasLiveRegs, this.contextLiveRegs, this.canvas.style.color);
            this.initCols(3);
            this.drawText("CPU");
            this.drawText("Target");
            this.drawText("Current");
            this.skipLines();
            this.drawText(cpu.model);
            this.drawText(cpu.getSpeedTarget());
            this.drawText(cpu.getSpeedCurrent());
            this.skipLines(2);
            this.initCols(8);
            this.initNumberFormat(16, cpu.model < X86.MODEL_80386? 4 : 8);
            this.drawText("AX", cpu.regEAX, 2);
            this.drawText("DS", cpu.getDS(), 0, 1);
            this.drawText("DX", cpu.regEDX, 2);
            this.drawText("SI", cpu.regESI, 0, 1.5);
            this.drawText("BX", cpu.regEBX, 2);
            this.drawText("ES", cpu.getES(), 0, 1);
            this.drawText("CX", cpu.regECX, 2);
            this.drawText("DI", cpu.regEDI, 0, 1.5);
            this.drawText("CS", cpu.getCS(), 2);
            this.drawText("SS", cpu.getSS(), 0, 1);
            this.drawText("IP", cpu.getIP(), 2);
            this.drawText("SP", cpu.getSP(), 0, 1.5);
            let regPS;
            this.drawText("PS", regPS = cpu.getPS(), 2);
            this.drawText("BP", cpu.regEBP, 0, 1.5);
            if (cpu.model >= X86.MODEL_80386) {
                this.drawText("FS", cpu.getFS(), 2);
                this.drawText("CR0", cpu.regCR0, 0, 1);
                this.drawText("GS", cpu.getGS(), 2);
                this.drawText("CR3", cpu.regCR3, 0, 1.5);
            }
            this.initCols(9);
            this.drawText("V" + ((regPS & X86.PS.OF)? 1 : 0));
            this.drawText("D" + ((regPS & X86.PS.DF)? 1 : 0));
            this.drawText("I" + ((regPS & X86.PS.IF)? 1 : 0));
            this.drawText("T" + ((regPS & X86.PS.TF)? 1 : 0));
            this.drawText("S" + ((regPS & X86.PS.SF)? 1 : 0));
            this.drawText("Z" + ((regPS & X86.PS.ZF)? 1 : 0));
            this.drawText("A" + ((regPS & X86.PS.AF)? 1 : 0));
            this.drawText("P" + ((regPS & X86.PS.PF)? 1 : 0));
            this.drawText("C" + ((regPS & X86.PS.CF)? 1 : 0), 0, 2);

            this.dumpMemory(this.addrDumpLast);

            this.context.drawImage(this.canvasLiveRegs, x, y, cx, cy, this.xReg, this.yReg, this.cxReg, this.cyReg);
        }
    }

    /**
     * dumpMemory(addr, fDraw)
     *
     * @this {Panel}
     * @param {number} addr
     * @param {boolean} [fDraw]
     */
    dumpMemory(addr, fDraw)
    {
        if (this.context && this.canvasLiveRegs && this.contextLiveRegs) {

            let x = 0, y = Panel.LIVEREGS.CY - Panel.LIVEDUMP.CY, cx = this.canvasLiveRegs.width, cy = Panel.LIVEDUMP.CY;

            this.contextLiveRegs.fillStyle = Panel.LIVEREGS.COLOR;
            this.contextLiveRegs.fillRect(x, y, cx, cy);

            this.initPen(x + 10, y + Panel.LIVECANVAS.FONT.CY, this.canvasLiveRegs, this.contextLiveRegs, this.canvas.style.color);
            this.initCols(24);
            if (addr == null) {
                this.drawText("Mouse over memory to dump");
            } else {
                this.drawText(Str.toHexLong(addr), null, 0, 1);
                for (let iLine = 1; iLine <= 16; iLine++) {
                    let sChars = "";
                    for (let iCol = 1; iCol <= 8; iCol++) {
                        let b = this.bus.getByteDirect(addr++);
                        this.drawText(Str.toHex(b, 2), null, 1);
                        sChars += (b >= 32 && b < 128? String.fromCharCode(b) : ".");
                    }
                    this.drawText(sChars, null, 0, 1);
                }
            }

            if (fDraw) this.context.drawImage(this.canvasLiveRegs, x, y, cx, cy, this.xDump, this.yDump, this.cxDump, this.cyDump);
        }
    }

    /**
     * initPen(xLeft, yTop, canvas, context, color, cyFont, sFontFace)
     *
     * @this {Panel}
     * @param {number} xLeft
     * @param {number} yTop
     * @param {HTMLCanvasElement} [canvas]
     * @param {Object} [context]
     * @param {string} [color]
     * @param {number} [cyFont]
     * @param {string} [sFontFace]
     */
    initPen(xLeft, yTop, canvas, context, color, cyFont, sFontFace)
    {
        this.setPen(this.xLeftMargin = xLeft, yTop);
        this.heightText = this.heightDefault = cyFont || Panel.LIVECANVAS.FONT.CY;
        if (!sFontFace) sFontFace = this.fontDefault || (this.heightDefault + "px " + Panel.LIVECANVAS.FONT.FACE);
        this.fontText = this.fontDefault = sFontFace;
        if (canvas) {
            this.canvasText = canvas;
        }
        if (context) {
            this.contextText = context;
            this.colorText = color || "white";
        }
    }

    /**
     * setPen(x, y)
     *
     * @this {Panel}
     * @param {number} x
     * @param {number} y
     */
    setPen(x, y)
    {
        this.xText = x;
        this.yText = y;
    }

    /**
     * centerPen(rect)
     *
     * @this {Panel}
     * @param {Rectangle} rect
     */
    centerPen(rect)
    {
        this.fontText = this.fontDefault;
        this.heightText = this.heightDefault;
        let x = rect.x + (rect.cx >> 1);
        let y = rect.y + (rect.cy >> 1);
        let maxText = rect.cy;
        if (rect.cx < rect.cy) {
            maxText = rect.cx;
            this.fVerticalText = true;
            this.contextText.save();
            this.contextText.translate(x, y);
            this.contextText.rotate(-Math.PI/2);
            x = y = 0;
        }
        if (maxText < this.heightText) {
            this.heightText = maxText;
            this.fontText = this.heightText + "px " + Panel.LIVECANVAS.FONT.FACE;
        }
        this.setPen(x, y);
    }

    /**
     * initCols(nCols)
     *
     * @this {Panel}
     * @param {number} nCols
     */
    initCols(nCols)
    {
        this.cxColumn = (this.canvasText.width / nCols) | 0;
    }

    /**
     * skipCols(nCols)
     *
     * @this {Panel}
     * @param {number} nCols
     */
    skipCols(nCols)
    {
        this.xText += this.cxColumn * nCols;
    }

    /**
     * skipLines(nLines)
     *
     * @this {Panel}
     * @param {number} [nLines]
     */
    skipLines(nLines)
    {
        this.xText = this.xLeftMargin;
        this.yText += (this.heightText + 2) * (nLines || 1);
    }

    /**
     * initNumberFormat(nBase, nDigits)
     *
     * @this {Panel}
     * @param {number} nBase
     * @param {number} nDigits
     */
    initNumberFormat(nBase, nDigits)
    {
        this.nDefaultBase = nBase;
        this.nDefaultDigits = nDigits;
    }

    /**
     * drawText(sText)
     *
     * @this {Panel}
     * @param {string} sText
     * @param {number|null|*} [nValue]
     * @param {number} [nColsSkip]
     * @param {number} [nLinesSkip]
     */
    drawText(sText, nValue, nColsSkip, nLinesSkip)
    {
        this.contextText.font = this.fontText;
        this.contextText.fillStyle = this.colorText;
        this.contextText.fillText(sText, this.xText, this.yText);
        this.xText += this.cxColumn;
        if (nValue != null) {
            let sValue;
            if (this.nDefaultBase != 16) {
                sValue = nValue.toString();
            } else {
                sValue = this.nDefaultDigits < 8? "0x" : "";
                sValue += Str.toHex(nValue, this.nDefaultDigits);
            }
            this.contextText.fillText(sValue, this.xText, this.yText);
            this.xText += this.cxColumn;
        }
        if (nColsSkip) this.skipCols(nColsSkip);
        if (nLinesSkip) this.skipLines(nLinesSkip);
    }

    /**
     * centerText(sText)
     *
     * To center text within a given Rectangle:
     *
     *      centerPen(rect)
     *      centerText(sText)
     *
     * centerPen() sets xLeft and yTop to the center of the specified rectangle, and centerText() calculates
     * the width of the text, adjusting the horizontal centering by its width and the vertical centering by the
     * default font height.  Then it calls drawText().
     *
     * @this {Panel}
     * @param {string} sText
     */
    centerText(sText)
    {
        this.contextText.font = this.fontText;
        let tm = this.contextText.measureText(sText);
        this.xText -= tm.width >> 1;
        this.yText += (this.heightText >> 1) - 2;
        this.drawText(sText);
        if (this.fVerticalText) {
            this.contextText.restore();
            this.fVerticalText = false;
        }
    }

    /**
     * Panel.init()
     *
     * This function operates on every HTML element of class "panel", extracting the
     * JSON-encoded parameters for the Panel constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Panel component, and then binding
     * any associated HTML controls to the new component.
     *
     * NOTE: Unlike most other component init() functions, this one is designed to be
     * called multiple times: once at load time, so that we can bind our print()
     * function to the panel's output control ASAP, and again when the Computer component
     * is verifying that all components are ready and invoking their powerUp() functions.
     *
     * Our powerUp() method gives us a second opportunity to notify any components that
     * that might care (eg, CPU, Keyboard, and Debugger) that we have some controls they
     * might want to use.
     */
    static init()
    {
        let fReady = false;
        let aePanels = Component.getElementsByClass(document, PCX86.APPCLASS, "panel");
        for (let iPanel=0; iPanel < aePanels.length; iPanel++) {
            let ePanel = aePanels[iPanel];
            let parmsPanel = Component.getComponentParms(ePanel);
            let panel = Component.getComponentByID(parmsPanel['id']);
            if (!panel) {
                fReady = true;
                panel = new Panel(parmsPanel);
            }
            Component.bindComponentControls(panel, ePanel, PCX86.APPCLASS);
            if (fReady) panel.setReady();
        }
        if (!fReady) {
            /*
             * If no panel was created for this invocation, then there must be a machine without
             * a panel; find it and give it a panel now.  Panels used to be optional, but now they
             * provide services to other components, so every machine gets one now, even if there
             * was no <panel> element and associated controls.
             */
            let aMachines = Component.getMachines();
            for (let i in aMachines) {
                let idPanel = aMachines[+i] + ".panel";
                let panel = Component.getComponentByType("Panel", idPanel);
                if (!panel) {
                    panel = new Panel({'id': idPanel});
                    panel.setReady();
                    break;
                }
            }
        }
    }
}

Panel.COLOR = {
    BLACK:  "#000000",
    RED:    "#ff0000",
    BLUE:   "#0000ff",
    GREEN:  "#00ff00"
};

Panel.STATE = {
    NONE:   Panel.COLOR.BLACK,
    WRITE:  Panel.COLOR.RED,
    READ:   Panel.COLOR.GREEN,
    SEEK:   Panel.COLOR.BLUE
};

/*
 * The "Live" canvases that we create internally have the following fixed dimensions, to make drawing
 * simpler.  We then render, via drawImage(), these canvases onto the supplied canvas, which will automatically
 * stretch the live images to fit.
 */
Panel.LIVECANVAS = {
    CX:         1280,
    CY:         720,
    FONT:       {
        CY:     18,
        FACE:   "Monaco, Lucida Console, Courier New"
    }
};

Panel.LIVEMEM = {
    CX: (Panel.LIVECANVAS.CX * 3) >> 2,
    CY: (Panel.LIVECANVAS.CY)
};

Panel.LIVEREGS = {
    CX:     (Panel.LIVECANVAS.CX - Panel.LIVEMEM.CX),
    CY:     (Panel.LIVECANVAS.CY),
    COLOR:  "black"
};

Panel.LIVEDUMP = {
    CX: (Panel.LIVECANVAS.CX - Panel.LIVEMEM.CX),
    CY: (Panel.LIVECANVAS.CY >> 1)
};

/*
 * findRegions() records block numbers in bits 0-14, a BackTrack "mod" bit in bit 15, and the block type at bit 16.
 */
Panel.REGION = {
    MASK:           0x7fff,
    BTMOD_SHIFT:    15,
    TYPE_SHIFT:     16
};

Panel.UPDATES_PER_SECOND = 10;

/*
 * Initialize every Panel module on the page.
 */
Web.onInit(Panel.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/bus.js (C) Jeff Parsons 2012-2018
 */


/**
 * Think of this Controller class definition as an interface definition, implemented by the Video Card
 * class and the RAM CompaqController class.
 *
 * class Controller
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Controller {
    /**
     * getMemoryAccess()
     *
     * @this {Controller}
     * @return {Array.<function()>}
     */
    getMemoryAccess()
    {
        return [];
    }

    /**
     * getMemoryBuffer(addr)
     *
     * @this {Controller}
     * @param {number} addr
     * @return {Array} containing the buffer (and an offset within that buffer)
     */
    getMemoryBuffer(addr)
    {
        return [];
    }
}

/**
 * class Bus
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Bus extends Component {
    /**
     * Bus(cpu, dbg)
     *
     * The Bus component manages physical memory and I/O address spaces.
     *
     * The Bus component has no UI elements, so it does not require an init() handler,
     * but it still inherits from the Component class and must be allocated like any
     * other device component.  It's currently allocated by the Computer's init() handler,
     * which then calls the initBus() method of all the other components.
     *
     * When initMemory() initializes the entire address space, it also passes aMemBlocks
     * to the CPU object, so that the CPU can perform its own address-to-block calculations
     * (essential, for example, when the CPU enables paging).
     *
     * For memory beyond the simple needs of the ROM and RAM components (ie, memory-mapped
     * devices), the address space must still be allocated through the Bus component via
     * addMemory().  If the component needs something more than simple read/write storage,
     * it must provide a controller with getMemoryBuffer() and getMemoryAccess() methods.
     *
     * All port (I/O) operations are defined by external handlers; they register with us,
     * and we manage those registrations and provide support for I/O breakpoints, but the
     * only default I/O behavior we provide is ignoring writes to any unregistered output
     * ports and returning 0xff from any unregistered input ports.
     *
     * @this {Bus}
     * @param {Object} parmsBus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    constructor(parmsBus, cpu, dbg)
    {
        super("Bus", parmsBus);

        this.cpu = cpu;
        this.dbg = dbg;

        this.nBusWidth = parmsBus['busWidth'] || 20;

        /*
         * Compute all Bus memory block parameters, based on the width of the bus.
         *
         * Regarding blockTotal, we want to avoid using block overflow expressions like:
         *
         *      iBlock < this.nBlockTotal? iBlock : 0
         *
         * As long as we know that blockTotal is a power of two (eg, 256 or 0x100, in the case of
         * nBusWidth == 20 and blockSize == 4096), we can define blockMask as (blockTotal - 1) and
         * rewrite the previous expression as:
         *
         *      iBlock & this.nBlockMask
         *
         * Similarly, we mask addresses with busMask to enforce "A20 wrap" on 20-bit buses.
         * For larger buses, A20 wrap can be simulated by either clearing bit 20 of busMask or by
         * changing all the block entries for the 2nd megabyte to match those in the 1st megabyte.
         *
         *      Bus Property        Old hard-coded values (when nBusWidth was always 20)
         *      ------------        ----------------------------------------------------
         *      this.nBusLimit      0xfffff
         *      this.nBusMask       [same as busLimit]
         *      this.nBlockSize     4096
         *      this.nBlockLen      (this.nBlockSize >> 2)
         *      this.nBlockShift    12
         *      this.nBlockLimit    0xfff
         *      this.nBlockTotal    ((this.nBusLimit + this.nBlockSize) / this.nBlockSize) | 0
         *      this.nBlockMask     (this.nBlockTotal - 1) [ie, 0xff]
         *
         * Note that we choose a nBlockShift value (and thus a physical memory block size) based on "buswidth":
         *
         *      Bus Width                       Block Shift     Block Size
         *      ---------                       -----------     ----------
         *      20 bits (1Mb address space):    12              4Kb (256 maximum blocks)
         *      24 bits (16Mb address space):   14              16Kb (1K maximum blocks)
         *      32 bits (4Gb address space);    15              32Kb (128K maximum blocks)
         *
         * The coarser block granularities (ie, 16Kb and 32Kb) may cause problems for certain RAM and/or ROM
         * allocations that are contiguous but are allocated out of order, or that have different controller
         * requirements.  Your choices, for the moment, are either to ensure the allocations are performed in
         * order, or to choose smaller nBlockShift values (at the expense of a generating a larger block array).
         *
         * UPDATE: The above is mostly historical thinking, because the new default block size is 4K (assuming
         * PAGEBLOCKS is set, which it always is now).  We really need the lower granularity for all machines,
         * because the original IBM MDA video card needs to be able to do 4K-granular aliasing.
         */
        this.addrTotal = Math.pow(2, this.nBusWidth);
        this.nBusLimit = this.nBusMask = (this.addrTotal - 1) | 0;
        this.nBlockShift = (PAGEBLOCKS /* && this.nBusWidth == 32 */ || this.nBusWidth <= 20)? 12 : (this.nBusWidth <= 24? 14 : 15);
        this.nBlockSize = 1 << this.nBlockShift;
        this.nBlockLen = this.nBlockSize >> 2;
        this.nBlockLimit = this.nBlockSize - 1;
        this.nBlockTotal = (this.addrTotal / this.nBlockSize) | 0;
        this.nBlockMask = this.nBlockTotal - 1;


        /*
         * Lists of I/O notification functions: aPortInputNotify and aPortOutputNotify are arrays, indexed by
         * port, of sub-arrays which contain:
         *
         *      [0]: registered function to call for every I/O access
         *
         * The registered function is called with the port address, and if the access was triggered by the CPU,
         * the linear instruction pointer (LIP) at the point of access.
         *
         * WARNING: Unlike the (old) read and write memory notification functions, these support only one
         * pair of input/output functions per port.  A more sophisticated architecture could support a list
         * of chained functions across multiple components, but I doubt that will be necessary here.
         *
         * UPDATE: The Debugger now piggy-backs on these arrays to indicate ports for which it wants notification
         * of I/O.  In those cases, the registered component/function elements may or may not be set, but the
         * following additional element will be set:
         *
         *      [1]: true to break on I/O, false to ignore I/O
         *
         * The false case is important if fPortInputBreakAll and/or fPortOutputBreakAll is set, because it allows the
         * Debugger to selectively ignore specific ports.
         */
        this.aPortInputNotify = [];
        this.aPortOutputNotify = [];
        this.fPortInputBreakAll = this.fPortOutputBreakAll = false;

        /*
         * By default, all I/O ports are 1 byte wide; ports that are wider must add themselves to one or both of
         * these lists, using addPortInputWidth() and/or addPortOutputWidth().
         */
        this.aPortInputWidth = [];
        this.aPortOutputWidth = [];

        /*
         * Allocate empty Memory blocks to span the entire physical address space.
         */
        this.initMemory();

        if (BACKTRACK) {
            this.abtObjects = [];
            this.cbtDeletions = 0;
            this.ibtLastAlloc = -1;
            this.ibtLastDelete = 0;
        }

        this.setReady();
    }

    /**
     * initMemory()
     *
     * Allocate enough (empty) Memory blocks to span the entire physical address space.
     *
     * @this {Bus}
     */
    initMemory()
    {
        let block = new Memory();
        block.copyBreakpoints(this.dbg);
        this.aMemBlocks = new Array(this.nBlockTotal);
        for (let iBlock = 0; iBlock < this.nBlockTotal; iBlock++) {
            this.aMemBlocks[iBlock] = block;
        }
        this.cpu.initMemory(this.aMemBlocks, this.nBlockShift);
        this.cpu.setAddressMask(this.nBusMask);
    }

    /**
     * reset()
     *
     * @this {Bus}
     */
    reset()
    {
        this.setA20(true);
        if (BACKTRACK) this.ibtLastDelete = 0;
    }

    /**
     * powerUp(data, fRepower)
     *
     * We don't need a powerDown() handler, because for largely historical reasons, our state (including the A20 state)
     * is saved by saveMemory(), which called by the CPU.
     *
     * However, we do need a powerUp() handler, because on resumable machines, the Computer's onReset() function calls
     * everyone's powerUp() handler rather than their reset() handler.
     *
     * TODO: Perhaps Computer should be smarter: if there's no powerUp() handler, then fallback to the reset() handler.
     * In that case, however, we'd either need to remove the powerUp() stub in Component, or detect the existence of the stub.
     *
     * @this {Bus}
     * @param {Object|null} data (always null because we supply no powerDown() handler)
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) this.reset();
        return true;
    }

    /**
     * addMemory(addr, size, type, controller)
     *
     * Adds new Memory blocks to the specified address range.  Any Memory blocks previously
     * added to that range must first be removed via removeMemory(); otherwise, you'll get
     * an allocation conflict error.  This helps prevent address calculation errors, redundant
     * allocations, etc.
     *
     * We've relaxed some of the original requirements (ie, that addresses must start at a
     * block-granular address, or that sizes must be equal to exactly one or more blocks),
     * because machines with large block sizes can make it impossible to load certain ROMs at
     * their required addresses.  Every allocation still allocates a whole number of blocks.
     *
     * Even so, Bus memory management does NOT provide a general-purpose heap.  Most memory
     * allocations occur during machine initialization and never change.  In particular, there
     * is NO support for removing partial-block allocations.  Typically, the only region that
     * changes post-initialization is the Video buffer, and only in the EGA/VGA implementation.
     *
     * Each Memory block keeps track of a start address (addr) and length (used), indicating
     * the used space within the block; any free space that precedes or follows that used space
     * can be allocated later, by simply extending the beginning or ending of the previously used
     * space.  However, any holes that might have existed between the original allocation and an
     * extension are subsumed by the extension.
     *
     * @this {Bus}
     * @param {number} addr is the starting physical address of the request
     * @param {number} size of the request, in bytes
     * @param {number} type is one of the Memory.TYPE constants
     * @param {Controller} [controller] is an optional memory controller component
     * @return {boolean} true if successful, false if not
     */
    addMemory(addr, size, type, controller)
    {
        let addrNext = addr;
        let sizeLeft = size;
        let iBlock = addrNext >>> this.nBlockShift;

        while (sizeLeft > 0 && iBlock < this.aMemBlocks.length) {

            let block = this.aMemBlocks[iBlock];
            let addrBlock = iBlock * this.nBlockSize;
            let sizeBlock = this.nBlockSize - (addrNext - addrBlock);
            if (sizeBlock > sizeLeft) sizeBlock = sizeLeft;

            if (block && block.size) {
                if (block.type == type && block.controller == controller) {
                    /*
                     * Where there is already a similar block with a non-zero size, we allow the allocation only if:
                     *
                     *   1) addrNext + sizeLeft <= block.addr (the request precedes the used portion of the current block), or
                     *   2) addrNext >= block.addr + block.used (the request follows the used portion of the current block)
                     */
                    if (addrNext + sizeLeft <= block.addr) {
                        block.used += (block.addr - addrNext);
                        block.addr = addrNext;
                        return true;
                    }
                    if (addrNext >= block.addr + block.used) {
                        let sizeAvail = block.size - (addrNext - addrBlock);
                        if (sizeAvail > sizeLeft) sizeAvail = sizeLeft;
                        block.used = addrNext - block.addr + sizeAvail;
                        addrNext = addrBlock + this.nBlockSize;
                        sizeLeft -= sizeAvail;
                        iBlock++;
                        continue;
                    }
                }
                return this.reportError(Bus.ERROR.ADD_MEM_INUSE, addrNext, sizeLeft);
            }

            let blockNew = new Memory(addrNext, sizeBlock, this.nBlockSize, type, controller);
            blockNew.copyBreakpoints(this.dbg, block);
            this.aMemBlocks[iBlock++] = blockNew;

            addrNext = addrBlock + this.nBlockSize;
            sizeLeft -= sizeBlock;
        }
        if (sizeLeft <= 0) {
            /*
             * If all addMemory() calls happened ONLY during device initialization, the following code would not
             * be necessary; unfortunately, the Video component can add and remove physical memory blocks during video
             * mode changes, so we have to kick out any PAGED blocks that could have references to those physical memory
             * blocks.  If paging isn't enabled (or supported by the current the CPU), this call has no effect.
             *
             * We could handle this case with a little more, um, precision, but Video mode changes aren't frequent enough
             * to warrant it.
             */
            this.cpu.flushPageBlocks();
            if (!this.cpu.isRunning()) {        // allocation messages at "run time" are bit too much
                let kb = (size / 1024)|0;
                let sb = kb? (kb + "Kb ") : (size + " bytes ");
                this.status(sb + Memory.TYPE.NAMES[type] + " at " + Str.toHex(addr));
            }
            return true;
        }
        return this.reportError(Bus.ERROR.ADD_MEM_BADRANGE, addr, size);
    }

    /**
     * cleanMemory(addr, size, fScrub)
     *
     * @this {Bus}
     * @param {number} addr
     * @param {number} size
     * @param {boolean} [fScrub] (true to "scrub" blocks as well)
     * @return {boolean} (true if all blocks were clean, false otherwise)
     */
    cleanMemory(addr, size, fScrub)
    {
        let fClean = true;
        let iBlock = addr >>> this.nBlockShift;
        let sizeBlock = this.nBlockSize - (addr & this.nBlockLimit);
        while (size > 0 && iBlock < this.aMemBlocks.length) {
            if (!this.aMemBlocks[iBlock].clean(fScrub)) {
                fClean = false;
            }
            size -= sizeBlock;
            sizeBlock = this.nBlockSize;
            iBlock++;
        }
        return fClean;
    }

    /**
     * scanMemory(info, addr, size)
     *
     * Returns a BusInfo object for the specified address range.
     *
     * @this {Bus}
     * @param {Object} [info] previous BusInfo, if any
     * @param {number} [addr] starting address of range (0 if none provided)
     * @param {number} [size] size of range, in bytes (up to end of address space if none provided)
     * @return {Object} updated info (or new info if no previous info provided)
     */
    scanMemory(info, addr, size)
    {
        if (addr == null) addr = 0;
        if (size == null) size = (this.addrTotal - addr) | 0;
        if (info == null) info = {cbTotal: 0, cBlocks: 0, aBlocks: []};

        let iBlock = addr >>> this.nBlockShift;
        let iBlockMax = ((addr + size - 1) >>> this.nBlockShift);

        info.cbTotal = 0;
        info.cBlocks = 0;
        while (iBlock <= iBlockMax) {
            let block = this.aMemBlocks[iBlock];
            info.cbTotal += block.size;
            if (block.size) {
                let btmod = (BACKTRACK && block.modBackTrack(false)? 1 : 0);
                info.aBlocks.push(Usr.initBitFields(Bus.BlockInfo, iBlock, 0, btmod, block.type));
                info.cBlocks++
            }
            iBlock++;
        }
        return info;
    }

    /**
     * getA20()
     *
     * @this {Bus}
     * @return {boolean} true if enabled, false if disabled
     */
    getA20()
    {
        return !this.aBlocks2Mb && this.nBusLimit == this.nBusMask;
    }

    /**
     * setA20(fEnable)
     *
     * On 32-bit bus machines, I've adopted the approach that COMPAQ took with DeskPro 386 machines,
     * which is to map the 1st Mb to the 2nd Mb whenever A20 is disabled, rather than blindly masking
     * the A20 address bit from all addresses; in fact, this is what the DeskPro 386 ROM BIOS requires.
     *
     * For 24-bit bus machines, we take the same approach that most if not all 80286 systems took, which
     * is simply masking the A20 address bit.  A lot of 32-bit machines probably took the same approach.
     *
     * TODO: On machines with a 32-bit bus, look into whether we can eliminate address masking altogether,
     * which seems feasible, provided all incoming addresses are already pre-truncated to 32 bits.  Also,
     * confirm that DeskPro 386 machines mapped the ENTIRE 1st Mb to the 2nd, and not simply the first 64Kb,
     * which is technically all that 8086 address wrap-around compatibility would require.
     *
     * @this {Bus}
     * @param {boolean} fEnable is true to enable A20 (default), false to disable
     */
    setA20(fEnable)
    {
        if (this.nBusWidth == 32) {
            if (fEnable) {
                if (this.aBlocks2Mb) {
                    this.setMemoryBlocks(0x100000, 0x100000, this.aBlocks2Mb);
                    this.aBlocks2Mb = null;
                }
            } else {
                if (!this.aBlocks2Mb) {
                    this.aBlocks2Mb = this.getMemoryBlocks(0x100000, 0x100000);
                    this.setMemoryBlocks(0x100000, 0x100000, this.getMemoryBlocks(0x0, 0x100000));
                }
            }
        }
        else if (this.nBusWidth > 20) {
            let addrMask = (this.nBusMask & ~0x100000) | (fEnable? 0x100000 : 0);
            if (addrMask != this.nBusMask) {
                this.nBusMask = addrMask;
                if (this.cpu) this.cpu.setAddressMask(addrMask);
            }
        }
    }

    /**
     * getWidth()
     *
     * @this {Bus}
     * @return {number}
     */
    getWidth()
    {
        return this.nBusWidth;
    }

    /**
     * setMemoryAccess(addr, size, afn, fQuiet)
     *
     * Updates the access functions in every block of the specified address range.  Since the only components
     * that should be dynamically modifying the memory access functions are those that use addMemory() with a custom
     * memory controller, we require that the block(s) being updated do in fact have a controller.
     *
     * @this {Bus}
     * @param {number} addr
     * @param {number} size
     * @param {Array.<function()>} [afn]
     * @param {boolean} [fQuiet] (true if any error should be quietly logged)
     * @return {boolean} true if successful, false if not
     */
    setMemoryAccess(addr, size, afn, fQuiet)
    {
        if (!(addr & this.nBlockLimit) && size && !(size & this.nBlockLimit)) {
            let iBlock = addr >>> this.nBlockShift;
            while (size > 0) {
                let block = this.aMemBlocks[iBlock];
                if (!block.controller) {
                    return this.reportError(Bus.ERROR.SET_MEM_NOCTRL, addr, size, fQuiet);
                }
                block.setAccess(afn, true);
                size -= this.nBlockSize;
                iBlock++;
            }
            return true;
        }
        return this.reportError(Bus.ERROR.SET_MEM_BADRANGE, addr, size);
    }

    /**
     * removeMemory(addr, size)
     *
     * Replaces every block in the specified address range with empty Memory blocks that ignore all reads/writes.
     *
     * TODO: Update the removeMemory() interface to reflect the relaxed requirements of the addMemory() interface.
     *
     * @this {Bus}
     * @param {number} addr
     * @param {number} size
     * @return {boolean} true if successful, false if not
     */
    removeMemory(addr, size)
    {
        if (!(addr & this.nBlockLimit) && size && !(size & this.nBlockLimit)) {
            let iBlock = addr >>> this.nBlockShift;
            while (size > 0) {
                let blockOld = this.aMemBlocks[iBlock];
                let blockNew = new Memory(addr);
                blockNew.copyBreakpoints(this.dbg, blockOld);
                this.aMemBlocks[iBlock++] = blockNew;
                addr = iBlock * this.nBlockSize;
                size -= this.nBlockSize;
            }
            /*
             * If all removeMemory() calls happened ONLY during device initialization, the following code would not
             * be necessary; unfortunately, the Video component can add and remove physical memory blocks during video
             * mode changes, so we have to kick out any PAGED blocks that could have references to those physical memory
             * blocks.  If paging isn't enabled (or supported by the current the CPU), this call has no effect.
             *
             * We could handle this case with a little more, um, precision, but Video mode changes aren't frequent enough
             * to warrant it.
             */
            this.cpu.flushPageBlocks();
            return true;
        }
        return this.reportError(Bus.ERROR.REM_MEM_BADRANGE, addr, size);
    }

    /**
     * getMemoryBlocks(addr, size)
     *
     * @this {Bus}
     * @param {number} addr is the starting physical address
     * @param {number} size of the request, in bytes
     * @return {Array} of Memory blocks
     */
    getMemoryBlocks(addr, size)
    {
        let aBlocks = [];
        let iBlock = addr >>> this.nBlockShift;
        while (size > 0 && iBlock < this.aMemBlocks.length) {
            aBlocks.push(this.aMemBlocks[iBlock++]);
            size -= this.nBlockSize;
        }
        return aBlocks;
    }

    /**
     * setMemoryBlocks(addr, size, aBlocks, type)
     *
     * If no type is specified, then specified address range uses all the provided blocks as-is;
     * this form of setMemoryBlocks() is used for complete physical aliases.
     *
     * Otherwise, new blocks are allocated with the specified type; the underlying memory from the
     * provided blocks is still used, but the new blocks may have different access to that memory.
     *
     * @this {Bus}
     * @param {number} addr is the starting physical address
     * @param {number} size of the request, in bytes
     * @param {Array} aBlocks as returned by getMemoryBlocks()
     * @param {number} [type] is one of the Memory.TYPE constants
     */
    setMemoryBlocks(addr, size, aBlocks, type)
    {
        let i = 0;
        let iBlock = addr >>> this.nBlockShift;
        while (size > 0 && iBlock < this.aMemBlocks.length) {
            let block = aBlocks[i++];

            if (!block) break;
            if (type !== undefined) {
                let blockNew = new Memory(addr);
                blockNew.clone(block, type, this.dbg);
                block = blockNew;
            }
            this.aMemBlocks[iBlock++] = block;
            size -= this.nBlockSize;
        }
    }

    /**
     * getByte(addr)
     *
     * For physical addresses only; for linear addresses, use cpu.getByte().
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @return {number} byte (8-bit) value at that address
     */
    getByte(addr)
    {
        return this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].readByte(addr & this.nBlockLimit, addr);
    }

    /**
     * getByteDirect(addr)
     *
     * This is useful for the Debugger and other components that want to bypass getByte() breakpoint detection.
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @return {number} byte (8-bit) value at that address
     */
    getByteDirect(addr)
    {
        return this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].readByteDirect(addr & this.nBlockLimit, addr);
    }

    /**
     * getShort(addr)
     *
     * For physical addresses only; for linear addresses, use cpu.getShort().
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @return {number} word (16-bit) value at that address
     */
    getShort(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off != this.nBlockLimit) {
            return this.aMemBlocks[iBlock].readShort(off, addr);
        }
        return this.aMemBlocks[iBlock++].readByte(off, addr) | (this.aMemBlocks[iBlock & this.nBlockMask].readByte(0, addr + 1) << 8);
    }

    /**
     * getShortDirect(addr)
     *
     * This is useful for the Debugger and other components that want to bypass getShort() breakpoint detection.
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @return {number} word (16-bit) value at that address
     */
    getShortDirect(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off != this.nBlockLimit) {
            return this.aMemBlocks[iBlock].readShortDirect(off, addr);
        }
        return this.aMemBlocks[iBlock++].readByteDirect(off, addr) | (this.aMemBlocks[iBlock & this.nBlockMask].readByteDirect(0, addr + 1) << 8);
    }

    /**
     * getLong(addr)
     *
     * For physical addresses only; for linear addresses, use cpu.getLong().
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @return {number} long (32-bit) value at that address
     */
    getLong(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off < this.nBlockLimit - 2) {
            return this.aMemBlocks[iBlock].readLong(off, addr);
        }
        /*
         * I think the previous version of this function tried to be too clever (ie, reading the last
         * long in the current block and the first long in the next block and masking/combining the results),
         * which may have also created some undesirable side-effects for custom memory controllers.
         * This simpler (and probably more reliable) approach is to simply read the long as individual bytes.
         */
        let l = 0;
        let cb = 4, nShift = 0;
        let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
        while (cb--) {
            l |= (this.aMemBlocks[iBlock].readByte(off++, addr++) << nShift);
            if (!--cbBlock) {
                iBlock = (iBlock + 1) & this.nBlockMask;
                off = 0;
            }
            nShift += 8;
        }
        return l;
    }

    /**
     * setByte(addr, b)
     *
     * For physical addresses only; for linear addresses, use cpu.setByte().
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {number} b is the byte (8-bit) value to write (we truncate it to 8 bits to be safe)
     */
    setByte(addr, b)
    {
        this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].writeByte(addr & this.nBlockLimit, b & 0xff, addr);
    }

    /**
     * setByteDirect(addr, b)
     *
     * This is useful for the Debugger and other components that want to bypass breakpoint detection AND read-only
     * memory protection (for example, this is an interface the ROM component could use to initialize ROM contents).
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {number} b is the byte (8-bit) value to write (we truncate it to 8 bits to be safe)
     */
    setByteDirect(addr, b)
    {
        this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].writeByteDirect(addr & this.nBlockLimit, b & 0xff, addr);
    }

    /**
     * setShort(addr, w)
     *
     * For physical addresses only; for linear addresses, use cpu.setShort().
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {number} w is the word (16-bit) value to write (we truncate it to 16 bits to be safe)
     */
    setShort(addr, w)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off != this.nBlockLimit) {
            this.aMemBlocks[iBlock].writeShort(off, w & 0xffff, addr);
            return;
        }
        this.aMemBlocks[iBlock++].writeByte(off, w & 0xff, addr);
        this.aMemBlocks[iBlock & this.nBlockMask].writeByte(0, (w >> 8) & 0xff, addr + 1);
    }

    /**
     * setShortDirect(addr, w)
     *
     * This is useful for the Debugger and other components that want to bypass breakpoint detection AND read-only
     * memory protection (for example, this is an interface the ROM component could use to initialize ROM contents).
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {number} w is the word (16-bit) value to write (we truncate it to 16 bits to be safe)
     */
    setShortDirect(addr, w)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off != this.nBlockLimit) {
            this.aMemBlocks[iBlock].writeShortDirect(off, w & 0xffff, addr);
            return;
        }
        this.aMemBlocks[iBlock++].writeByteDirect(off, w & 0xff, addr);
        this.aMemBlocks[iBlock & this.nBlockMask].writeByteDirect(0, (w >> 8) & 0xff, addr + 1);
    }

    /**
     * setLong(addr, l)
     *
     * For physical addresses only; for linear addresses, use cpu.setLong().
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {number} l is the long (32-bit) value to write
     */
    setLong(addr, l)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off < this.nBlockLimit - 2) {
            this.aMemBlocks[iBlock].writeLong(off, l);
            return;
        }
        /*
         * I think the previous version of this function tried to be too clever (ie, reading and rewriting
         * the last long in the current block, and then reading and rewriting the first long in the next
         * block), which may have also created some undesirable side-effects for custom memory controllers.
         * This simpler (and probably more reliable) approach is to simply write the long as individual bytes.
         */
        let cb = 4;
        let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
        while (cb--) {
            this.aMemBlocks[iBlock].writeByte(off++, l & 0xff, addr++);
            if (!--cbBlock) {
                iBlock = (iBlock + 1) & this.nBlockMask;
                off = 0;
            }
            l >>>= 8;
        }
    }

    /**
     * addBackTrackObject(obj, bto, off)
     *
     * If bto is null, then we create bto (ie, an object that wraps obj and records off).
     *
     * If bto is NOT null, then we verify that off is within the given bto's range; if not,
     * then we must create a new bto and return that instead.
     *
     * @this {Bus}
     * @param {Object} obj
     * @param {BackTrack|null} bto
     * @param {number} off (the offset within obj that this wrapper object is relative to)
     * @return {BackTrack|null}
     */
    addBackTrackObject(obj, bto, off)
    {
        if (BACKTRACK && obj) {
            let cbtObjects = this.abtObjects.length;
            if (!bto) {
                /*
                 * Try the most recently created bto, on the off-chance it's what the caller needs
                 */
                if (this.ibtLastAlloc >= 0) bto = this.abtObjects[this.ibtLastAlloc];
            }
            if (!bto || bto.obj != obj || off < bto.off || off >= bto.off + Bus.BTINFO.OFF_MAX) {

                bto = {obj: obj, off: off, slot: 0, refs: 0};

                let slot;
                if (!this.cbtDeletions) {
                    slot = cbtObjects;
                } else {
                    for (slot = this.ibtLastDelete; slot < cbtObjects; slot++) {
                        let btoTest = this.abtObjects[slot];
                        if (!btoTest || !btoTest.refs && !this.isBackTrackWeak(slot << Bus.BTINFO.SLOT_SHIFT)) {
                            this.ibtLastDelete = slot + 1;
                            this.cbtDeletions--;
                            break;
                        }
                    }
                    /*
                     * There's no longer any guarantee that simply because cbtDeletions was non-zero that there WILL
                     * be an available (existing) slot, because cbtDeletions also counts weak references that may still
                     * be weak.
                     *
                     *
                     */
                }
                /*
                 *  I hit the following error after running in a machine with lots of disk activity:
                 *
                 *      Error: assertion failure in deskpro386.bus
                 *      at Bus.Component.assert (http://pcjs:8088/modules/shared/lib/component.js:732:31)
                 *      at Bus.addBackTrackObject (http://pcjs:8088/modules/pcx86/lib/bus.js:980:18)
                 *      at onATCReadData (http://pcjs:8088/modules/pcx86/lib/hdc.js:1410:35)
                 *      at HDC.readData (http://pcjs:8088/modules/pcx86/lib/hdc.js:2573:23)
                 *      at HDC.inATCByte (http://pcjs:8088/modules/pcx86/lib/hdc.js:1398:20)
                 *      at HDC.inATCData (http://pcjs:8088/modules/pcx86/lib/hdc.js:1487:17)
                 *      at Bus.checkPortInputNotify (http://pcjs:8088/modules/pcx86/lib/bus.js:1457:38)
                 *      at CPUX86.INSw (http://pcjs:8088/modules/pcx86/lib/x86ops.js:1640:26)
                 *      at CPUX86.stepCPU (http://pcjs:8088/modules/pcx86/lib/cpux86.js:4637:37)
                 *      at CPUX86.CPU.runCPU (http://pcjs:8088/modules/pcx86/lib/cpu.js:1014:22)
                 *
                 * TODO: Investigate.  For now, disable BACKTRACK if you run into this or other problems.
                 */

                this.ibtLastAlloc = slot;
                bto.slot = slot + 1;
                if (slot == cbtObjects) {
                    this.abtObjects.push(bto);
                } else {
                    this.abtObjects[slot] = bto;
                }
            }
            return bto;
        }
        return null;
    }

    /**
     * getBackTrackIndex(bto, off)
     *
     * @this {Bus}
     * @param {BackTrack|null} bto
     * @param {number} off
     * @return {number}
     */
    getBackTrackIndex(bto, off)
    {
        let bti = 0;
        if (BACKTRACK && bto) {
            bti = (bto.slot << Bus.BTINFO.SLOT_SHIFT) | Bus.BTINFO.TYPE_DATA | (off - bto.off);
        }
        return bti;
    }

    /**
     * writeBackTrackObject(addr, bto, off)
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {BackTrack|null} bto
     * @param {number} off
     */
    writeBackTrackObject(addr, bto, off)
    {
        if (BACKTRACK && bto) {

            let bti = (bto.slot << Bus.BTINFO.SLOT_SHIFT) | Bus.BTINFO.TYPE_DATA | (off - bto.off);
            this.writeBackTrack(addr, bti);
        }
    }

    /**
     * readBackTrack(addr)
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @return {number}
     */
    readBackTrack(addr)
    {
        if (BACKTRACK) {
            return this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].readBackTrack(addr & this.nBlockLimit);
        }
        return 0;
    }

    /**
     * writeBackTrack(addr, bti)
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {number} bti
     */
    writeBackTrack(addr, bti)
    {
        if (BACKTRACK) {
            let slot = bti >>> Bus.BTINFO.SLOT_SHIFT;
            let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
            let btiPrev = this.aMemBlocks[iBlock].writeBackTrack(addr & this.nBlockLimit, bti);
            let slotPrev = btiPrev >>> Bus.BTINFO.SLOT_SHIFT;
            if (slot != slotPrev) {
                this.aMemBlocks[iBlock].modBackTrack(true);
                if (btiPrev && slotPrev) {
                    let btoPrev = this.abtObjects[slotPrev-1];
                    if (!btoPrev) {
                        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(Messages.WARN)) {
                            this.dbg.message("writeBackTrack(%" + Str.toHex(addr) + ',' + Str.toHex(bti) + "): previous index (" + Str.toHex(btiPrev) + ") refers to empty slot (" + slotPrev + ")");
                        }
                    }
                    else if (btoPrev.refs <= 0) {
                        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(Messages.WARN)) {
                            this.dbg.message("writeBackTrack(%" + Str.toHex(addr) + ',' + Str.toHex(bti) + "): previous index (" + Str.toHex(btiPrev) + ") refers to object with bad ref count (" + btoPrev.refs + ")");
                        }
                    } else if (!--btoPrev.refs) {
                        /*
                         * We used to just slam a null into the previous slot and consider it gone, but there may still
                         * be "weak references" to that slot (ie, it may still be associated with a register bti).
                         *
                         * The easiest way to handle weak references is to leave the slot allocated, with the object's ref
                         * count sitting at zero, and change addBackTrackObject() to look for both empty slots AND non-empty
                         * slots with a ref count of zero; in the latter case, it should again check for weak references,
                         * after which we can re-use the slot if all its weak references are now gone.
                         */
                        if (!this.isBackTrackWeak(btiPrev)) this.abtObjects[slotPrev-1] = null;
                        /*
                         * TODO: Consider what the appropriate trigger should be for resetting ibtLastDelete to zero;
                         * if we don't OCCASIONALLY set it to zero, we may never clear out obsolete weak references,
                         * whereas if we ALWAYS set it to zero, we may be forcing addBackTrackObject() to scan the entire
                         * table too often.
                         *
                         * I'd prefer to do something like this:
                         *
                         *      if (this.ibtLastDelete > slotPrev-1) this.ibtLastDelete = slotPrev-1;
                         *
                         * or even this:
                         *
                         *      if (this.ibtLastDelete > slotPrev-1) this.ibtLastDelete = 0;
                         *
                         * But neither one of those guarantees that we will at least occasionally scan the entire table.
                         */
                        this.ibtLastDelete = 0;
                        this.cbtDeletions++;
                    }
                }
                if (bti && slot) {
                    let bto = this.abtObjects[slot-1];
                    if (bto) {

                        bto.refs++;
                    }
                }
            }
        }
    }

    /**
     * isBackTrackWeak(bti)
     *
     * @param {number} bti
     * @returns {boolean} true if the given bti is still referenced by a register, false if not
     */
    isBackTrackWeak(bti)
    {
        let bt = this.cpu.backTrack;
        let slot = bti >> Bus.BTINFO.SLOT_SHIFT;
        return (bt.btiAL   >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiAH   >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiBL   >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiBH   >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiCL   >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiCH   >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiDL   >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiDH   >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiBPLo >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiBPHi >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiSILo >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiSIHi >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiDILo >> Bus.BTINFO.SLOT_SHIFT == slot ||
                bt.btiDIHi >> Bus.BTINFO.SLOT_SHIFT == slot
        );
    }

    /**
     * updateBackTrackCode(addr, bti)
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {number} bti
     */
    updateBackTrackCode(addr, bti)
    {
        if (BACKTRACK) {
            if (bti & Bus.BTINFO.TYPE_DATA) {
                bti = (bti & ~Bus.BTINFO.TYPE_MASK) | Bus.BTINFO.TYPE_COUNT_INC;
            } else if ((bti & Bus.BTINFO.TYPE_MASK) < Bus.BTINFO.TYPE_COUNT_MAX) {
                bti += Bus.BTINFO.TYPE_COUNT_INC;
            } else {
                return;
            }
            this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].writeBackTrack(addr & this.nBlockLimit, bti);
        }
    }

    /**
     * getBackTrackObject(bti)
     *
     * @this {Bus}
     * @param {number} bti
     * @return {Object|null}
     */
    getBackTrackObject(bti)
    {
        if (BACKTRACK) {
            let slot = bti >>> Bus.BTINFO.SLOT_SHIFT;
            if (slot) return this.abtObjects[slot-1];
        }
        return null;
    }

    /**
     * getBackTrackInfo(bti, fSymbol, fNearest)
     *
     * @this {Bus}
     * @param {number} bti
     * @param {boolean} [fSymbol] (true to return only symbol)
     * @param {boolean} [fNearest] (true to return nearest symbol)
     * @return {string|null}
     */
    getBackTrackInfo(bti, fSymbol, fNearest)
    {
        if (BACKTRACK) {
            let bto = this.getBackTrackObject(bti);
            if (bto) {
                let off = bti & Bus.BTINFO.OFF_MASK;
                let file = bto.obj.file;
                if (file) {

                    return file.getSymbol(bto.obj.offFile + off, fNearest);
                }
                if (!fSymbol || fNearest) {
                    if (bto.obj.idComponent) {
                        return bto.obj.idComponent + '+' + Str.toHex(bto.off + off, 0, true);
                    }
                }
            }
        }
        return null;
    }

    /**
     * getSymbol(addr, fNearest)
     *
     * @this {Bus}
     * @param {number} addr
     * @param {boolean} [fNearest] (true to return nearest symbol)
     * @return {string|null}
     */
    getSymbol(addr, fNearest)
    {
        return BACKTRACK? this.getBackTrackInfo(this.readBackTrack(addr), true, fNearest) : null;
    }

    /**
     * saveMemory(fAll)
     *
     * All blocks will be stored in a single array, as pairs of block numbers and data arrays, like so:
     *
     *      [iBlock0, [dw0, dw1, ...], iBlock1, [dw0, dw1, ...], ...]
     *
     * In a normal 4Kb block, there will be 1K DWORD values in the data array.  Remember that each DWORD is a signed 32-bit
     * integer (because they are formed using bitwise operator rather than floating-point math operators), so don't be
     * surprised to see negative numbers in the data.
     *
     * The above example assumes "uncompressed" data arrays.  If we choose to use "compressed" data arrays, the data arrays
     * will look like:
     *
     *      [count0, dw0, count1, dw1, ...]
     *
     * where each count indicates how many times the following DWORD value occurs.  A data array length less than 1K indicates
     * that it's compressed, since we'll only store them in compressed form if they actually shrank, and we'll use State
     * helper methods compress() and decompress() to create and expand the compressed data arrays.
     *
     * @this {Bus}
     * @param {boolean} [fAll] (true to save all non-ROM memory blocks, regardless of their modified() state)
     * @return {Array} a
     */
    saveMemory(fAll = true)
    {
        /*
         * A quick-and-dirty work-around for 32-bit bus machines, to ensure that all blocks in the 2nd Mb are
         * mapped in before we save.  We do this by forcing A20 on, and then turning it off again before we leave.
         */
        let fA20 = this.getA20();
        if (!fA20) this.setA20(true);

        let i = 0, a = [];
        for (let iBlock = 0; iBlock < this.nBlockTotal; iBlock++) {
            let block = this.aMemBlocks[iBlock];
            if (block.size) {
                if (fAll && block.type != Memory.TYPE.ROM || block.modified()) {
                    let adw = block.save();
                    if (adw) {
                        a[i++] = iBlock;
                        a[i++] = State.compress(adw);
                    }
                }
            }
        }
        if (!fA20) this.setA20(false);
        a[i] = fA20;
        return a;
    }

    /**
     * restoreMemory(a)
     *
     * This restores the contents of all Memory blocks; called by CPUX86.restore().
     *
     * In theory, we ONLY have to save/restore block contents.  Other block attributes,
     * like the type, the memory controller (if any), and the active memory access functions,
     * should already be restored, since every component (re)allocates all the memory blocks
     * it was using when it's restored.  And since the CPU is guaranteed to be the last
     * component to be restored, all those blocks (and their attributes) should be in place now.
     *
     * See saveMemory() for more information on how the memory block contents are saved.
     *
     * @this {Bus}
     * @param {Array} a
     * @return {boolean} true if successful, false if not
     */
    restoreMemory(a)
    {
        let i, scale = 1;
        for (i = 0; i < a.length - 1; i += 2) {
            let iBlock = a[i] * scale, adw = a[i+1];
            /*
             * One wrinkle here is dealing with blocks that were saved when the machine was using an
             * older (larger) block size (eg, 16K or 32K), because now I ALWAYS use a block size of 4K.
             *
             * Detecting that situation is a little tricky, because our memory states don't include the
             * block size that was in effect, and the blocks themselves could be compressed; in a worst
             * case scenario, the very first block of a machine using 16K blocks might have been compressed
             * to exactly 4K, and we'd have no idea if that block should be decompressed or used as-is.
             *
             * So, if the length of the block is less than our default length, we know we must decompress,
             * but furthermore, if the length is not a power-of-two, that's another clue.  Checking for
             * a power-of-two is a simple matter of AND'ing the value with one less than the value; if
             * the result is non-zero, it's not a power-of-two.
             */
            if (adw) {
                if (adw.length < this.nBlockLen * scale || (adw.length & (adw.length - 1))) {
                    adw = State.decompress(adw);
                }
                let nBlocks = (adw.length / this.nBlockLen)|0;
                if (nBlocks && scale == 1) scale = nBlocks;
                while (nBlocks > 0) {
                    let adwBlock = nBlocks > 1? adw.splice(0, this.nBlockLen) : adw;
                    let block = this.aMemBlocks[iBlock];
                    if (!block || !block.restore(adwBlock)) {
                        /*
                         * Either the block to restore hasn't been allocated, indicating a change in the machine
                         * configuration since it was last saved (the most likely explanation) or there's some internal
                         * inconsistency (eg, the block size is wrong).
                         */
                        Component.error("Unable to restore memory block " + iBlock);
                        return false;
                    }
                    nBlocks--;
                    iBlock++;
                }
            }
        }
        if (a[i] !== undefined) this.setA20(a[i]);
        return true;
    }

    /**
     * addPortInputBreak(port)
     *
     * @this {Bus}
     * @param {number|null} [port]
     * @return {boolean} true if break on port input enabled, false if disabled
     */
    addPortInputBreak(port)
    {
        if (port == null) {
            this.fPortInputBreakAll = !this.fPortInputBreakAll;
            return this.fPortInputBreakAll;
        }
        if (this.aPortInputNotify[port] === undefined) {
            this.aPortInputNotify[port] = [null, false];
        }
        this.aPortInputNotify[port][1] = !this.aPortInputNotify[port][1];
        return this.aPortInputNotify[port][1];
    }

    /**
     * addPortInputNotify(start, end, fn)
     *
     * Add a port input-notification handler to the list of such handlers.
     *
     * @this {Bus}
     * @param {number} start port address
     * @param {number} end port address
     * @param {function(number,number)} fn is called with the port and LIP values at the time of the input
     */
    addPortInputNotify(start, end, fn)
    {
        if (fn !== undefined) {
            for (let port = start; port <= end; port++) {
                if (this.aPortInputNotify[port] !== undefined) {
                    Component.warning("Input port " + Str.toHexWord(port) + " already registered");
                    continue;
                }
                this.aPortInputNotify[port] = [fn, false];
                if (MAXDEBUG) this.log("addPortInputNotify(" + Str.toHexWord(port) + ")");
            }
        }
    }

    /**
     * addPortInputTable(component, table, offset)
     *
     * Add port input-notification handlers from the specified table (a batch version of addPortInputNotify)
     *
     * @this {Bus}
     * @param {Component} component
     * @param {Object} table
     * @param {number} [offset] is an optional port offset
     */
    addPortInputTable(component, table, offset)
    {
        if (offset === undefined) offset = 0;
        for (let port in table) {
            this.addPortInputNotify(+port + offset, +port + offset, table[port].bind(component));
        }
    }

    /**
     * addPortInputWidth(port, size)
     *
     * By default, all input ports are 1 byte wide; ports that are wider must call this function.
     *
     * @this {Bus}
     * @param {number} port
     * @param {number} size (1, 2 or 4)
     */
    addPortInputWidth(port, size)
    {
        this.aPortInputWidth[port] = size;
    }

    /**
     * checkPortInputNotify(port, size, addrLIP)
     *
     * @this {Bus}
     * @param {number} port
     * @param {number} size (1, 2 or 4)
     * @param {number} [addrLIP] is the LIP value at the time of the input
     * @return {number} simulated port data
     *
     * NOTE: It seems that parts of the ROM BIOS (like the RS-232 probes around F000:E5D7 in the 5150 BIOS)
     * assume that ports for non-existent hardware return 0xff rather than 0x00, hence my new default (0xff) below.
     */
    checkPortInputNotify(port, size, addrLIP)
    {
        let data = 0, shift = 0;

        while (size > 0) {

            let aNotify = this.aPortInputNotify[port];
            let sizePort = this.aPortInputWidth[port] || 1;
            let maskPort = (sizePort == 1? 0xff : (sizePort == 2? 0xffff : -1));
            let dataPort = maskPort;

            /*
             * TODO: We need to decide what to do about 8-bit I/O to a 16-bit port (ditto for 16-bit I/O
             * to a 32-bit port).  We probably should pass the size through to the aNotify[0] handler,
             * and let it decide what to do, but I don't feel like changing all the I/O handlers right now.
             * The good news, at least, is that the 8-bit handlers would not have to do anything special.
             * This assert will warn us if this is a pressing need.
             */


            if (BACKTRACK) {
                this.cpu.backTrack.btiIO = 0;
            }

            if (aNotify !== undefined) {
                if (aNotify[0]) {
                    dataPort = aNotify[0](port, addrLIP);
                    if (dataPort == null) {
                        dataPort = maskPort;
                    } else {
                        dataPort &= maskPort;
                    }
                }
                if (DEBUGGER && this.dbg && this.fPortInputBreakAll != aNotify[1]) {
                    this.dbg.checkPortInput(port, size, dataPort);
                }
            }
            else {
                if (DEBUGGER && this.dbg) {
                    this.dbg.messageIO(this, port, undefined, addrLIP);
                    if (this.fPortInputBreakAll) this.dbg.checkPortInput(port, size, dataPort);
                }
            }

            data |= dataPort << shift;
            shift += (sizePort << 3);
            port += sizePort;
            size -= sizePort;
        }


        return data;
    }

    /**
     * addPortOutputBreak(port)
     *
     * @this {Bus}
     * @param {number|null} [port]
     * @return {boolean} true if break on port output enabled, false if disabled
     */
    addPortOutputBreak(port)
    {
        if (port == null) {
            this.fPortOutputBreakAll = !this.fPortOutputBreakAll;
            return this.fPortOutputBreakAll;
        }
        if (this.aPortOutputNotify[port] === undefined) {
            this.aPortOutputNotify[port] = [null, false];
        }
        this.aPortOutputNotify[port][1] = !this.aPortOutputNotify[port][1];
        return this.aPortOutputNotify[port][1];
    }

    /**
     * addPortOutputNotify(start, end, fn)
     *
     * Add a port output-notification handler to the list of such handlers.
     *
     * @this {Bus}
     * @param {number} start port address
     * @param {number} end port address
     * @param {function(number,number)} fn is called with the port and LIP values at the time of the output
     */
    addPortOutputNotify(start, end, fn)
    {
        if (fn !== undefined) {
            for (let port = start; port <= end; port++) {
                if (this.aPortOutputNotify[port] !== undefined) {
                    Component.warning("Output port " + Str.toHexWord(port) + " already registered");
                    continue;
                }
                this.aPortOutputNotify[port] = [fn, false];
                if (MAXDEBUG) this.log("addPortOutputNotify(" + Str.toHexWord(port) + ")");
            }
        }
    }

    /**
     * addPortOutputTable(component, table, offset)
     *
     * Add port output-notification handlers from the specified table (a batch version of addPortOutputNotify)
     *
     * @this {Bus}
     * @param {Component} component
     * @param {Object} table
     * @param {number} [offset] is an optional port offset
     */
    addPortOutputTable(component, table, offset)
    {
        if (offset === undefined) offset = 0;
        for (let port in table) {
            this.addPortOutputNotify(+port + offset, +port + offset, table[port].bind(component));
        }
    }

    /**
     * addPortOutputWidth(port, size)
     *
     * By default, all output ports are 1 byte wide; ports that are wider must call this function.
     *
     * @this {Bus}
     * @param {number} port
     * @param {number} size (1, 2 or 4)
     */
    addPortOutputWidth(port, size)
    {
        this.aPortOutputWidth[port] = size;
    }

    /**
     * checkPortOutputNotify(port, size, data, addrLIP)
     *
     * @this {Bus}
     * @param {number} port
     * @param {number} size
     * @param {number} data
     * @param {number} [addrLIP] is the LIP value at the time of the output
     */
    checkPortOutputNotify(port, size, data, addrLIP)
    {
        let shift = 0;

        while (size > 0) {

            let aNotify = this.aPortOutputNotify[port];
            let sizePort = this.aPortOutputWidth[port] || 1;
            let maskPort = (sizePort == 1? 0xff : (sizePort == 2? 0xffff : -1));
            let dataPort = (data >>>= shift) & maskPort;

            /*
             * TODO: We need to decide what to do about 8-bit I/O to a 16-bit port (ditto for 16-bit I/O
             * to a 32-bit port).  We probably should pass the size through to the aNotify[0] handler,
             * and let it decide what to do, but I don't feel like changing all the I/O handlers right now.
             * The good news, at least, is that the 8-bit handlers would not have to do anything special.
             * This assert will warn us if this is a pressing need.
             */


            if (aNotify !== undefined) {
                if (aNotify[0]) {
                    aNotify[0](port, dataPort, addrLIP);
                }
                if (DEBUGGER && this.dbg && this.fPortOutputBreakAll != aNotify[1]) {
                    this.dbg.checkPortOutput(port, size, dataPort);
                }
            }
            else {
                if (DEBUGGER && this.dbg) {
                    this.dbg.messageIO(this, port, dataPort, addrLIP);
                    if (this.fPortOutputBreakAll) this.dbg.checkPortOutput(port, size, dataPort);
                }
            }

            shift += (sizePort << 3);
            port += sizePort;
            size -= sizePort;
        }

    }

    /**
     * reportError(op, addr, size, fQuiet)
     *
     * @this {Bus}
     * @param {number} op
     * @param {number} addr
     * @param {number} size
     * @param {boolean} [fQuiet] (true if any error should be quietly logged)
     * @return {boolean} false
     */
    reportError(op, addr, size, fQuiet)
    {
        let sError = "Memory block error (" + op + ": " + Str.toHex(addr) + "," + Str.toHex(size) + ")";
        if (fQuiet) {
            if (this.dbg) {
                this.dbg.message(sError);
            } else {
                this.log(sError);
            }
        } else {
            Component.error(sError);
        }
        return false;
    }

    /**
     * getLongDirect(addr)
     *
     * This is useful for the Debugger and other components that want to bypass getLong() breakpoint detection.
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @return {number} long (32-bit) value at that address
     *
     getLongDirect(addr)
     {
         let off = addr & this.nBlockLimit;
         let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
         if (off < this.nBlockLimit - 2) {
             return this.aMemBlocks[iBlock].readLongDirect(off, addr);
         }
         //
         // I think the previous version of this function tried to be too clever (ie, reading the last
         // long in the current block and the first long in the next block and masking/combining the results),
         // which may have also created some undesirable side-effects for custom memory controllers.
         // This simpler (and probably more reliable) approach is to simply read the long as individual bytes.
         //
         let l = 0;
         let cb = 4, nShift = 0;
         let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
         while (cb--) {
             l |= (this.aMemBlocks[iBlock].readByteDirect(off++, addr++) << nShift);
             if (!--cbBlock) {
                 iBlock = (iBlock + 1) & this.nBlockMask;
                 off = 0;
             }
             nShift += 8;
         }
         return l;
     }
     */

    /**
     * setLongDirect(addr, l)
     *
     * This is useful for the Debugger and other components that want to bypass breakpoint detection AND read-only
     * memory protection (for example, this is an interface the ROM component could use to initialize ROM contents).
     *
     * @this {Bus}
     * @param {number} addr is a physical address
     * @param {number} l is the long (32-bit) value to write
     *
     setLongDirect(addr, l)
     {
         let off = addr & this.nBlockLimit;
         let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
         if (off < this.nBlockLimit - 2) {
             this.aMemBlocks[iBlock].writeLongDirect(off, l, addr);
             return;
         }
         //
         // I think the previous version of this function tried to be too clever (ie, reading and rewriting
         // the last long in the current block, and then reading and rewriting the first long in the next
         // block), which may have also created some undesirable side-effects for custom memory controllers.
         // This simpler (and probably more reliable) approach is to simply write the long as individual bytes.
         //
         let cb = 4;
         let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
         while (cb--) {
             this.aMemBlocks[iBlock].writeByteDirect(off++, l & 0xff, addr++);
             if (!--cbBlock) {
                 iBlock = (iBlock + 1) & this.nBlockMask;
                 off = 0;
             }
             l >>>= 8;
         }
     }
     */

    /**
     * getBackTrackObjectFromAddr(addr)
     *
     * @this {Bus}
     * @param {number} addr
     * @return {Object|null}
     *
     getBackTrackObjectFromAddr(addr)
     {
         return BACKTRACK? this.getBackTrackObject(this.readBackTrack(addr)) : null;
     }
     */

    /**
     * getBackTrackInfoFromAddr(addr)
     *
     * @this {Bus}
     * @param {number} addr
     * @return {string|null}
     *
     getBackTrackInfoFromAddr(addr)
     {
         return BACKTRACK? this.getBackTrackInfo(this.readBackTrack(addr)) : null;
     }
     */

    /**
     * removePortInputNotify(start, end)
     *
     * Remove port input-notification handler(s) (to be ENABLED later if needed)
     *
     * @this {Bus}
     * @param {number} start address
     * @param {number} end address
     *
     removePortInputNotify(start, end)
     {
         for (let port = start; port < end; port++) {
             if (this.aPortInputNotify[port]) {
                 delete this.aPortInputNotify[port];
             }
         }
     }
     */

    /**
     * removePortOutputNotify(start, end)
     *
     * Remove port output-notification handler(s) (to be ENABLED later if needed)
     *
     * @this {Bus}
     * @param {number} start address
     * @param {number} end address
     *
     removePortOutputNotify(start, end)
     {
         for (let port = start; port < end; port++) {
             if (this.aPortOutputNotify[port]) {
                 delete this.aPortOutputNotify[port];
             }
         }
     }
     */
}

/*
 * Data types used by scanMemory()
 */

/**
 * @typedef {number}
 */
var BlockInfo;

/**
 * This defines the BlockInfo bit fields used by scanMemory() when it creates the aBlocks array.
 *
 * @typedef {{
 *  num:    BitField,
 *  count:  BitField,
 *  btmod:  BitField,
 *  type:   BitField
 * }}
 */
Bus.BlockInfo = Usr.defineBitFields({num:20, count:8, btmod:1, type:3});

/**
 * BusInfo object definition (returned by scanMemory())
 *
 *  cbTotal:    total bytes allocated
 *  cBlocks:    total Memory blocks allocated
 *  aBlocks:    array of allocated Memory block numbers
 *
 * @typedef {{
 *  cbTotal:    number,
 *  cBlocks:    number,
 *  aBlocks:    Array.<BlockInfo>
 * }}
 */
var BusInfo;

if (BACKTRACK) {
    /**
     * BackTrack object definition
     *
     *  obj:        reference to the source object (eg, ROM object, Sector object)
     *  off:        the offset within the source object that this object refers to
     *  slot:       the slot (+1) in abtObjects which this object currently occupies
     *  refs:       the number of memory references, as recorded by writeBackTrack()
     *
     * @typedef {{
     *  obj:        Object,
     *  off:        number,
     *  slot:       number,
     *  refs:       number
     * }}
     */
    var BackTrack;

    /*
     * BackTrack indexes are 31-bit values, where bits 0-8 store an object offset (0-511) and bits 16-30 store
     * an object number (1-32767).  Object number 0 is reserved for dynamic data (ie, data created independent
     * of any source); examples include zero values produced by instructions such as "SUB AX,AX" or "XOR AX,AX".
     * We must special-case instructions like that, because even though AX will almost certainly contain some source
     * data prior to the instruction, the result no longer has any connection to the source.  Similarly, "SBB AX,AX"
     * may produce 0 or -1, depending on carry, but since we don't track the source of individual bits (including the
     * carry flag), AX is now source-less.  TODO: This is an argument for maintaining source info on selected flags,
     * even though it would be rather expensive.
     *
     * The 7 middle bits (9-15) record type and access information, as follows:
     *
     *      bit 15: set to indicate a "data" byte, clear to indicate a "code" byte
     *
     * All bytes start out as "data" bytes; only once they've been executed do they become "code" bytes.  For code
     * bytes, the remaining 6 middle bits (9-14) represent an execution count that starts at 1 (on the byte's initial
     * transition from data to code) and tops out at 63.
     *
     * For data bytes, the remaining middle bits indicate any transformations the data has undergone; eg:
     *
     *      bit 14: ADD/SUB/INC/DEC
     *      bit 13: MUL/DIV
     *      bit 12: OR/AND/XOR/NOT
     *
     * We make no attempt to record the original data or the transformation data, only that the transformation occurred.
     *
     * Other middle bits indicate whether the data was ever read and/or written:
     *
     *      bit 11: READ
     *      bit 10: WRITE
     *
     * Bit 9 is reserved for now.
     */
    Bus.BTINFO = {
        SLOT_MAX:       32768,
        SLOT_SHIFT:     16,
        TYPE_DATA:      0x8000,
        TYPE_ADDSUB:    0x4000,
        TYPE_MULDIV:    0x2000,
        TYPE_LOGICAL:   0x1000,
        TYPE_READ:      0x0800,
        TYPE_WRITE:     0x0400,
        TYPE_COUNT_INC: 0x0200,
        TYPE_COUNT_MAX: 0x7E00,
        TYPE_MASK:      0xFE00,
        TYPE_SHIFT:     9,
        OFF_MAX:        512,
        OFF_MASK:       0x1FF
    };
}

Bus.ERROR = {
    ADD_MEM_INUSE:      1,
    ADD_MEM_BADRANGE:   2,
    SET_MEM_NOCTRL:     3,
    SET_MEM_BADRANGE:   4,
    REM_MEM_BADRANGE:   5
};



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/memory.js (C) Jeff Parsons 2012-2018
 */


/**
 * @class DataView
 * @property {function(number,boolean):number} getUint8
 * @property {function(number,number,boolean)} setUint8
 * @property {function(number,boolean):number} getUint16
 * @property {function(number,number,boolean)} setUint16
 * @property {function(number,boolean):number} getInt32
 * @property {function(number,number,boolean)} setInt32
 */

var littleEndian = (TYPEDARRAYS? (function() {
    let buffer = new ArrayBuffer(2);
    new DataView(buffer).setUint16(0, 256, true);
    return new Uint16Array(buffer)[0] === 256;
})() : false);

/**
 * class Memory
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Memory {
    /**
     * Memory(addr, used, size, type, controller)
     *
     * The Bus component allocates Memory objects so that each has a memory buffer with a
     * block-granular starting address and an address range equal to bus.nBlockSize; however,
     * the size of any given Memory object's underlying buffer can be either zero or bus.nBlockSize;
     * memory read/write functions for empty (buffer-less) blocks are mapped to readNone/writeNone.
     *
     * The Bus allocates empty blocks for the entire address space during initialization, so that
     * any reads/writes to undefined addresses will have no effect.  Later, the ROM and RAM
     * components will ask the Bus to allocate memory for specific ranges, and the Bus will allocate
     * as many new blockSize Memory objects as the ranges require.  Partial Memory blocks could
     * also be supported in theory, but in practice, they're not.
     *
     * Because Memory blocks now allow us to have a "sparse" address space, we could choose to
     * take the memory hit of allocating 4K arrays per block, where each element stores only one byte,
     * instead of the more frugal but slightly slower approach of allocating arrays of 32-bit dwords
     * (LONGARRAYS) and shifting/masking bytes/words to/from dwords; in theory, byte accesses would
     * be faster and word accesses somewhat less faster.
     *
     * However, preliminary testing of that feature (BYTEARRAYS) did not yield significantly faster
     * performance, so it is OFF by default to minimize our memory consumption.  Using TYPEDARRAYS
     * would seem best, but as discussed in defines.js, it's off by default, because it doesn't perform
     * as well as LONGARRAYS; the other advantage of TYPEDARRAYS is that it should theoretically use
     * about 1/2 the memory of LONGARRAYS (32-bit elements vs 64-bit numbers), but I value speed over
     * size at this point.  Also, not all JavaScript implementations support TYPEDARRAYS (IE9 is probably
     * the only real outlier: it lacks typed arrays but otherwise has all the necessary HTML5 support).
     *
     * WARNING: Since Memory blocks are low-level objects that have no UI requirements, they
     * do not inherit from the Component class, so if you want to use any Component class methods,
     * such as Component.assert(), use the corresponding Debugger methods instead (assuming a debugger
     * is available).
     *
     * @this {Memory}
     * @param {number} [addr] of lowest used address in block
     * @param {number} [used] portion of block in bytes (0 for none); must be a multiple of 4
     * @param {number} [size] of block's buffer in bytes (0 for none); must be a multiple of 4
     * @param {number} [type] is one of the Memory.TYPE constants (default is Memory.TYPE.NONE)
     * @param {Controller} [controller] is an optional memory controller component
     * @param {CPUX86} [cpu] is required for UNPAGED memory blocks, so that the CPU can map it to a PAGED block
     */
    constructor(addr, used, size, type, controller, cpu)
    {
        let i;
        this.id = (Memory.idBlock += 2);
        this.adw = null;
        this.offset = 0;
        this.addr = addr;
        this.used = used;
        this.size = size || 0;
        this.type = type || Memory.TYPE.NONE;
        this.fReadOnly = (type == Memory.TYPE.ROM);
        this.controller = null;
        this.cpu = cpu;             // if a CPU reference is provided, then this must be an UNPAGED Memory block allocation
        this.copyBreakpoints();     // initialize the block's Debugger info (eg, breakpoint totals); the caller will reinitialize

        /*
         * Dirty block tracking is now controller-specific.  As noted in the paged block handlers (eg, writeBytePLE),
         * the original purposes were to allow saveMemory() to save only dirty blocks and to enable the Video component
         * to quickly detect changes to the video buffer.  But saveMemory() has since been changed to save (and compress)
         * all memory blocks by default, and the Video component now uses a custom memory controller for all video modes,
         * which performs its own dirty block tracking, so general-purpose memory blocks no longer need to pay this
         * penalty.
         */
        this.flags = Memory.FLAGS.CLEAN;

        if (BACKTRACK) {
            if (!size || controller) {
                this.fModBackTrack = false;
                this.readBackTrack = this.readBackTrackNone;
                this.writeBackTrack = this.writeBackTrackNone;
                this.modBackTrack = this.modBackTrackNone;
            } else {
                this.fModBackTrack = true;
                this.readBackTrack = this.readBackTrackIndex;
                this.writeBackTrack = this.writeBackTrackIndex;
                this.modBackTrack = this.modBackTrackIndex;
                this.abtIndexes = new Array(size);
                for (i = 0; i < size; i++) this.abtIndexes[i] = 0;
            }
        }

        /*
         * For empty memory blocks, all we need to do is ensure all access functions
         * are mapped to "none" handlers (or "unpaged" handlers if paging is enabled).
         */
        if (!size) {
            this.setAccess();
            return;
        }

        /*
         * When a controller is specified, the controller must provide a buffer,
         * via getMemoryBuffer(), and memory access functions, via getMemoryAccess().
         */
        if (controller) {
            this.controller = controller;
            let a = controller.getMemoryBuffer(addr|0);
            this.adw = a[0];
            this.offset = a[1];
            this.setAccess(controller.getMemoryAccess());
            return;
        }

        /*
         * This is the normal case: allocate a buffer that provides 8 bits of data per address;
         * no controller is required because our default memory access functions (see afnMemory)
         * know how to deal with this simple 1-1 mapping of addresses to bytes and words.
         *
         * TODO: Consider initializing the memory array to random (or pseudo-random) values in DEBUG
         * mode; pseudo-random might be best, to help make any bugs reproducible.
         */
        if (TYPEDARRAYS) {
            this.buffer = new ArrayBuffer(size);
            this.dv = new DataView(this.buffer, 0, size);
            /*
             * If littleEndian is true, we can use ab[], aw[] and adw[] directly; well, we can use them
             * whenever the offset is a multiple of 1, 2 or 4, respectively.  Otherwise, we must fallback to
             * dv.getUint8()/dv.setUint8(), dv.getUint16()/dv.setUint16() and dv.getInt32()/dv.setInt32().
             */
            this.ab = new Uint8Array(this.buffer, 0, size);
            this.aw = new Uint16Array(this.buffer, 0, size >> 1);
            this.adw = new Int32Array(this.buffer, 0, size >> 2);
            this.setAccess(littleEndian? Memory.afnArrayLE : Memory.afnArrayBE);
        } else {
            if (BYTEARRAYS) {
                this.ab = new Array(size);
            } else {
                /*
                 * NOTE: This is the default mode of operation (!TYPEDARRAYS && !BYTEARRAYS), because it
                 * seems to provide the best performance; and although in theory, that performance might
                 * come at twice the overhead of TYPEDARRAYS, it's increasingly likely that the JavaScript
                 * runtime will notice that all we ever store are 32-bit values, and optimize accordingly.
                 */
                this.adw = new Array(size >> 2);
                for (i = 0; i < this.adw.length; i++) this.adw[i] = 0;
            }
            this.setAccess(Memory.afnMemory);
        }
    }

    /**
     * init(addr)
     *
     * Quick reinitializer when reusing a Memory block.
     *
     * @this {Memory}
     * @param {number} addr
     */
    init(addr)
    {
        this.addr = addr;
    }

    /**
     * clean(fScrub)
     *
     * @this {Memory}
     * @param {boolean} [fScrub]
     * @return {boolean} (true if block is not dirty, false otherwise)
     */
    clean(fScrub)
    {
        if (this.flags & Memory.FLAGS.DIRTY) {
            if (fScrub) {
                this.flags = (this.flags & ~Memory.FLAGS.DIRTY) | Memory.FLAGS.MODIFIED;
            }
            return false;
        }
        return true;
    }

    /**
     * modified()
     *
     * @this {Memory}
     * @return {boolean} (true if block is dirty and/or modified, false otherwise)
     */
    modified()
    {
        return (this.flags & (Memory.FLAGS.DIRTY | Memory.FLAGS.MODIFIED)) != 0;
    }

    /**
     * clone(mem, type)
     *
     * Converts the current Memory block (this) into a clone of the given Memory block (mem),
     * and optionally overrides the current block's type with the specified type.
     *
     * @this {Memory}
     * @param {Memory} mem
     * @param {number} [type]
     * @param {DebuggerX86} [dbg]
     */
    clone(mem, type, dbg)
    {
        /*
         * Original memory block IDs are even; cloned memory block IDs are odd;
         * the original ID of the current block is lost, but that's OK, since it was presumably
         * produced merely to become a clone.
         */
        this.id = mem.id | 0x1;
        this.used = mem.used;
        this.size = mem.size;
        if (type) {
            this.type = type;
            this.fReadOnly = (type == Memory.TYPE.ROM);
        }
        if (TYPEDARRAYS) {
            this.buffer = mem.buffer;
            this.dv = mem.dv;
            this.ab = mem.ab;
            this.aw = mem.aw;
            this.adw = mem.adw;
            this.setAccess(littleEndian? Memory.afnArrayLE : Memory.afnArrayBE);
        } else {
            if (BYTEARRAYS) {
                this.ab = mem.ab;
            } else {
                this.adw = mem.adw;
            }
            this.setAccess(Memory.afnMemory);
        }
        this.copyBreakpoints(dbg, mem);
    }

    /**
     * save()
     *
     * This gets the contents of a Memory block as an array of 32-bit values; used by Bus.saveMemory(),
     * which in turn is called by CPUX86.save().
     *
     * Memory blocks with custom memory controllers do NOT save their contents; that's the responsibility
     * of the controller component.
     *
     * @this {Memory}
     * @return {Array|Int32Array|null}
     */
    save()
    {
        let adw, i;
        if (this.controller) {
            adw = null;
        }
        else if (BYTEARRAYS) {
            adw = new Array(this.size >> 2);
            let off = 0;
            for (i = 0; i < adw.length; i++) {
                adw[i] = this.ab[off] | (this.ab[off + 1] << 8) | (this.ab[off + 2] << 16) | (this.ab[off + 3] << 24);
                off += 4;
            }
        }
        else if (TYPEDARRAYS) {
            /*
             * It might be tempting to just return a copy of Int32Array(this.buffer, 0, this.size >> 2),
             * but we can't be sure of the "endianness" of an Int32Array -- which would be OK if the array
             * was always saved/restored on the same machine, but there's no guarantee of that, either.
             * So we use getInt32() and require little-endian values.
             *
             * Moreover, an Int32Array isn't treated by JSON.stringify() and JSON.parse() exactly like
             * a normal array; it's serialized as an Object rather than an Array, so it lacks a "length"
             * property and causes problems for State.store() and State.parse().
             */
            adw = new Array(this.size >> 2);
            for (i = 0; i < adw.length; i++) {
                adw[i] = this.dv.getInt32(i << 2, true);
            }
        }
        else {
            adw = this.adw;
        }
        return adw;
    }

    /**
     * restore(adw)
     *
     * This restores the contents of a Memory block from an array of 32-bit values; used by
     * Bus.restoreMemory(), which is called by CPUX86.restore(), after all other components have been
     * restored and thus all Memory blocks have been allocated by their respective components.
     *
     * @this {Memory}
     * @param {Array} adw
     * @return {boolean} true if successful, false if block size mismatch
     */
    restore(adw)
    {
        /*
         * If this block has its own controller, then that controller is responsible for performing the
         * restore, since we don't know the underlying memory format.  However, we no longer blow off these
         * restore calls, because old machine states may still try to restore video memory blocks for MDA
         * and CGA video buffers (and in those cases, the memory formats should be compatible).
         */
        let i, off;
        if (this.controller) {
            if (this.adw) {
                /*
                 * If the controller memory buffer appears to be for either an MDA using 2048 16-bit values
                 * or a CGA using 8192 16-bit values, then split up the saved 32-bit values accordingly.
                 * Otherwise, do a 1-for-1 restore and hope for the best.
                 */
                if (this.adw.length == 2048 || this.adw.length == 8192) {
                    off = (this.offset >> 1);
                    for (i = 0; i < adw.length; i++) {
                        if (off >= this.adw.length) break;
                        this.adw[off++] = adw[i] & 0xffff;
                        this.adw[off++] = (adw[i] >> 16) & 0xffff;
                    }
                }
                else {
                    off = (this.offset >> 2);
                    for (i = 0; i < adw.length; i++) {
                        if (off >= this.adw.length) break;
                        this.adw[off++] = adw[i];
                    }
                }
                this.flags |= Memory.FLAGS.DIRTY;
            }
            return true;
        }
        if (this.size == adw.length << 2) {
            if (BYTEARRAYS) {
                off = 0;
                for (i = 0; i < adw.length; i++) {
                    this.ab[off] = adw[i] & 0xff;
                    this.ab[off + 1] = (adw[i] >> 8) & 0xff;
                    this.ab[off + 2] = (adw[i] >> 16) & 0xff;
                    this.ab[off + 3] = (adw[i] >> 24) & 0xff;
                    off += 4;
                }
            } else if (TYPEDARRAYS) {
                for (i = 0; i < adw.length; i++) {
                    this.dv.setInt32(i << 2, adw[i], true);
                }
            } else {
                this.adw = adw;
            }
            this.flags |= Memory.FLAGS.DIRTY;
            return true;
        }
        return false;
    }

    /**
     * setAccess(afn, fDirect)
     *
     * The afn parameter should be a 6-entry function table containing two byte handlers, two
     * short handlers, and two long handlers.  See the static afnMemory table for an example.
     *
     * If no function table is specified, a default is selected based on the Memory type;
     * similarly, any undefined entries in the table are filled with default handlers that fall
     * back to the byte handlers, and if one or both byte handlers are undefined, they default
     * to handlers that simply ignore the access.
     *
     * fDirect indicates that both the default AND the direct handlers should be updated.  Direct
     * handlers normally match the default handlers, except when "checked" handlers are installed;
     * this allows "checked" handlers to know where to dispatch the call after performing checks.
     * Examples of checks are read/write breakpoints, but it's really up to the Debugger to decide
     * what the check consists of.
     *
     * @this {Memory}
     * @param {Array.<function()>} [afn] function table
     * @param {boolean} [fDirect] (true to update direct access functions as well; default is true)
     */
    setAccess(afn, fDirect)
    {
        if (!afn) {
            if (this.type == Memory.TYPE.UNPAGED) {
                afn = Memory.afnUnpaged;
            }
            else if (this.type == Memory.TYPE.PAGED) {
                afn = Memory.afnPaged;
            } else {

                afn = Memory.afnNone;
            }
        }
        this.setReadAccess(afn, fDirect);
        this.setWriteAccess(afn, fDirect);
    }

    /**
     * setReadAccess(afn, fDirect)
     *
     * @this {Memory}
     * @param {Array.<function()>} afn
     * @param {boolean} [fDirect]
     */
    setReadAccess(afn, fDirect)
    {
        if (!fDirect || !this.cReadBreakpoints) {
            this.readByte = afn[0] || this.readNone;
            this.readShort = afn[2] || this.readShortDefault;
            this.readLong = afn[4] || this.readLongDefault;
        }
        if (fDirect || fDirect === undefined) {
            this.readByteDirect = afn[0] || this.readNone;
            this.readShortDirect = afn[2] || this.readShortDefault;
            this.readLongDirect = afn[4] || this.readLongDefault;
        }
    }

    /**
     * setWriteAccess(afn, fDirect)
     *
     * @this {Memory}
     * @param {Array.<function()>} afn
     * @param {boolean} [fDirect]
     */
    setWriteAccess(afn, fDirect)
    {
        if (!fDirect || !this.cWriteBreakpoints) {
            this.writeByte = !this.fReadOnly && afn[1] || this.writeNone;
            this.writeShort = !this.fReadOnly && afn[3] || this.writeShortDefault;
            this.writeLong = !this.fReadOnly && afn[5] || this.writeLongDefault;
        }
        if (fDirect || fDirect === undefined) {
            this.writeByteDirect = afn[1] || this.writeNone;
            this.writeShortDirect = afn[3] || this.writeShortDefault;
            this.writeLongDirect = afn[5] || this.writeLongDefault;
        }
    }

    /**
     * resetReadAccess()
     *
     * @this {Memory}
     */
    resetReadAccess()
    {
        this.readByte = this.readByteDirect;
        this.readShort = this.readShortDirect;
        this.readLong = this.readLongDirect;
    }

    /**
     * resetWriteAccess()
     *
     * @this {Memory}
     */
    resetWriteAccess()
    {
        this.writeByte = this.fReadOnly? this.writeNone : this.writeByteDirect;
        this.writeShort = this.fReadOnly? this.writeShortDefault : this.writeShortDirect;
        this.writeLong = this.fReadOnly? this.writeLongDefault : this.writeLongDirect;
    }

    /**
     * getPageBlock(addr, fWrite)
     *
     * Called for UNPAGED Memory blocks only.
     *
     * @this {Memory}
     * @param {number} addr
     * @param {boolean} fWrite (true if called for a write, false if for a read)
     * @return {Memory}
     */
    getPageBlock(addr, fWrite)
    {
        /*
         * Even when mapPageBlock() fails (ie, when the page is not present or has insufficient privileges), it
         * will trigger a fault (since we don't set fSuppress), but it will still return a block (ie, an empty block).
         */
        return this.cpu.mapPageBlock(addr, fWrite);
    }

    /**
     * setPhysBlock(blockPhys, blockPDE, offPDE, blockPTE, offPTE)
     *
     * @this {Memory}
     * @param {Memory} blockPhys
     * @param {Memory} blockPDE
     * @param {number} offPDE
     * @param {Memory} blockPTE
     * @param {number} offPTE
     */
    setPhysBlock(blockPhys, blockPDE, offPDE, blockPTE, offPTE)
    {
        this.blockPhys = blockPhys;
        this.blockPDE = blockPDE;
        this.iPDE = offPDE >> 2;    // convert offPDE into iPDE (an adw index)
        this.blockPTE = blockPTE;
        this.iPTE = offPTE >> 2;    // convert offPTE into iPTE (an adw index)
        /*
         * This is an optimization for "normal" pages, installing paged memory handlers that mimic
         * normal memory but also know how to update page tables.  If any of the criteria are not met
         * for these special handlers, we fall back to the slower default "paged" memory handlers.
         */
        if (TYPEDARRAYS && littleEndian && blockPhys.adw && !blockPhys.controller && !blockPhys.cReadBreakpoints && !blockPhys.cWriteBreakpoints) {
            this.ab = blockPhys.ab;
            this.aw = blockPhys.aw;
            this.adw = blockPhys.adw;
            this.setAccess(Memory.afnPagedLE);
        } else {
            this.bitPTEAccessed = blockPhys? Memory.adjustEndian(X86.PTE.ACCESSED) : 0;
            this.bitPTEDirty = blockPhys? Memory.adjustEndian(X86.PTE.ACCESSED | X86.PTE.DIRTY) : 0;
            this.setAccess(Memory.afnPaged);
        }
    }

    /**
     * printAddr(sMessage)
     *
     * @this {Memory}
     * @param {string} sMessage
     */
    printAddr(sMessage)
    {
        if (DEBUG && this.dbg && this.dbg.messageEnabled(Messages.MEM)) {
            this.dbg.printMessage(sMessage + ' ' + (this.addr != null? ('%' + Str.toHex(this.addr)) : '#' + this.id), true);
        }
    }

    /**
     * addBreakpoint(off, fWrite, cpu)
     *
     * NOTE: Some Memory blocks already require access to the CPU (eg, UNPAGED blocks that need to call cpu.mapPageBlock()),
     * while others require access only if the CPU has set a read or write breakpoint in one of its Debug registers; the latter
     * case is handled here by virtue of the CPU parameter.
     *
     * @this {Memory}
     * @param {number} off
     * @param {boolean} fWrite
     * @param {CPUX86} [cpu] (required for breakpoints set by the CPU, as opposed to the Debugger)
     */
    addBreakpoint(off, fWrite, cpu)
    {
        if (!fWrite) {
            if (this.cReadBreakpoints++ === 0) {
                if (cpu) this.cpu = cpu;
                this.setReadAccess(Memory.afnChecked, false);
            }
            if (DEBUG) this.printAddr("read breakpoint added to memory block");
        }
        else {
            if (this.cWriteBreakpoints++ === 0) {
                if (cpu) this.cpu = cpu;
                this.setWriteAccess(Memory.afnChecked, false);
            }
            if (DEBUG) this.printAddr("write breakpoint added to memory block");
        }
    }

    /**
     * removeBreakpoint(off, fWrite)
     *
     * NOTE: If this Memory block is not an UNPAGED block that might need to call cpu.mapPageBlock()), and it no
     * longer has any read or write breakpoints associated with it, then it no longer needs a CPU reference.  The
     * existence of a CPU reference only impacts the performance of the "checked" memory access functions, so it's
     * not critical to eliminate it.
     *
     * TODO: Another option would be to count CPU references separately from Debugger references, so that when
     * the former goes to zero, we can unconditionally remove the CPU reference; UNPAGED blocks would automatically
     * increment that reference count, so their CPU reference would never go away.
     *
     * @this {Memory}
     * @param {number} off
     * @param {boolean} fWrite
     */
    removeBreakpoint(off, fWrite)
    {
        if (!fWrite) {
            if (--this.cReadBreakpoints === 0) {
                this.resetReadAccess();
                if (DEBUG) this.printAddr("all read breakpoints removed from memory block");
            }

        }
        else {
            if (--this.cWriteBreakpoints === 0) {
                this.resetWriteAccess();
                if (DEBUG) this.printAddr("all write breakpoints removed from memory block");
            }

        }
    }

    /**
     * copyBreakpoints(dbg, mem)
     *
     * @this {Memory}
     * @param {DebuggerX86} [dbg]
     * @param {Memory} [mem] (outgoing Memory block to copy breakpoints from, if any)
     */
    copyBreakpoints(dbg, mem)
    {
        this.dbg = dbg;
        this.cReadBreakpoints = this.cWriteBreakpoints = 0;
        if (mem) {
            if (mem.cpu) this.cpu = mem.cpu;
            if ((this.cReadBreakpoints = mem.cReadBreakpoints)) {
                this.setReadAccess(Memory.afnChecked, false);
            }
            if ((this.cWriteBreakpoints = mem.cWriteBreakpoints)) {
                this.setWriteAccess(Memory.afnChecked, false);
            }
        }
    }

    /**
     * readNone(off)
     *
     * Previously, this always returned 0x00, but the initial memory probe by the COMPAQ DeskPro 386 ROM BIOS
     * writes 0x0000 to the first word of every 64Kb block in the nearly 16Mb address space it supports, and
     * if it reads back 0x0000, it will initially think that LOTS of RAM exists, only to be disappointed later
     * when it performs a more exhaustive memory test, generating unwanted error messages in the process.
     *
     * TODO: Determine if we should have separate readByteNone(), readShortNone() and readLongNone() functions
     * to return 0xff, 0xffff and 0xffffffff|0, respectively.  This seems sufficient for now, as it seems unlikely
     * that a system would require nonexistent memory locations to return ALL bits set.
     *
     * Also, I'm reluctant to address that potential issue by simply returning -1, because to date, the above
     * Memory interfaces have always returned values that are properly masked to 8, 16 or 32 bits, respectively.
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readNone(off, addr)
    {
        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(Messages.CPU | Messages.MEM) /* && !off */) {
            this.dbg.message("attempt to read invalid block %" + Str.toHex(addr), true);
        }
        return 0xff;
    }

    /**
     * writeNone(off, v, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} v (could be either a byte or word value, since we use the same handler for both kinds of accesses)
     * @param {number} addr
     */
    writeNone(off, v, addr)
    {
        if (DEBUGGER && this.dbg && this.dbg.messageEnabled(Messages.CPU | Messages.MEM) /* && !off */) {
            this.dbg.message("attempt to write " + Str.toHexWord(v) + " to invalid block %" + Str.toHex(addr), true);
        }
    }

    /**
     * readShortDefault(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readShortDefault(off, addr)
    {
        return this.readByte(off++, addr++) | (this.readByte(off, addr) << 8);
    }

    /**
     * readLongDefault(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readLongDefault(off, addr)
    {
        return this.readByte(off++, addr++) | (this.readByte(off++, addr++) << 8) | (this.readByte(off++, addr++) << 16) | (this.readByte(off, addr) << 24);
    }

    /**
     * writeShortDefault(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeShortDefault(off, w, addr)
    {
        this.writeByte(off++, w & 0xff, addr++);
        this.writeByte(off, w >> 8, addr);
    }

    /**
     * writeLongDefault(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeLongDefault(off, w, addr)
    {
        this.writeByte(off++, w & 0xff, addr++);
        this.writeByte(off++, (w >> 8) & 0xff, addr++);
        this.writeByte(off++, (w >> 16) & 0xff, addr++);
        this.writeByte(off, (w >>> 24), addr);
    }

    /**
     * readByteMemory(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readByteMemory(off, addr)
    {
        if (BYTEARRAYS) {
            return this.ab[off];
        }
        return ((this.adw[off >> 2] >>> ((off & 0x3) << 3)) & 0xff);
    }

    /**
     * readShortMemory(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readShortMemory(off, addr)
    {
        if (BYTEARRAYS) {
            return this.ab[off] | (this.ab[off + 1] << 8);
        }
        let w;
        let idw = off >> 2;
        let nShift = (off & 0x3) << 3;
        let dw = (this.adw[idw] >> nShift);
        if (nShift < 24) {
            w = dw & 0xffff;
        } else {
            w = (dw & 0xff) | ((this.adw[idw + 1] & 0xff) << 8);
        }
        return w;
    }

    /**
     * readLongMemory(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readLongMemory(off, addr)
    {
        if (BYTEARRAYS) {
            return this.ab[off] | (this.ab[off + 1] << 8) | (this.ab[off + 2] << 16) | (this.ab[off + 3] << 24);
        }
        let idw = off >> 2;
        let nShift = (off & 0x3) << 3;
        let l = this.adw[idw];
        if (nShift) {
            l >>>= nShift;
            l |= this.adw[idw + 1] << (32 - nShift);
        }
        return l;
    }

    /**
     * writeByteMemory(off, b, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} b
     * @param {number} addr
     */
    writeByteMemory(off, b, addr)
    {
        if (BYTEARRAYS) {
            this.ab[off] = b;
        } else {
            let idw = off >> 2;
            let nShift = (off & 0x3) << 3;
            this.adw[idw] = (this.adw[idw] & ~(0xff << nShift)) | (b << nShift);
        }
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeShortMemory(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeShortMemory(off, w, addr)
    {
        if (BYTEARRAYS) {
            this.ab[off] = (w & 0xff);
            this.ab[off + 1] = (w >> 8);
        } else {
            let idw = off >> 2;
            let nShift = (off & 0x3) << 3;
            if (nShift < 24) {
                this.adw[idw] = (this.adw[idw] & ~(0xffff << nShift)) | (w << nShift);
            } else {
                this.adw[idw] = (this.adw[idw] & 0x00ffffff) | (w << 24);
                idw++;
                this.adw[idw] = (this.adw[idw] & (0xffffff00|0)) | (w >> 8);
            }
        }
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeLongMemory(off, l, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongMemory(off, l, addr)
    {
        if (BYTEARRAYS) {
            this.ab[off] = (l & 0xff);
            this.ab[off + 1] = (l >> 8) & 0xff;
            this.ab[off + 2] = (l >> 16) & 0xff;
            this.ab[off + 3] = (l >> 24) & 0xff;
        } else {
            let idw = off >> 2;
            let nShift = (off & 0x3) << 3;
            if (!nShift) {
                this.adw[idw] = l;
            } else {
                let mask = (0xffffffff|0) << nShift;
                this.adw[idw] = (this.adw[idw] & ~mask) | (l << nShift);
                idw++;
                this.adw[idw] = (this.adw[idw] & mask) | (l >>> (32 - nShift));
            }
        }
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * readByteChecked(off, addr)
     *
     * NOTE: When we're called in the context of a PAGED block (eg, with one or more DEBUGGER breakpoints set),
     * the checkMemory functions need "this.addr + off" rather than "addr", because the former will be the physical
     * address rather than the linear address.
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readByteChecked(off, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryRead(this.addr + off)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 1, false);
        }
        return this.readByteDirect(off, addr);
    }

    /**
     * readShortChecked(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readShortChecked(off, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryRead(this.addr + off, 2)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 2, false);
        }
        return this.readShortDirect(off, addr);
    }

    /**
     * readLongChecked(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readLongChecked(off, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryRead(this.addr + off, 4)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 4, false);
        }
        return this.readLongDirect(off, addr);
    }

    /**
     * writeByteChecked(off, b, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @param {number} b
     */
    writeByteChecked(off, b, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryWrite(this.addr + off)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 1, true);
        }
        if (this.fReadOnly) this.writeNone(off, b, addr); else this.writeByteDirect(off, b, addr);
    }

    /**
     * writeShortChecked(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @param {number} w
     */
    writeShortChecked(off, w, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryWrite(this.addr + off, 2)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 2, true);
        }
        if (this.fReadOnly) this.writeNone(off, w, addr); else this.writeShortDirect(off, w, addr);
    }

    /**
     * writeLongChecked(off, l, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongChecked(off, l, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryWrite(this.addr + off, 4)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 4, true);
        }
        if (this.fReadOnly) this.writeNone(off, l, addr); else this.writeLongDirect(off, l, addr);
    }

    /**
     * readBytePaged(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readBytePaged(off, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEAccessed;
        return this.blockPhys.readByte(off, addr);
    }

    /**
     * readShortPaged(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readShortPaged(off, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEAccessed;
        return this.blockPhys.readShort(off, addr);
    }

    /**
     * readLongPaged(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readLongPaged(off, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEAccessed;
        return this.blockPhys.readLong(off, addr);
    }

    /**
     * writeBytePaged(off, b, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} b
     * @param {number} addr
     */
    writeBytePaged(off, b, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEDirty;
        this.blockPhys.writeByte(off, b, addr);
    }

    /**
     * writeShortPaged(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeShortPaged(off, w, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEDirty;
        this.blockPhys.writeShort(off, w, addr);
    }

    /**
     * writeLongPaged(off, l, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongPaged(off, l, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEDirty;
        this.blockPhys.writeLong(off, l, addr);
    }

    /**
     * readByteUnpaged(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readByteUnpaged(off, addr)
    {
        return this.getPageBlock(addr, false).readByte(off, addr);
    }

    /**
     * readShortUnpaged(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readShortUnpaged(off, addr)
    {
        return this.getPageBlock(addr, false).readShort(off, addr);
    }

    /**
     * readLongUnpaged(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readLongUnpaged(off, addr)
    {
        return this.getPageBlock(addr, false).readLong(off, addr);
    }

    /**
     * writeByteUnpaged(off, b, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} b
     * @param {number} addr
     */
    writeByteUnpaged(off, b, addr)
    {
        this.getPageBlock(addr, true).writeByte(off, b, addr);
    }

    /**
     * writeShortUnpaged(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeShortUnpaged(off, w, addr)
    {
        this.getPageBlock(addr, true).writeShort(off, w, addr);
    }

    /**
     * writeLongUnpaged(off, l, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongUnpaged(off, l, addr)
    {
        this.getPageBlock(addr, true).writeLong(off, l, addr);
    }

    /**
     * readByteBE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readByteBE(off, addr)
    {
        return this.ab[off];
    }

    /**
     * readByteLE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readByteLE(off, addr)
    {
        return this.ab[off];
    }

    /**
     * readBytePLE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readBytePLE(off, addr)
    {
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED;
        /*
         * TODO: Review this performance hack.  Basically, after the first read of a page,
         * we redirect the default read handler to a faster handler.  However, if operating
         * systems clear the PDE/PTE bits without reloading CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE
         * entries, and whenever those entries are written, reset the read/write handlers
         * for the corresponding pages.
         */
        this.readByte = this.readByteLE;
        return this.ab[off];
    }

    /**
     * readShortBE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readShortBE(off, addr)
    {
        return this.dv.getUint16(off, true);
    }

    /**
     * readShortLE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readShortLE(off, addr)
    {
        /*
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned read
         * vs. always reading the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        return (off & 0x1)? (this.ab[off] | (this.ab[off+1] << 8)) : this.aw[off >> 1];
    }

    /**
     * readShortPLE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readShortPLE(off, addr)
    {
        /*
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned read
         * vs. always reading the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED;
        /*
         * TODO: Review this performance hack.  Basically, after the first read of a page,
         * we redirect the default read handler to a faster handler.  However, if operating
         * systems clear the PDE/PTE bits without reloading CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE
         * entries, and whenever those entries are written, reset the read/write handlers
         * for the corresponding pages.
         */
        this.readShort = this.readShortLE;
        return (off & 0x1)? (this.ab[off] | (this.ab[off+1] << 8)) : this.aw[off >> 1];
    }

    /**
     * readLongBE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readLongBE(off, addr)
    {
        return this.dv.getInt32(off, true);
    }

    /**
     * readLongLE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readLongLE(off, addr)
    {
        /*
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned read
         * vs. always reading the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        return (off & 0x3)? (this.ab[off] | (this.ab[off+1] << 8) | (this.ab[off+2] << 16) | (this.ab[off+3] << 24)) : this.adw[off >> 2];
    }

    /**
     * readLongPLE(off, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @return {number}
     */
    readLongPLE(off, addr)
    {
        /*
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned read
         * vs. always reading the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED;
        /*
         * TODO: Review this performance hack.  Basically, after the first read of a page, we redirect the default
         * read handler to a faster handler.  However, if operating systems clear the PDE/PTE bits without reloading
         * CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE entries, and whenever
         * those entries are written, reset the read/write handlers for the corresponding pages.
         */
        this.readLong = this.readLongLE;
        return (off & 0x3)? (this.ab[off] | (this.ab[off+1] << 8) | (this.ab[off+2] << 16) | (this.ab[off+3] << 24)) : this.adw[off >> 2];
    }

    /**
     * writeByteBE(off, b, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} b
     * @param {number} addr
     */
    writeByteBE(off, b, addr)
    {
        this.ab[off] = b;
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeByteLE(off, b, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @param {number} b
     */
    writeByteLE(off, b, addr)
    {
        this.ab[off] = b;
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeBytePLE(off, b, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @param {number} b
     */
    writeBytePLE(off, b, addr)
    {
        this.ab[off] = b;
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED | X86.PTE.DIRTY;
        /*
         * TODO: Review this performance hack.  Basically, after the first write of a page, we redirect the default
         * write handler to a faster handler.  However, if operating systems clear the PDE/PTE bits without reloading
         * CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE entries, and whenever
         * those entries are written, reset the read/write handlers for the corresponding pages.
         */
        this.writeByte = this.writeByteLE;
        /*
         * NOTE: Technically, we should be setting the DIRTY flag on blockPDE and blockPTE as well, but let's consider
         * the two sole uses of DIRTY.  First, we have cleanMemory(), which is currently used only by the Video component,
         * and video memory should never contain page directories or page tables, so no worries there.  Second, we have
         * saveMemory(), but the CPU now asks that function to save all physical memory blocks whenever paging is enabled,
         * so no worries there either.
         */
        // this.blockPhys.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeShortBE(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @param {number} w
     */
    writeShortBE(off, w, addr)
    {
        this.dv.setUint16(off, w, true);
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeShortLE(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @param {number} w
     */
    writeShortLE(off, w, addr)
    {
        /*
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned write
         * vs. always writing the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        if (off & 0x1) {
            this.ab[off] = w;
            this.ab[off+1] = w >> 8;
        } else {
            this.aw[off >> 1] = w;
        }
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeShortPLE(off, w, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} addr
     * @param {number} w
     */
    writeShortPLE(off, w, addr)
    {
        /*
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned write
         * vs. always writing the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        if (off & 0x1) {
            this.ab[off] = w;
            this.ab[off+1] = w >> 8;
        } else {
            this.aw[off >> 1] = w;
        }
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED | X86.PTE.DIRTY;
        /*
         * TODO: Review this performance hack.  Basically, after the first write of a page,
         * we redirect the default write handler to a faster handler.  However, if operating
         * systems clear the PDE/PTE bits without reloading CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE
         * entries, and whenever those entries are written, reset the read/write handlers
         * for the corresponding pages.
         */
        this.writeShort = this.writeShortLE;
        /*
         * NOTE: Technically, we should be setting the DIRTY flag on blockPDE and blockPTE as well, but let's
         * consider the two sole uses of DIRTY.  First, we have cleanMemory(), which is currently used only by
         * the Video component, and video memory should never contain page directories or page tables, so no
         * worries there.  Second, we have saveMemory(), but the CPU now asks that function to save all physical
         * memory blocks whenever paging is enabled, so no worries there either.
         */
        // this.blockPhys.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeLongBE(off, l, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongBE(off, l, addr)
    {
        this.dv.setInt32(off, l, true);
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeLongLE(off, l, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongLE(off, l, addr)
    {
        /*
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned write
         * vs. always writing the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        if (off & 0x3) {
            this.ab[off] = l;
            this.ab[off+1] = (l >> 8);
            this.ab[off+2] = (l >> 16);
            this.ab[off+3] = (l >> 24);
        } else {
            this.adw[off >> 2] = l;
        }
        // this.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * writeLongPLE(off, l, addr)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongPLE(off, l, addr)
    {
        /*
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned write
         * vs. always writing the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        if (off & 0x3) {
            this.ab[off] = l;
            this.ab[off+1] = (l >> 8);
            this.ab[off+2] = (l >> 16);
            this.ab[off+3] = (l >> 24);
        } else {
            this.adw[off >> 2] = l;
        }
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED | X86.PTE.DIRTY;
        /*
         * TODO: Review this performance hack.  Basically, after the first write of a page,
         * we redirect the default write handler to a faster handler.  However, if operating
         * systems clear the PDE/PTE bits without reloading CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE
         * entries, and whenever those entries are written, reset the read/write handlers
         * for the corresponding pages.
         */
        this.writeLong = this.writeLongLE;
        /*
         * NOTE: Technically, we should be setting the DIRTY flag on blockPDE and blockPTE as well, but let's
         * consider the two sole uses of DIRTY.  First, we have cleanMemory(), which is currently used only by
         * the Video component, and video memory should never contain page directories or page tables, so no
         * worries there.  Second, we have saveMemory(), but the CPU now asks that function to save all physical
         * memory blocks whenever paging is enabled, so no worries there either.
         */
        // this.blockPhys.flags |= Memory.FLAGS.DIRTY;
    }

    /**
     * readBackTrackNone(off)
     *
     * @this {Memory}
     * @param {number} off
     * @return {number}
     */
    readBackTrackNone(off)
    {
        return 0;
    }

    /**
     * writeBackTrackNone(off, bti)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} bti
     */
    writeBackTrackNone(off, bti)
    {
    }

    /**
     * modBackTrackNone(fMod)
     *
     * @this {Memory}
     * @param {boolean} fMod
     */
    modBackTrackNone(fMod)
    {
        return false;
    }

    /**
     * readBackTrackIndex(off)
     *
     * @this {Memory}
     * @param {number} off
     * @return {number}
     */
    readBackTrackIndex(off)
    {
        return this.abtIndexes[off];
    }

    /**
     * writeBackTrackIndex(off, bti)
     *
     * @this {Memory}
     * @param {number} off
     * @param {number} bti
     * @return {number} previous bti (0 if none)
     */
    writeBackTrackIndex(off, bti)
    {
        let btiPrev;
        btiPrev = this.abtIndexes[off];
        this.abtIndexes[off] = bti;
        return btiPrev;
    }

    /**
     * modBackTrackIndex(fMod)
     *
     * @this {Memory}
     * @param {boolean} fMod
     * @return {boolean} previous value
     */
    modBackTrackIndex(fMod)
    {
        let fModPrev = this.fModBackTrack;
        this.fModBackTrack = fMod;
        return fModPrev;
    }

    /**
     * adjustEndian(dw)
     *
     * @param {number} dw
     * @return {number}
     */
    static adjustEndian(dw)
    {
        if (TYPEDARRAYS && !littleEndian) {
            dw = (dw << 24) | ((dw << 8) & 0x00ff0000) | ((dw >> 8) & 0x0000ff00) | (dw >>> 24);
        }
        return dw;
    }
}

/*
 * Basic memory types
 *
 * RAM is the most conventional memory type, providing full read/write capability to x86-compatible (ie,
 * 'little endian") storage.  ROM is equally conventional, except that the fReadOnly property is set,
 * disabling writes.  VIDEO is treated exactly like RAM, unless a controller is provided.  Both RAM and
 * VIDEO memory are always considered writable, and even ROM can be written using the Bus setByteDirect()
 * interface (which in turn uses the Memory writeByteDirect() interface), allowing the ROM component to
 * initialize its own memory.  The CTRL type is used to identify memory-mapped devices that do not need
 * any default storage and always provide their own controller.
 *
 * UNPAGED and PAGED blocks are created by the CPU when paging is enabled; the role of an UNPAGED block
 * is simply to perform page translation and replace itself with a PAGED block, which redirects read/write
 * requests to the physical page located during translation.  UNPAGED and PAGED blocks are considered
 * "logical" blocks that don't contain any storage of their own; all other block types represent "physical"
 * memory (or a memory-mapped device).
 *
 * Unallocated regions of the address space contain a special memory block of type NONE that contains
 * no storage.  Mapping every addressible location to a memory block allows all accesses to be routed in
 * exactly the same manner, without resorting to any range or processor checks.
 *
 * Originally, the Debugger always went through the Bus interfaces, and could therefore modify ROMs as well,
 * but with the introduction of protected mode memory segmentation (and later paging), where logical and
 * physical addresses were no longer the same, that is no longer true.  For coherency, all Debugger memory
 * accesses now go through SegX86 and CPUX86 memory interfaces, so that the user sees the same segment
 * and page translation that the CPU sees.  However, the Debugger uses a special probeAddr() interface to
 * read memory, along with a special "fSuppress" flag to mapPageBlock(), to prevent its memory accesses
 * from triggering segment and/or page faults when invalid or not-present segments or pages are accessed.
 *
 * These types are not mutually exclusive.  For example, VIDEO memory could be allocated as RAM, with or
 * without a custom controller (the original Monochrome and CGA video cards used read/write storage that
 * was indistinguishable from RAM), and CTRL memory could be allocated as an empty block of any type, with
 * a custom controller.  A few types are required for certain features (eg, ROM is required if you want
 * read-only memory), but the larger purpose of these types is to help document the caller's intent and to
 * provide the Control Panel with the ability to highlight memory regions accordingly.
 */
Memory.TYPE = {
    NONE:       0,
    RAM:        1,
    ROM:        2,
    VIDEO:      3,
    CTRL:       4,
    UNPAGED:    5,
    PAGED:      6,
    COLORS:     ["black", "blue", "green", "cyan"],
    NAMES:      ["NONE",  "RAM",  "ROM",   "VIDEO", "H/W", "UNPAGED", "PAGED"]
};

Memory.FLAGS = {
    CLEAN:      0x0,
    DIRTY:      0x1,
    MODIFIED:   0x2
};

/*
 * Last used block ID (used for debugging only)
 */
Memory.idBlock = 0;


/*
 * This is the effective definition of afnNone, but we need not fully define it, because setAccess() uses these
 * defaults when any of the 6 handlers (ie, 2 byte handlers, 2 short handlers, and 2 long handlers) are undefined.
 *
Memory.afnNone = [
    Memory.prototype.readNone,
    Memory.prototype.writeNone,
    Memory.prototype.readShortDefault,
    Memory.prototype.writeShortDefault,
    Memory.prototype.readLongDefault,
    Memory.prototype.writeLongDefault
];
 */
Memory.afnNone = [];

Memory.afnMemory = [
    Memory.prototype.readByteMemory,
    Memory.prototype.writeByteMemory,
    Memory.prototype.readShortMemory,
    Memory.prototype.writeShortMemory,
    Memory.prototype.readLongMemory,
    Memory.prototype.writeLongMemory
];

Memory.afnChecked = [
    Memory.prototype.readByteChecked,
    Memory.prototype.writeByteChecked,
    Memory.prototype.readShortChecked,
    Memory.prototype.writeShortChecked,
    Memory.prototype.readLongChecked,
    Memory.prototype.writeLongChecked
];

if (PAGEBLOCKS) {
    Memory.afnPaged = [
        Memory.prototype.readBytePaged,
        Memory.prototype.writeBytePaged,
        Memory.prototype.readShortPaged,
        Memory.prototype.writeShortPaged,
        Memory.prototype.readLongPaged,
        Memory.prototype.writeLongPaged
    ];

    Memory.afnUnpaged = [
        Memory.prototype.readByteUnpaged,
        Memory.prototype.writeByteUnpaged,
        Memory.prototype.readShortUnpaged,
        Memory.prototype.writeShortUnpaged,
        Memory.prototype.readLongUnpaged,
        Memory.prototype.writeLongUnpaged
    ];
}

if (TYPEDARRAYS) {
    Memory.afnArrayBE = [
        Memory.prototype.readByteBE,
        Memory.prototype.writeByteBE,
        Memory.prototype.readShortBE,
        Memory.prototype.writeShortBE,
        Memory.prototype.readLongBE,
        Memory.prototype.writeLongBE
    ];

    Memory.afnArrayLE = [
        Memory.prototype.readByteLE,
        Memory.prototype.writeByteLE,
        Memory.prototype.readShortLE,
        Memory.prototype.writeShortLE,
        Memory.prototype.readLongLE,
        Memory.prototype.writeLongLE
    ];

    Memory.afnPagedLE = [
        Memory.prototype.readBytePLE,
        Memory.prototype.writeBytePLE,
        Memory.prototype.readShortPLE,
        Memory.prototype.writeShortPLE,
        Memory.prototype.readLongPLE,
        Memory.prototype.writeLongPLE
    ];
}



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/cpu.js (C) Jeff Parsons 2012-2018
 */


/**
 * class CPU
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class CPU extends Component {
    /**
     * CPU(parmsCPU, nCyclesDefault)
     *
     * The CPU class supports the following (parmsCPU) properties:
     *
     *      cycles: the machine's base cycles per second; the CPUX86 constructor will provide us with a default
     *      (based on the CPU model) to use as a fallback.
     *
     *      multiplier: base cycle multiplier; default is 1.
     *
     *      autoStart: true to automatically start, false to not, or null if "it depends"; null is the default,
     *      which means autostart UNLESS there is a Debugger present.
     *
     *      csStart: the number of cycles that runCPU() must wait before generating checksum records;
     *      -1 if disabled.  checksum records are a diagnostic aid used to help compare one CPU run to another.
     *
     *      csInterval: the number of cycles that runCPU() must execute before generating a checksum record;
     *      -1 if disabled.
     *
     *      csStop: the number of cycles to stop generating checksum records.
     *
     * This component is primarily responsible for interfacing the CPU with the outside world (eg, Panel and Debugger
     * components), and managing overall CPU operation.
     *
     * It is extended by the CPUX86 component, where all the x86-specific logic resides.
     *
     * @this {CPU}
     * @param {Object} parmsCPU
     * @param {number} nCyclesDefault
     */
    constructor(parmsCPU, nCyclesDefault)
    {
        super("CPU", parmsCPU, Messages.CPU);

        let nCycles = parmsCPU['cycles'] || nCyclesDefault;

        let nMultiplier = parmsCPU['multiplier'] || 1;

        this.counts = {};
        this.counts.nBaseCyclesPerSecond = nCycles;
        this.counts.msPerYield = Math.round(1000 / CPU.YIELDS_PER_SECOND);

        /*
         * nTargetMultiplier replaces the old "speed" variable (0, 1, 2) and eliminates the need for
         * the constants (SPEED_SLOW, SPEED_FAST and SPEED_MAX).  The UI simply doubles the target multiplier
         * until we've exceeded the host's speed limit (ie, the current value is unable to reach the target),
         * at which point we reset the target back to the default.
         */
        this.counts.nBaseMultiplier = this.counts.nCurrentMultiplier = this.counts.nTargetMultiplier = nMultiplier;
        this.counts.mhzBase = Math.round(this.counts.nBaseCyclesPerSecond / 10000) / 100;
        this.counts.mhzCurrent = this.counts.mhzTarget = this.counts.mhzBase * this.counts.nTargetMultiplier;

        /*
         * We add a number of flags to those initialized by Component.
         */
        this.flags.starting = this.flags.running = this.flags.yield = false;
        this.flags.autoStart = parmsCPU['autoStart'];

        /*
         * TODO: Add some UI for displayLiveRegs (either an XML property, or a UI checkbox, or both)
         */
        this.flags.displayLiveRegs = false;

        /*
         * Get checksum parameters, if any. runCPU() behavior is not affected until fChecksum
         * is true, which won't happen until resetChecksum() is called with nCyclesChecksumInterval
         * ("csInterval") set to a positive value.
         *
         * As above, any of these parameters can also be set with the Debugger's execution options
         * command ("x"); for example, "x cs int 5000" will set nCyclesChecksumInterval to 5000
         * and call resetChecksum().
         */
        this.flags.checksum = false;
        this.counts.nChecksum = this.counts.nCyclesChecksumNext = 0;
        this.counts.nCyclesChecksumStart = parmsCPU["csStart"];
        this.counts.nCyclesChecksumInterval = parmsCPU["csInterval"];
        this.counts.nCyclesChecksumStop = parmsCPU["csStop"];

        /*
         * Array of countdown timers managed by addTimer() and setTimer().
         *
         * See also: getMSCycles(), getBurstCycles(), saveTimers(), restoreTimers(), and updateTimers()
         */
        this.aTimers = [];

        this.idRunTimeout = 0;
        this.onRunTimeout = this.runCPU.bind(this); // function onRunTimeout() { cpu.runCPU(); };
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {CPU}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPU} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.dbg = dbg;

        for (let i = 0; i < CPU.BUTTONS.length; i++) {
            let control = this.bindings[CPU.BUTTONS[i]];
            if (control) this.cmp.setBinding("", CPU.BUTTONS[i], control);
        }

        this.fpu = cmp.getMachineComponent("FPU");

        /*
         * Attach the ChipSet component to the CPU so that it can obtain the IDT vector number
         * of pending hardware interrupts in response to the ChipSet's updateINTR() notifications.
         *
         * We must also call chipset.updateAllTimers() periodically; stepCPU() takes care of that.
         */
        this.chipset = cmp.getMachineComponent("ChipSet");

        /*
         * We've already saved the parmsCPU 'autoStart' setting, but there may be a machine (or URL) override.
         */
        this.flags.autoStart = cmp.getMachineBoolean('autoStart', this.flags.autoStart);

        this.timerYield = cpu.addTimer(this.id, function yieldTimer() {
            cpu.flags.yield = true;
        }, this.counts.msPerYield);

        this.setReady();
    }

    /**
     * reset()
     *
     * This is a placeholder for reset (overridden by the CPUX86 component).
     *
     * @this {CPU}
     */
    reset()
    {
    }

    /**
     * save(fRunning)
     *
     * This is a placeholder for save support (overridden by the CPUX86 component).
     *
     * @this {CPU}
     * @param {boolean} [fRunning]
     * @return {Object|null}
     */
    save(fRunning)
    {
        return null;
    }

    /**
     * restore(data)
     *
     * This is a placeholder for restore support (overridden by the CPUX86 component).
     *
     * @this {CPU}
     * @param {Object} data
     * @return {boolean} true if restore successful, false if not
     */
    restore(data)
    {
        return false;
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {CPU}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.reset();
            } else {
                this.resetCycles();
                if (!this.restore(data)) return false;
                this.resetChecksum();
            }
            /*
             * Give the Debugger a chance to do/print something once we've powered up
             */
            if (DEBUGGER && this.dbg) {
                this.dbg.init();
            } else {
                this.println("No debugger detected");
            }
        }
        /*
         * The Computer component (which is responsible for all powerDown and powerUp notifications)
         * is now responsible for managing a component's fPowered flag, not us.
         *
         *      this.flags.powered = true;
         */
        this.updateCPU(false);
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {CPU}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        /*
         * The Computer component (which is responsible for all powerDown and powerUp notifications)
         * is now responsible for managing a component's fPowered flag, not us.
         *
         *      this.flags.powered = false;
         */
        let fRunning = this.flags.running;
        if (fShutdown) this.stopCPU();
        return fSave? this.save(fRunning) : true;
    }

    /**
     * autoStart()
     *
     * @this {CPU}
     * @return {boolean} true if started, false if not
     */
    autoStart()
    {
        if (this.flags.running) {
            return true;
        }
        /*
         * Start running automatically on power-up, assuming there's no Debugger.
         */
        if (this.flags.autoStart || this.flags.autoStart == null && !this.dbg) {
            return this.startCPU(true);
        }
        return false;
    }

    /**
     * isPowered()
     *
     * @this {CPU}
     * @return {boolean}
     */
    isPowered()
    {
        if (!this.flags.powered) {
            this.println(this.toString() + " not powered");
            return false;
        }
        return true;
    }

    /**
     * isRunning()
     *
     * @this {CPU}
     * @return {boolean}
     */
    isRunning()
    {
        return this.flags.running;
    }

    /**
     * getChecksum()
     *
     * This will be implemented by the CPUX86 component.
     *
     * @this {CPU}
     * @return {number} a 32-bit summation of key elements of the current CPU state (used by the CPU checksum code)
     */
    getChecksum()
    {
        return 0;
    }

    /**
     * resetChecksum()
     *
     * If checksum generation is enabled (fChecksum is true), this resets the running 32-bit checksum and the
     * cycle counter that will trigger the next displayChecksum(); called by resetCycles(), which is called whenever
     * the CPU is reset or restored.
     *
     * @this {CPU}
     * @return {boolean} true if checksum generation enabled, false if not
     */
    resetChecksum()
    {
        if (this.counts.nCyclesChecksumStart === undefined) this.counts.nCyclesChecksumStart = 0;
        if (this.counts.nCyclesChecksumInterval === undefined) this.counts.nCyclesChecksumInterval = -1;
        if (this.counts.nCyclesChecksumStop === undefined) this.counts.nCyclesChecksumStop = -1;
        this.flags.checksum = (this.counts.nCyclesChecksumStart >= 0 && this.counts.nCyclesChecksumInterval > 0);
        if (this.flags.checksum) {
            this.counts.nChecksum = 0;
            this.counts.nCyclesChecksumNext = this.counts.nCyclesChecksumStart - this.nTotalCycles;
            /*
             *  this.counts.nCyclesChecksumNext = this.counts.nCyclesChecksumStart + this.counts.nCyclesChecksumInterval -
             *      (this.nTotalCycles % this.counts.nCyclesChecksumInterval);
             */
            return true;
        }
        return false;
    }

    /**
     * updateChecksum(nCycles)
     *
     * When checksum generation is enabled (fChecksum is true), runCPU() asks stepCPU() to execute a minimum
     * number of cycles (1), effectively limiting execution to a single instruction, and then we're called with
     * the exact number cycles that were actually executed.  This should give us instruction-granular checksums
     * at precise intervals that are 100% repeatable.
     *
     * @this {CPU}
     * @param {number} nCycles
     */
    updateChecksum(nCycles)
    {
        if (this.flags.checksum) {
            /*
             * Get a 32-bit summation of the current CPU state and add it to our running 32-bit checksum
             */
            let fDisplay = false;
            this.counts.nChecksum = (this.counts.nChecksum + this.getChecksum())|0;
            this.counts.nCyclesChecksumNext -= nCycles;
            if (this.counts.nCyclesChecksumNext <= 0) {
                this.counts.nCyclesChecksumNext += this.counts.nCyclesChecksumInterval;
                fDisplay = true;
            }
            if (this.counts.nCyclesChecksumStop >= 0) {
                if (this.counts.nCyclesChecksumStop <= this.getCycles()) {
                    this.counts.nCyclesChecksumInterval = this.counts.nCyclesChecksumStop = -1;
                    this.resetChecksum();
                    this.stopCPU();
                    fDisplay = true;
                }
            }
            if (fDisplay) this.displayChecksum();
        }
    }

    /**
     * displayChecksum()
     *
     * When checksum generation is enabled (fChecksum is true), this is called to provide a crude log of all
     * checksums generated at the specified cycle intervals, as specified by the "csStart" and "csInterval" parmsCPU
     * properties).
     *
     * @this {CPU}
     */
    displayChecksum()
    {
        this.println(this.getCycles() + " cycles: " + "checksum=" + Str.toHex(this.counts.nChecksum));
    }

    /**
     * displayValue(sLabel, nValue, cch)
     *
     * This is principally for displaying register values, but in reality, it can be used to display any
     * numeric (hex) value bound to the given label.
     *
     * @this {CPU}
     * @param {string} sLabel
     * @param {number} nValue
     * @param {number} cch
     */
    displayValue(sLabel, nValue, cch)
    {
        if (this.bindings[sLabel]) {
            if (nValue === undefined) {
                this.setError("Value for " + sLabel + " is invalid");
                this.stopCPU();
            }
            let sVal;
            if (!this.flags.running || this.flags.displayLiveRegs) {
                sVal = Str.toHex(nValue, cch);
            } else {
                sVal = "--------".substr(0, cch);
            }
            /*
             * TODO: Determine if this test actually avoids any redrawing when a register hasn't changed, and/or if
             * we should maintain our own (numeric) cache of displayed register values (to avoid creating these temporary
             * string values that will have to garbage-collected), and/or if this is actually slower, and/or if I'm being
             * too obsessive.
             */
            if (this.bindings[sLabel].textContent != sVal) this.bindings[sLabel].textContent = sVal;
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {CPU}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "run")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let cpu = this;
        let fBound = false;

        switch (sBinding) {
        case "power":
        case "reset":
            /*
             * The "power" and "reset" buttons are functions of the entire computer, not just the CPU,
             * but it's not always convenient to stick a power button in the Computer component definition,
             * so we record those bindings here and pass them on to the Computer component in initBus().
             */
            this.bindings[sBinding] = control;
            fBound = true;
            break;

        case "run":
            this.bindings[sBinding] = control;
            control.onclick = function onClickRun() {
                let fRunning = cpu.flags.running;
                if (!cpu.cmp || !cpu.cmp.checkPower()) return;
                /*
                 * We snapped the CPU's running flag before calling checkPower() because there are rare (REPOWER)
                 * situations where checkPower() will have started the CPU as well.  So toggle the CPU state ONLY
                 * if the running flag remains unchanged.
                 */
                if (fRunning == cpu.flags.running) {
                    if (!cpu.flags.running) {
                        cpu.startCPU(true);
                    } else {
                        cpu.stopCPU(true);
                    }
                }
            };
            fBound = true;
            break;

        case "speed":
            this.bindings[sBinding] = control;
            fBound = true;
            break;

        case "setSpeed":
            this.bindings[sBinding] = control;
            control.onclick = function onClickSetSpeed() {
                cpu.setSpeed(cpu.counts.nTargetMultiplier << 1, true);
            };
            control.textContent = this.getSpeedTarget();
            fBound = true;
            break;

        default:
            break;
        }
        return fBound;
    }

    /**
     * setBurstCycles(nCycles)
     *
     * This function is used by the ChipSet component whenever (for example) a very low timer count is set.
     *
     * @this {CPU}
     * @param {number} nCycles (the target number of cycles to drop the current burst)
     * @return {boolean}
     */
    setBurstCycles(nCycles)
    {
        if (this.flags.running) {
            let delta = this.nStepCycles - nCycles;
            if (delta > 0) {
                /*
                 * NOTE: If the delta is negative, we would actually be increasing nStepCycles and nBurstCycles.
                 * Which used to be OK, but now that we have CPU timers that calculate and rely upon maximum bursts,
                 * this can no longer be allowed.  TODO: Determine if there are any, um, negative side-effects on
                 * ChipSet timers if we don't allow negative deltas.
                 */
                this.nStepCycles -= delta;
                this.nBurstCycles -= delta;
                return true;
            }
        }
        return false;
    }

    /**
     * addCycles(nCycles, fEndStep)
     *
     * @this {CPU}
     * @param {number} nCycles
     * @param {boolean} [fEndStep]
     */
    addCycles(nCycles, fEndStep)
    {
        this.nTotalCycles += nCycles;
        if (fEndStep) {
            this.nBurstCycles = this.nStepCycles = 0;
        }
    }

    /**
     * calcCycles()
     *
     * Calculate the maximum number of cycles we should attempt to process before the next yield.
     *
     * @this {CPU}
     * @return {boolean} (true if there was a change to the multiplier, false if not)
     */
    calcCycles()
    {
        let nMultiplier = this.counts.mhzCurrent / this.counts.mhzBase;
        if (!nMultiplier || nMultiplier > this.counts.nTargetMultiplier) {
            nMultiplier = this.counts.nTargetMultiplier;
        }
        this.counts.nCyclesPerYield = Math.floor(this.counts.nBaseCyclesPerSecond / CPU.YIELDS_PER_SECOND * nMultiplier);
        if (this.counts.nCurrentMultiplier !== nMultiplier) {
            this.counts.nCurrentMultiplier = nMultiplier;
            return true;
        }
        return false;
    }

    /**
     * getCycles(fScaled)
     *
     * getCycles() returns the number of cycles executed so far.  Note that we can be called after
     * runCPU() OR during runCPU(), perhaps from a handler triggered during the current run's stepCPU(),
     * so nRunCycles must always be adjusted by number of cycles stepCPU() was asked to run (nBurstCycles),
     * less the number of cycles it has yet to run (nStepCycles).
     *
     * nRunCycles is zeroed whenever the CPU is halted or the CPU speed is changed, which is why we also
     * have nTotalCycles, which accumulates all nRunCycles before we zero it.  However, nRunCycles and
     * nTotalCycles eventually get reset by calcSpeed(), to avoid overflow, so components that rely on
     * getCycles() returning steadily increasing values should also be prepared for a reset at any time.
     *
     * @this {CPU}
     * @param {boolean} [fScaled] is true if the caller wants a cycle count relative to a multiplier of 1
     * @return {number}
     */
    getCycles(fScaled)
    {
        let nCycles = this.nTotalCycles + this.nRunCycles + this.nBurstCycles - this.nStepCycles;
        if (fScaled && this.counts.nTargetMultiplier > 1 && this.counts.mhzCurrent > this.counts.mhzBase) {
            /*
             * We could scale the current cycle count by the current speed (this.counts.mhzCurrent); eg:
             *
             *      nCycles = Math.round(nCycles / (this.counts.mhzCurrent / this.counts.mhzBase));
             *
             * but that speed will fluctuate somewhat: large fluctuations at first, but increasingly smaller
             * fluctuations after each burst of instructions that runCPU() executes.
             *
             * Alternatively, we can scale the cycle count by the multiplier, which is good in that the
             * multiplier doesn't vary once the user changes it, but a potential downside is that the
             * multiplier might be set too high, resulting in a target speed that's higher than the effective
             * speed is able to reach.
             *
             * Also, if multipliers were always limited to a power-of-two, then this could be calculated
             * with a simple shift.  However, only the "setSpeed" UI binding limits it that way; the Debugger
             * interface allows any value, as does the CPU "multiplier" parmsCPU property (from the machine's
             * XML file).
             */
            nCycles = Math.round(nCycles / this.counts.nTargetMultiplier);
        }
        return nCycles;
    }

    /**
     * getBaseCyclesPerSecond()
     *
     * This returns the CPU's base speed (ie, the original cycles per second defined for the machine)
     *
     * @this {CPU}
     * @return {number}
     */
    getBaseCyclesPerSecond()
    {
        return this.counts.nBaseCyclesPerSecond;
    }

    /**
     * getCurrentCyclesPerSecond()
     *
     * This returns the CPU's current speed (ie, the actual cycles per second, according the current multiplier)
     *
     * @this {CPU}
     * @return {number}
     */
    getCurrentCyclesPerSecond()
    {
        return (this.counts.nBaseCyclesPerSecond * this.counts.nCurrentMultiplier)|0;
    }

    /**
     * resetCycles()
     *
     * Resets speed and cycle information as part of any reset() or restore(); this typically occurs during powerUp().
     * It's important that this be called BEFORE the actual restore() call, because restore() may want to call setSpeed(),
     * which in turn assumes that all the cycle counts have been initialized to sensible values.
     *
     * @this {CPU}
     */
    resetCycles()
    {
        this.nTotalCycles = this.nRunCycles = this.nBurstCycles = this.nStepCycles = 0;
        this.resetChecksum();
        this.setSpeed(this.counts.nBaseMultiplier);
    }

    /**
     * getSpeed()
     *
     * @this {CPU}
     * @return {number} the current speed multiplier
     */
    getSpeed()
    {
        return this.counts.nTargetMultiplier;
    }

    /**
     * getSpeedCurrent()
     *
     * @this {CPU}
     * @return {string} the current speed, in mhz, as a string formatted to two decimal places
     */
    getSpeedCurrent()
    {
        return ((this.flags.running && this.counts.mhzCurrent)? (this.counts.mhzCurrent.toFixed(2) + "Mhz") : "Stopped");
    }

    /**
     * getSpeedTarget()
     *
     * @this {CPU}
     * @return {string} the target speed, in mhz, as a string formatted to two decimal places
     */
    getSpeedTarget()
    {
        return this.counts.mhzTarget.toFixed(2) + "Mhz";
    }

    /**
     * setSpeed(nMultiplier, fUpdateFocus)
     *
     * @this {CPU}
     * @param {number} [nMultiplier] is the new proposed multiplier (reverts to default if target was too high)
     * @param {boolean} [fUpdateFocus] is true to update Computer focus
     * @return {boolean} true if successful, false if not
     *
     * @desc Whenever the speed is changed, the running cycle count and corresponding start time must be reset,
     * so that the next effective speed calculation obtains sensible results.  In fact, when runCPU() initially calls
     * setSpeed() with no parameters, that's all this function does (it doesn't change the current speed setting).
     */
    setSpeed(nMultiplier, fUpdateFocus)
    {
        let fSuccess = true;
        if (nMultiplier !== undefined) {
            /*
             * If we haven't reached 90% (0.9) of the current target speed, revert to the default multiplier.
             */
            if (this.counts.mhzCurrent > 0 && this.counts.mhzCurrent < this.counts.mhzTarget * 0.9) {
                nMultiplier = this.counts.nBaseMultiplier;
                fSuccess = false;
            }
            this.counts.mhzCurrent = 0;
            this.counts.nTargetMultiplier = nMultiplier;
            let mhzTarget = this.counts.mhzBase * this.counts.nTargetMultiplier;
            if (this.counts.mhzTarget != mhzTarget) {
                this.counts.mhzTarget = mhzTarget;
                let sSpeed = this.getSpeedTarget();
                let controlSpeed = this.bindings["setSpeed"];
                if (controlSpeed) controlSpeed.textContent = sSpeed;
                this.println("target speed: " + sSpeed);
            }
            if (fUpdateFocus && this.cmp) this.cmp.updateFocus();
        }
        this.addCycles(this.nRunCycles);
        this.nRunCycles = 0;
        this.counts.msStartRun = this.counts.msEndThisRun = 0;
        if (this.calcCycles()) {    // if a new value was calculated for the current cycle multiplier
            this.resetTimers();     // then update all the fixed-period timers using the new cycle multiplier
        }
        return fSuccess;
    }

    /**
     * calcSpeed(nCycles, msElapsed)
     *
     * @this {CPU}
     * @param {number} nCycles
     * @param {number} msElapsed
     */
    calcSpeed(nCycles, msElapsed)
    {
        if (msElapsed) {
            this.counts.mhzCurrent = Math.round(nCycles / (msElapsed * 10)) / 100;
            if (msElapsed >= 86400000) {
                this.nTotalCycles = 0;
                if (this.chipset) this.chipset.updateAllTimers(true);
                this.setSpeed();        // reset all counters once per day so that we never have to worry about overflow
            }
        }
    }

    /**
     * calcStartTime()
     *
     * @this {CPU}
     */
    calcStartTime()
    {
        this.calcCycles();

        this.counts.nCyclesThisRun = 0;
        this.counts.msDiscount = 0;
        this.counts.msStartThisRun = Usr.getTime();
        if (!this.counts.msStartRun) {
            this.counts.msStartRun = this.counts.msStartThisRun;
        }

        /*
         * Try to detect situations where the browser may have throttled us, such as when the user switches
         * to a different tab; in those situations, Chrome and Safari may restrict setTimeout() callbacks
         * to roughly one per second.
         *
         * Another scenario: the user resizes the browser window.  setTimeout() callbacks are not throttled,
         * but there can still be enough of a lag between the callbacks that CPU speed will be noticeably
         * erratic if we don't compensate for it here.
         *
         * We can detect throttling/lagging by verifying that msEndThisRun (which was set at the end of the
         * previous run and includes any requested sleep time) is comparable to the current msStartThisRun;
         * if the delta is significant, we compensate by bumping msStartRun forward by that delta.
         *
         * This shouldn't be triggered when the Debugger halts the CPU, because setSpeed() -- which is called
         * whenever the CPU starts running again -- zeroes msEndThisRun.
         *
         * This also won't do anything about other internal delays; for example, Debugger message() calls.
         * By the time the message() function has called yieldCPU(), the cost of the message has already been
         * incurred, so it will be end up being charged against the instruction(s) that triggered it.
         *
         * TODO: Consider calling yieldCPU() sooner from message(), so that it can arrange for the msEndThisRun
         * "snapshot" to occur sooner; it's unclear, however, whether that will really improve the CPU's ability
         * to hit its target speed, since any instruction that displays a message is unavoidably slooooow.
         */
        let msDelta = 0;
        if (this.counts.msEndThisRun) {
            msDelta = this.counts.msStartThisRun - this.counts.msEndThisRun;
            if (msDelta > this.counts.msPerYield) {
                this.counts.msStartRun += msDelta;
                /*
                 * Bumping msStartRun forward should NEVER cause it to exceed msStartThisRun; however, just
                 * in case, I make absolutely sure it cannot happen, since doing so could result in negative
                 * speed calculations.
                 */

                if (this.counts.msStartRun > this.counts.msStartThisRun) {
                    this.counts.msStartRun = this.counts.msStartThisRun;
                }
            }
        }
    }

    /**
     * calcRemainingTime()
     *
     * @this {CPU}
     * @return {number}
     */
    calcRemainingTime()
    {
        this.counts.msEndThisRun = Usr.getTime();

        if (this.counts.msDiscount) {
            this.counts.msStartRun += this.counts.msDiscount;
            this.counts.msStartThisRun += this.counts.msDiscount;
        }

        let msYield = this.counts.msPerYield;
        if (this.counts.nCyclesThisRun) {
            /*
             * Normally, we would assume we executed a full quota of work over msPerYield, but since the CPU
             * now has the option of calling yieldCPU(), that might not be true.  If nCyclesThisRun is correct, then
             * the ratio of nCyclesThisRun/nCyclesPerYield should represent the percentage of work we performed,
             * and so applying that percentage to msPerYield should give us a better estimate of work vs. time.
             */
            msYield = Math.round(msYield * this.counts.nCyclesThisRun / this.counts.nCyclesPerYield);
        }

        let msElapsedThisRun = this.counts.msEndThisRun - this.counts.msStartThisRun;
        let msRemainsThisRun = msYield - msElapsedThisRun;

        /*
         * We could pass only "this run" results to calcSpeed():
         *
         *      nCycles = this.counts.nCyclesThisRun;
         *      msElapsed = msElapsedThisRun;
         *
         * but it seems preferable to use longer time periods and hopefully get a more accurate speed.
         */
        let nCycles = this.nRunCycles;
        let msElapsed = this.counts.msEndThisRun - this.counts.msStartRun;

        if (MAXDEBUG && msRemainsThisRun < 0 && this.counts.nTargetMultiplier > 1) {
            this.println("warning: updates @" + msElapsedThisRun + "ms (prefer " + Math.round(msYield) + "ms)");
        }

        this.calcSpeed(nCycles, msElapsed);

        if (msRemainsThisRun < 0) {
            /*
             * Try "throwing out" the effects of large anomalies, by moving the overall run start time up;
             * ordinarily, this should only happen when the someone is using an external Debugger or some other
             * tool or feature that is interfering with our overall execution.
             */
            if (msRemainsThisRun < -1000) {
                this.counts.msStartRun -= msRemainsThisRun;
            }
            /*
             * If the last burst took MORE time than we allotted (ie, it's taking more than 1 second to simulate
             * nBaseCyclesPerSecond), all we can do is yield for as little time as possible (ie, 0ms) and hope
             * that the simulation is at least usable.
             */
            msRemainsThisRun = 0;
        }
        else if (this.counts.mhzCurrent < this.counts.mhzTarget) {
            msRemainsThisRun = 0;
        }

        if (DEBUG && this.messageEnabled(Messages.CPU)) {
            /*
             * Every time the browser gives us another chance to run, we want to display our targets for that run
             * here, followed by what we accomplished in that run.
             */
            this.printMessage(Str.sprintf("%3dms run  %3dms wait  %6dcy  %6.2fmhz  %6dms total  %8dcy total  %6.2fmhz total",
                msElapsedThisRun,
                msRemainsThisRun,
                this.counts.nCyclesThisRun,
                Math.round(this.counts.nCyclesThisRun / (msElapsedThisRun * 10)) / 100,
                msElapsed,
                nCycles,
                this.counts.mhzCurrent
            ));
        }

        this.counts.msEndThisRun += msRemainsThisRun;

        return msRemainsThisRun;
    }

    /**
     * addTimer(id, callBack, ms)
     *
     * Components that want to have timers that fire after some number of milliseconds call addTimer() to create
     * the timer, and then setTimer() when they want to arm it.  Alternatively, they can specify an automatic timeout
     * value (in milliseconds) to have the timer fire automatically at regular intervals.  There is currently
     * no removeTimer() because these are generally used for the entire lifetime of a component.
     *
     * Internally, each timer entry is a preallocated Array with the following entries:
     *
     *      [0]: timer ID
     *      [1]: countdown value, in cycles
     *      [2]: setTimer value: milliseconds if positive, cycles if negative, zero if not used
     *      [3]: callback function
     *
     * A timer is initially dormant; dormant timers have a countdown value of -1 (although any negative number
     * will suffice) and active timers have a non-negative value.
     *
     * Why not use JavaScript's setTimeout() instead?  Good question.  For a good answer, see setTimer() below.
     *
     * @this {CPU}
     * @param {string} id
     * @param {function()} callBack
     * @param {number} [ms] (setTimer value: milliseconds if positive, cycles if negative, zero if not used)
     * @return {number} timer index
     */
    addTimer(id, callBack, ms = 0)
    {
        let iTimer = this.aTimers.length;
        this.aTimers.push([id, -1, ms, callBack]);
        if (ms) this.setTimer(iTimer, ms);
        return iTimer;
    }

    /**
     * clearTimer(iTimer)
     *
     * Using the timer index from a previous addTimer() call, this clears that timer.
     *
     * @this {CPU}
     * @param {number} iTimer
     * @return {boolean}
     */
    clearTimer(iTimer)
    {
        if (iTimer >= 0 && iTimer < this.aTimers.length) {
            this.aTimers[iTimer][1] = -1;
            return true;
        }
        return false;
    }

    /**
     * findTimer(id)
     *
     * @this {CPU}
     * @param {string} id
     * @return {Array|null}
     */
    findTimer(id)
    {
        for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
            let timer = this.aTimers[iTimer];
            if (timer[0] == id) return timer;
        }
        return null;
    }

    /**
     * isTimerSet(iTimer)
     *
     * @this {CPU}
     * @param {number} iTimer
     * @return {boolean}
     */
    isTimerSet(iTimer)
    {
        if (iTimer >= 0 && iTimer < this.aTimers.length) {
            return this.aTimers[iTimer][1] >= 0;
        }
        return false;
    }

    /**
     * resetTimers()
     *
     * When the target CPU speed multiplier is altered, it's a good idea to run through all the timers that
     * have a fixed millisecond period and re-arm them, because the timers are using cycle counts that were based
     * on a previous multiplier.
     *
     * @this {CPU}
     */
    resetTimers()
    {
        for (let iTimer = this.aTimers.length - 1; iTimer >= 0; iTimer--) {
            let timer = this.aTimers[iTimer];
            if (timer[2]) this.setTimer(iTimer, timer[2], true);
        }
    }

    /**
     * restoreTimers(aTimerStates)
     *
     * @this {CPU}
     * @param {Array} aTimerStates
     */
    restoreTimers(aTimerStates)
    {
        for (let iTimerState = 0; iTimerState < aTimerStates.length; iTimerState++) {
            let state = aTimerStates[iTimerState];
            let timer = this.findTimer(state[0]);
            if (timer) {
                timer[1] = state[1];
                /*
                 * When restoring from a new state (ie, when state[3] is true), the theory was we could use
                 * state[2] as-is, but in reality, overriding a component's timeout value is problematic, especially
                 * if a component wants to start using a new value (ie, we don't want an old value trumping it).
                 */
                // if (state[3] || state[2] > 0) timer[2] = state[2];
            }
        }
    }

    /**
     * saveTimers()
     *
     * @this {CPU}
     * @return {Array}
     */
    saveTimers()
    {
        let aTimerStates = [];
        for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
            let timer = this.aTimers[iTimer];
            /*
             * We now push a 4th element (true) to indicate that this is a new timer state, where timer[2] is
             * a tri-state value (positive for milliseconds, negative for cycles, zero for none); previously, it
             * was negative (-1) for none or else some number of milliseconds.
             */
            aTimerStates.push([timer[0], timer[1], timer[2], true]);
        }
        return aTimerStates;
    }

    /**
     * setTimer(iTimer, ms, fReset)
     *
     * Using the timer index from a previous addTimer() call, this sets that timer to fire after the
     * specified number of milliseconds.
     *
     * This is preferred over JavaScript's setTimeout(), because all our timers are effectively paused when
     * the CPU is paused (eg, when the Debugger halts execution).  Moreover, setTimeout() handlers only run after
     * runCPU() yields, which is far too granular for some components (eg, when the SerialPort tries to simulate
     * interrupts at 9600 baud).
     *
     * Ideally, the only function that would use setTimeout() is runCPU(), while the rest of the components
     * use setTimer(); however, due to legacy code (ie, code that predates these functions and/or laziness),
     * that may not be the case.
     *
     * @this {CPU}
     * @param {number} iTimer
     * @param {number} ms (number of milliseconds if positive, cycles otherwise)
     * @param {boolean} [fReset] (true if the timer should be reset even if already armed)
     * @return {number} (number of cycles used to arm timer, or -1 if error)
     */
    setTimer(iTimer, ms, fReset)
    {
        let nCycles = -1;
        if (iTimer >= 0 && iTimer < this.aTimers.length) {
            let timer = this.aTimers[iTimer];
            if (fReset || timer[1] < 0) {
                nCycles = ms > 0? this.getMSCycles(ms) : -ms;
                /*
                 * If the CPU is currently executing a burst of cycles, the number of cycles it has executed in
                 * that burst so far must NOT be charged against the cycle timeout we're about to set.  The simplest
                 * way to resolve that is to immediately call endBurst() and bias the cycle timeout by the number
                 * of cycles that the burst executed.
                 */
                if (this.flags.running) {
                    nCycles += this.endBurst();
                }
                timer[1] = nCycles;
            }
        }
        return nCycles;
    }

    /**
     * updateTimers(nCycles)
     *
     * Used by runCPU() to reduce all active timer countdown values by the number of cycles just executed;
     * this is the function that actually "fires" any timer(s) whose countdown has reached (or dropped below)
     * zero, invoking their callback function.
     *
     * @this {CPU}
     * @param {number} nCycles (number of cycles actually executed)
     */
    updateTimers(nCycles)
    {
        for (let iTimer = this.aTimers.length - 1; iTimer >= 0; iTimer--) {
            let timer = this.aTimers[iTimer];

            if (timer[1] < 0) continue;
            timer[1] -= nCycles;
            if (timer[1] <= 0) {
                if (DEBUG && this.messageEnabled(Messages.CPU | Messages.TIMER)) {      // CPU TIMER message (as opposed to CHIPSET TIMER message)
                    this.printMessage("updateTimer(" + nCycles + "): firing " + timer[0] + " with only " + (timer[1] + nCycles) + " cycles left");
                }
                timer[1] = -1;      // zero is technically an "active" value, so ensure the timer is dormant now
                timer[3]();         // safe to invoke the callback function now
                if (timer[2]) {
                    this.setTimer(iTimer, timer[2]);
                    if (DEBUG && this.messageEnabled(Messages.CPU | Messages.TIMER)) {  // CPU TIMER message (as opposed to CHIPSET TIMER message)
                        this.printMessage("updateTimer(" + nCycles + "): rearming " + timer[0] + " for " + timer[2] + "ms (" + timer[1] + " cycles)");
                    }
                }
            }
        }
    }

    /**
     * getMSCycles(ms)
     *
     * @this {CPU}
     * @param {number} ms
     * @return {number} number of corresponding cycles
     */
    getMSCycles(ms)
    {
        return ((this.counts.nBaseCyclesPerSecond * this.counts.nCurrentMultiplier) / 1000 * ms)|0;
    }

    /**
     * getBurstCycles(nCycles)
     *
     * @this {CPU}
     * @param {number} nCycles (maximum number of cycles to execute)
     * @return {number}
     */
    getBurstCycles(nCycles)
    {
        for (let iTimer = this.aTimers.length - 1; iTimer >= 0; iTimer--) {
            let timer = this.aTimers[iTimer];

            if (timer[1] < 0) continue;
            if (nCycles > timer[1]) {
                nCycles = timer[1];
            }
        }
        return nCycles;
    }

    /**
     * endBurst()
     *
     * @this {CPU}
     * @return {number} (number of cycles executed in the most recent burst)
     */
    endBurst()
    {
        let nCycles = this.nBurstCycles - this.nStepCycles;
        this.nBurstCycles = this.nStepCycles = 0;
        this.counts.nCyclesThisRun += nCycles;
        this.nRunCycles += nCycles;
        return nCycles;
    }

    /**
     * runCPU()
     *
     * @this {CPU}
     */
    runCPU()
    {
        this.idRunTimeout = 0;
        if (!this.flags.running) return;

        /*
         *  calcStartTime() initializes the cycle counter and timestamp for this runCPU() invocation.
         */
        this.calcStartTime();

        try {
            this.flags.yield = false;
            do {
                /*
                 * getBurstCycles() tells us how many cycles to execute as a burst.  The answer will always
                 * be less than getCurrentCyclesPerSecond(), because at the very least, our own timer fires more than
                 * once per second.
                 */
                let nCycles = this.getBurstCycles(this.flags.checksum? 1 : this.getCurrentCyclesPerSecond());

                if (this.chipset) {
                    this.chipset.updateAllTimers();
                    nCycles = this.chipset.getTimerCycleLimit(0, nCycles);
                    nCycles = this.chipset.getRTCCycleLimit(nCycles);
                }
                /*
                 * Execute the burst.
                 */
                try {
                    this.stepCPU(nCycles);
                }
                catch(exception) {
                    if (typeof exception != "number") throw exception;
                    if (MAXDEBUG) this.println("CPU exception " + Str.toHexByte(exception));
                    /*
                     * TODO: If we ever get into a situation where every single instruction is generating a fault
                     * (eg, if an 8088 executes opcode 0xFF 0xFF, which is incorrectly routed to helpFault() instead
                     * of fnGRPUndefined()), the browser may hang because we're failing to yield often enough.
                     * This is likely because the thrown exceptions are taking MUCH longer than normal instructions,
                     * throwing off our burst calculations.  We need to either adjust the burst or break out of the
                     * DO-WHILE loop on every exception.
                     */
                }

                /*
                 * Terminate the burst, returning the number of cycles that stepCPU() actually ran.  If this
                 * returns zero, then presumably someone already called endBurst(), such as stopCPU(), and already
                 * took care of all the timers.
                 */
                nCycles = this.endBurst();
                if (nCycles) {
                    this.updateTimers(nCycles);
                    this.updateChecksum(nCycles);
                }
            } while (this.flags.running && !this.flags.yield);
        }
        catch (e) {
            this.stopCPU();
            this.updateCPU();
            if (this.cmp) this.cmp.stop(Usr.getTime(), this.getCycles());
            this.setError(e.stack || e.message);
            return;
        }

        if (this.flags.running) {

            this.idRunTimeout = setTimeout(this.onRunTimeout, this.calcRemainingTime());
        }
    }

    /**
     * startCPU(fUpdateFocus)
     *
     * For use by any component that wants to start the CPU.
     *
     * @param {boolean} [fUpdateFocus]
     * @param {boolean} [fQuiet]
     * @return {boolean}
     */
    startCPU(fUpdateFocus, fQuiet)
    {
        if (this.isError()) {
            return false;
        }
        if (this.flags.running) {
            if (!fQuiet) this.println(this.toString() + " busy");
            return false;
        }
        if (this.idRunTimeout) {
            clearTimeout(this.idRunTimeout);
            this.idRunTimeout = 0;
        }
        /*
         *  setSpeed() without a speed parameter leaves the selected speed in place, but also resets the
         *  cycle counter and timestamp for the current series of runCPU() calls, and calculates the maximum number
         *  of cycles for each burst based on the last known effective CPU speed.
         */
        this.setSpeed();
        this.flags.running = true;
        this.flags.starting = true;
        if (this.chipset) this.chipset.start();
        let controlRun = this.bindings["run"];
        if (controlRun) controlRun.textContent = "Halt";
        if (this.cmp) {
            this.cmp.updateStatus(true);
            if (fUpdateFocus) this.cmp.updateFocus();
            this.cmp.start(this.counts.msStartRun, this.getCycles());
        }

        this.idRunTimeout = setTimeout(this.onRunTimeout, 0);
        return true;
    }

    /**
     * stepCPU(nMinCycles)
     *
     * This will be implemented by the CPUX86 component.
     *
     * @this {CPU}
     * @param {number} nMinCycles (0 implies a single-step, and therefore breakpoints should be ignored)
     * @return {number} of cycles executed; 0 indicates that the last instruction was not executed
     */
    stepCPU(nMinCycles)
    {
        return 0;
    }

    /**
     * stopCPU(fComplete)
     *
     * For use by any component that wants to stop the CPU.
     *
     * @this {CPU}
     * @param {boolean} [fComplete]
     * @return {boolean} true if the CPU was stopped, false if it was already stopped
     */
    stopCPU(fComplete)
    {
        let fStopped = false;
        if (this.flags.running) {
            let nCycles = this.endBurst();
            if (nCycles) {
                this.updateTimers(nCycles);
                this.updateChecksum(nCycles);
            }
            this.addCycles(this.nRunCycles);
            this.nRunCycles = 0;
            this.flags.running = false;
            if (this.chipset) this.chipset.stop();
            let controlRun = this.bindings["run"];
            if (controlRun) controlRun.textContent = "Run";
            if (this.cmp) {
                this.cmp.stop(Component.getTime(), this.getCycles());
                this.cmp.updateStatus(true);
            }
            if (!this.dbg) this.status("Stopped");
            fStopped = true;
        }
        this.flags.complete = fComplete;
        return fStopped;
    }

    /**
     * nonCPU(fn)
     *
     * Use this function to perform any work outside the scope of the CPU (eg, DOM updates),
     * to prevent that work from disrupting our speed calculations.
     *
     * @this {CPU}
     * @param {function()} fn (should return true only if the function actually performed any work)
     * @return {boolean}
     */
    nonCPU(fn)
    {
        let msStart = Usr.getTime();
        if (fn()) {
            let msStop = Usr.getTime();
            this.counts.msDiscount += msStop - msStart;
            return true;
        }
        return false;
    }

    /**
     * updateCPU(fForce)
     *
     * This used to be performed at the end of every stepCPU(), but runCPU() -- which relies upon
     * stepCPU() -- needed to have more control over when these updates are performed.  However, for
     * other callers of stepCPU(), such as the Debugger, the combination of stepCPU() + updateCPU()
     * provides the old behavior.
     *
     * @this {CPU}
     * @param {boolean} [fForce] (true to force a Computer update; used by the Debugger)
     */
    updateCPU(fForce)
    {
        if (this.cmp) this.cmp.updateStatus(fForce);
    }

    /**
     * yieldCPU()
     *
     * Similar to stopCPU() with regard to how it resets various cycle countdown values, but the CPU
     * remains in a "running" state.
     *
     * @this {CPU}
     */
    yieldCPU()
    {
        this.flags.yield = true;
        /*
         * The Debugger calls yieldCPU() after every message() to ensure browser responsiveness, but it looks
         * odd for those messages to show CPU state changes but for the CPU's own status display to not (ditto
         * for the Video display), so I've added this call to try to keep things looking synchronized.
         */
        this.updateCPU();
    }
}

CPU.YIELDS_PER_SECOND = 60;

CPU.BUTTONS = ["power", "reset"];



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/cpux86.js (C) Jeff Parsons 2012-2018
 */


/**
 * class CPUX86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class CPUX86 extends CPU {
    /**
     * CPUX86(parmsCPU)
     *
     * The CPUX86 class uses the following (parmsCPU) properties:
     *
     *      model: a string (eg, "8088") that should match one of the X86.MODEL values (default is "8088")
     *      stepping: a string (eg, "B1") that should match one of the X86.STEPPING values (default is "")
     *
     * This extends the CPU class and passes any remaining parmsCPU properties to the CPU class
     * constructor, along with a default speed (cycles per second) based on the specified (or default)
     * CPU model number.
     *
     * The CPUX86 class was initially written to simulate a 8086/8088 microprocessor, although over time
     * it has evolved to support later microprocessors (eg, the 80186/80188 and the 80286, including
     * protected-mode support).
     *
     * This is a logical simulation, not a physical simulation, and performance is critical, second only
     * to the accuracy of the simulation when running real-world x86 software.  Consequently, it takes a
     * few liberties with the operation of the simulated hardware, especially with regard to timings,
     * little-used features, etc.  We do make an effort to maintain approximate instruction cycle counts,
     * but there are many other obstacles (eg, prefetch queue, wait states) to achieving accurate timings.
     *
     * For example, our 8237 DMA controller performs all DMA transfers immediately, since internally
     * they are all memory-to-memory, and attempting to interleave DMA cycles with instruction execution
     * cycles would hurt overall performance.  Similarly, 8254 timer counters are updated only on-demand.
     *
     * The 8237 and 8254, along with the 8259 interrupt controller and several other "chips", are combined
     * into a single ChipSet component, to keep the number of components we juggle to a minimum.
     *
     * All that being said, this does not change the overall goal: to produce as accurate a simulation as
     * possible, within the limits of what JavaScript allows and how precisely/predictably it behaves.
     *
     * @this {CPUX86}
     * @param {Object} parmsCPU
     */
    constructor(parmsCPU)
    {
        let nCyclesDefault;
        let model = +parmsCPU['model'] || X86.MODEL_8088;

        switch(model) {
        case X86.MODEL_8088:
        default:
            nCyclesDefault = 4772727;
            break;
        case X86.MODEL_80286:
            nCyclesDefault = 6000000;
            break;
        case X86.MODEL_80386:
            nCyclesDefault = 16000000;
            break;
        }

        super(parmsCPU, nCyclesDefault);

        this.model = model;

        /*
         * We take the 'stepping' value, convert it to a hex value, and then add that to the model to provide
         * a single value that's unique for any given CPU stepping.  If no stepping is provided, then stepping
         * is equal to model.
         */
        let stepping = parmsCPU['stepping'];
        this.stepping = model + (stepping? Str.parseInt(stepping, 16) : 0);

        /*
         * Initialize processor operation to match the requested model
         */
        this.initProcessor();

        /*
         * List of software interrupt notification functions: aIntNotify is an array, indexed by
         * interrupt number, where each element contains:
         *
         *      registered function to call for every software interrupt
         *
         * The registered function is called with the linear address (LIP) following the software interrupt;
         * if any function returns false, the software interrupt will be skipped (presumed to be emulated),
         * and no further notification functions will be called.
         *
         * NOTE: Registered functions are called only for INT N instructions -- *not* INT 0x03 or INTO or the
         * INT 0x00 generated by a divide-by-zero or any other kind of interrupt (nor any interrupt simulated
         * with PUSHF/CALLF).
         *
         * aIntReturn is a hash of return address notifications set up by software interrupt notification
         * functions that want to receive return notifications.  A software interrupt function must call
         * cpu.addIntReturn(fn).
         *
         * WARNING: There's no mechanism in place to insure that software interrupt return notifications don't
         * get "orphaned" if an interrupt handler bypasses the normal return path (INT 0x24 is one example of an
         * "evil" software interrupt).
         */
        this.aIntNotify = [];
        this.aIntReturn = [];

        /*
         * Since aReturnNotify is a "sparse array", this global count gives the CPU a quick way of knowing whether
         * or not RETF or IRET instructions need to bother calling checkIntReturn().
         */
        this.cIntReturn = 0;

        /*
         * A variety of stepCPU() state variables that don't strictly need to be initialized before the first
         * stepCPU() call, but it's good form to do so.
         */
        this.resetCycles();
        this.flags.complete = this.flags.debugCheck = false;

        /*
         * If there are no live registers to display, then updateStatus() can skip a bit....
         */
        this.cLiveRegs = 0;

        /*
         * We're just declaring aMemBlocks and associated Bus parameters here; they'll be initialized by initMemory()
         * when the Bus is initialized.
         */
        this.aBusBlocks = this.aMemBlocks = [];
        this.nBusMask = this.nMemMask = -1;
        this.nBlockShift = this.nBlockSize = this.nBlockLimit = this.nBlockTotal = this.nBlockMask = 0;

        if (PREFETCH) {
            this.cbPrefetch = 0;
            this.adwPrefetch = null;
        }

        /*
         * This initial resetRegs() call is important to create all the registers (eg, the SegX86 registers),
         * so that if/when we call restore(), it will have something to fill in.
         */
        this.resetRegs();
    }

    /**
     * initMemory(aMemBlocks, nBlockShift)
     *
     * Notification from Bus.initMemory(), giving us direct access to the entire memory space
     * (aMemBlocks).  Since the CPU must perform additional layers of address decoding depending
     * on the mode (real-mode, protected-mode, paging), it's best if the CPU can avoid going
     * through the Bus component for every memory access.
     *
     * We also initialize a 32-bit prefetch queue, containing dword-aligned values; the queue is
     * an array of dwords indexed by a masked regLIP; for example, a queue of 4 dwords is indexed
     * by "regLIP & 0xC"; we use a sparse array to avoid right-shifting the index, like so:
     *
     *      0:  [dword]
     *      4:  [dword]
     *      8:  [dword]
     *     12:  [dword]
     *
     * The actual regLIP mask is CPUX86.PFINFO.IP_MASK; ie, (CPUX86.PFINFO.LENGTH - 1) & ~0x3.
     *
     * On refilling, the queue is always filled to capacity, and cbPrefetch is set to its maximum
     * value (eg, a value from 16 to 13, depending on whether "regLIP & 0x3" is 0, 1, 2 or 3).
     *
     * When a byte is requested from the queue, the dword is extracted from index "regLIP & 0xC"
     * and then shifted by 0, 8, 16, or 24, depending on whether "regLIP & 0x3" is 0, 1, 2 or 3
     * (ie, "(regLIP & 0x3) << 3").
     *
     * TODO: Consider how/whether to simulate an effective prefetch queue size of 4 bytes for an 8088,
     * 6 bytes for an 8086, 12 for an 80386, etc.
     *
     * @this {CPUX86}
     * @param {Array} aMemBlocks
     * @param {number} nBlockShift
     */
    initMemory(aMemBlocks, nBlockShift)
    {
        /*
         * aBusBlocks preserves the Bus block array for the life of the machine, whereas aMemBlocks
         * will be altered if/when the CPU enables paging.  PAGEBLOCKS must be true when using Memory
         * blocks to simulate paging, ensuring that physical blocks and pages have the same size (4Kb).
         */
        this.aBusBlocks = this.aMemBlocks = aMemBlocks;
        this.nBlockShift = nBlockShift;
        this.nBlockSize = 1 << this.nBlockShift;
        this.nBlockLimit = this.nBlockSize - 1;
        this.nBlockTotal = aMemBlocks.length;
        this.nBlockMask = this.nBlockTotal - 1;
        if (PREFETCH) {
         // this.nBusCycles = 0;
            this.adwPrefetch = new Array(CPUX86.PFINFO.LENGTH);
        }
    }

    /**
     * setAddressMask(nBusMask)
     *
     * Notification from Bus.initMemory() and Bus.setA20(); the latter calls us whenever the physical
     * A20 line changes (note that on a 20-bit bus machine, address lines A20 and higher are always zero).
     *
     * For 32-bit bus machines (eg, 80386), nBusMask is never changed after the initial call, because A20
     * wrap-around is simulated by changing the physical memory map rather than altering the A20 bit in nBusMask.
     *
     * We maintain nMemMask separate from nBusMask, because when paging is enabled on the 80386, the CPU memory
     * functions are now dealing with linear addresses rather than physical addresses, so it would be incorrect
     * to apply nBusMask to those addresses; nMemMask must remain 0xffffffff (-1) for the duration.  If we change
     * how A20 is simulated on the 80386, then enablePageBlocks() and disablePageBlocks() will need to override
     * nMemMask appropriately.
     *
     * TODO: Ideally, we would eliminate masking altogether of 32-bit addresses, but that would require different
     * sets of memory access functions for different machines (ie, those with 20-bit or 24-bit buses).
     *
     * @this {CPUX86}
     * @param {number} nBusMask
     */
    setAddressMask(nBusMask)
    {
        this.nBusMask = this.nMemMask = nBusMask;
    }

    /**
     * addMemBreak(addr, fWrite, fPhysical)
     *
     * NOTE: addMemBreak() could be merged with addMemCheck(), but the new merged interface would
     * have to provide one additional parameter indicating whether the Debugger or the CPU is the client.
     *
     * For now, this is simply a DEBUGGER-only interface.
     *
     * @this {CPUX86}
     * @param {number} addr
     * @param {boolean} fWrite is true for a memory write breakpoint, false for a memory read breakpoint
     * @param {boolean} [fPhysical] (true for physical breakpoint, false for linear)
     */
    addMemBreak(addr, fWrite, fPhysical)
    {
        if (DEBUGGER) {
            let iBlock = addr >>> this.nBlockShift;
            let aBlocks = (fPhysical? this.aBusBlocks : this.aMemBlocks);
            aBlocks[iBlock].addBreakpoint(addr & this.nBlockLimit, fWrite);
            /*
             * When a physical memory breakpoint is added, a fresh setPhysBlock() call is REQUIRED for any
             * linear mappings to that address.  This is a bit of a sledgehammer solution, but at least it's a solution.
             */
            if (fPhysical) this.flushPageBlocks();
        }
    }

    /**
     * removeMemBreak(addr, fWrite, fPhysical)
     *
     * NOTE: removeMemBreak() could be merged with removeMemCheck(), but the new merged interface would
     * have to provide one additional parameter indicating whether the Debugger or the CPU is the client.
     *
     * For now, this is simply a DEBUGGER-only interface.
     *
     * @this {CPUX86}
     * @param {number} addr
     * @param {boolean} fWrite is true for a memory write breakpoint, false for a memory read breakpoint
     * @param {boolean} [fPhysical] (true for physical breakpoint, false for linear)
     */
    removeMemBreak(addr, fWrite, fPhysical)
    {
        if (DEBUGGER) {
            let iBlock = addr >>> this.nBlockShift;
            let aBlocks = (fPhysical? this.aBusBlocks : this.aMemBlocks);
            aBlocks[iBlock].removeBreakpoint(addr & this.nBlockLimit, fWrite);
            /*
             * When a physical memory breakpoint is removed, a fresh setPhysBlock() call is RECOMMENDED for any
             * linear mappings to that address.  This is a bit of a sledgehammer solution, but at least it's a solution.
             */
            if (fPhysical) this.flushPageBlocks();
        }
    }

    /**
     * addMemCheck(addr, fWrite)
     *
     * These functions provide Debug register functionality to the CPU by leveraging the same Memory block-based
     * breakpoint support originally created for our built-in Debugger.  Only minimal changes were required to the
     * Memory component, by adding additional checkMemoryException() call-outs from the "checked" Memory access
     * functions.
     *
     * Note that those call-outs occur only AFTER our own Debugger (if present) has checked the address and has
     * passed on it, because we want our own Debugger's breakpoints to take precedence over any breakpoints that
     * the emulated machine may have enabled.
     *
     * @this {CPUX86}
     * @param {number} addr
     * @param {boolean} fWrite is true for a memory write check, false for a memory read check
     */
    addMemCheck(addr, fWrite)
    {
        let iBlock = addr >>> this.nBlockShift;
        this.aMemBlocks[iBlock].addBreakpoint(addr & this.nBlockLimit, fWrite, this);
    }

    /**
     * removeMemCheck(addr, fWrite)
     *
     * @this {CPUX86}
     * @param {number} addr
     * @param {boolean} fWrite is true for a memory write check, false for a memory read check
     */
    removeMemCheck(addr, fWrite)
    {
        let iBlock = addr >>> this.nBlockShift;
        this.aMemBlocks[iBlock].removeBreakpoint(addr & this.nBlockLimit, fWrite);
    }

    /**
     * enablePageBlocks()
     *
     * Whenever the CPU turns on paging and/or updates CR3, this function is called to update our copy
     * of the Bus block array, to simulate paging.  Whenever the CPU turns paging off, disablePageBlocks()
     * must be called to restore our copy of the Bus block array to its original (physical) mapping.
     *
     * This also requires PAGEBLOCKS be enabled, to ensure the Bus is configured with a 4Kb block size.
     *
     * The first time this function is called, aMemBlocks and aBusBlocks are identical, so aMemBlocks is
     * reinitialized with special UNPAGED Memory blocks that know how to perform page directory/page table
     * lookup and replace themselves with special PAGED Memory blocks that reference memory from the
     * appropriate block in aBusBlocks.  A parallel array, aBlocksPaged, keeps track (by block number) of
     * which blocks have been PAGED, so that whenever CR3 is updated, those blocks can be quickly UNPAGED.
     *
     * @this {CPUX86}
     */
    enablePageBlocks()
    {
        if (!PAGEBLOCKS) {
            this.setError("PAGEBLOCKS support required");
            return;
        }
        let iBlock;
        if (this.aMemBlocks === this.aBusBlocks) {
            this.aMemBlocks = new Array(this.nBlockTotal);
            /*
             * TODO: Currently we allocate only one UNPAGED block for the entire linear address space;
             * only when a block is touched and becomes PAGED do we allocate a dedicated Memory block
             * for that slot.  One potential downside to using a single UNPAGED block, however, is that
             * it will accumulate all breakpoints for all UNPAGED blocks, requiring copyBreakpoints() to
             * do extra work to figure out which breakpoints should be copied (ie, removed) from the
             * outgoing block -- which it can't currently do, because blocks only keep track of the total
             * number of breakpoints, not the actual breakpoint addresses.
             *
             * So, Memory blocks either need to start maintaining their own breakpoint address lists,
             * or we need to allocate separate (empty) UNPAGED blocks for every slot.  I've not tackled
             * this yet, because it's largely just a debugging issue.
             *
             * Notice that when we call copyBreakpoints() here, it's merely to initialize the new block;
             * we make no attempt to copy any breakpoints from physical blocks to linear blocks, although
             * perhaps we should.  The plan for our Debugger is to maintain separate physical and linear
             * breakpoint address lists, but what about CPU Debug registers?  If the CPU sets the Debug
             * registers, then enables paging, do all the previous Debug register addresses automatically
             * become linear addresses?  I'm guessing they do.
             */
            this.blockUnpaged = new Memory(undefined, 0, 0, Memory.TYPE.UNPAGED, null, this);
            this.blockUnpaged.copyBreakpoints(this.dbg);
            for (iBlock = 0; iBlock < this.nBlockTotal; iBlock++) {
                this.aMemBlocks[iBlock] = this.blockUnpaged;
            }
            /*
             * We also use a special "empty" Memory block that mapPageBlock() can pass back to callers
             * whenever a valid block cannot be found for an UNPAGED block.  Under normal conditions,
             * an invalid block will trigger a fault, so memEmpty will never actually be returned, but
             * if the Debugger is suppressing faults or calling probeAddr(), returning memEmpty is helpful.
             */
            this.memEmpty = new Memory();

            /*
             * Initialize our PAGEBLOCKS cache (see acquirePageBlock() and releasePageBlock()).
             */
            this.aCacheBlocks = new Array(CPUX86.PAGEBLOCKS_CACHE);
            this.iCacheBlocks = 0;
        } else {
            /*
             * Our equivalent of a TLB flush.  NOTE: We do not attempt to simulate an actual TLB; our
             * aMemBlocks array will "cache" as many pages (ie, allow as many PAGED block) as there are
             * entries in the array.  I'm assuming we won't run into any system software that relies on
             * a constrained TLB -- at least not from the 80386 era, which is all we're emulating.
             */
            for (let i = 0; i < this.aBlocksPaged.length; i++) {
                iBlock = this.aBlocksPaged[i];
                this.releasePageBlock(this.aMemBlocks[iBlock]);
                this.aMemBlocks[iBlock] = this.blockUnpaged;
            }
        }
        this.aBlocksPaged = [];
    }

    /**
     * flushPageBlocks()
     *
     * @this {CPUX86}
     */
    flushPageBlocks()
    {
        if (this.regCR0 & X86.CR0.PG) this.enablePageBlocks();
    }

    /**
     * acquirePageBlock(addr)
     *
     * This implements a simple paged memory block cache.  Candidates for caching must be released via
     * releasePageBlock().
     *
     * After acquiring a block from this cache, the caller MUST use setPhysBlock() to properly reinitialize
     * it for the new given linear address.
     *
     * @this {CPUX86}
     * @param {number} addr
     * @return {Memory}
     */
    acquirePageBlock(addr)
    {
        let block;
        if (this.iCacheBlocks > 0) {
            block = this.aCacheBlocks[--this.iCacheBlocks];
            /*
             * Paged memory blocks are all very generic and contain no memory of their own, so the fact
             * that we're not calling the Memory constructor to reinitialize it is OK.  setPhysBlock() is
             * what's critical, and the caller will take care of that.  However, to avoid any confusion,
             * especially when debugging, there are a few properties we should reinitialize, hence init().
             */
            block.init(addr);
        } else {
            block = new Memory(addr, 0, 0, Memory.TYPE.PAGED);
        }
        return block;
    }

    /**
     * releasePageBlock(block)
     *
     * Instead of simply tossing Memory blocks onto the garbage collector's heap, we'll retain a maximum
     * number (CPUX86.PAGEBLOCKS_CACHE) in aCacheBlocks, with iCacheBlocks pointing to the next free element.
     *
     * @this {CPUX86}
     * @param {Memory} block
     */
    releasePageBlock(block)
    {

        if (this.iCacheBlocks < CPUX86.PAGEBLOCKS_CACHE) {
            this.aCacheBlocks[this.iCacheBlocks++] = block;
        }
    }

    /**
     * mapPageBlock(addr, fWrite, fSuppress)
     *
     * Locate the corresponding physical PDE, PTE and memory blocks for the given linear address, and then
     * upgrade the block from an UNPAGED Memory block to a new PAGED Memory block; all future accesses to
     * the current page will go directly to that block, instead of coming here through the UNPAGED block
     * handlers.
     *
     * Note that since the incoming address (addr) is a linear address, we never need to mask it with nBusMask,
     * but all the intermediate (PDE, PTE) and final physical addresses we calculate should still be masked.
     *
     * Granted, nBusMask on a 32-bit bus is generally going to be 0xffffffff (-1), so masking might seem like
     * a waste of time; however, if we decide to once again rely on nBusMask for emulating A20 wrap-around
     * (instead of changing the physical memory map to alias the 2nd Mb to the 1st Mb), then performing
     * consistent masking will be important.
     *
     * Also, addrPDE, addrPTE and addrPhys do not need any offsets added to them, because we immediately shift
     * the offset portion of those addresses out.  But for now, at least for debugging and documentation purposes,
     * my preference is to include the offset in the address calculations.
     *
     * Besides, this should not be a performance-critical function; it's normally called only once per UNPAGED
     * page.  Obviously, if CR3 is constantly being updated, that will trigger repeated calls to enablePageBlocks(),
     * which will perform our equivalent of a TLB flush (ie, resetting all PAGED blocks back to UNPAGED blocks).
     * That would hurt our performance, but it would hurt performance on a real machine as well, so presumably
     * CR3 updates will be minimal.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @param {boolean} fWrite (true if called for a write, false if for a read)
     * @param {boolean} [fSuppress] (true if any faults, remapping, etc should be suppressed)
     * @return {Memory}
     */
    mapPageBlock(addr, fWrite, fSuppress)
    {
        let offPDE = (addr & X86.LADDR.PDE.MASK) >>> X86.LADDR.PDE.SHIFT;
        let addrPDE = this.regCR3 + offPDE;

        /*
         * bus.getLong(addrPDE) would be simpler, but setPhysBlock() needs to know blockPDE and offPDE, too.
         * TODO: Since we're immediately shifting addrPDE by nBlockShift, then we could also skip adding offPDE.
         */
        let blockPDE = this.aBusBlocks[(addrPDE & this.nBusMask) >>> this.nBlockShift];
        let pde = blockPDE.readLong(offPDE);

        if (!(pde & X86.PTE.PRESENT)) {
            if (!fSuppress) X86.helpPageFault.call(this, addr, false, fWrite);
            return this.memEmpty;
        }

        if (!(pde & X86.PTE.USER) && this.nCPL == 3) {
            if (!fSuppress) X86.helpPageFault.call(this, addr, true, fWrite);
            return this.memEmpty;
        }

        let offPTE = (addr & X86.LADDR.PTE.MASK) >>> X86.LADDR.PTE.SHIFT;
        let addrPTE = (pde & X86.PTE.FRAME) + offPTE;

        /*
         * bus.getLong(addrPTE) would be simpler, but setPhysBlock() needs to know blockPTE and offPTE, too.
         * TODO: Since we're immediately shifting addrPDE by nBlockShift, then we could also skip adding offPTE.
         */
        let blockPTE = this.aBusBlocks[(addrPTE & this.nBusMask) >>> this.nBlockShift];
        let pte = blockPTE.readLong(offPTE);

        if (!(pte & X86.PTE.PRESENT)) {
            if (!fSuppress) X86.helpPageFault.call(this, addr, false, fWrite);
            return this.memEmpty;
        }

        if (!(pte & X86.PTE.USER) && this.nCPL == 3) {
            if (!fSuppress) X86.helpPageFault.call(this, addr, true, fWrite);
            return this.memEmpty;
        }

        let addrPhys = (pte & X86.PTE.FRAME) + (addr & X86.LADDR.OFFSET);
        /*
         * TODO: Since we're immediately shifting addrPhys by nBlockShift, we could also skip adding the addr's offset.
         */
        let blockPhys = this.aBusBlocks[(addrPhys & this.nBusMask) >>> this.nBlockShift];
        if (fSuppress) return blockPhys;

        let iBlock = addr >>> this.nBlockShift;
        let block = this.aMemBlocks[iBlock];

        /*
         * So we have the block containing the physical memory corresponding to the given linear address.
         *
         * Now we can create a new PAGED Memory block and record the physical block info using setPhysBlock().
         */
        let blockPage = this.acquirePageBlock(addr & ~X86.LADDR.OFFSET);
        blockPage.setPhysBlock(blockPhys, blockPDE, offPDE, blockPTE, offPTE);
        blockPage.copyBreakpoints(this.dbg, block);

        this.aMemBlocks[iBlock] = blockPage;
        this.aBlocksPaged.push(iBlock);

        return blockPage;
    }

    /**
     * disablePageBlocks()
     *
     * Whenever the CPU turns off paging, this function restores the CPU's original aMemBlocks.
     *
     * @this {CPUX86}
     */
    disablePageBlocks()
    {
        if (this.aMemBlocks !== this.aBusBlocks) {
            this.aMemBlocks = this.aBusBlocks;
            this.blockUnpaged = null;
            this.aBlocksPaged = null;
            this.memEmpty = null;
        }
    }

    /**
     * isPagingEnabled()
     *
     * @this {CPUX86}
     * @return {boolean}
     */
    isPagingEnabled()
    {
        let fPaging = !!(this.regCR0 & X86.CR0.PG);

        return fPaging;
    }

    /**
     * initProcessor()
     *
     * This isolates 80186/80188/80286/80386 support, so that it can be selectively enabled/tested.
     *
     * Here's a summary of 80186/80188 differences according to "AP-186: Introduction to the 80186
     * Microprocessor, March 1983" (pp.55-56).  "The iAPX 86,88 and iAPX 186,188 User's Manual Programmer's
     * Reference", p.3-38, apparently contains the same information, but I've not seen that document.
     *
     * Undefined [Invalid] Opcodes:
     *
     *      When the opcodes 63H, 64H, 65H, 66H, 67H, F1H, FEH/xx111xxxB and FFH/xx111xxxB are executed,
     *      the 80186 will execute an illegal [invalid] instruction exception, interrupt 0x06.
     *      The 8086 will ignore the opcode.
     *
     * 0FH opcode:
     *
     *      When the opcode 0FH is encountered, the 8086 will execute a POP CS, while the 80186 will
     *      execute an illegal [invalid] instruction exception, interrupt 0x06.
     *
     * Word Write at Offset FFFFH:
     *
     *      When a word write is performed at offset FFFFH in a segment, the 8086 will write one byte
     *      at offset FFFFH, and the other at offset 0, while the 80186 will write one byte at offset
     *      FFFFH, and the other at offset 10000H (one byte beyond the end of the segment). One byte segment
     *      underflow will also occur (on the 80186) if a stack PUSH is executed and the Stack Pointer
     *      contains the value 1.
     *
     * Shift/Rotate by Value Greater Then [sic] 31:
     *
     *      Before the 80186 performs a shift or rotate by a value (either in the CL register, or by an
     *      immediate value) it ANDs the value with 1FH, limiting the number of bits rotated to less than 32.
     *      The 8086 does not do this.
     *
     * LOCK prefix:
     *
     *      The 8086 activates its LOCK signal immediately after executing the LOCK prefix. The 80186 does
     *      not activate the LOCK signal until the processor is ready to begin the data cycles associated
     *      with the LOCKed instruction.
     *
     * Interrupted String Move Instructions:
     *
     *      If an 8086 is interrupted during the execution of a repeated string move instruction, the return
     *      value it will push on the stack will point to the last prefix instruction before the string move
     *      instruction. If the instruction had more than one prefix (e.g., a segment override prefix in
     *      addition to the repeat prefix), it will not be re-executed upon returning from the interrupt.
     *      The 80186 will push the value of the first prefix to the repeated instruction, so long as prefixes
     *      are not repeated, allowing the string instruction to properly resume.
     *
     * Conditions causing divide error with an integer divide:
     *
     *      The 8086 will cause a divide error whenever the absolute value of the quotient is greater then
     *      [sic] 7FFFH (for word operations) or if the absolute value of the quotient is greater than 7FH
     *      (for byte operations). The 80186 has expanded the range of negative numbers allowed as a quotient
     *      by 1 to include 8000H and 80H. These numbers represent the most negative numbers representable
     *      using 2's complement arithmetic (equaling -32768 and -128 in decimal, respectively).
     *
     * ESC Opcode:
     *
     *      The 80186 may be programmed to cause an interrupt type 7 whenever an ESCape instruction (used for
     *      co-processors like the 8087) is executed. The 8086 has no such provision. Before the 80186 performs
     *      this trap, it must be programmed to do so. [The details of this "programming" are not included.]
     *
     * Here's a summary of 80286 differences according to "80286 and 80287 Programmer's Reference Manual",
     * Appendix C, p.C-1 (p.329):
     *
     *   1. Add Six Interrupt Vectors
     *
     *      The 80286 adds six interrupts which arise only if the 8086 program has a hidden bug. These interrupts
     *      occur only for instructions which were undefined on the 8086/8088 or if a segment wraparound is attempted.
     *      It is recommended that you add an interrupt handler to the 8086 software that is to be run on the 80286,
     *      which will treat these interrupts as invalid operations.
     *
     *      This additional software does not significantly effect [sic] the existing 8086 software because the interrupts
     *      do not normally occur and should not already have been used since they are in the interrupt group reserved
     *      by Intel. [NOTE: IBM ignored Intel's admonishments.]
     *
     *   2. Do not Rely on 8086/8088 Instruction Clock Counts
     *
     *      The 80286 takes fewer clocks for most instructions than the 8086/8088. The areas to look into are delays
     *      between I/0 operations, and assumed delays in 8086/8088 operating in parallel with an 8087.
     *
     *   3. Divide Exceptions Point at the DIV Instruction
     *
     *      Any interrupt on the 80286 will always leave the saved CS:IP value pointing at the beginning of the
     *      instruction that failed (including prefixes). On the 8086, the CS:IP value saved for a divide exception
     *      points at the next instruction.
     *
     *   4. Use Interrupt 16 (0x10) for Numeric Exceptions
     *
     *      Any 80287 system must use interrupt vector 16 for the numeric error interrupt. If an 8086/8087 or 8088/8087
     *      system uses another vector for the 8087 interrupt, both vectors should point at the numeric error interrupt
     *      handler.
     *
     *   5. Numeric Exception Handlers Should allow Prefixes
     *
     *      The saved CS:IP value in the NPX environment save area will point at any leading prefixes before an ESC
     *      instruction. On 8086/8088 systems, this value points only at the ESC instruction.
     *
     *   6. Do Not Attempt Undefined 8086/8088 Operations
     *
     *      Instructions like POP CS or MOV CS,op will either cause exception 6 (undefined [invalid] opcode) or perform
     *      a protection setup operation like LIDT on the 80286. Undefined bit encodings for bits 5-3 of the second byte
     *      of POP MEM or PUSH MEM will cause exception 13 on the 80286.
     *
     *   7. Place a Far JMP Instruction at FFFF0H
     *
     *      After reset, CS:IP = F000:FFF0 on the 80286 (versus FFFF:0000 on the 8086/8088). This change was made to allow
     *      sufficient code space to enter protected mode without reloading CS. Placing a far JMP instruction at FFFF0H
     *      will avoid this difference. Note that the BOOTSTRAP option of LOC86 will automatically generate this jump
     *      instruction.
     *
     *   8. Do not Rely on the Value Written by PUSH SP
     *
     *      The 80286 will push a different value on the stack for PUSH SP than the 8086/8088. If the value pushed is
     *      important [and when would it NOT be?], replace PUSH SP instructions with the following three instructions:
     *
     *          PUSH    BP
     *          MOV     BP,SP
     *          XCHG    BP,[BP]
     *
     *      This code functions as the 8086/8088 PUSH SP instruction on the 80286.
     *
     *   9. Do not Shift or Rotate by More than 31 Bits
     *
     *      The 80286 masks all shift/rotate counts to the low 5 bits. This MOD 32 operation limits the count to a maximum
     *      of 31 bits. With this change, the longest shift/rotate instruction is 39 clocks. Without this change, the longest
     *      shift/rotate instruction would be 264 clocks, which delays interrupt response until the instruction completes
     *      execution.
     *
     *  10. Do not Duplicate Prefixes
     *
     *      The 80286 sets an instruction length limit of 10 bytes. The only way to violate this limit is by duplicating
     *      a prefix two or more times before an instruction. Exception 6 occurs if the instruction length limit is violated.
     *      The 8086/8088 has no instruction length limit.
     *
     *  11. Do not Rely on Odd 8086/8088 LOCK Characteristics
     *
     *      The LOCK prefix and its corresponding output signal should only be used to prevent other bus masters from
     *      interrupting a data movement operation. The 80286 will always assert LOCK during an XCHG instruction with memory
     *      (even if the LOCK prefix was not used). LOCK should only be used with the XCHG, MOV, MOVS, INS, and OUTS instructions.
     *
     *      The 80286 LOCK signal will not go active during an instruction prefetch.
     *
     *  12. Do not Single Step External Interrupt Handlers
     *
     *      The priority of the 80286 single step interrupt is different from that of the 8086/8088. This change was made
     *      to prevent an external interrupt from being single-stepped if it occurs while single stepping through a program.
     *      The 80286 single step interrupt has higher priority than any external interrupt.
     *
     *      The 80286 will still single step through an interrupt handler invoked by INT instructions or an instruction
     *      exception.
     *
     *  13. Do not Rely on IDIV Exceptions for Quotients of 80H or 8000H
     *
     *      The 80286 can generate the largest negative number as a quotient for IDIV instructions. The 8086 will instead
     *      cause exception O.
     *
     *  14. Do not Rely on NMI Interrupting NMI Handlers
     *
     *      After an NMI is recognized, the NMI input and processor extension limit error interrupt is masked until the
     *      first IRET instruction is executed.
     *
     *  15. The NPX error signal does not pass through an interrupt controller (an 8087 INT signal does). Any interrupt
     *      controller-oriented instructions for the 8087 may have to be deleted.
     *
     *  16. If any real-mode program relies on address space wrap-around (e.g., FFF0:0400=0000:0300), then external hardware
     *      should be used to force the upper 4 addresses to zero during real mode.
     *
     *  17. Do not use I/O ports 00F8-00FFH. These are reserved for controlling 80287 and future processor extensions.
     *
     * @this {CPUX86}
     */
    initProcessor()
    {
        this.PS_SET = X86.PS_SET_8086;
        this.PS_DIRECT = X86.PS_DIRECT_8086;
        this.PS_CLEAR_RM = X86.PS.IOPL.MASK | X86.PS.NT;

        this.OPFLAG_NOINTR_8086 = X86.OPFLAG.NOINTR;
        this.nShiftCountMask = 0xff;            // on an 8086/8088, all shift counts are used as-is

        this.cycleCounts = (this.model >= X86.MODEL_80286? X86.CYCLES_80286 : X86.CYCLES_8088);

        this.aOps     = X86.aOps;
        this.aOpGrp4b = X86.aOpGrp4b;
        this.aOpGrp4w = X86.aOpGrp4w;
        this.aOpGrp6  = X86.aOpGrp6Real;        // setProtMode() will ensure that aOpGrp6 is switched

        if (this.model >= X86.MODEL_80186) {
            /*
             * I don't go out of my way to make 80186/80188 cycle times accurate, since I'm not aware of any
             * IBM PC models that used those processors; beyond the 8086, my next priorities are the 80286 and
             * 80386, but I might revisit the 80186 someday.
             *
             * Instruction handlers that contain "hard-coded" 80286 cycle times include: opINSb, opINSw, opOUTSb,
             * opOUTSw, opENTER, and opLEAVE.
             */
            this.aOps = X86.aOps.slice();       // make copies of opcode tables before modifying
            this.aOpGrp4b = X86.aOpGrp4b.slice();
            this.aOpGrp4w = X86.aOpGrp4w.slice();
            this.nShiftCountMask = 0x1f;        // on newer processors, all shift counts are MOD 32
            this.aOps[0x0F]                 = X86.opInvalid;
            this.aOps[X86.OPCODE.PUSHA]     = X86.opPUSHA;      // 0x60
            this.aOps[X86.OPCODE.POPA]      = X86.opPOPA;       // 0x61
            this.aOps[X86.OPCODE.BOUND]     = X86.opBOUND;      // 0x62
            this.aOps[X86.OPCODE.ARPL]      = X86.opInvalid;    // 0x63
            this.aOps[X86.OPCODE.FS]        = X86.opInvalid;    // 0x64
            this.aOps[X86.OPCODE.GS]        = X86.opInvalid;    // 0x65
            this.aOps[X86.OPCODE.OS]        = X86.opInvalid;    // 0x66
            this.aOps[X86.OPCODE.AS]        = X86.opInvalid;    // 0x67
            this.aOps[X86.OPCODE.PUSHN]     = X86.opPUSHn;      // 0x68
            this.aOps[X86.OPCODE.IMULN]     = X86.opIMULn;      // 0x69
            this.aOps[X86.OPCODE.PUSH8]     = X86.opPUSH8;      // 0x6A
            this.aOps[X86.OPCODE.IMUL8]     = X86.opIMUL8;      // 0x6B
            this.aOps[X86.OPCODE.INSB]      = X86.opINSb;       // 0x6C
            this.aOps[X86.OPCODE.INSW]      = X86.opINSw;       // 0x6D
            this.aOps[X86.OPCODE.OUTSB]     = X86.opOUTSb;      // 0x6E
            this.aOps[X86.OPCODE.OUTSW]     = X86.opOUTSw;      // 0x6F
            this.aOps[0xC0]                 = X86.opGRP2bn;     // 0xC0
            this.aOps[0xC1]                 = X86.opGRP2wn;     // 0xC1
            this.aOps[X86.OPCODE.ENTER]     = X86.opENTER;      // 0xC8
            this.aOps[X86.OPCODE.LEAVE]     = X86.opLEAVE;      // 0xC9
            this.aOps[X86.OPCODE.INT1]      = X86.opUndefined;  // 0xF1
            this.aOpGrp4b[0x07]             = X86.fnGRPInvalid;
            this.aOpGrp4w[0x07]             = X86.fnGRPInvalid;

            if (this.model >= X86.MODEL_80286) {

                let i;
                this.PS_SET = X86.PS.BIT1;      // on the 80286, only BIT1 of Processor Status (flags) is always set
                this.PS_DIRECT |= X86.PS.IOPL.MASK | X86.PS.NT;

                this.OPFLAG_NOINTR_8086 = 0;    // for instructions that do *not* set NOINTR on an 80286 (eg, non-SS segment loads)

                this.aOps[0x0F] = X86.op0F;
                this.aOps0F = X86.aOps0F.slice();
                for (i = 0; i < this.aOps0F.length; i++) {
                    if (!this.aOps0F[i]) this.aOps0F[i] = X86.opUndefined;
                }
                this.aOps[X86.OPCODE.PUSHSP] = X86.opPUSHSP;    // 0x54
                this.aOps[X86.OPCODE.ARPL]   = X86.opARPL;      // 0x63

                if (I386) {
                    if (this.model >= X86.MODEL_80386) {
                        let bOpcode;
                        this.PS_CLEAR_RM = 0;   // NOTE: This allows the 80386 to modify X86.PS.NT in real-mode (which is presumably OK)
                        this.PS_DIRECT |= X86.PS.RF | X86.PS.VM;
                        this.aOps[X86.OPCODE.FS]    = X86.opFS;     // 0x64
                        this.aOps[X86.OPCODE.GS]    = X86.opGS;     // 0x65
                        this.aOps[X86.OPCODE.OS]    = X86.opOS;     // 0x66
                        this.aOps[X86.OPCODE.AS]    = X86.opAS;     // 0x67
                        this.aOps[X86.OPCODE.INT1]  = X86.opINT1;   // 0xF1
                        for (bOpcode in X86.aOps0F386) {
                            this.aOps0F[+bOpcode] = X86.aOps0F386[+bOpcode];
                        }
                        if (this.stepping >= X86.STEPPING_80386_A0 && this.stepping <= X86.STEPPING_80386_B0) {
                            this.aOps0F[0xA6] = X86.opXBTS;
                            this.aOps0F[0xA7] = X86.opIBTS;
                        }
                    } else {
                        /*
                         * Let's make any "undefined" 80286 0x0F opcode handler "invalid" instead IFF the opcode
                         * is defined on the 80386.  Whereas if someone is using an opcode that isn't defined on ANY
                         * of these processors, then I want to know about it; ie, leave it set to opUndefined().
                         */
                        for (i = 0; i < X86.aOps0F386.length; i++) {
                            if (X86.aOps0F386[i] && this.aOps0F[i] == X86.opUndefined) this.aOps0F[i] = X86.opInvalid;
                        }
                    }
                }
            }
        }
    }

    /**
     * reset()
     *
     * @this {CPUX86}
     */
    reset()
    {
        this.resetRegs();
        this.resetCycles();
        this.clearError();      // clear any fatal error/exception that setError() may have flagged
    }

    /**
     * getReg(i)
     *
     * @this {CPUX86}
     * @param {number} i (0-7)
     * @return {number}
     */
    getReg(i)
    {
        let reg;
        switch(i) {
        case 0x0:
            reg = this.regEAX;
            break;
        case 0x1:
            reg = this.regECX;
            break;
        case 0x2:
            reg = this.regEDX;
            break;
        case 0x3:
            reg = this.regEBX;
            break;
        case 0x4:
            reg = this.getSP();
            break;
        case 0x5:
            reg = this.regEBP;
            break;
        case 0x6:
            reg = this.regESI;
            break;
        case 0x7:
            reg = this.regEDI;
            break;
        }
        return reg;
    }

    /**
     * setReg(i, reg)
     *
     * @this {CPUX86}
     * @param {number} i (0-7)
     * @param {number} reg
     */
    setReg(i, reg)
    {
        switch(i) {
        case 0x0:
            this.regEAX = reg;
            break;
        case 0x1:
            this.regECX = reg;
            break;
        case 0x2:
            this.regEDX = reg;
            break;
        case 0x3:
            this.regEBX = reg;
            break;
        case 0x4:
            this.setSP(reg);
            break;
        case 0x5:
            this.regEBP = reg;
            break;
        case 0x6:
            this.regESI = reg;
            break;
        case 0x7:
            this.regEDI = reg;
            break;
        }
    }

    /**
     * resetRegs()
     *
     * According to "The 8086 Book", p.7-5, a RESET signal initializes the following registers:
     *
     *      PS          =   0x0000 (which has the important side-effect of disabling interrupts and traps)
     *      IP          =   0x0000
     *      CS          =   0xFFFF
     *      DS/ES/SS    =   0x0000
     *
     * It is silent as to whether the remaining registers are initialized to any particular values.
     *
     * According to the "80286 and 80287 Programmer's Reference Manual", these 80286 registers are reset:
     *
     *      PS          =   0x0002
     *      MSW         =   0xFFF0
     *      IP          =   0xFFF0
     *      CS Selector =   0xF000      DS/ES/SS Selector =   0x0000
     *      CS Base     = 0xFF0000      DS/ES/SS Base     = 0x000000        IDT Base  = 0x000000
     *      CS Limit    =   0xFFFF      DS/ES/SS Limit    =   0xFFFF        IDT Limit =   0x03FF
     *
     * And from the "INTEL 80386 PROGRAMMER'S REFERENCE MANUAL 1986", section 10.1:
     *
     *      The contents of EAX depend upon the results of the power-up self test. The self-test may be requested
     *      externally by assertion of BUSY# at the end of RESET. The EAX register holds zero if the 80386 passed
     *      the test. A nonzero value in EAX after self-test indicates that the particular 80386 unit is faulty.
     *      If the self-test is not requested, the contents of EAX after RESET is undefined.
     *
     *      DX holds a component identifier and revision number after RESET as Figure 10-1 illustrates. DH contains
     *      3, which indicates an 80386 component. DL contains a unique identifier of the revision level.
     *
     *      EFLAGS      =   0x00000002
     *      IP          =   0x0000FFF0
     *      CS selector =   0xF000 (base of 0xFFFF0000 and limit of 0xFFFF)
     *      DS selector =   0x0000
     *      ES selector =   0x0000
     *      SS selector =   0x0000
     *      FS selector =   0x0000
     *      GS selector =   0x0000
     *      IDTR        =   base of 0 and limit of 0x3FF
     *
     * All other 80386 registers are undefined after a reset (ie, Intel did not document how or if they are set).
     *
     * We've elected to set DX to 0x0308 on a reset, the highest known 80386 revision, since we have no desire to
     * try to emulate all the bugs in older (eg, B1) steppings -- at least not initially.  We leave stepping-accurate
     * emulation for another day.  It's also known that the B1 (and possibly B0) reported 0x0303 in DX, and that
     * the D0 stepping reported 0x0305; beyond that, it's not known exactly what revision numbers Intel used for all
     * 80386 revisions.
     *
     * We define some additional "registers", such as regLIP, which mirrors the linear address corresponding to
     * CS:IP (the address of the next opcode byte).  In fact, regLIP functions as our internal IP register, so any
     * code that needs the real IP must call getIP().  This, in turn, means that whenever CS or IP must be modified,
     * regLIP must be recalculated, so you must use either setCSIP(), which takes both an offset and a segment,
     * or setIP(), whichever is appropriate; in unusual cases where only segCS is changing (eg, undocumented 8086
     * opcodes), use setCS().
     *
     * Similarly, regLSP mirrors the linear address corresponding to SS:SP, and therefore you must rely on getSP()
     * to read the current SP, and setSP() and setSS() to update SP and SS.
     *
     * The other segment registers, such as segDS and segES, have similar getters and setters, but we do not mirror
     * any other segment:offset values in the same way that regLIP mirrors CS:IP, or that regLSP mirrors SS:SP.
     *
     * @this {CPUX86}
     */
    resetRegs()
    {
        this.regEAX = 0;
        this.regEBX = 0;
        this.regECX = 0;
        this.regEDX = 0;
        this.regESP = 0;            // this isn't needed in a 16-bit environment, but is required for I386
        this.regEBP = 0;
        this.regESI = 0;
        this.regEDI = 0;

        /*
         * The following are internal "registers" used to capture intermediate values inside selected helper
         * functions and use them if they've been modified (or are known to change); for example, the MUL and DIV
         * instructions perform calculations that must be propagated to specific registers (eg, AX and/or DX), which
         * the ModRM decoder functions don't know about.  We initialize them here mainly for documentation purposes.
         */
        this.fMDSet = false;        // regMDHi and/or regMDLo are invalid unless fMDSet is true
        this.regMDLo = this.regMDHi = 0;
        this.r64Div = [0, 0];
        this.r64Rem = [0, 0];
        this.regXX = 0;             // for internal use only (eg, assists with ModRM helper functions)

        /*
         * This internal "register" is set in selected opcode handlers to record the original opcode; ordinarily,
         * we dispatch on the opcode but never save it, because it's rarely needed.
         */
        this.bOpcode = 0;

        /*
         * Another internal "register" we occasionally need is an interim copy of bModRM, set inside selected opcode
         * handlers so that the helper function can have access to the instruction's bModRM without resorting to a
         * closure (which, in the Chrome V8 engine, for example, may cause constant recompilation).
         */
        this.bModRM = 0;

        /*
         * NOTE: Even though the 8086 doesn't have CR0 (aka MSW) and IDTR, we initialize them for ALL CPUs, so
         * that functions like X86.helpINT() can use the same code for both.  The 8086/8088 have no direct way
         * of accessing or changing them, so this is an implementation detail those processors are unaware of.
         */
        this.regCR0 = X86.CR0.MSW.ON;
        this.addrIDT = 0;
        this.addrIDTLimit = 0x03FF;
        this.regPS = this.nIOPL = 0;// these should be set before the first setPS() call

        /*
         * Define all the result registers that can be used to "cache" arithmetic and logical flags.
         *
         * In addition, setPS() will initialize resultType, which keeps track of which flags are cached,
         * and resultSize, which maintains the size of the last result; initially, no flags are cached.
         */
        this.resultDst = this.resultSrc = this.resultArith = this.resultLogic = 0;

        /*
         * nFault is set by helpFault() and reset (to -1) by resetRegs() and opIRET().  Its initial purpose was to
         * help helpFault() determine when a nested fault should be converted into either a double-fault (DF_FAULT)
         * or a triple-fault (ie, a processor reset).
         *
         * It has since evolved into another important role: helping segCS.loadIDT() know when an exception
         * is occurring, as opposed to a software interrupt (eg, INT3, INT n or INTO).  The former must set nFault
         * to the corresponding fault #, whereas the latter must set it to -1, so that if the IDT contains a gate
         * whose DPL < CPL, a GP fault will be generated instead.
         *
         * The former always call helpFault(), and the latter call helpTrap(), so nFault is updated automatically.
         * However, there are also intermediate cases, like hardware interrupts, which call helpINT() after manually
         * setting nFault to the IDT #.  TODO: Review all those "intermediate" cases.
         */
        this.nFault = -1;

        /*
         * These are used to snapshot regLIP and regLSP, to help make instructions restartable;
         * currently opLIP is updated prior to every instruction, but opLSP is updated only for instructions
         * that modify the stack pointer (eg, RETF) and should otherwise remain set to X86.ADDR_INVALID.
         *
         * More recently, opCS was added to selectively snapshot an instruction's original CS in case an
         * exception occurs accessing the stack after a new CS has been loaded, allowing the exception handler
         * to recover the old CS and make instructions like CALLF restartable; otherwise, opCS should remain -1.
         *
         * Ditto for opSS and the SS register.
         */
        this.opCS = this.opSS = -1;
        this.opLIP = this.opLSP = X86.ADDR_INVALID;

        /*
         * Segment registers used to be defined as separate selector and base variables (eg, regCS and regCS0),
         * but now they are defined as SegX86 objects.
         */
        this.segCS     = new SegX86(this, SegX86.ID.CODE,  "CS");
        this.segDS     = new SegX86(this, SegX86.ID.DATA,  "DS");
        this.segES     = new SegX86(this, SegX86.ID.DATA,  "ES");
        this.segSS     = new SegX86(this, SegX86.ID.STACK, "SS");
        this.setSP(0);
        this.setSS(0);

        if (I386 && this.model >= X86.MODEL_80386) {
            /*
             * As explained above, EAX depends upon the results of the CPU's power-up self-test; however, the only
             * documented value is zero, which indicates that the 80386 passed.  Additionally, DH is set to the CPU
             * identifier (3) and DL is set to the revision level (stepping).
             */
            switch(this.stepping) {
            case X86.STEPPING_80386_B0:
            case X86.STEPPING_80386_B1:
                this.regEDX = 0x0303;
                break;
            case X86.STEPPING_80386_C0:
                this.regEDX = 0x0304;
                break;
            case X86.STEPPING_80386_D0:
                this.regEDX = 0x0305;
                break;
            case X86.STEPPING_80386_D1:
            case X86.STEPPING_80386_D2:
                this.regEDX = 0x0308;
                break;
            default:
                this.regEDX = 0x0300;       // in the absence of a specific stepping, set revision (DL) to zero
                break;
            }
            this.regCR0 = X86.CR0.ON | X86.CR0.ET;
            this.regCR1 = 0;                // reserved
            this.regCR2 = 0;                // page fault linear address (PFLA)
            this.regCR3 = 0;                // page directory base register (PDBR)
            this.regDR  = [0,0,0,0,null,null,0,0];              // Debug Registers DR0-DR7 (DR4-DR5 are undefined)
            this.regTR  = [null,null,null,null,null,null,0,0];  // Test Registers TR0-TR7 (TR0-TR5 are undefined)
            this.segFS = new SegX86(this, SegX86.ID.DATA,  "FS");
            this.segGS = new SegX86(this, SegX86.ID.DATA,  "GS");
            /*
             * Synchronize the fact that paging is initially disabled with our PAGEBLOCKS functions
             */
            this.disablePageBlocks();
        }

        this.segNULL = new SegX86(this, SegX86.ID.NULL,  "NULL");

        /*
         * The next few initializations mirror what we must do prior to each instruction (ie, inside the stepCPU() function);
         * note that opPrefixes, along with segData and segStack, are reset only after we've executed a non-prefix instruction.
         */
        this.segData = this.segDS;
        this.segStack = this.segSS;
        this.opFlags = this.opPrefixes = 0;
        this.regEA = this.regEAWrite = X86.ADDR_INVALID;

        this.segEA = this.segNULL;

        /*
         * intFlags contains some internal states we use to indicate whether a hardware interrupt (INTFLAG.INTR) or
         * Trap software interrupt (INTR.TRAP) has been requested, as well as when we're in a "HLT" state (INTFLAG.HALT)
         * that requires us to wait for a hardware interrupt (INTFLAG.INTR) before continuing execution.
         *
         * intFlags must be cleared only by checkINTR(), whereas opFlags must be cleared prior to every CPU operation.
         */
        this.intFlags = X86.INTFLAG.NONE;

        if (BACKTRACK) {
            /*
             * Initialize the backtrack indexes for all registers to zero.  And while, yes, it IS possible
             * for raw data to flow through segment registers as well, it's not common enough in real-mode
             * (and too difficult in protected-mode) to merit the overhead.  Ditto for SP, which can't really
             * be considered a general-purpose register.
             *
             * Every time getByte() is called, btiMem0 is filled with the matching backtrack info; similarly,
             * every time getWord() is called, btiMem0 and btiMem1 are filled with the matching backtrack info
             * for the low and high bytes, respectively.
             */
            this.backTrack = {
                btiAL:      0,
                btiAH:      0,
                btiBL:      0,
                btiBH:      0,
                btiCL:      0,
                btiCH:      0,
                btiDL:      0,
                btiDH:      0,
                btiBPLo:    0,
                btiBPHi:    0,
                btiSILo:    0,
                btiSIHi:    0,
                btiDILo:    0,
                btiDIHi:    0,
                btiMem0:    0,
                btiMem1:    0,
                btiMem2:    0,
                btiMem3:    0,
                btiEALo:    0,
                btiEAHi:    0,
                btiIO:      0
            };
        }

        /*
         * Set the initial CS:IP appropriate for the processor; this should be done before the first setPS() call,
         * in part so that CPL will be set properly.
         */
        if (this.model < X86.MODEL_80286) {
            this.setCSIP(0, 0xffff);
        } else {
            /*
             * Assorted 80286-specific registers.  The GDTR and IDTR registers are stored as the following pieces:
             *
             *      GDTR:   addrGDT (24 bits) and addrGDTLimit (24 bits)
             *      IDTR:   addrIDT (24 bits) and addrIDTLimit (24 bits)
             *
             * while the LDTR and TR are stored as special segment registers: segLDT and segTSS.
             *
             * So, yes, our GDTR and IDTR "registers" differ from other segment registers in that we do NOT record
             * the 16-bit limit specified by the LGDT or LIDT instructions; instead, we immediately calculate the limiting
             * address, and record that instead.
             *
             * In addition to different CS:IP reset values, the CS base address must be set to the top of the 16Mb
             * address space rather than the top of the first 1Mb (which is why the MODEL_5170 ROM must be addressable
             * at both 0x0F0000 and 0xFF0000; see the ROM component's "alias" parameter).
             *
             * TODO: Verify what the 80286 actually sets addrGDT and addrGDTLimit to on reset (or if it leaves them alone).
             */
            this.addrGDT = 0; this.addrGDTLimit = 0xffff;                   // GDTR
            this.segLDT = new SegX86(this, SegX86.ID.LDT, "LDT", true);     // LDTR
            this.segTSS = new SegX86(this, SegX86.ID.TSS, "TSS", true);     // TR
            this.segVER = new SegX86(this, SegX86.ID.VER, "VER", true);     // a scratch segment register for VERR and VERW instructions
            this.setCSIP(0xfff0, 0xf000);                   // on an 80286 or 80386, the default CS:IP is 0xF000:0xFFF0 instead of 0xFFFF:0x0000
            this.setCSBase(0xffff0000|0);                   // on an 80286 or 80386, all CS base address bits above bit 15 must be set
        }

        /*
         * This resets the Processor Status flags (regPS), along with all the internal "result registers";
         * we've taken care to ensure that both CPL and IOPL are initialized before this first setPS() call.
         */
        this.setPS(0);

        /*
         * Now that all the segment registers have been created, it's safe to set the current addressing mode.
         */
        this.setProtMode();
    }

    /**
     * updateAddrSize()
     *
     * Select the appropriate ModRM dispatch tables, based on the current ADDRESS size (addrSize), which
     * is based foremost on segCS.sizeAddr, but can also be overridden by an ADDRESS size instruction prefix.
     *
     * There used to be six primary ModRM dispatch table pointers:
     *
     *      aOpModRegByte
     *      aOpModMemByte
     *      aOpModGrpByte
     *      aOpModRegWord
     *      aOpModMemWord
     *      aOpModGrpWord
     *
     * However, when support for the 80386 was added, the number of dispatch tables doubled, and since each entry
     * in the table was a discrete function, decoding was fast, but it also required a LOT of code.
     *
     * So we have now replaced the above table pointers with function pointers:
     *
     *      decodeModRegByte (set to one of: modRegByte16, modRegByte32)
     *      decodeModMemByte (set to one of: modMemByte16, modMemByte32)
     *      decodeModGrpByte (set to one of: modGrpByte16, modGrpByte32)
     *      decodeModRegWord (set to one of: modRegShort16, modRegLong16, modRegShort32, modRegLong32)
     *      decodeModMemWord (set to one of: modMemShort16, modMemLong16, modMemShort32, modMemLong32)
     *      decodeModGrpWord (set to one of: modGrpShort16, modGrpLong16, modGrpShort32, modGrpLong32)
     *
     * So opcode handlers that used to do this:
     *
     *      this.aOpModMemByte[b].call(this, X86.fnADDb);
     *
     * now do this:
     *
     *      this.decodeModMemByte.call(this, X86.fnADDb);
     *
     * Decoding of ModRM bytes is now slightly slower, but the previous code is still in the repository
     * (look for x86modb.js and x86modw.js for the pre-80386 dispatch tables, and x86modb16.js, x86modb32.js,
     * x86modw16.js, x86modw32.js, and x86modsib.js for the post-80386 dispatch tables).
     *
     * @this {CPUX86}
     */
    updateAddrSize()
    {
        if (!I386) {
            this.getAddr = (PREFETCH? this.getShortPrefetch : this.getShort);
            this.decodeModRegByte = X86.modRegByte16;
            this.decodeModMemByte = X86.modMemByte16;
            this.decodeModGrpByte = X86.modGrpByte16;
            this.decodeModRegWord = X86.modRegShort16;
            this.decodeModMemWord = X86.modMemShort16;
            this.decodeModGrpWord = X86.modGrpShort16;
        } else {
            if (this.sizeAddr == 2) {
                this.getAddr = (PREFETCH? this.getShortPrefetch : this.getShort);
                this.decodeModRegByte = X86.modRegByte16;
                this.decodeModMemByte = X86.modMemByte16;
                this.decodeModGrpByte = X86.modGrpByte16;
                if (this.sizeData == 2) {
                    this.decodeModRegWord = X86.modRegShort16;
                    this.decodeModMemWord = X86.modMemShort16;
                    this.decodeModGrpWord = X86.modGrpShort16;
                } else {
                    this.decodeModRegWord = X86.modRegLong16;
                    this.decodeModMemWord = X86.modMemLong16;
                    this.decodeModGrpWord = X86.modGrpLong16;
                }
            } else {
                this.getAddr = (PREFETCH? this.getLongPrefetch : this.getLong);
                this.decodeModRegByte = X86.modRegByte32;
                this.decodeModMemByte = X86.modMemByte32;
                this.decodeModGrpByte = X86.modGrpByte32;
                if (this.sizeData == 2) {
                    this.decodeModRegWord = X86.modRegShort32;
                    this.decodeModMemWord = X86.modMemShort32;
                    this.decodeModGrpWord = X86.modGrpShort32;
                } else {
                    this.decodeModRegWord = X86.modRegLong32;
                    this.decodeModMemWord = X86.modMemLong32;
                    this.decodeModGrpWord = X86.modGrpLong32;
                }
            }
        }
    }

    /**
     * setDataSize(size)
     *
     * This is used by opcodes that require a particular OPERAND size, which we enforce by internally
     * simulating an OPERAND size override, if needed.
     *
     * @this {CPUX86}
     * @param {number} size (2 for 2-byte/16-bit operands, or 4 for 4-byte/32-bit operands)
     */
    setDataSize(size)
    {
        if (this.sizeData != size) {
            this.opPrefixes |= X86.OPFLAG.DATASIZE;
            this.sizeData = size;
            this.maskData = (size == 2? 0xffff : (0xffffffff|0));
            this.updateDataSize();
        }
    }

    /**
     * updateDataSize()
     *
     * @this {CPUX86}
     */
    updateDataSize()
    {
        if (this.sizeData == 2) {
            this.typeData = X86.RESULT.WORD;
            this.getWord = this.getShort;
            this.setWord = this.setShort;
            if (this.sizeAddr == 2) {
                this.decodeModRegWord = X86.modRegShort16;
                this.decodeModMemWord = X86.modMemShort16;
                this.decodeModGrpWord = X86.modGrpShort16;
            } else {
                this.decodeModRegWord = X86.modRegShort32;
                this.decodeModMemWord = X86.modMemShort32;
                this.decodeModGrpWord = X86.modGrpShort32;
            }
        } else {
            this.typeData = X86.RESULT.DWORD;
            this.getWord = this.getLong;
            this.setWord = this.setLong;
            if (this.sizeAddr == 2) {
                this.decodeModRegWord = X86.modRegLong16;
                this.decodeModMemWord = X86.modMemLong16;
                this.decodeModGrpWord = X86.modGrpLong16;
            } else {
                this.decodeModRegWord = X86.modRegLong32;
                this.decodeModMemWord = X86.modMemLong32;
                this.decodeModGrpWord = X86.modGrpLong32;
            }
        }
    }

    /**
     * resetSizes()
     *
     * @this {CPUX86}
     */
    resetSizes()
    {
        /*
         * The following contain the (default) ADDRESS size (2 for 16 bits, 4 for 32 bits), and the corresponding
         * masks for isolating the (src) bits of an address and clearing the (dst) bits of an address.  Like the
         * OPERAND size properties, these are reset to their segCS counterparts at the start of every new instruction.
         */
        this.sizeAddr = this.segCS.sizeAddr;
        this.maskAddr = this.segCS.maskAddr;

        /*
         * It's also worth noting that instructions that implicitly use the stack also rely on STACK size,
         * which is based on the BIG bit of the last descriptor loaded into SS; use the following segSS properties:
         *
         *      segSS.sizeAddr      (2 or 4)
         *      segSS.maskAddr      (0xffff or 0xffffffff)
         *
         * As there is no STACK size instruction prefix override, there's no need to propagate these segSS properties
         * to separate CPUX86 properties, as we do for the OPERAND size and ADDRESS size properties.
         */

        this.updateAddrSize();

        /*
         * The following contain the (default) OPERAND size (2 for 16 bits, 4 for 32 bits), and the corresponding masks
         * for isolating the (src) bits of an OPERAND and clearing the (dst) bits of an OPERAND.  These are reset to
         * their segCS counterparts at the start of every new instruction, but are also set here for documentation purposes.
         */
        this.sizeData = this.segCS.sizeData;
        this.maskData = this.segCS.maskData;

        this.updateDataSize();

        this.opPrefixes &= ~(X86.OPFLAG.ADDRSIZE | X86.OPFLAG.DATASIZE);
    }

    /**
     * getChecksum()
     *
     * @this {CPUX86}
     * @return {number} a 32-bit summation of key elements of the current CPU state (used by the CPU checksum code)
     */
    getChecksum()
    {
        let sum = (this.regEAX + this.regEBX + this.regECX + this.regEDX + this.getSP() + this.regEBP + this.regESI + this.regEDI)|0;
        sum = (sum + this.getIP() + this.getCS() + this.getDS() + this.getSS() + this.getES() + this.getPS())|0;
        return sum;
    }

    /**
     * addIntNotify(nInt, fn)
     *
     * Add a software interrupt notification handler to the CPU's list of such handlers.
     *
     * TODO: Consider adding removeIntNotify().  Example use case: if the Debugger's intWindowsDebugger() function
     * detects that an INT 0x41 client is loaded, it would be quite happy to uninstall itself.
     *
     * @this {CPUX86}
     * @param {number} nInt
     * @param {function(number)} fn is called with the LIP value following the software interrupt
     */
    addIntNotify(nInt, fn)
    {
        if (this.aIntNotify[nInt] === undefined) {
            this.aIntNotify[nInt] = [];
        }
        this.aIntNotify[nInt].push(fn);
    }

    /**
     * checkIntNotify(nInt)
     *
     * NOTE: This is called ONLY for "INT N" instructions -- not "INTO" or breakpoint or single-step interrupts
     * or divide exception interrupts, or hardware interrupts, or any simulation of an interrupt (eg, "PUSHF/CALLF").
     *
     * @this {CPUX86}
     * @param {number} nInt
     * @return {boolean} true if software interrupt may proceed, false if software interrupt should be skipped
     */
    checkIntNotify(nInt)
    {
        let aNotify = this.aIntNotify[nInt];
        if (aNotify !== undefined) {
            for (let i = 0; i < aNotify.length; i++) {
                if (!aNotify[i](this.regLIP)) {
                    return false;
                }
            }
        }
        /*
         * The enabling of INT messages is one of the criteria that's also included in the Debugger's checksEnabled()
         * function, and therefore included in fDebugCheck, so for maximum speed, we check fDebugCheck first.
         *
         * NOTE: We've added MAXDEBUG to the test below, because onIntReturn() generates a lot of noise, via
         * dbg.messageIntReturn(), and because there's no way to be sure we'll catch the return (or for some interrupts,
         * *whether* they will return), so it's safer to disable this feature unless you really want it.
         *
         * For most purposes, just having dbg.messageInt(), and the Debugger's ability to selectively turn categories
         * of messages on and off, is good enough.
         */
        if (DEBUGGER && this.flags.debugCheck) {
            if (this.messageEnabled(Messages.INT) && this.dbg.messageInt(nInt, this.regLIP) && MAXDEBUG) {
                this.addIntReturn(this.regLIP, function(cpu, nCycles) {
                    return function onIntReturn(nLevel) {
                        cpu.dbg.messageIntReturn(nInt, nLevel, cpu.getCycles() - nCycles);
                    };
                }(this, this.getCycles()));
            }
        }
        return true;
    }

    /**
     * addIntReturn(addr, fn)
     *
     * Add a return notification handler to the CPU's list of such handlers.
     *
     * When fn(n) is called, it's passed a "software interrupt level", which will normally be 0,
     * unless it's a return from a nested software interrupt (eg, return from INT 0x10 Video BIOS
     * call issued inside another INT 0x10 Video BIOS call).
     *
     * Note that the nesting could be due to a completely different software interrupt that
     * another interrupt notification function is intercepting, so use it as an advisory value only.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @param {function(number)} fn is an interrupt-return notification function
     */
    addIntReturn(addr, fn)
    {
        if (fn !== undefined) {
            if (this.aIntReturn[addr] == null) {
                this.cIntReturn++;
            }
            this.aIntReturn[addr] = fn;
        }
    }

    /**
     * checkIntReturn(addr)
     *
     * We check for possible "INT n" software interrupt returns in the cases of "IRET" (helpIRET), "RETF 2"
     * (helpRETF) and "JMPF [DWORD]" (fnJMPFdw).
     *
     * "JMPF [DWORD]" is an unfortunate choice that newer versions of DOS (as of at least 3.20, and probably
     * earlier) employed in their INT 0x13 hooks; I would have preferred not making this call for that opcode.
     *
     * It is expected (though not required) that callers will check cIntReturn and avoid calling this function
     * if the count is zero, for maximum performance.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     */
    checkIntReturn(addr)
    {
        let fn = this.aIntReturn[addr];
        if (fn != null) {
            fn(--this.cIntReturn);
            delete this.aIntReturn[addr];
        }
    }

    /**
     * checkDebugRegisters(fEnable)
     *
     * opMOVdr() simplifies its life by doing work ONLY if the contents of a Debug register is actually changing.
     *
     * Whenever a single register is about to change, it calls this function with fEnable set to false to REMOVE any
     * active checks, then updates the Debug register, then calls us again with fEnable set to true to (re)ADD active
     * checks.
     *
     * @this {CPUX86}
     * @param {boolean} fEnable
     */
    checkDebugRegisters(fEnable)
    {
        /*
         * We use a constant mask for the enable bits (X86.DR7.L0 | X86.DR7.G0) and shift our copy of regDR7
         * right 2 bits after each Debug register check.
         *
         * Similarly, we make a copy of regDR7 in bitsDR7 and shift the latter right 4 bits at a time, so that
         * the RW and LEN bits for the next Debug register are always in positions 1-0 and 3-2, respectively.
         */
        let regDR7 = this.regDR[7];
        let bitsDR7 = regDR7 >> 16;

        for (let i = 0; i < 4; i++) {
            if (regDR7 & (X86.DR7.L0 | X86.DR7.G0)) {
                /*
                 * We look only to the low bit of the RW field to determine if we should be watching for a write.
                 * FYI, if the low bit is clear but the high bit is set, that's "undefined"; we treat it as a read.
                 */
                let fWrite = !!(bitsDR7 & 0x1);
                /*
                 * The address in regDR[i] should already be masked with ~0x1 for 2-byte accesses (LEN == 0x1) or
                 * with ~0x3 for 4-byte accesses (LEN == 0x3), but if the client forgets, the hardware supposedly
                 * enforces it, so that's what we do here, too.
                 *
                 * FYI, if LEN is set to the "undefined" value of (0x2), we still apply a mask to the address, albeit
                 * a nonsensical mask of ~0x2 or 0xfffffffd.  That's how we define that particular "undefined" LEN.
                 */
                let addr = this.regDR[i];
                let len = ((bitsDR7 >> 2) & 0x3);
                addr &= ~len;       // NOTE: if LEN == 0x0, we don't need to mask, but ~0x0 is equivalent to no mask
                if (fEnable) {
                    this.addMemCheck(addr, fWrite);
                } else {
                    this.removeMemCheck(addr, fWrite);
                }
            }
            regDR7 >>= 2; bitsDR7 >>= 4;
        }
    }

    /**
     * checkMemoryException(addr, nb, fWrite)
     *
     * This "check" function is called by a Memory block to inform us that a memory read or write is occurring,
     * giving us the opportunity look for a matching "read" or "write" breakpoint enabled in one of the DRn registers.
     *
     * TODO: This currently does not discriminate between data reads and execution reads.  When we switch to a true
     * "prefetch" model, that would also be a good time to include a signal to this function indicating which "read"
     * accesses are are actually "exec" accesses.
     *
     * @this {CPUX86}
     * @param {number} addr
     * @param {number} nb (# of bytes)
     * @param {boolean|null} [fWrite] (false if read, true if write, null if exec)
     */
    checkMemoryException(addr, nb, fWrite)
    {
        /*
         * NOTE: We're preventing redundant X86.EXCEPTION.DB_EXC exceptions for a single instruction by checking
         * X86.OPFLAG.DBEXC.  I decided not to rely on the generic X86.OPFLAG.FAULT, because if an instruction
         * first triggers a DIFFERENT exception which then triggers a DEBUG exception (eg, because a Debug register
         * was set on the IDT entry of the first exception), then presumably we'd like to see that DEBUG exception,
         * as opposed to, say, a double fault.  TODO: Determine whether that SHOULD generate a double-fault.
         */
        if (!(this.opFlags & X86.OPFLAG.DBEXC) && (this.regDR[7] & X86.DR7.ENABLE)) {
            nb--;
            /*
             * We use a constant mask for the enable bits (X86.DR7.L0 | X86.DR7.G0) and shift our copy of regDR7
             * right 2 bits after each Debug register check.
             *
             * Similarly, we make a copy of regDR7 in bitsDR7 and shift the latter right 4 bits at a time, so that
             * the RW and LEN bits for the next Debug register are always in positions 1-0 and 3-2, respectively.
             */
            let regDR7 = this.regDR[7];
            let bitsDR7 = regDR7 >> 16;

            let bitsRWMask = X86.DR7.RW0 >> 16;
            let bitsRWRequired = (fWrite? 0x1 : (fWrite == false? 0x3 : 0x0));

            for (let i = 0; i < 4; i++) {
                if ((regDR7 & (X86.DR7.L0 | X86.DR7.G0)) && (bitsDR7 & bitsRWMask) == bitsRWRequired) {
                    /*
                     * NOTE: We reduced nb from 1-4 to 0-3 above, so we don't need to add 1 to len either.
                     */
                    let len = (bitsDR7 >> 2);
                    /*
                     * Time to determine if addr through addr + nb overlaps regDR[i] through regDR[i] + len.
                     */
                    if (addr + nb >= this.regDR[i] && addr <= this.regDR[i] + len) {
                        this.regDR[6] |= (1 << i);
                        /*
                         * Data access breakpoints are not faults; they must generate a trap at the end of the
                         * instruction, so we use the X86.INTFLAG.TRAP flag to generate the X86.EXCEPTION.DB_EXC trap.
                         *
                         *      X86.helpFault.call(this, X86.EXCEPTION.DB_EXC);
                         */
                        this.intFlags |= X86.INTFLAG.TRAP;
                        return;
                    }
                }
                regDR7 >>= 2; bitsDR7 >>= 4;
            }
        }
    }

    /**
     * isProtMode()
     *
     * @this {CPUX86}
     * @return {boolean} true if protected-mode, false if not
     */
    isProtMode()
    {
        return !!(this.regCR0 & X86.CR0.MSW.PE);
    }

    /**
     * isV86Mode()
     *
     * @this {CPUX86}
     * @return {boolean} true if V86-mode, false if not
     */
    isV86Mode()
    {
        return !!(this.regPS & X86.PS.VM);
    }

    /**
     * setProtMode(fProt, fV86)
     *
     * Update any opcode handlers that operate significantly differently in real-mode vs. protected-mode, and
     * notify all the segment registers about the mode change as well -- but only those that are "bi-modal"; internal
     * segment registers like segLDT and segTSS do not need to be notified, because they cannot be accessed in real-mode
     * (ie, LLDT, LTR, SLDT, STR are invalid instructions in real-mode, and are among the opcode handlers that we
     * update here).
     *
     * NOTE: Ideally, this function would do its work ONLY on mode *transitions*, but we assume calls to setProtMode()
     * are sufficiently infrequent that it doesn't really matter.
     *
     * @this {CPUX86}
     * @param {boolean} [fProt] (use the current MSW PE bit if not specified)
     * @param {boolean} [fV86] true if the X86.PS.VM (V86-mode) flag is set (or is about to be)
     */
    setProtMode(fProt, fV86)
    {
        if (fProt === undefined) {
            fProt = this.isProtMode();
        }
        if (fV86 === undefined) {
            fV86 = this.isV86Mode();
        }
        if (DEBUG && (fProt != this.isProtMode() || fV86 != this.isV86Mode()) && this.messageEnabled()) {
            this.printMessage("CPU switching to " + (fProt? (fV86? "v86" : "protected") : "real") + "-mode", this.bitsMessage, true);
        }
        this.aOpGrp6 = (fProt && !fV86? X86.aOpGrp6Prot : X86.aOpGrp6Real);
        this.segCS.updateMode(false, fProt, fV86);
        this.segDS.updateMode(false, fProt, fV86);
        this.segSS.updateMode(false, fProt, fV86);
        this.segES.updateMode(false, fProt, fV86);
        if (I386 && this.model >= X86.MODEL_80386) {
            this.segFS.updateMode(false, fProt, fV86);
            this.segGS.updateMode(false, fProt, fV86);
        }
        /*
         * This function used to be called only when I386 is true, but it's probably best if we ALWAYS call it, even
         * for 16-bit-only CPUs like the 8086 and 80286; this allows us to write opcode logic by either checking I386
         * and using appropriate hard-coded sizes, or NOT checking I386 and simply using the "soft-coded" sizes in
         * sizeData and sizeAddr.
         */
        this.resetSizes();
    }

    /**
     * saveProtMode()
     *
     * Save CPU state related to protected-mode, for save()
     *
     * @this {CPUX86}
     * @return {Array}
     */
    saveProtMode()
    {
        if (this.addrGDT != null) {
            let a = [
                this.regCR0,
                this.addrGDT,
                this.addrGDTLimit,
                this.addrIDT,
                this.addrIDTLimit,
                this.segLDT.save(),
                this.segTSS.save(),
                this.nIOPL
            ];
            if (I386 && this.model >= X86.MODEL_80386) {
                a.push(this.regCR1);
                a.push(this.regCR2);
                a.push(this.regCR3);
                a.push(this.regDR);
                a.push(this.regTR);
            }
            return a;
        }
        return null;
    }

    /**
     * restoreProtMode()
     *
     * Restore CPU state related to protected-mode, for restore()
     *
     * @this {CPUX86}
     * @param {Array} a
     */
    restoreProtMode(a)
    {
        if (a && a.length) {
            this.regCR0 = a[0];
            this.addrGDT = a[1];
            this.addrGDTLimit = a[2];
            this.addrIDT = a[3];
            this.addrIDTLimit = a[4];
            this.segLDT.restore(a[5]);
            this.segTSS.restore(a[6]);
            this.nIOPL = a[7];
            if (I386 && this.model >= X86.MODEL_80386) {
                this.regCR1 = a[8];
                this.regCR2 = a[9];
                this.regCR3 = a[10];
                this.regDR  = a[11];
                this.regTR  = a[12];
            }
            this.setProtMode();
        }
    }

    /**
     * save(fRunning)
     *
     * This implements save support for the X86 component.
     *
     * NOTE: When the Computer starts issuing powerDown() calls, it always calls the CPU first, and the CPU's
     * powerDown() handler has the added responsibility of:
     *
     *      1) recording whether or not the CPU is currently running
     *      2) stopping the CPU if the powerDown is part of a shutDown
     *      3) passing the original running state to us
     *
     * UPDATES: The current speed multiplier from getSpeed() is now saved in group #3, so that your speed is preserved.
     *
     * @this {CPUX86}
     * @param {boolean} [fRunning]
     * @return {Object|null}
     */
    save(fRunning)
    {
        let state = new State(this);
        state.set(0, [this.regEAX, this.regEBX, this.regECX, this.regEDX, this.getSP(), this.regEBP, this.regESI, this.regEDI]);
        let a = [this.getIP(), this.segCS.save(), this.segDS.save(), this.segSS.save(), this.segES.save(), this.saveProtMode(), this.getPS()];
        if (I386 && this.model >= X86.MODEL_80386) {
            a.push(this.segFS.save());
            a.push(this.segGS.save());
        }
        state.set(1, a);
        state.set(2, [this.segData.sName, this.segStack.sName, this.opFlags, this.opPrefixes, this.intFlags, this.regEA, this.regEAWrite]);
        state.set(3, [0, this.nTotalCycles, this.getSpeed(), fRunning, this.saveTimers()]);
        state.set(4, this.bus.saveMemory());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the X86 component.
     *
     * @this {CPUX86}
     * @param {Object} data
     * @return {boolean} true if restore successful, false if not
     */
    restore(data)
    {
        let a = data[0];
        this.regEAX = a[0];
        this.regEBX = a[1];
        this.regECX = a[2];
        this.regEDX = a[3];
        let regESP = a[4];
        this.regEBP = a[5];
        this.regESI = a[6];
        this.regEDI = a[7];

        a = data[1];
        this.segCS.restore(a[1]);
        this.segDS.restore(a[2]);
        this.segSS.restore(a[3]);
        this.segES.restore(a[4]);
        this.restoreProtMode(a[5]);
        this.setPS(a[6]);

        /*
         * The introduction of protected-mode requires us to restore memory contents sooner than we used to
         * (ie, before we load any segment registers).
         */
        let fRestored = false;

        if (this.bus.restoreMemory(data[4])) {
            /*
             * It's important to call setCSIP(), both to ensure that the CPU's linear IP register (regLIP) is updated
             * properly AND to ensure the CPU's default ADDRESS and OPERAND sizes are set properly.
             */
            this.setCSIP(a[0], this.segCS.sel);

            /*
             * It's also important to call setSP(), so that the linear SP register (regLSP) will be updated properly;
             * we also need to call setSS(), to ensure that the lower and upper stack limits are properly initialized.
             */
            this.setSP(regESP);
            this.setSS(this.segSS.sel);

            if (I386 && this.model >= X86.MODEL_80386) {
                this.segFS.restore(a[7]);
                this.segGS.restore(a[8]);
            }
            fRestored = true;
        }

        a = data[2];
        this.segData  = a[0] != null && this.getSeg(a[0]) || this.segDS;
        this.segStack = a[1] != null && this.getSeg(a[1]) || this.segSS;
        this.opFlags = a[2];
        this.opPrefixes = a[3];
        this.intFlags = a[4];
        this.regEA = a[5];          // save/restore of last EA calculation(s) isn't strictly necessary,
        this.regEAWrite = a[6];     // but they may be of some interest to, say, the Debugger

        a = data[3];
        this.nTotalCycles = a[1];   // a[0] was previously nBurstDivisor (no longer used)
        this.setSpeed(a[2]);        // old states didn't contain a value from getSpeed(), but setSpeed() checks
        if (a[3] != null) {         // less old states didn't preserve the original running state, so we must check it
            this.flags.autoStart = a[3];
        }
        if (a[4] != null) {
            this.restoreTimers(a[4]);
        }
        return fRestored;
    }

    /**
     * getSeg(sName)
     *
     * @param {string} sName
     * @return {SegX86|Array}
     */
    getSeg(sName)
    {
        switch(sName) {
        case "CS":
            return this.segCS;
        case "DS":
            return this.segDS;
        case "SS":
            return this.segSS;
        case "ES":
            return this.segES;
        case "NULL":
            return this.segNULL;
        default:
            /*
             * HACK: We return a fake segment register object in which only the base linear address is valid,
             * because that's all the caller provided (ie, we must be restoring from an older state).
             */

            return [0, sName, 0, 0, ""];
        }
    }

    /**
     * getCS()
     *
     * @this {CPUX86}
     * @return {number}
     */
    getCS()
    {
        return this.segCS.sel;
    }

    /**
     * setCS(sel)
     *
     * NOTE: This is used ONLY by those few undocumented 8086/8088/80186/80188 instructions that "MOV" or "POP" a value
     * into CS, which we assume have the same behavior as any other instruction that moves or pops a segment register
     * (ie, suppresses h/w interrupts for one instruction).  Instructions that "JMP" or "CALL" or "INT" or "IRET" a new
     * value into CS are always accompanied by a new IP value, so they use setCSIP() instead, which does NOT suppress
     * h/w interrupts.
     *
     * @this {CPUX86}
     * @param {number} sel
     * @return {boolean}
     */
    setCS(sel)
    {
        if (this.setCSIP(this.getIP(), sel) != null) {
            if (!BUGS_8086) this.opFlags |= this.OPFLAG_NOINTR_8086;
            return true;
        }
        return false;
    }

    /**
     * getDS()
     *
     * @this {CPUX86}
     * @return {number}
     */
    getDS()
    {
        return this.segDS.sel;
    }

    /**
     * setDS(sel)
     *
     * @this {CPUX86}
     * @param {number} sel
     */
    setDS(sel)
    {
        if (this.segDS.load(sel) !== X86.ADDR_INVALID) {
            if (!BUGS_8086) this.opFlags |= this.OPFLAG_NOINTR_8086;
            return true;
        }
        return false;
    }

    /**
     * getSS()
     *
     * @this {CPUX86}
     * @return {number}
     */
    getSS()
    {
        return this.segSS.sel;
    }

    /**
     * setSS(sel)
     *
     * @this {CPUX86}
     * @param {number} sel
     * @param {boolean} [fInterruptable]
     * @return {boolean}
     */
    setSS(sel, fInterruptable)
    {
        let regESP = this.getSP();
        let regLSP = this.segSS.load(sel);
        if (regLSP !== X86.ADDR_INVALID) {
            /*
             * The safest way to update regLSP after a potential change to segSS.base is to call setSP() with the
             * original stack pointer retrieved above via getSP().  When I tried to be clever and do this instead:
             *
             *      this.regLSP = (regLSP + regESP)|0;
             *
             * 16-bit stacks began inadvertently using ESP instead of SP.  The moral: don't be needlessly clever.
             */
            this.setSP(regESP);

            /*
             * The desire to use a linear stack pointer (regLSP) for internal stack operations has some pitfalls;
             * one involves these upper and lower limit calculations.  Example: Xenix 386 creates a (non-expand-down)
             * 32-bit data segment for all of DS, ES, and SS, which uses a limit of "-1"; ie:
             *
             *      SS=0018[ED800000,FFFFFFFF] DS=0018[ED800000,FFFFFFFF] ES=0018[ED800000,FFFFFFFF]
             *
             * so we end up calculating an upper limit of 0xED7FFFFF, which is lower than the lower limit of 0xED800000.
             *
             * For now, these "limit wrap-around" situations are resolved by using unsigned values and then applying
             * a linear address ceiling.  TODO: Come up with a simple solution for properly dealing with limit wrap-around.
             */
            if (this.segSS.fExpDown) {
                this.regLSPLimit = (this.segSS.base >>> 0) + (this.segSS.maskAddr >>> 0);
                this.regLSPLimitLow = (this.segSS.base >>> 0) + (this.segSS.limit >>> 0);
            } else {
                this.regLSPLimit = (this.segSS.base >>> 0) + (this.segSS.limit >>> 0);
                this.regLSPLimitLow = (this.segSS.base >>> 0);
            }

            this.regLSPLimit = Math.min(this.regLSPLimit, this.nMemMask >>> 0);
            this.regLSPLimitLow = Math.min(this.regLSPLimitLow, this.nMemMask >>> 0);

            if (!BUGS_8086 && !fInterruptable) this.opFlags |= X86.OPFLAG.NOINTR;
            return true;
        }
        return false;
    }

    /**
     * getES()
     *
     * @this {CPUX86}
     * @return {number}
     */
    getES()
    {
        return this.segES.sel;
    }

    /**
     * setES(sel)
     *
     * @this {CPUX86}
     * @param {number} sel
     * @return {boolean}
     */
    setES(sel)
    {
        if (this.segES.load(sel) !== X86.ADDR_INVALID) {
            if (!BUGS_8086) this.opFlags |= this.OPFLAG_NOINTR_8086;
            return true;
        }
        return false;
    }

    /**
     * getFS()
     *
     * NOTE: segFS is defined for I386 only.
     *
     * @this {CPUX86}
     * @return {number}
     */
    getFS()
    {
        return this.segFS.sel;
    }

    /**
     * setFS(sel)
     *
     * NOTE: segFS is defined for I386 only.
     *
     * @this {CPUX86}
     * @param {number} sel
     * @return {boolean}
     */
    setFS(sel)
    {
        return this.segFS.load(sel) !== X86.ADDR_INVALID;
    }

    /**
     * getGS()
     *
     * NOTE: segGS is defined for I386 only.
     *
     * @this {CPUX86}
     * @return {number}
     */
    getGS()
    {
        return this.segGS.sel;
    }

    /**
     * setGS(sel)
     *
     * NOTE: segGS is defined for I386 only.
     *
     * @this {CPUX86}
     * @param {number} sel
     * @return {boolean}
     */
    setGS(sel)
    {
        return this.segGS.load(sel) !== X86.ADDR_INVALID;
    }

    /**
     * getIP()
     *
     * @this {CPUX86}
     * @return {number}
     */
    getIP()
    {
        return (this.regLIP - this.segCS.base)|0;
    }

    /**
     * setIP(off)
     *
     * @this {CPUX86}
     * @param {number} off
     */
    setIP(off)
    {
        this.regLIP = (this.segCS.base + (off & (I386? this.maskData : 0xffff)))|0;
        if (PREFETCH) this.refillPrefetch();
    }

    /**
     * setLIP(addr)
     *
     * @this {CPUX86}
     * @param {number} addr
     */
    setLIP(addr)
    {
        this.regLIP = addr;
        this.regLIPMax = (this.segCS.base >>> 0) + (this.segCS.limit >>> 0) + 1;

        /*
         * TODO: Verify the proper source for CPL.  Should it come from segCS.cpl or segCS.dpl?
         * Also, note that LOADALL386 wants it to come from segSS.dpl.
         */
        this.nCPL = this.segCS.cpl;             // cache the current CPL where it's more convenient

        if (I386 && this.model >= X86.MODEL_80386) this.resetSizes();

        /*
         * Here, we need to additionally test whether the prefetch buffer (adwPrefetch) has been allocated yet,
         * because when resetRegs() is first called, the Bus hasn't been initialized yet, so there's nothing to fetch.
         *
         * We'll allocate the prefetch buffer when the Bus calls initMemory().
         */
        if (PREFETCH && this.adwPrefetch) this.refillPrefetch();
    }

    /**
     * setCSIP(off, sel, fCall)
     *
     * This function is a little different from the other segment setters, only because it turns out that CS is
     * never set without an accompanying IP (well, except for a few undocumented instructions, like POP CS, which
     * were available ONLY on the 8086/8088/80186/80188; see setCS() for details).
     *
     * And even though this function is called setCSIP(), please note the order of the parameters is [IP,CS],
     * which matches the order that CS:IP values are normally stored in memory, allowing us to make calls like this:
     *
     *      this.setCSIP(this.popWord(), this.popWord());
     *
     * @this {CPUX86}
     * @param {number} off
     * @param {number} sel
     * @param {boolean} [fCall] is true if CALLF in progress, false if RETF/IRET in progress, undefined otherwise
     * @return {boolean|null} true if a stack switch occurred; the only operation that needs to pay attention is opRETFn()
     */
    setCSIP(off, sel, fCall)
    {
        /*
         * Setting IP needs to occur AFTER loadCode(), because it may differ from the given IP if sel refers to a gate.
         */
        let base = this.segCS.loadCode(off, sel, fCall);
        if (base !== X86.ADDR_INVALID) {
            this.setLIP(base + (this.segCS.offIP & (I386? this.segCS.maskData : 0xffff)));
            return this.segCS.fStackSwitch;
        }
        return null;
    }

    /**
     * setCSBase(addr)
     *
     * Since the CPU must maintain regLIP as the sum of the CS base and the current IP, all calls to setBase()
     * for segCS need to go through here.
     *
     * @param {number} addr
     */
    setCSBase(addr)
    {
        let regIP = this.getIP();
        addr = this.segCS.setBase(addr);
        this.regLIP = (addr + regIP)|0;
        this.regLIPMax = (addr >>> 0) + (this.segCS.limit >>> 0) + 1;
    }

    /**
     * checkIP(inc)
     *
     * TODO: If we didn't care about compatibility, we could just return:
     *
     *      (this.regLIP + inc)|0
     *
     * and be done with it, because there probably isn't any "good" code that triggers the
     * "newLIP > this.regLIPMax" condition.  This check costs us about 2Mhz performance on an 80386.
     *
     * Turning PREFETCH on tends to offset this performance hit, but PREFETCH *without* this hit would
     * probably perform even better.
     *
     * @this {CPUX86}
     * @param {number} inc (positive)
     * @return {number} new LIP
     */
    checkIP(inc)
    {
        let newLIP = (this.regLIP >>> 0) + inc;
        if (newLIP > this.regLIPMax) {
            /*
             * There's no such thing as a GP fault on the 8086/8088, and I'm now assuming that,
             * on newer processors, all attempts to fetch opcodes beyond the limit trigger a fault.
             */
            if (this.model <= X86.MODEL_8088 /* || this.segCS.limit == this.segCS.maskAddr */) {
                newLIP = this.segCS.base + ((newLIP - this.regLIPMax) & (I386? this.maskData : 0xffff));
                if (inc == 2) this.opFlags |= X86.OPFLAG.WRAP;
            } else {
                X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
            }
        }
        return newLIP|0;
    }

    /**
     * resetIP()
     *
     * @this {CPUX86}
     */
    resetIP()
    {
        if (PREFETCH) {
            this.cbPrefetch += this.regLIP - this.opLIP;
            this.regLIP = this.opLIP;
            /*
             * If the reset produces a prefetch total greater than the allocated amount, then we must have
             * refilled the queue somewhere in the middle of the rewound instruction, so we need to refill the
             * queue all over again; otherwise, the next repetition may fetch future data instead of past data.
             *
             * That's the bad news; the good news is that this extra refill should only hurt performance of the
             * first repetition.
             */
            if (this.cbPrefetch > CPUX86.PFINFO.LENGTH) this.refillPrefetch();
        } else {
            this.regLIP = this.opLIP;
        }
    }

    /**
     * rewindIP(fCheckSeg)
     *
     * This "rewinds" IP to the beginning of the current instruction (ie, the REP prefix of a string instruction);
     * this also sets the REPSEG flag to record string instructions with multiple prefixes (ie, a segment override),
     * so that checkINTR() has the option to simulate the 8086/8088's failure to properly restart such an instruction
     * after a hardware interrupt (which became known as a "feature", hence not part of BUGS_8086).
     *
     * @this {CPUX86}
     * @param {boolean} [fCheckSeg]
     */
    rewindIP(fCheckSeg = false)
    {
        if (fCheckSeg && (this.opPrefixes & X86.OPFLAG.SEG)) {
            this.opFlags |= X86.OPFLAG.REPSEG;
        }
        this.opFlags |= X86.OPFLAG.REPEAT;
        this.resetIP();
    }

    /**
     * getSP()
     *
     * @this {CPUX86}
     * @return {number}
     */
    getSP()
    {
        if (I386) {
            // assert(!((this.regLSP - this.segSS.base) & ~this.segSS.maskAddr));
            return (this.regESP & ~this.segSS.maskAddr) | (this.regLSP - this.segSS.base);
        }
        return (this.regLSP - this.segSS.base)|0;
    }

    /**
     * setSP(off)
     *
     * @this {CPUX86}
     * @param {number} off
     */
    setSP(off)
    {
        if (I386) {
            this.regESP = off;
            this.regLSP = (this.segSS.base + (off & this.segSS.maskAddr))|0;
        } else {
            this.regLSP = (this.segSS.base + off)|0;
        }
    }

    /**
     * setArithResult(dst, src, value, type, fSubtract)
     *
     * Updates the flags for arithmetic instructions; use setLogicResult() for logical instructions.
     *
     * The type parameter indicates both the size of the result (BYTE, WORD or DWORD) and which of the
     * flags should now be considered "cached" by the new result variables.  If the previous resultType
     * specifies any flags not contained in the new type parameter, then those flags must be immediately
     * calculated and written to the appropriate bit(s) in regPS.
     *
     * The default assumes an "addition" (eg, ADD, ADC, INC), where value = dst + src. The fSubtract
     * parameter is used to indicate a "subtraction" (eg, CMP, DEC, SUB, SBB), where value = dst - src;
     * We can transform a subtraction into an addition, since it's also true that dst = value + src,
     * by swapping swap dst and value -- which is exactly what we do below.  This allows all downstream
     * flag calculations (eg, getCF(), getOF()) to remain the same.
     *
     * @this {CPUX86}
     * @param {number} dst
     * @param {number} src
     * @param {number} value
     * @param {number} type
     * @param {boolean} [fSubtract]
     */
    setArithResult(dst, src, value, type, fSubtract)
    {
        if ((type & X86.RESULT.ALL) != X86.RESULT.ALL && type != this.resultType) {
            let diff = ((type ^ this.resultType) & this.resultType);
            if (diff) {
                if (diff & X86.RESULT.CF) this.getCF();
                if (diff & X86.RESULT.PF) this.getPF();
                if (diff & X86.RESULT.AF) this.getAF();
                if (diff & X86.RESULT.ZF) this.getZF();
                if (diff & X86.RESULT.SF) this.getSF();
                if (diff & X86.RESULT.OF) this.getOF();
            }
        }
        if (!fSubtract) {
            this.resultDst = dst;
            this.resultArith = value;
        } else {
            this.resultDst = value;
            this.resultArith = dst;
        }
        this.resultSrc = src;
        this.resultLogic = value;
        this.resultType = type;
    }

    /**
     * setLogicResult(value, type, carry, overflow)
     *
     * Updates the flags for logical instructions (eg, AND, OR, TEST, XOR); ie, instructions
     * that update PF, ZF, and SF, while clearing CF and OF (although CF and OF can be explicitly
     * set via the carry and overflow parameters as needed).  AF is always considered undefined.
     *
     * TODO: We should observe the behavior of AF on real CPUs, and determine if there is a
     * well-defined behavior, even though none is documented.  Ditto for OF on shift instructions
     * when the shift count > 1.
     *
     * @this {CPUX86}
     * @param {number} value
     * @param {number} type
     * @param {number} [carry]
     * @param {number} [overflow]
     * @return {number} value
     */
    setLogicResult(value, type, carry, overflow)
    {
        this.resultType = type | X86.RESULT.LOGIC;
        this.resultLogic = value;
        if (carry) this.setCF(); else this.clearCF();
        if (overflow) this.setOF(); else this.clearOF();
        return value;
    }

    /**
     * setRotateResult(result, carry, size)
     *
     * Used by all rotate instructions (ie, RCL, RCR, ROL, ROR) to update CF and OF.
     *
     * TODO: We should observe the behavior of OF on real CPUs whenever the rotate count > 1,
     * and determine if there is a well-defined behavior, even though none is documented.
     *
     * @this {CPUX86}
     * @param {number} result
     * @param {number} carry
     * @param {number} size
     */
    setRotateResult(result, carry, size)
    {
        if (carry & size) this.setCF(); else this.clearCF();
        if ((result ^ carry) & size) this.setOF(); else this.clearOF();
    }

    /**
     * getCarry()
     *
     * @this {CPUX86}
     * @return {number} 0 or 1, depending on whether CF is clear or set
     */
    getCarry()
    {
        return this.getCF()? 1 : 0;
    }

    /**
     * getCF()
     *
     * The following table summarizes bit 31 of the dst (D) and src (S) operands, bit 31 of the
     * addition (A), along with the expected carry bit (C):
     *
     *      D   S   A   C
     *      -   -   -   -
     *      0   0   0   0       no
     *      0   0   1   0       no (there must have been a carry out of bit 30, but it was "absorbed")
     *      0   1   0   1       yes (there must have been a carry out of bit 30, but it was NOT "absorbed")
     *      0   1   1   0       no
     *      1   0   0   1       yes (same as the preceding "yes" case)
     *      1   0   1   0       no
     *      1   1   0   1       yes (since the addition of two ones must always produce a carry)
     *      1   1   1   1       yes (since the addition of two ones must always produce a carry)
     *
     * So, we use the following calculation:
     *
     *      (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))) & resultType
     *
     * NOTE: The above table assumes that the resultDst (D) and resultSrc (S) operands were ADDED to
     * produce resultArith (A); if they were SUBTRACTED instead (D - S), then D and A must be swapped
     * after the subtraction, so that the above truth table still applies; see setArithResult().
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.CF
     */
    getCF()
    {
        if (this.resultType & X86.RESULT.CF) {
            this.regPS &= ~X86.PS.CF;
            if ((this.resultDst ^ ((this.resultDst ^ this.resultSrc) & (this.resultSrc ^ this.resultArith))) & (this.resultType & X86.RESULT.TYPE)) {
                this.regPS |= X86.PS.CF;
            }
            this.resultType &= ~X86.RESULT.CF;
        }
        return this.regPS & X86.PS.CF;
    }

    /**
     * getPF()
     *
     * From http://graphics.stanford.edu/~seander/bithacks.html#ParityParallel:
     *
     *      unsigned int v;  // word value to compute the parity of
     *      v ^= v >> 16;
     *      v ^= v >> 8;
     *      v ^= v >> 4;
     *      v &= 0xf;
     *      return (0x6996 >> v) & 1;
     *
     *      The method above takes around 9 operations, and works for 32-bit words.  It may be optimized to work just on
     *      bytes in 5 operations by removing the two lines immediately following "unsigned int v;".  The method first shifts
     *      and XORs the eight nibbles of the 32-bit value together, leaving the result in the lowest nibble of v.  Next,
     *      the binary number 0110 1001 1001 0110 (0x6996 in hex) is shifted to the right by the value represented in the
     *      lowest nibble of v.  This number is like a miniature 16-bit parity-table indexed by the low four bits in v.
     *      The result has the parity of v in bit 1, which is masked and returned.
     *
     * The x86 parity flag (PF) is based exclusively on the low 8 bits of resultParitySign, so our calculation is bit
     * simpler.  Note that PF must be SET if that byte has EVEN parity, and CLEAR if it has ODD parity.
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.PF
     */
    getPF()
    {
        if (this.resultType & X86.RESULT.PF) {
            this.regPS &= ~X86.PS.PF;
            if ((0x9669 >> ((this.resultLogic ^ (this.resultLogic >> 4)) & 0xf)) & 1) {
                this.regPS |= X86.PS.PF;
            }
            this.resultType &= ~X86.RESULT.PF;
        }
        return this.regPS & X86.PS.PF;
    }

    /**
     * getAF()
     *
     * To determine if there's been a carry out of the low 4 bits of an arithmetic operation,
     * we look at all the possible inputs for bit 4, and calculate AF = A^(D^S).
     *
     *      D   S   A   D^S AF
     *      -   -   -   --- --
     *      0   0   0   0   0
     *      0   0   1   0   1
     *      0   1   0   1   1
     *      0   1   1   1   0
     *      1   0   0   1   1
     *      1   0   1   1   0
     *      1   1   0   0   0
     *      1   1   1   0   1
     *
     * The final calculation looks like:
     *
     *      (resultArith ^ (resultDst ^ resultSrc)) & 0x0010
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.AF
     */
    getAF()
    {
        if (this.resultType & X86.RESULT.AF) {
            this.regPS &= ~X86.PS.AF;
            if ((this.resultArith ^ (this.resultDst ^ this.resultSrc)) & 0x0010) {
                this.regPS |= X86.PS.AF;
            }
            this.resultType &= ~X86.RESULT.AF;
        }
        return this.regPS & X86.PS.AF;
    }

    /**
     * getZF()
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.ZF
     */
    getZF()
    {
        if (this.resultType & X86.RESULT.ZF) {
            this.regPS &= ~X86.PS.ZF;
            if (!(this.resultLogic & (((this.resultType & X86.RESULT.TYPE) - 1) | (this.resultType & X86.RESULT.TYPE)))) {
                this.regPS |= X86.PS.ZF;
            }
            this.resultType &= ~X86.RESULT.ZF;
        }
        return this.regPS & X86.PS.ZF;
    }

    /**
     * getSF()
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.SF
     */
    getSF()
    {
        if (this.resultType & X86.RESULT.SF) {
            this.regPS &= ~X86.PS.SF;
            if (this.resultLogic & (this.resultType & X86.RESULT.TYPE)) {
                this.regPS |= X86.PS.SF;
            }
            this.resultType &= ~X86.RESULT.SF;
        }
        return this.regPS & X86.PS.SF;
    }

    /**
     * getOF()
     *
     * Overflow was originally calculated as:
     *
     *      (resultParitySign ^ resultAuxOverflow ^ (resultParitySign >> 1)) & (resultSize >> 1)
     *
     * but as you can see, that calculation depends on the carry out of the 8/16/32-bit result in
     * resultParitySign, which we don't have access to for 32-bit results.  So we fall-back to the
     * following:
     *
     *      ((resultDst ^ resultArith) & (resultSrc ^ resultArith)) & resultType
     *
     * which you can verify from the following table of sign bits, where x1 is resultDst ^ resultArith,
     * and x2 is resultSrc ^ resultArith:
     *
     *      D   S   A   x1  x2  OF
     *      -   -   -   --  --  --
     *      0   0   0   0   0   0
     *      0   0   1   1   1   1 (adding two positive values yielded a negative value)
     *      0   1   0   0   1   0
     *      0   1   1   1   0   0
     *      1   0   0   1   0   0
     *      1   0   1   0   1   0
     *      1   1   0   1   1   1 (adding two negative values yielded a positive value)
     *      1   1   1   0   0   0
     *
     * NOTE: The above table assumes that the resultDst (D) and resultSrc (S) operands were ADDED to
     * produce resultArith (A); if they were SUBTRACTED instead (D - S), then D and A must be swapped
     * after the subtraction, so that the above truth table still applies; see setArithResult().
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.OF
     */
    getOF()
    {
        if (this.resultType & X86.RESULT.OF) {
            this.regPS &= ~X86.PS.OF;
            if (((this.resultDst ^ this.resultArith) & (this.resultSrc ^ this.resultArith)) & (this.resultType & X86.RESULT.TYPE)) {
                this.regPS |= X86.PS.OF;
            }
            this.resultType &= ~X86.RESULT.OF;
        }
        return this.regPS & X86.PS.OF;
    }

    /**
     * getTF()
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.TF
     */
    getTF()
    {
        return (this.regPS & X86.PS.TF);
    }

    /**
     * getIF()
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.IF
     */
    getIF()
    {
        return (this.regPS & X86.PS.IF);
    }

    /**
     * getDF()
     *
     * @this {CPUX86}
     * @return {number} 0 or X86.PS.DF
     */
    getDF()
    {
        return (this.regPS & X86.PS.DF);
    }

    /**
     * clearCF()
     *
     * @this {CPUX86}
     */
    clearCF()
    {
        this.resultType &= ~X86.RESULT.CF;
        this.regPS &= ~X86.PS.CF;
    }

    /**
     * clearPF()
     *
     * @this {CPUX86}
     */
    clearPF()
    {
        this.resultType &= ~X86.RESULT.PF;
        this.regPS &= ~X86.PS.PF;
    }

    /**
     * clearAF()
     *
     * @this {CPUX86}
     */
    clearAF()
    {
        this.resultType &= ~X86.RESULT.AF;
        this.regPS &= ~X86.PS.AF;
    }

    /**
     * clearZF()
     *
     * @this {CPUX86}
     */
    clearZF()
    {
        this.resultType &= ~X86.RESULT.ZF;
        this.regPS &= ~X86.PS.ZF;
    }

    /**
     * clearSF()
     *
     * @this {CPUX86}
     */
    clearSF()
    {
        this.resultType &= ~X86.RESULT.SF;
        this.regPS &= ~X86.PS.SF;
    }

    /**
     * clearIF()
     *
     * @this {CPUX86}
     */
    clearIF()
    {
        this.regPS &= ~X86.PS.IF;
    }

    /**
     * clearDF()
     *
     * @this {CPUX86}
     */
    clearDF()
    {
        this.regPS &= ~X86.PS.DF;
    }

    /**
     * clearOF()
     *
     * @this {CPUX86}
     */
    clearOF()
    {
        this.resultType &= ~X86.RESULT.OF;
        this.regPS &= ~X86.PS.OF;
    }

    /**
     * setCF()
     *
     * @this {CPUX86}
     */
    setCF()
    {
        this.resultType &= ~X86.RESULT.CF;
        this.regPS |= X86.PS.CF;
    }

    /**
     * setPF()
     *
     * @this {CPUX86}
     */
    setPF()
    {
        this.resultType &= ~X86.RESULT.PF;
        this.regPS |= X86.PS.PF;
    }

    /**
     * setAF()
     *
     * @this {CPUX86}
     */
    setAF()
    {
        this.resultType &= ~X86.RESULT.AF;
        this.regPS |= X86.PS.AF;
    }

    /**
     * setZF()
     *
     * @this {CPUX86}
     */
    setZF()
    {
        this.resultType &= ~X86.RESULT.ZF;
        this.regPS |= X86.PS.ZF;
    }

    /**
     * setSF()
     *
     * @this {CPUX86}
     */
    setSF()
    {
        this.resultType &= ~X86.RESULT.SF;
        this.regPS |= X86.PS.SF;
    }

    /**
     * setIF()
     *
     * @this {CPUX86}
     */
    setIF()
    {
        this.regPS |= X86.PS.IF;
    }

    /**
     * setDF()
     *
     * @this {CPUX86}
     */
    setDF()
    {
        this.regPS |= X86.PS.DF;
    }

    /**
     * setOF()
     *
     * @this {CPUX86}
     */
    setOF()
    {
        this.resultType &= ~X86.RESULT.OF;
        this.regPS |= X86.PS.OF;
    }

    /**
     * getPS()
     *
     * @this {CPUX86}
     * @return {number}
     */
    getPS()
    {
        return (this.regPS & ~X86.PS_CACHED) | (this.getCF() | this.getPF() | this.getAF() | this.getZF() | this.getSF() | this.getOF());
    }

    /**
     * setMSW(w)
     *
     * Factored out of x86op0f.js, since both opLMSW and opLOADALL are capable of setting a new MSW.
     * The caller is responsible for assessing the appropriate cycle cost.
     *
     * @this {CPUX86}
     * @param {number} w
     */
    setMSW(w)
    {
        /*
         * This instruction is always allowed to set MSW.PE, but it cannot clear MSW.PE once set;
         * therefore, we always OR the previous value of MSW.PE into the new value before loading.
         */
        w |= (this.regCR0 & X86.CR0.MSW.PE) | X86.CR0.MSW.ON;
        this.regCR0 = (this.regCR0 & ~X86.CR0.MSW.MASK) | (w & X86.CR0.MSW.MASK);
        /*
         * Since the 80286 cannot return to real-mode via this instruction, the only transition we
         * must worry about is to protected-mode.  And there's no harm calling setProtMode() if the
         * CPU is already in protected-mode; we could certainly optimize out the call in that case,
         * but the instruction isn't used frequently enough to warrant it.
         */
        if (this.regCR0 & X86.CR0.MSW.PE) this.setProtMode(true);
    }

    /**
     * setPS(regPS)
     *
     * @this {CPUX86}
     * @param {number} regPS
     * @param {number} [cpl]
     */
    setPS(regPS, cpl)
    {
        /*
         * OS/2 1.0 discriminates between an 80286 and an 80386 based on whether an IRET in real-mode that
         * pops 0xF000 into the flags is able to set *any* of flag bits 12-15: if it can, then OS/2 declares
         * the CPU an 80386.
         *
         * So, if the CPU is an 80286, we clear incoming bits 12-14 in real-mode (bit 15 is never allowed to
         * be modified, so there's no need to mask it).  And if the CPU is an 80386, no bits are automatically
         * cleared in real-mode (PS_CLEAR_RM is zero); although that allows the IOPL bits to change, it doesn't
         * affect real-mode operation, since CPL is always zero, making IOPL irrelevant.
         */
        if (!(this.regCR0 & X86.CR0.MSW.PE)) regPS &= ~this.PS_CLEAR_RM;

        /*
         * There are some cases (eg, an IRET returning to a less privileged code segment) where the CPL
         * we compare against should come from the outgoing code segment, so if the caller provided it, use it.
         */
        if (cpl === undefined) cpl = this.nCPL;

        /*
         * Since PS.IOPL and PS.IF are part of PS_DIRECT, we need to take care of any 80286-specific behaviors
         * before setting the PS_DIRECT bits from the incoming regPS bits.
         *
         * Specifically, PS.IOPL is unchanged if CPL > 0, and PS.IF is unchanged if CPL > IOPL.
         */
        if (!cpl) {
            this.nIOPL = (regPS & X86.PS.IOPL.MASK) >> X86.PS.IOPL.SHIFT;           // IOPL allowed to change
        } else {
            regPS = (regPS & ~X86.PS.IOPL.MASK) | (this.regPS & X86.PS.IOPL.MASK);  // IOPL not allowed to change
        }

        if (cpl > this.nIOPL) {
            regPS = (regPS & ~X86.PS.IF) | (this.regPS & X86.PS.IF);                // IF not allowed to change
        }

        this.resultType = X86.RESULT.BYTE;
        this.regPS = (this.regPS & ~(this.PS_DIRECT|X86.PS_CACHED)) | (regPS & (this.PS_DIRECT|X86.PS_CACHED)) | this.PS_SET;

        if (this.regPS & X86.PS.TF) {
            this.intFlags |= X86.INTFLAG.TRAP;
            this.opFlags |= X86.OPFLAG.NOINTR;
        }
    }

    /**
     * checkIOPM(port, nPorts, fInput)
     *
     * @this {CPUX86}
     * @param {number} port (0x0000 to 0xffff)
     * @param {number} nPorts (1 to 4)
     * @param {boolean} [fInput] (true if input, false if output; output assumed if not specified)
     * @return {boolean} true if allowed, false if not
     */
    checkIOPM(port, nPorts, fInput)
    {
        let bitsPorts = 0;
        if (I386 && (this.regCR0 & X86.CR0.MSW.PE) && (this.nCPL > this.nIOPL || (this.regPS & X86.PS.VM)) && this.segTSS.addrIOPM) {
            let offIOPM = port >>> 3;
            let addrIOPM = this.segTSS.addrIOPM + offIOPM;
            bitsPorts = ((1 << nPorts) - 1) << (port & 0x7);
            while (bitsPorts && addrIOPM <= this.segTSS.addrIOPMLimit) {
                let bits = this.getByte(addrIOPM);
                if (bits & bitsPorts) break;
                bitsPorts >>>= 8;
                addrIOPM++;
            }
        }
        if (bitsPorts) {
            if (this.messageEnabled(Messages.IOPM)) this.printMessage("checkIOPM(" + Str.toHexWord(port) + "," + nPorts + "," + (fInput? "input" : "output") + "): trapped", true, true);
            X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
            return false;
        }
        return true;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {CPUX86}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "AX")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let fBound = false;
        switch (sBinding) {
        case "EAX":
        case "EBX":
        case "ECX":
        case "EDX":
        case "ESP":
        case "EBP":
        case "ESI":
        case "EDI":
        case "EIP":
        case "AX":
        case "BX":
        case "CX":
        case "DX":
        case "SP":
        case "BP":
        case "SI":
        case "DI":
        case "IP":
        case "PC":      // deprecated as an alias for "IP" (still used by older XML files, like the one at http://tpoindex.github.io/crobots/)
        case "CS":
        case "DS":
        case "SS":
        case "ES":
        case "FS":
        case "GS":
        case "CR0":
        case "CR2":
        case "CR3":
        case "PS":      // this refers to "Processor Status", aka the 16-bit flags register (although DEBUG.COM refers to this as "PC", surprisingly)
        case "C":
        case "P":
        case "A":
        case "Z":
        case "S":
        case "T":
        case "I":
        case "D":
        case "V":
            this.bindings[sBinding] = control;
            this.cLiveRegs++;
            fBound = true;
            break;
        default:
            fBound = super.setBinding(sHTMLType, sBinding, control);
            break;
        }
        return fBound;
    }

    /**
     * probeAddr(addr, size, fPhysical)
     *
     * Used by the Debugger to probe addresses without risk of triggering a page fault, and by internal
     * functions, like helpCheckFault(), that must also avoid triggering faults, since they're not part of
     * standard CPU operation.
     *
     * Since originally written, I've also relaxed the requirement that the request be contained entirely
     * within a single block; this was never a problem for any size-aligned request, but unfortunately, it
     * was difficult for the Debugger to guarantee that every 2 or 4-byte request would be always be word or
     * dword-aligned.  So now requests that straddle blocks will be broken into smaller probeAddr() requests.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @param {number} [size] is a length (default is 1; if specified, must be 1, 2 or 4)
     * @param {boolean} [fPhysical] (true for physical probe, false for linear; linear is the default)
     * @return {number|null} value at the specified address, or null if invalid
     */
    probeAddr(addr, size, fPhysical)
    {
        let aBlocks = (fPhysical? this.aBusBlocks : this.aMemBlocks);
        let block = aBlocks[(addr & this.nMemMask) >>> this.nBlockShift];
        if (block && block.type == Memory.TYPE.UNPAGED) block = this.mapPageBlock(addr, false, true);

        if (block) {
            let off = addr & this.nBlockLimit;
            if (!size || size == 1) {
                return block.readByteDirect(off, addr);
            }
            if (size == 2) {
                if (off < this.nBlockLimit) {
                    return block.readShortDirect(off, addr);
                }
                return block.readByteDirect(off, addr) | (this.probeAddr(addr + 1, 1, fPhysical) << 8);
            }
            if (size == 4) {
                if (off < this.nBlockLimit - 2) {
                    return block.readLongDirect(off, addr);
                }
                if (off == this.nBlockLimit - 1) {
                    return block.readShortDirect(off, addr) | (this.probeAddr(addr + 2, 2, fPhysical) << 16);
                }
                return block.readByteDirect(off, addr) | (this.probeAddr(addr + 1, 1, fPhysical) << 8) | (this.probeAddr(addr + 2, 1, fPhysical) << 16) | (this.probeAddr(addr + 3, 1, fPhysical) << 24);
            }
        }

        /*
         * Since the Bus component initializes all unused portions of physical address space with an empty
         * block, we have also written mapPageBlock() to return an empty block (memEmpty) whenever there is
         * no valid mapping.  So if we ever end up here, this may represent a hole that needs plugging.
         *
         * It's also possible the caller passed a bogus parameter, such as an invalid size (must be 1, 2 or 4).
         */

        return null;
    }

    /**
     * getByte(addr)
     *
     * Use bus.getByte() for physical addresses, and cpu.getByte() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @return {number} byte (8-bit) value at that address
     */
    getByte(addr)
    {
        if (BACKTRACK) this.backTrack.btiMem0 = this.bus.readBackTrack(addr);
        return this.aMemBlocks[(addr & this.nMemMask) >>> this.nBlockShift].readByte(addr & this.nBlockLimit, addr);
    }

    /**
     * getShort(addr)
     *
     * Use bus.getShort() for physical addresses, and cpu.getShort() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @return {number} word (16-bit) value at that address
     */
    getShort(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nMemMask) >>> this.nBlockShift;
        /*
         * On the 8088, it takes 4 cycles to read the additional byte REGARDLESS whether the address is odd or even.
         * TODO: For the 8086, the penalty is actually "(addr & 0x1) << 2" (4 additional cycles only when the address is odd).
         */
        this.nStepCycles -= this.cycleCounts.nWordCyclePenalty;

        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.bus.readBackTrack(addr);
            this.backTrack.btiMem1 = this.bus.readBackTrack(addr + 1);
        }
        if (off < this.nBlockLimit) {
            return this.aMemBlocks[iBlock].readShort(off, addr);
        }
        let w = this.aMemBlocks[iBlock].readByte(off, addr);
        if (!(this.opFlags & X86.OPFLAG.FAULT)) {
            w |= this.aMemBlocks[(iBlock + 1) & this.nBlockMask].readByte(0, addr + 1) << 8;
        }
        return w;
    }

    /**
     * getLong(addr)
     *
     * Use bus.getLong() for physical addresses, and cpu.getLong() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @return {number} long (32-bit) value at that address
     */
    getLong(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nMemMask) >>> this.nBlockShift;
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.bus.readBackTrack(addr);
            this.backTrack.btiMem1 = this.bus.readBackTrack(addr + 1);
            this.backTrack.btiMem2 = this.bus.readBackTrack(addr + 2);
            this.backTrack.btiMem3 = this.bus.readBackTrack(addr + 3);
        }
        if (off < this.nBlockLimit - 2) {
            return this.aMemBlocks[iBlock].readLong(off, addr);
        }
        /*
         * I think the previous version of this function tried to be too clever (ie, reading the last
         * long in the current block and the first long in the next block and masking/combining the results),
         * which may have also created some undesirable side-effects for custom memory controllers.
         * This simpler (and probably more reliable) approach is to simply read the long as individual bytes.
         */
        let l = 0;
        let cb = 4, nShift = 0;
        let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
        while (cb--) {
            l |= (this.aMemBlocks[iBlock].readByte(off++, addr++) << nShift);
            if (this.opFlags & X86.OPFLAG.FAULT) break;
            if (!--cbBlock) {
                iBlock = (iBlock + 1) & this.nBlockMask;
                off = 0;
            }
            nShift += 8;
        }
        return l;
    }

    /**
     * setByte(addr, b)
     *
     * Use bus.setByte() for physical addresses, and cpu.setByte() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @param {number} b is the byte (8-bit) value to write (which we truncate to 8 bits; required by opSTOSb)
     */
    setByte(addr, b)
    {
        if (BACKTRACK) this.bus.writeBackTrack(addr, this.backTrack.btiMem0);
        this.aMemBlocks[(addr & this.nMemMask) >>> this.nBlockShift].writeByte(addr & this.nBlockLimit, b & 0xff, addr);
    }

    /**
     * setShort(addr, w)
     *
     * Use bus.setShort() for physical addresses, and cpu.setShort() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @param {number} w is the word (16-bit) value to write (which we truncate to 16 bits to be safe)
     */
    setShort(addr, w)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nMemMask) >>> this.nBlockShift;
        /*
         * On the 8088, it takes 4 cycles to write the additional byte REGARDLESS whether the address is odd or even.
         * TODO: For the 8086, the penalty is actually "(addr & 0x1) << 2" (4 additional cycles only when the address is odd).
         */
        this.nStepCycles -= this.cycleCounts.nWordCyclePenalty;

        if (BACKTRACK) {
            this.bus.writeBackTrack(addr, this.backTrack.btiMem0);
            this.bus.writeBackTrack(addr + 1, this.backTrack.btiMem1);
        }
        if (off < this.nBlockLimit) {
            this.aMemBlocks[iBlock].writeShort(off, w & 0xffff, addr);
            return;
        }
        this.aMemBlocks[iBlock++].writeByte(off, w & 0xff, addr);
        if (this.opFlags & X86.OPFLAG.FAULT) return;
        this.aMemBlocks[iBlock & this.nBlockMask].writeByte(0, (w >> 8) & 0xff, addr + 1);
    }

    /**
     * setLong(addr, l)
     *
     * Use bus.setLong() for physical addresses, and cpu.setLong() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUX86}
     * @param {number} addr is a linear address
     * @param {number} l is the long (32-bit) value to write
     */
    setLong(addr, l)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nMemMask) >>> this.nBlockShift;
        this.nStepCycles -= this.cycleCounts.nWordCyclePenalty;

        if (BACKTRACK) {
            this.bus.writeBackTrack(addr, this.backTrack.btiMem0);
            this.bus.writeBackTrack(addr + 1, this.backTrack.btiMem1);
            this.bus.writeBackTrack(addr + 2, this.backTrack.btiMem2);
            this.bus.writeBackTrack(addr + 3, this.backTrack.btiMem3);
        }
        if (off < this.nBlockLimit - 2) {
            this.aMemBlocks[iBlock].writeLong(off, l, addr);
            return;
        }
        /*
         * I think the previous version of this function tried to be too clever (ie, reading and rewriting
         * the last long in the current block, and then reading and rewriting the first long in the next
         * block), which may have also created some undesirable side-effects for custom memory controllers.
         * This simpler (and probably more reliable) approach is to simply write the long as individual bytes.
         */
        let cb = 4;
        let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
        while (cb--) {
            this.aMemBlocks[iBlock].writeByte(off++, l & 0xff, addr++);
            if (this.opFlags & X86.OPFLAG.FAULT) return;
            if (!--cbBlock) {
                iBlock = (iBlock + 1) & this.nBlockMask;
                off = 0;
            }
            l >>>= 8;
        }
    }

    /**
     * getEAByte(seg, off)
     *
     * @this {CPUX86}
     * @param {SegX86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @return {number} byte (8-bit) value at that address
     */
    getEAByte(seg, off)
    {
        this.segEA = seg;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = seg.checkRead(this.offEA, 1);
        if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
        let b = this.getByte(this.regEA);
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiMem0;
        return b;
    }

    /**
     * getEAByteData(off)
     *
     * @this {CPUX86}
     * @param {number} off is a segment-relative offset
     * @return {number} byte (8-bit) value at that address
     */
    getEAByteData(off)
    {
        return this.getEAByte(this.segData, off);
    }

    /**
     * getEAByteStack(off)
     *
     * @this {CPUX86}
     * @param {number} off is a segment-relative offset
     * @return {number} byte (8-bit) value at that address
     */
    getEAByteStack(off)
    {
        return this.getEAByte(this.segStack, off);
    }

    /**
     * getEAWord(seg, off)
     *
     * @this {CPUX86}
     * @param {SegX86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @return {number} word (16-bit or 32-bit) value at that address
     */
    getEAWord(seg, off)
    {
        let w;
        this.segEA = seg;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = seg.checkRead(this.offEA, (I386? this.sizeData : 2));
        if (this.opFlags & (X86.OPFLAG.NOREAD | X86.OPFLAG.WRAP)) {
            if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
            /*
             * The WRAP flag must have been set by checkReadReal(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regEA) | (this.getByte(seg.checkRead(0, 1)) << 8);
        }
        else {
            w = this.getWord(this.regEA);
        }
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEAShortData(off)
     *
     * @this {CPUX86}
     * @param {number} off is a segment-relative offset
     * @return {number} short (16-bit) value at that address
     */
    getEAShortData(off)
    {
        let w;
        this.segEA = this.segData;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = this.segEA.checkRead(this.offEA, 2);
        if (this.opFlags & (X86.OPFLAG.NOREAD | X86.OPFLAG.WRAP)) {
            if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
            /*
             * The WRAP flag must have been set by checkReadReal(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regEA) | (this.getByte(this.segEA.checkRead(0, 1)) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            w = this.getShort(this.regEA);
        }
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEAShortStack(off)
     *
     * @this {CPUX86}
     * @param {number} off is a segment-relative offset
     * @return {number} short (16-bit) value at that address
     */
    getEAShortStack(off)
    {
        let w;
        this.segEA = this.segStack;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = this.segEA.checkRead(this.offEA, 2);
        if (this.opFlags & (X86.OPFLAG.NOREAD | X86.OPFLAG.WRAP)) {
            if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
            /*
             * The WRAP flag must have been set by checkReadReal(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regEA) | (this.getByte(this.segEA.checkRead(0, 1)) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            w = this.getShort(this.regEA);
        }
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEALongData(off)
     *
     * @this {CPUX86}
     * @param {number} off is a segment-relative offset
     * @return {number} long (32-bit) value at that address
     */
    getEALongData(off)
    {
        this.segEA = this.segData;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = this.segEA.checkRead(this.offEA, 4);
        if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
        let w = this.getLong(this.regEA);
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEALongStack(off)
     *
     * @this {CPUX86}
     * @param {number} off is a segment-relative offset
     * @return {number} long (32-bit) value at that address
     */
    getEALongStack(off)
    {
        this.segEA = this.segStack;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = this.segEA.checkRead(this.offEA, 4);
        if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
        let w = this.getLong(this.regEA);
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * setEAByte(b)
     *
     * @this {CPUX86}
     * @param {number} b is the byte (8-bit) value to write
     */
    setEAByte(b)
    {
        if (this.opFlags & X86.OPFLAG.NOWRITE) return;
        if (BACKTRACK) this.backTrack.btiMem0 = this.backTrack.btiEALo;
        this.setByte(this.segEA.checkWrite(this.offEA, 1), b);
    }

    /**
     * setEAShort(w)
     *
     * @this {CPUX86}
     * @param {number} w is the short (16-bit) value to write
     */
    setEAShort(w)
    {
        if (this.opFlags & X86.OPFLAG.NOWRITE) return;
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiEALo;
            this.backTrack.btiMem1 = this.backTrack.btiEAHi;
        }
        let addr = this.segEA.checkWrite(this.offEA, 2);
        if (this.opFlags & X86.OPFLAG.WRAP) {
            /*
             * The WRAP flag must have been set by checkWriteReal(), so we also know that we're dealing with
             * a 16-bit write, which allows us to make some simplifications here.
             */
            this.setByte(addr, w);
            this.setByte(this.segEA.checkWrite(0, 1), w >> 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            this.setShort(addr, w);
        }
    }

    /**
     * setEALong(l)
     *
     * @this {CPUX86}
     * @param {number} l is the long (32-bit) value to write
     */
    setEALong(l)
    {
        if (this.opFlags & X86.OPFLAG.NOWRITE) return;
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiEALo;
            this.backTrack.btiMem1 = this.backTrack.btiEAHi;
        }
        this.setLong(this.segEA.checkWrite(this.offEA, 4), l);
    }

    /**
     * setEAWord(w)
     *
     * @this {CPUX86}
     * @param {number} w is the word (16-bit or 32-bit) value to write
     */
    setEAWord(w)
    {
        if (this.opFlags & X86.OPFLAG.NOWRITE) return;
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiEALo;
            this.backTrack.btiMem1 = this.backTrack.btiEAHi;
        }
        let addr = this.segEA.checkWrite(this.offEA, this.sizeData);
        if (this.opFlags & X86.OPFLAG.WRAP) {
            /*
             * The WRAP flag must have been set by checkWriteReal(), so we also know that we're dealing with
             * a 16-bit write, which allows us to make some simplifications here.
             */
            this.setByte(addr, w);
            this.setByte(this.segEA.checkWrite(0, 1), w >> 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            this.setWord(addr, w);
        }
    }

    /**
     * getSOByte(seg, off)
     *
     * This is like getEAByte(), but it does NOT update regEA.
     *
     * @this {CPUX86}
     * @param {SegX86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @return {number} byte (8-bit) value at that address
     */
    getSOByte(seg, off)
    {
       return this.getByte(seg.checkRead(off, 1));
   }

    /**
     * getSOWord(seg, off)
     *
     * This is like getEAWord(), but it does NOT update regEA.
     *
     * @this {CPUX86}
     * @param {SegX86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @return {number} word (16-bit) value at that address
     */
    getSOWord(seg, off)
    {
        let w;
        let addr = seg.checkRead(off, this.sizeData);
        if (this.opFlags & X86.OPFLAG.WRAP) {
            /*
             * The WRAP flag must have been set by checkReadReal(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(addr) | (this.getByte(seg.checkRead(0, 1)) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            w = this.getWord(addr);
        }
        return w;
    }

    /**
     * setSOByte(seg, off, b)
     *
     * This is like setEAByte(), but it does NOT update regEAWrite.
     *
     * @this {CPUX86}
     * @param {SegX86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @param {number} b is the byte (8-bit) value to write
     */
    setSOByte(seg, off, b)
    {
        this.setByte(seg.checkWrite(off, 1), b);
    }

    /**
     * setSOWord(seg, off, w)
     *
     * This is like setEAWord(), but it does NOT update regEAWrite.
     *
     * @this {CPUX86}
     * @param {SegX86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @param {number} w is the word (16-bit) value to write
     */
    setSOWord(seg, off, w)
    {
        let addr = seg.checkWrite(off, this.sizeData);
        if (this.opFlags & X86.OPFLAG.WRAP) {
            /*
             * The WRAP flag must have been set by checkWriteReal(), so we also know that we're dealing with
             * a 16-bit write, which allows us to make some simplifications here.
             */
            this.setByte(addr, w);
            this.setByte(seg.checkWrite(0, 1), w >> 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            this.setWord(addr, w);
        }
    }

    /**
     * getBytePrefetch()
     *
     * @this {CPUX86}
     * @return {number} byte (8-bit) value at regLIP
     */
    getBytePrefetch()
    {
        if (!this.cbPrefetch) {
            this.refillPrefetch();
            if (!this.cbPrefetch) return this.getByte(this.regLIP);
        }
        let b = (this.adwPrefetch[this.regLIP & CPUX86.PFINFO.IP_MASK] >> ((this.regLIP & 0x3) << 3)) & 0xff;

        this.cbPrefetch--;
        return b;
    }

    /**
     * getShortPrefetch()
     *
     * @this {CPUX86}
     * @return {number} short (16-bit) value at regLIP
     */
    getShortPrefetch()
    {
        if (this.cbPrefetch < 2) {
            this.refillPrefetch();
            if (this.cbPrefetch < 2) {
                this.cbPrefetch = 0;
                return this.getShort(this.regLIP);
            }
        }
        let shift = (this.regLIP & 0x3) << 3;
        let w = (this.adwPrefetch[this.regLIP & CPUX86.PFINFO.IP_MASK] >>> shift) & 0xffff;
        if (shift > 16) w |= (this.adwPrefetch[(this.regLIP + 4) & CPUX86.PFINFO.IP_MASK] & 0xff) << 8;

        this.cbPrefetch -= 2;
        return w;
    }

    /**
     * getLongPrefetch()
     *
     * @this {CPUX86}
     * @return {number} long (32-bit) value at regLIP
     */
    getLongPrefetch()
    {
        if (this.cbPrefetch < 4) {
            this.refillPrefetch();
            if (this.cbPrefetch < 4) {
                this.cbPrefetch = 0;
                return this.getLong(this.regLIP);
            }
        }
        let shift = (this.regLIP & 0x3) << 3;
        let l = (this.adwPrefetch[this.regLIP & CPUX86.PFINFO.IP_MASK] >>> shift)|0;
        if (shift) l |= this.adwPrefetch[(this.regLIP + 4) & CPUX86.PFINFO.IP_MASK] << (32 - shift);

        this.cbPrefetch -= 4;
        return l;
    }

    /**
     * getWordPrefetch()
     *
     * @this {CPUX86}
     * @return {number} short (16-bit) or long (32-bit) value as appropriate
     */
    getWordPrefetch()
    {
        return (I386 && this.sizeData == 4? this.getLongPrefetch() : this.getShortPrefetch());
    }

    /**
     * refillPrefetch()
     *
     * This function is similar to probeAddr() in that must NOT trigger a fault, because prefetching
     * inherently runs the risk of fetching more bytes that may actually be executed.  Also, to keep it
     * simple, we limit prefetching to whatever bytes (if any) are available in the current page.  If the
     * page is not present, or there are insufficient bytes in the current page to completely fill the
     * queue, then the caller must request byte(s) "the old-fashioned way", to ensure proper fault handling.
     *
     * For example, if getShortPrefetch() finds there are only 0 or 1 bytes in the prefetch queue, and
     * if it is unable to obtain any more bytes via refillPrefetch(), then getShortPrefetch() must call
     * getShort(this.regLIP) (which is also what would be called if PREFETCH was disabled completely).
     *
     * @this {CPUX86}
     */
    refillPrefetch()
    {
        let aBlocks = this.aMemBlocks;
        let regLIP = this.regLIP & ~0x3;
        let block = aBlocks[(regLIP & this.nMemMask) >>> this.nBlockShift];
        if (block && block.type == Memory.TYPE.UNPAGED) {
            block = this.mapPageBlock(regLIP, false, true);
            if (block === this.memEmpty) block = null;
        }
        if (block) {
            let i = 0;
            let off = regLIP & this.nBlockLimit;
            let cbMax = this.nBlockSize - off;
            if (cbMax > CPUX86.PFINFO.LENGTH) cbMax = CPUX86.PFINFO.LENGTH;
            for (; i < cbMax; i += 4) {
                this.adwPrefetch[regLIP & CPUX86.PFINFO.IP_MASK] = block.readLongDirect(off, regLIP);
                off += 4; regLIP += 4;
            }
            this.cbPrefetch = i - (this.regLIP & 0x3);
         // this.nBusCycles += 4;
        } else {
            this.cbPrefetch = 0;
        }
    }

    /**
     * getIPByte()
     *
     * @this {CPUX86}
     * @return {number} byte at the current IP; IP advanced by 1
     */
    getIPByte()
    {
        let newLIP = this.checkIP(1);
        let b = (PREFETCH? this.getBytePrefetch() : this.getByte(this.regLIP));
        if (BACKTRACK) this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
        /*
         * With the following cycle penalty (which really only affects 8086/8088 CPUs), PC Tools 4.30
         * correctly reports an IBM PC-relative speed of 100% (assuming you're using a 4.77Mhz configuration).
         */
        this.nStepCycles -= this.cycleCounts.nWordCyclePenalty;
        this.regLIP = newLIP;
        return b;
    }

    /**
     * getIPShort()
     *
     * @this {CPUX86}
     * @return {number} short at the current IP; IP advanced by 2
     */
    getIPShort()
    {
        let w;
        let newLIP = this.checkIP(2);
        if (PREFETCH) {
            w = this.getShortPrefetch();
        } else if (!(this.opFlags & X86.OPFLAG.WRAP)) {
            w = this.getShort(this.regLIP);
        } else {
            /*
             * The WRAP flag must have been set by checkIP(2), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regLIP) | (this.getByte(newLIP - 1) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        if (BACKTRACK) {
            this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
            this.bus.updateBackTrackCode(this.regLIP + 1, this.backTrack.btiMem1);
        }
        this.regLIP = newLIP;
        return w;
    }

    /**
     * getIPAddr()
     *
     * @this {CPUX86}
     * @return {number} word at the current IP; IP advanced by 2 or 4, depending on address size
     */
    getIPAddr()
    {
        let w;
        let newLIP = this.checkIP(this.sizeAddr);
        if (PREFETCH) {
            w = this.getAddr();
        } else if (!(this.opFlags & X86.OPFLAG.WRAP)) {
            w = this.getAddr(this.regLIP);
        } else {
            /*
             * The WRAP flag must have been set by checkIP(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regLIP) | (this.getByte(newLIP - 1) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        if (BACKTRACK) {
            this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
            this.bus.updateBackTrackCode(this.regLIP + 1, this.backTrack.btiMem1);
        }
        this.regLIP = newLIP;
        return w;
    }

    /**
     * getIPWord()
     *
     * @this {CPUX86}
     * @return {number} word at the current IP; IP advanced by 2 or 4, depending on operand size
     */
    getIPWord()
    {
        let w;
        let newLIP = this.checkIP(this.sizeData);
        if (PREFETCH) {
            w = this.getWordPrefetch();
        } else if (!(this.opFlags & X86.OPFLAG.WRAP)) {
            w = this.getWord(this.regLIP);
        } else {
            /*
             * The WRAP flag must have been set by checkIP(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regLIP) | (this.getByte(newLIP - 1) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        if (BACKTRACK) {
            this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
            this.bus.updateBackTrackCode(this.regLIP + 1, this.backTrack.btiMem1);
        }
        this.regLIP = newLIP;
        return w;
    }

    /**
     * getIPDisp()
     *
     * @this {CPUX86}
     * @return {number} sign-extended (32-bit) value from the byte at the current IP; IP advanced by 1
     */
    getIPDisp()
    {
        let newLIP = this.checkIP(1);
        let w = ((PREFETCH? this.getBytePrefetch() : this.getByte(this.regLIP)) << 24) >> 24;
        if (BACKTRACK) this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
        this.regLIP = newLIP;
        return w;
    }

    /**
     * peekIPByte()
     *
     * @this {CPUX86}
     * @return {number} byte at the current IP
     */
    peekIPByte()
    {
        return (PREFETCH? this.getBytePrefetch() : this.getByte(this.regLIP));
    }

    /**
     * popWord()
     *
     * @this {CPUX86}
     * @return {number} word popped from the current SP; SP increased by 2 or 4
     */
    popWord()
    {
        let data = this.getWord(this.regLSP);
        let width = I386? this.sizeData : 2;
        this.regLSP = (this.regLSP + width)|0;

        let delta = this.regLSPLimit - (this.regLSP >>> 0);
        if (delta < 0) {
            /*
             * There's no such thing as an SS fault on the 8086/8088, and in fact, we have to support the
             * operation even when the address straddles the wrap boundary; other emulators tend to barf on
             * a wrap, usually because they're running in V86 mode instead of real mode.
             */
            if (this.model <= X86.MODEL_8088) {
                this.setSP((this.regLSP - this.segSS.base) & this.segSS.maskAddr);
                if (delta < -1) {
                    data = (data & 0xff) | (this.getByte(this.regLSP - 1) << 8);
                }
            }
            else {
                /*
                 * I'm assuming that, on newer processors, when the stack segment limit is set to the maximum,
                 * it's OK for the stack to wrap, unless the new address is straddling the wrap boundary (ie, when
                 * delta is < -1).
                 *
                 * NOTE: This combines the old 8088 address-wrap check with the new segment-limit check, even though
                 * the correct time to do the latter is immediately BEFORE the fetch, not AFTER.
                 */
                if (delta < -1) {
                    X86.helpFault.call(this, X86.EXCEPTION.SS_FAULT, 0);
                }
                else if (!this.segSS.fExpDown && this.segSS.limit == this.segSS.maskAddr || this.segSS.fExpDown && !this.segSS.limit) {
                    this.setSP((this.regLSP - this.segSS.base) & this.segSS.maskAddr);
                }
            }
        }
        return data;
    }

    /**
     * pushWord(w)
     *
     * NOTE: pushWord() used to do a simplified version of pushData(), and while that might have made the emulator
     * slightly faster, it was woefully duplicative.  Let's trust the combination of the Closure Compiler and the
     * JavaScript engines to automatically inline instead.
     *
     * @this {CPUX86}
     * @param {number} w is the word (16-bit) value to push at current SP; SP decreased by 2 or 4
     */
    pushWord(w)
    {
        this.pushData(w, I386? this.sizeData : 2);
    }

    /**
     * pushData(data, width, size)
     *
     * The size parameter serves two very limited purposes: 1) the ability to push data according to a previous
     * operand size, and 2) the ability to write fewer bytes than the width if necessary.
     *
     * The former occurs when a 32-bit code segment performs a 16:32 call to a 16-bit code segment; after the
     * new 16-bit code segment is loaded (and possible stack switch occurs), the return address (both segment
     * and offset) must still be pushed as 32-bit values.
     *
     * The latter occurs with segment register pushes.  When a 32-bit operand size is in effect (ie, width is 4),
     * only the low 16 bits should be written (size must be 2).
     *
     * For all other kinds of pushes, width and size are impliedly the same.
     *
     * @this {CPUX86}
     * @param {number} data is the data to push at current SP; SP decreased by size
     * @param {number} width is the width of the data to push, in bytes (must be either 2 or 4)
     * @param {number} [size] is the size of the data to push, in bytes (must be 1, 2, or 4, and <= width)
     */
    pushData(data, width, size = width)
    {


        let regLSP = (this.regLSP - width)|0;

        let delta = (regLSP >>> 0) - this.regLSPLimitLow;
        if (delta < 0) {
            /*
             * There's no such thing as an SS fault on the 8086/8088, and in fact, we have to support the
             * operation even when the address straddles the wrap boundary (ie, when delta is -1); other
             * emulators tend to barf on a wrap, usually because they're running in V86 mode instead of real mode.
             */
            if (this.model <= X86.MODEL_8088) {
                if (delta == -1) {
                    this.setByte(regLSP + 1, data >> 8);
                    this.setSP((regLSP - this.segSS.base) & this.segSS.maskAddr);
                    this.setByte(this.regLSP, data);
                    return;
                }

            }
            /*
             * I'm assuming that, on newer processors, when the stack segment limit is set to the maximum,
             * it's OK for the stack to wrap, unless the new address is straddling the wrap boundary (ie, when
             * delta is < 0 and > -width).
             */
            if (!this.segSS.fExpDown && this.segSS.limit == this.segSS.maskAddr || this.segSS.fExpDown && !this.segSS.limit) {
                if (delta > -width) {
                    X86.helpFault.call(this, X86.EXCEPTION.SS_FAULT, 0);
                    return;
                }
                this.setSP((regLSP - this.segSS.base) & this.segSS.maskAddr);
                regLSP = this.regLSP;
            } else {
                X86.helpFault.call(this, X86.EXCEPTION.SS_FAULT, 0);
                return;
            }
        }

        switch(size) {
        case 1:
            this.setByte(regLSP, data);
            break;
        case 2:
            this.setShort(regLSP, data);
            break;
        case 4:
            this.setLong(regLSP, data);
            break;
        default:

            break;
        }

        /*
         * We update this.regLSP at the end to make life simpler for opcode handlers that perform only one
         * pushWord() operation, relieving them from having to snapshot this.regLSP into this.opLSP needlessly.
         */
        this.regLSP = regLSP;
    }

    /**
     * checkINTR()
     *
     * This must only be called when intFlags (containing the simulated INTFLAG.INTR signal) is known to be set.
     * Note that it's perfectly possible that between the time updateINTR(true) was called and we request the
     * interrupt vector number below, the interrupt could have been cleared or masked, in which case getIRRVector()
     * will return -1 and we'll simply clear INTFLAG.INTR.
     *
     * intFlags has been overloaded with the INTFLAG.TRAP bit as well, since the acknowledgment of h/w interrupts
     * and the Trap flag are similar; they must both honor the NOINTR suppression flag, and stepCPU() shouldn't
     * have to check multiple variables when deciding whether to simulate an interrupt.
     *
     * This function also includes a check for the new async INTFLAG.DMA flag, which is triggered by a ChipSet call
     * to setDMA().  This DMA flag actually has nothing to do with interrupts; it's simply an expedient way to
     * piggy-back on the CPU's execution logic, to help drive async DMA requests.
     *
     * Originally, DMA requests (eg, FDC or HDC I/O operations) were all handled synchronously, since no actual
     * I/O was required to satisfy the request; from the CPU's perspective, this meant DMA operations were virtually
     * instantaneous.  However, with the introduction of remote disk connections, some actual I/O may now be required;
     * in practice, this means that the FIRST byte requested as part of a DMA operation may require a callback to
     * finish, while all remaining bytes will be retrieved during subsequent checkINTR() calls -- unless of course
     * additional remote I/O operations are required to complete the DMA operation.
     *
     * As a result, the CPU will run slightly slower while an async DMA request is in progress, but the slowdown
     * should be negligible.  One downside is that this slowdown will be in effect for the entire duration of the
     * I/O (ie, even while we're waiting for the remote I/O to finish), so the ChipSet component should avoid
     * calling setDMA() whenever possible.
     *
     * TODO: While comparing SYMDEB tracing in both PCx86 and VMware, I noticed that after single-stepping ANY
     * segment-load instruction, SYMDEB would get control immediately after that instruction in VMware, whereas
     * I delay acknowledgment of the Trap flag until the *following* instruction, so in PCx86, SYMDEB doesn't get
     * control until the following instruction.  I think PCx86 behavior is correct, at least for SS.
     *
     * ERRATA: Early revisions of the 8086/8088 failed to suppress hardware interrupts (and possibly also Trap
     * acknowledgements) after an SS load, but Intel corrected the problem at some point; however, I don't know when
     * that change was made or which IBM PC models may have been affected, if any.  TODO: More research required.
     *
     * WARNING: There is also a priority consideration here.  On the 8086/8088, hardware interrupts have higher
     * priority than Trap interrupts (which is why the code below is written the way it is).  A potentially
     * undesirable side-effect is that a hardware interrupt handler could end up being single-stepped if an
     * external interrupt occurs immediately after the Trap flag is set.  This is why some 8086 debuggers temporarily
     * mask all hardware interrupts during a single-step operation (although that doesn't help with NMIs generated
     * by a coprocessor).  As of the 80286, those priorities were inverted, giving the Trap interrupt higher priority
     * than external interrupts.
     *
     * TODO: Determine the priorities for the 80186.
     *
     * @this {CPUX86}
     * @return {boolean} true if h/w interrupt (or trap) has just been acknowledged, false if not
     */
    checkINTR()
    {
        // DEBUG:

        if (!(this.opFlags & X86.OPFLAG.NOINTR)) {
            /*
             * As discussed above, the 8086/8088 give hardware interrupts higher priority than the TRAP interrupt,
             * whereas the 80286 and up give TRAPs higher priority.
             */
            let iPriority = (this.model < X86.MODEL_80286? 0 : 1);
            for (let cPriorities = 0; cPriorities < 2; cPriorities++) {
                switch(iPriority) {
                case 0:
                    if ((this.intFlags & X86.INTFLAG.INTR) && (this.regPS & X86.PS.IF)) {
                        let nIDT = this.chipset.getIRRVector();
                        if (nIDT >= -1) {
                            this.intFlags &= ~X86.INTFLAG.INTR;
                            if (nIDT >= 0) {
                                this.intFlags &= ~X86.INTFLAG.HALT;
                                /*
                                 * This is a hack that simulates the 8086/8088's failure to preserve more than one prefix
                                 * when a string instruction is interrupted.  TODO: Faithful simulation would require maintaining
                                 * a prefix byte count, whereas we simply maintain a special flag (REPSEG) that indicates multiple
                                 * prefixes were detected, so we simply "skip over" one of them.
                                 */
                                if (this.model <= X86.MODEL_8088 && (this.opFlags & X86.OPFLAG.REPSEG)) {
                                    this.regLIP = (this.regLIP + 1)|0;
                                }
                                X86.helpInterrupt.call(this, nIDT);
                                return true;
                            }
                        }
                    }
                    break;
                case 1:
                    if ((this.intFlags & X86.INTFLAG.TRAP)) {
                        this.intFlags &= ~X86.INTFLAG.TRAP;
                        if (I386 && this.model >= X86.MODEL_80386) this.regDR[6] |= X86.DR6.BS;
                        X86.helpInterrupt.call(this, X86.EXCEPTION.DB_EXC);
                        return true;
                    }
                    break;
                }
                iPriority = 1 - iPriority;
            }
        }
        /*
         * As long as the ChipSet component isn't calling setDMA(), we don't need to test INTFLAG.DMA...
         *
        if (this.intFlags & X86.INTFLAG.DMA) {
            if (!this.chipset.checkDMA()) {
                this.intFlags &= ~X86.INTFLAG.DMA;
            }
        }
         */
        return false;
    }

    /**
     * updateINTR(fRaise)
     *
     * This is called by the ChipSet component whenever a h/w interrupt needs to be simulated.
     * This is how the PIC component simulates raising the INTFLAG.INTR signal.  We will honor the request
     * only if we have a reference back to the ChipSet component.  The CPU will then "respond" by calling
     * checkINTR() and request the corresponding interrupt vector from the ChipSet.
     *
     * @this {CPUX86}
     * @param {boolean} fRaise is true to raise INTFLAG.INTR, false to lower
     */
    updateINTR(fRaise)
    {
        if (this.chipset) {
            if (fRaise) {
                this.intFlags |= X86.INTFLAG.INTR;
            } else {
                this.intFlags &= ~X86.INTFLAG.INTR;
            }
        }
    }

    /**
     * delayINTR()
     *
     * This is called by the ChipSet component whenever the IMR register is being unmasked, to avoid
     * interrupts being simulated too quickly. This works around a problem in the ROM BIOS "KBD_RESET"
     * (F000:E688) function, which is called with interrupts enabled by the "TST8" (F000:E30D) code.
     *
     * "KBD_RESET" appears to be written with the assumption that CLI is in effect, because it issues an
     * STI immediately after unmasking the keyboard IRQ.  And normally, the STI would delay INTFLAG.INTR
     * long enough to allow AH to be set to 0. But if interrupts are already enabled, an interrupt could
     * theoretically occur before the STI.  And since AH isn't initialized until after the STI, such an
     * interrupt would be missed.
     *
     * I'm assuming this never happens in practice because the PIC isn't that fast.  But for us to
     * guarantee that, we need to provide this function to the ChipSet component.
     *
     * @this {CPUX86}
     */
    delayINTR()
    {
        this.opFlags |= X86.OPFLAG.NOINTR;
    }

    /**
     * updateReg(sReg, nValue)
     *
     * This function helps updateStatus() by massaging the register names and values according to
     * CPU type before passing the call to displayValue(); in the "old days", updateStatus() called
     * displayValue() directly (although then it was called displayReg()).
     *
     * @this {CPUX86}
     * @param {string} sReg
     * @param {number} nValue
     */
    updateReg(sReg, nValue)
    {
        let cch = 4;
        if (sReg.length == 1) {
            cch = 1;
            nValue = nValue? 1 : 0;
        }
        if (this.model < 80386) {
            if (sReg.length > 2) {
                sReg = sReg.substr(1, 2);
            }
        } else {
            if (sReg == "PS" || sReg.length > 2) {
                cch = 8;
            }
        }
        this.displayValue(sReg, nValue, cch);
    }

    /**
     * updateStatus(fForce)
     *
     * This provides periodic Control Panel updates (eg, a few times per second; see Computer.UPDATES_PER_SECOND).
     * this is where we take care of any DOM updates (eg, register values) while the CPU is running.
     *
     * @this {CPUX86}
     * @param {boolean} [fForce] (true will display registers even if the CPU is running and "live" registers are not enabled)
     */
    updateStatus(fForce)
    {
        if (this.cLiveRegs) {
            if (fForce || !this.flags.running || this.flags.displayLiveRegs) {
                this.updateReg("EAX", this.regEAX);
                this.updateReg("EBX", this.regEBX);
                this.updateReg("ECX", this.regECX);
                this.updateReg("EDX", this.regEDX);
                this.updateReg("ESP", this.getSP());
                this.updateReg("EBP", this.regEBP);
                this.updateReg("ESI", this.regESI);
                this.updateReg("EDI", this.regEDI);
                this.updateReg("CS", this.getCS());
                this.updateReg("DS", this.getDS());
                this.updateReg("SS", this.getSS());
                this.updateReg("ES", this.getES());
                this.updateReg("EIP", this.getIP());
                let regPS = this.getPS();
                this.updateReg("PS", regPS);
                this.updateReg("V", (regPS & X86.PS.OF));
                this.updateReg("D", (regPS & X86.PS.DF));
                this.updateReg("I", (regPS & X86.PS.IF));
                this.updateReg("T", (regPS & X86.PS.TF));
                this.updateReg("S", (regPS & X86.PS.SF));
                this.updateReg("Z", (regPS & X86.PS.ZF));
                this.updateReg("A", (regPS & X86.PS.AF));
                this.updateReg("P", (regPS & X86.PS.PF));
                this.updateReg("C", (regPS & X86.PS.CF));
                if (this.model == X86.MODEL_80386) {
                    this.updateReg("FS", this.getFS());
                    this.updateReg("GS", this.getGS());
                    this.updateReg("CR0", this.regCR0);
                    this.updateReg("CR2", this.regCR2);
                    this.updateReg("CR3", this.regCR3);
                }
            }
        }

        let controlSpeed = this.bindings["speed"];
        if (controlSpeed) controlSpeed.textContent = this.getSpeedCurrent();
    }

    /**
     * stepCPU(nMinCycles)
     *
     * NOTE: Single-stepping should not be confused with the Trap flag; single-stepping is a Debugger
     * operation that's completely independent of Trap status.  The CPU can go in and out of Trap mode,
     * in and out of h/w interrupt service routines (ISRs), etc, but from the Debugger's perspective,
     * they're all one continuous stream of instructions that can be stepped or run at will.  Moreover,
     * stepping vs. running should never change the behavior of the simulation.
     *
     * Similarly, the Debugger's execution breakpoints have no involvement with the x86 breakpoint instruction
     * (0xCC); the Debugger monitors changes to the regLIP register to implement its own execution breakpoints.
     *
     * As a result, the Debugger's complete independence means you can run other 8086/8088 debuggers
     * (eg, DEBUG) inside the simulation without interference; you can even "debug" them with the Debugger.
     *
     * @this {CPUX86}
     * @param {number} nMinCycles (0 implies a single-step, and therefore breakpoints should be ignored)
     * @return {number} of cycles executed; 0 indicates a pre-execution condition (ie, an execution breakpoint
     * was hit), -1 indicates a post-execution condition (eg, a read or write breakpoint was hit), and a positive
     * number indicates successful completion of that many cycles (which should always be >= nMinCycles).
     */
    stepCPU(nMinCycles)
    {
        /*
         * The Debugger uses fComplete to determine if the instruction completed (true) or was interrupted
         * by a breakpoint or some other exceptional condition (false).  NOTE: this does NOT include JavaScript
         * exceptions, which stepCPU() expects the caller to catch using its own exception handler.
         *
         * The CPU relies on the use of stopCPU() rather than fComplete, because the CPU never single-steps
         * (ie, nMinCycles is always some large number), whereas the Debugger does.  And conversely, when the
         * Debugger is single-stepping (even when performing multiple single-steps), fRunning is never set,
         * so stopCPU() would have no effect as far as the Debugger is concerned.
         */
        this.flags.complete = true;

        /*
         * fDebugCheck is true if we need to "check" every instruction with the Debugger.
         */
        let fDebugCheck = this.flags.debugCheck = (DEBUGGER && this.dbg && this.dbg.checksEnabled());

        /*
         * nDebugState is checked only when fDebugCheck is true, and its sole purpose is to tell the first call
         * to checkInstruction() that it can skip breakpoint checks, and that will be true ONLY when fStarting is
         * true OR nMinCycles is zero (the latter means the Debugger is single-stepping).
         *
         * Once we snap fStarting, we clear it, because technically, we've moved beyond "starting" and have
         * officially "started" now.
         */
        let nDebugState = (!nMinCycles)? -1 : (this.flags.starting? 0 : 1);
        this.flags.starting = false;

        /*
         * We move the minimum cycle count to nStepCycles (the number of cycles left to step), so that other
         * functions have the ability to force that number to zero (eg, stopCPU()), and thus we don't have to check
         * any other criteria to determine whether we should continue stepping or not.
         */
        this.nBurstCycles = this.nStepCycles = nMinCycles;

        /*
         * NOTE: Even though runCPU() calls updateAllTimers(), we need an additional call here if we're being
         * called from the Debugger, so that single-stepping will update timers as well.  TODO: What about RTC?
         */
        if (this.chipset && !nMinCycles) this.chipset.updateAllTimers();

        /*
         * Let's also suppress h/w interrupts whenever the Debugger is single-stepping an instruction; I'm loathe
         * to allow Debugger interactions to affect the behavior of the virtual machine in ANY way, but I'm making
         * this small concession to avoid the occasional and sometimes unexpected Debugger command that ends up
         * stepping into a hardware interrupt service routine (ISR).
         *
         * Note that this is similar to the problem discussed in checkINTR() regarding the priority of external h/w
         * interrupts vs. Trap interrupts, but they require different solutions, because our Debugger operates
         * independently of the CPU.
         *
         * One exception I make here is when you've asked the Debugger to display PIC messages, the idea being that
         * if you're watching the PIC that closely, then you want to hardware interrupts to occur regardless.
         */
        if (!nMinCycles && !this.messageEnabled(Messages.PIC)) this.opFlags |= X86.OPFLAG.NOINTR;

        do {
            let opPrefixes = this.opFlags & X86.OPFLAG_PREFIXES;
            if (opPrefixes) {
                this.opPrefixes |= opPrefixes;
            } else {
                /*
                 * opLIP is used, among other things, to help string instructions rewind to the first prefix
                 * byte whenever the instruction needs to be repeated.  Repeating string instructions in this
                 * manner (essentially restarting them) is a bit heavy-handed, but ultimately it's more compatible,
                 * because it allows hardware interrupts (as well as Trap processing and Debugger single-stepping)
                 * to occur at any point during the string operation, without any additional effort.
                 *
                 * NOTE: The way we restart string instructions actually fixes an 8086/8088 flaw, because string
                 * instructions with multiple prefixes (eg, a REP and a segment override) would not be restarted
                 * properly following a hardware interrupt.  The recommended workarounds were to either turn off
                 * interrupts or to follow the string instruction with a LOOPNZ back to the first prefix byte.
                 * To emulate the flawed behavior, turn on BUGS_8086.
                 */
                this.opLIP = this.regLIP;
                this.segData = this.segDS;
                this.segStack = this.segSS;
                this.regEA = this.regEAWrite = X86.ADDR_INVALID;

                if (I386 && (this.opPrefixes & (X86.OPFLAG.ADDRSIZE | X86.OPFLAG.DATASIZE))) {
                    this.resetSizes();
                }

                this.opPrefixes = this.opFlags & X86.OPFLAG.REPEAT;

                if (this.intFlags) {
                    if (this.checkINTR()) {
                        if (!nMinCycles) {

                            if (DEBUGGER) {
                                this.println("interrupt dispatched");
                                this.opFlags = 0;
                                break;
                            }
                        }
                    }
                    if (this.intFlags & X86.INTFLAG.HALT) {
                        /*
                         * As discussed in opHLT(), the CPU is never REALLY halted by a HLT instruction, because the
                         * entire machine relies on the steady advance of the overall cycle count, to ensure that timer
                         * updates, video updates, etc, all continue to occur at the expected rates.
                         *
                         * So opHLT() sets X86.INTFLAG.HALT, signalling that we should not execute any more instructions
                         * until checkINTR() detects a hardware interrupt and clears X86.INTFLAG.HALT.
                         *
                         * Ideally, we would also end the current burst; ie:
                         *
                         *      this.nStepCycles = 0;
                         *      this.opFlags = 0;
                         *      break;
                         *
                         * and save the browser a bunch of work, which would translate into power savings for the host
                         * operating system, just as HLT was intended to do for the guest operating system.  Unfortunately,
                         * that screws up up our dynamic speed recalculations, because it makes it appear that a single
                         * instruction (HLT) performed the work of many.
                         *
                         * We could certainly add more cycle bookkeeping to compensate for HLT's lack of work, but for now,
                         * it's simpler to re-execute the HLT as long as X86.INTFLAG.HALT is set.
                         */
                        X86.opHLT.call(this);
                        continue;
                    }
                }
            }

            if (DEBUGGER && fDebugCheck) {
                if (this.dbg.checkInstruction(this.regLIP, nDebugState)) {
                    this.stopCPU();
                    break;
                }
                nDebugState = 1;
            }

            this.opFlags = 0;

            /*
            if (DEBUG || PREFETCH) {
                this.nBusCycles = 0;
                this.nSnapCycles = this.nStepCycles;
            }
             */

            this.aOps[this.getIPByte()].call(this);

            /*
            if (PREFETCH) {
                let nSpareCycles = (this.nSnapCycles - this.nStepCycles) - this.nBusCycles;
                if (nSpareCycles >= 4) {
                    this.fillPrefetch(nSpareCycles >> 2);   // for every 4 spare cycles, fetch 1 instruction byte
                }
            }
             */

            /*
            if (DEBUG) {
                //
                // Make sure that every instruction is assessing a cycle cost, and that the cost is a net positive.
                //
                if (this.flags.complete && this.nStepCycles >= this.nSnapCycles && !(this.opFlags & X86.OPFLAG_PREFIXES)) {
                    this.println("cycle miscount: " + (this.nSnapCycles - this.nStepCycles));
                    this.setIP(this.opLIP - this.segCS.base);
                    this.stopCPU();
                    break;
                }
            }
             */

        } while (this.nStepCycles > 0);

        return (this.flags.complete? this.nBurstCycles - this.nStepCycles : (this.flags.complete === undefined? 0 : -1));
    }

    /**
     * setAddrSize(size)
     *
     * This is used by opcodes that require a particular ADDRESS size, which we enforce by
     * internally simulating an ADDRESS size override, if needed.
     *
     * @this {CPUX86}
     * @param {number} size (2 for 2-byte/16-bit operands, or 4 for 4-byte/32-bit operands)
     *
     setAddrSize(size)
     {
         if (this.sizeAddr != size) {
             this.opPrefixes |= X86.OPFLAG.ADDRSIZE;
             this.sizeAddr = size;
             this.maskAddr = (size == 2? 0xffff : (0xffffffff|0));
             this.updateAddrSize();
         }
     }
     */

    /**
     * getIPLong()
     *
     * @this {CPUX86}
     * @return {number} long at the current IP; IP advanced by 4
     *
     getIPLong()
     {
         let newLIP = this.checkIP(4);
         let l = (PREFETCH? this.getLongPrefetch() : this.getLong(this.regLIP));
         if (BACKTRACK) {
             this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
             this.bus.updateBackTrackCode(this.regLIP + 1, this.backTrack.btiMem1);
             this.bus.updateBackTrackCode(this.regLIP + 2, this.backTrack.btiMem2);
             this.bus.updateBackTrackCode(this.regLIP + 3, this.backTrack.btiMem3);
         }
         this.regLIP = newLIP;
         return l;
     }
     */

    /**
     * setDMA(fActive)
     *
     * This is called by the ChipSet component to update DMA status.
     *
     * @this {CPUX86}
     * @param {boolean} fActive is true to set INTFLAG.DMA, false to clear
     *
     setDMA(fActive)
     {
        if (this.chipset) {
            if (fActive) {
                this.intFlags |= X86.INTFLAG.DMA;
            } else {
                this.intFlags &= ~X86.INTFLAG.DMA;
            }
        }
    }
     */

    /**
     * CPUX86.init()
     *
     * This function operates on every HTML element of class "cpu", extracting the
     * JSON-encoded parameters for the CPUX86 constructor from the element's "data-value"
     * attribute, invoking the constructor (which in turn invokes the CPU constructor)
     * to create a CPUX86 component, and then binding any associated HTML controls to the
     * new component.
     */
    static init()
    {
        let aeCPUs = Component.getElementsByClass(document, PCX86.APPCLASS, "cpu");
        for (let iCPU = 0; iCPU < aeCPUs.length; iCPU++) {
            let eCPU = aeCPUs[iCPU];
            let parmsCPU = Component.getComponentParms(eCPU);
            let cpu = new CPUX86(parmsCPU);
            Component.bindComponentControls(cpu, eCPU, PCX86.APPCLASS);
        }
    }
}

if (PREFETCH) {
    /*
     * NOTE: CPUX86.PFINFO.LENGTH must be set to a power of two, so that LENGTH - 1 will form a mask
     * (IP_MASK) we can use to create a sliding prefetch window of LENGTH bytes.  We also zero the low
     * 2 bits of IP_MASK so that the sliding window always starts on a 32-bit (long) boundary.  Finally,
     * instead breaking breaking all the longs we prefetch into bytes, we simply store the longs as-is
     * into every 4th element of the queue (the queue is sparse array).
     */
    CPUX86.PFINFO = {
        LENGTH:     16              // 16 generates a 16-byte prefetch queue consisting of 4 32-bit entries
    };
    CPUX86.PFINFO.IP_MASK = ((CPUX86.PFINFO.LENGTH - 1) & ~0x3);
}

CPUX86.PAGEBLOCKS_CACHE = 512;      // TODO: This seems adequate for 4Mb of RAM, but it should be dynamically reconfigured

/*
 * Initialize every CPU module on the page
 */
Web.onInit(CPUX86.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/fpux86.js (C) Jeff Parsons 2012-2018
 */


/*
 * Operand Type Reference
 *
 *      ST(0), ST           stack top; the register currently at the top of the stack
 *      ST(i)               register in the stack i (0<=i<=7) stack elements from the top
 *      SR (short-real)     short real (32 bits) number in memory; exponent bias is 127 (0x7f)
 *      LR (long-real)      long real (64 bits) number in memory; exponent bias is 1023 (0x3ff)
 *      TR (temp-real)      temporary real (80 bits) number in memory; exponent bias is 16383 (0x3fff)
 *      PD (packed-decimal) packed decimal integer (18 digits, 10 bytes) in memory
 *      WI (word-integer)   word binary integer (16 bits) in memory
 *      SI (short-integer)  short binary integer (32 bits) in memory
 *      LI (long-integer)   long binary integer (64 bits) in memory
 *      NN (nn-bytes)       memory area nn bytes long
 *
 * FPU Coprocessor Trivia
 *
 *      Microsoft C 4.00 libraries executed software interrupts in the range 0x34-0x3B immediately after
 *      FPU operations, to assist with floating-point emulation when no coprocessor was present, since
 *      processors prior to the 80286 had no mechanism for generating a fault when an unsupported FPU
 *      instruction was executed.
 *
 *      In short, INT 0x34 through INT 0x3B was used after ESC opcodes 0xD8 through 0xDF, INT 0x3C was
 *      used for FPU instructions containing a segment override, and INT 0x3D was used for FWAIT.
 *
 *      A sample piece of code is available in x86ops.js, because it also highlights the Microsoft C 4.00
 *      library's dependency on the 8086/8088 behavior of "PUSH SP" (see the opPUSHSP_8086() function).
 */

/**
 * @class FPUX86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class FPUX86 extends Component {
    /**
     * FPUX86(parmsFPU)
     *
     * The FPUX86 class uses the following (parmsFPU) properties:
     *
     *      model: a number (eg, 8087) that should match one of the X86.FPU.MODEL values (default is 8087)
     *      stepping: a string (eg, "B1") that should match one of the X86.FPU.STEPPING values (default is "")
     *
     * @this {FPUX86}
     * @param {Object} parmsFPU
     */
    constructor(parmsFPU)
    {
        super("FPU", parmsFPU);

        this.model = parmsFPU['model'] || X86.FPU.MODEL_8087;

        /*
         * We take the 'stepping' value, convert it to a hex value, and then add that to the model to provide
         * a single value that's unique for any given CPU stepping.  If no stepping is provided, then stepping
         * is equal to model.
         */
        let stepping = parmsFPU['stepping'];
        this.stepping = this.model + (stepping? Str.parseInt(stepping, 16) : 0);

        /*
         * Perform a one-time allocation of all floating-point registers.
         * NOTE: The FPU's internal registers are supposed to be 80-bit, but JavaScript gives us only 64-bit floats.
         */
        this.regStack = new Float64Array(8);
        this.intStack = new Int32Array(this.regStack.buffer);

        /*
         * Used for "short-real" (SR) 32-bit floating-point operations.
         */
        this.regTmpSR = new Float32Array(1);
        this.intTmpSR = new Int32Array(this.regTmpSR.buffer);

        /*
         * Used for "long-real" (LR) 64-bit floating-point operations.  We also use intTmpLR as temporary storage
         * for all "word-integer" (WI or INT16), "short-integer" (SI or INT32) and "long-integer" (LI or INT64) values,
         * since it's just large enough to accommodate all three integer sizes.
         */
        this.regTmpLR = new Float64Array(1);
        this.intTmpLR = new Int32Array(this.regTmpLR.buffer);

        /*
         * Used for conversion to/from the 80-bit "temp-real" (TR) format; used as three 32-bit integers,
         * where [0] contains TR bits 0-31, [1] contains TR bits 32-63, and [2] contains TR bits 64-79; the
         * upper 16 bits of [2] are not used and should remain zero.
         */
        this.intTmpTR = new Array(3);

        /*
         * Initialize other (non-floating-point) coprocessor registers that resetFPU() doesn't touch,
         * such as the "exception" registers: regCodeSel, regCodeOff, regDataSel, regDataOff, and regOpcode.
         *
         * Note that regCodeSel and regDataSel are NEVER set in real-mode and are ALWAYS set in protected-mode,
         * so we set them to -1 in their "unset" state; if those values ever show up in an exception block,
         * something may have gone amiss (it's not impossible though, because if an exception occurs before any
         * memory operands have been used, regDataSel may still be "unset").
         *
         * NOTE: iStack is the low 3 bits of the bModRM byte, for instructions that have an explicit stack operand.
         */
        this.regCodeSel = this.regDataSel = -1;
        this.regCodeOff = this.regDataOff = this.regOpcode = this.iStack = 0;

        /*
         * Initialize special floating-point constants, as if they were internal read-only registers;
         * all other simple (non-special) constants are "statically" initialized below, as class constants.
         */
        this.regIndefinite = new Float64Array(1);
        this.intIndefinite = new Int32Array(this.regIndefinite.buffer);
        this.intIndefinite[0] = 0x00000000; this.intIndefinite[1] = 0xFFF8000;

        /*
         * Initialize all other coprocessor registers (control word, tag word, status word, etc) by resetting them.
         */
        this.resetFPU();
        /**
         * setEAFromSR()
         *
         * Stores the (32-bit) "short-real" value in the internal regTmpSR register to the address in regEA.
         *
         * @this {FPUX86}
         */
        this.setEAFromSR = FPUX86.prototype.setEAFromSI;
        /**
         * setEAFromLR()
         *
         * Stores the (64-bit) "long-real" value in the internal regTmpLR register to the address in regEA.
         *
         * @this {FPUX86}
         */
        this.setEAFromLR = FPUX86.prototype.setEAFromLI;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {FPUX86}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cpu = cpu;
        this.chipset = cmp.getMachineComponent("ChipSet");
        this.setReady();
    }

    /**
     * clearBusy()
     *
     * The ChipSet calls us whenever an I/O operation that clears the coprocessor's "busy" state is performed.
     *
     * @this {FPUX86}
     */
    clearBusy()
    {
        /*
         * We're never "busy" as far as other components are concerned, because we perform all FPU operations
         * synchronously, so there's nothing to do here.
         */
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {FPUX86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.resetFPU();
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {FPUX86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * save()
     *
     * This implements save support for the FPUX86 component.
     *
     * @this {FPUX86}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        let a = [], i = 0;
        a[i++] = this.regControl;
        a[i++] = this.getStatus();
        a[i++] = this.getTags();
        /*
         * Note that, unlike the FSAVE() and FRSTOR() operations, we save the registers in regStack in their physical
         * order (0-7) rather than their logical order (ST0-ST7).  Moreover, FSAVE() and FRSTOR() use the "temp-real" (TR)
         * format, whereas we use the current native format -- which, sadly, is only a 64-bit "long-real" (LR) format.
         */
        for (let iReg = 0; iReg < this.regStack.length; iReg++) {
            a[i++] = this.regStack[iReg];
        }
        state.set(0, a);
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the FPUX86 component.
     *
     * @this {FPUX86}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        let a = data[0], i = 0;
        this.setControl(a[i++]);
        this.setStatus(a[i++]);
        this.setTags(a[i++]);
        for (let iReg = 0; iReg < this.regStack.length; iReg++) {
            this.regStack[iReg] = a[i++];
        }
        return true;
    }

    /**
     * resetFPU()
     *
     * Aside from calling this internally (eg, during initialization and FINIT operations), the ChipSet may also call
     * us whenever an I/O operation that resets the coprocessor is performed.  Only 80487 coprocessors and higher will
     * also clear the "exception" registers, but the 80487 is currently beyond my planned level of support.
     *
     * TODO: Add support for X86.FPU.CONTROL.PC (Precision Control) and X86.FPU.CONTROL.IC (Infinity Control)
     *
     * @this {FPUX86}
     */
    resetFPU()
    {
        this.regUsed = 0;           // bits 0-7 are set as regs 0-7 are used
        this.regControl = X86.FPU.CONTROL.INIT;
        this.regStatus = 0;         // contains all status register bits EXCEPT for ST
        this.iST = 0;               // the ST bits for regStatus are actually stored here
        if (DEBUG) {
            /*
             * All the registers were tagged "unused" above, which is all that would normally happen, but debugging is
             * a little easier if we zero all the registers as well.
             */
            for (let iReg = 0; iReg < this.regStack.length; iReg++) {
                this.regStack[iReg] = 0.0;
            }
        }
        if (this.chipset) this.chipset.clearFPUInterrupt();
    }

    /**
     * isModel(model)
     *
     * If the current model is equal to the specified model, then it's assumed the current operation
     * is supported, and we return true.
     *
     * @this {FPUX86}
     * @param {number} model
     * @return {boolean}
     */
    isModel(model)
    {
        return this.model == model;
    }

    /**
     * isAtLeastModel(model)
     *
     * If the current model is greater than or equal to the specified model, then it's assumed that the
     * current operation is supported, and we return true.
     *
     * @this {FPUX86}
     * @param {number} model
     * @return {boolean}
     */
    isAtLeastModel(model)
    {
        return this.model >= model;
    }

    /**
     * opStop(fError)
     *
     * Place this inside any opcode handler to stop the CPU from running the current instruction; eg:
     *
     *      if (this.opStop()) return;
     *
     * You can still use the Debugger to single-step over the instruction; opStop() will return false in that case.
     *
     * @this {FPUX86}
     * @param {boolean} [fError]
     * @return {boolean} (true if there was an error or the CPU was running, false if not)
     */
    opStop(fError)
    {
        if (DEBUG) {
            let cpu = this.cpu;
            if (fError || cpu.isRunning()) {
                cpu.setIP(cpu.opLIP - cpu.segCS.base);
                cpu.stopCPU();
                return true;
            }
        }
        return false;
    }

    /**
     * opNone()
     *
     * Used for any coprocessor opcode that has no known operation for the given model.
     *
     * @this {FPUX86}
     */
    opNone()
    {
        if (DEBUG) this.println(this.idComponent + ".opNone(" + Str.toHexByte(this.cpu.bOpcode) + "," + Str.toHexByte(this.cpu.bModRM) + ")");
        this.opStop(true);
    }

    /**
     * opObsolete()
     *
     * Used for any coprocessor opcodes that are redundant and potentially obsolete.
     *
     * @this {FPUX86}
     */
    opObsolete()
    {
        if (DEBUG) this.println(this.idComponent + ".opObsolete(" + Str.toHexByte(this.cpu.bOpcode) + "," + Str.toHexByte(this.cpu.bModRM) + ")");
        this.opStop(true);
    }

    /**
     * opUnimplemented()
     *
     * Used for any coprocessor opcode that DOES have a known operation, we just haven't implemented it yet.
     *
     * @this {FPUX86}
     */
    opUnimplemented()
    {
        if (DEBUG) this.println(this.idComponent + ".opUnimplemented(" + Str.toHexByte(this.cpu.bOpcode) + "," + Str.toHexByte(this.cpu.bModRM) + ")");
        this.opStop(true);
    }

    /**
     * checkException()
     *
     * @this {FPUX86}
     * @return {boolean} (true if unmasked exception exists, false if not)
     */
    checkException()
    {
        this.regStatus &= ~X86.FPU.STATUS.ES;
        /*
         * NOTE: The "Stack Fault" (SF) status bit wasn't introduced until the 80387, so it triggers the pre-existing
         * "Invalid Operation" (IE) exception; there is no corresponding "Stack Fault" (SE) exception, and the matching
         * control bit is still reserved.  Consequently, X86.FPU.CONTROL.EXC is a *subset* of X86.FPU.STATUS.EXC (0x3F
         * instead of 0x7F).
         *
         * However, we shouldn't have to do anything special when SF is set, because any setException() call that sets
         * SF should ALSO set IE.
         */
        if (this.regStatus & (~this.regControl & X86.FPU.CONTROL.EXC)) {
            this.regStatus |= X86.FPU.STATUS.ES;    // set ES whenever one or more unmasked EXC bits are set
        }
        if ((this.regStatus & X86.FPU.STATUS.ES) && !(this.regControl & X86.FPU.CONTROL.IEM)) {
            this.chipset.setFPUInterrupt();
            return true;
        }
        this.chipset.clearFPUInterrupt();
        return false;
    }

    /**
     * setException(n)
     *
     * Sets one or more of the FPU.STATUS.ECX bits; ie:
     *
     *      IE (0x0001 bit 0: Invalid Operation)
     *      DE (0x0002 bit 1: Denormalized Operand)
     *      ZE (0x0004 bit 2: Zero Divide)
     *      OE (0x0008 bit 3: Overflow)
     *      UE (0x0010 bit 4: Underflow)
     *      PE (0x0020 bit 5: Precision)
     *      SF (0x0040 bit 6: Stack Fault; 80387 and later)
     *
     * Also, as noted in checkException(), any time you set the SF bit, you should also set the IE bit, because
     * Stack Fault is a subset of Invalid Operation.  TODO: We should include a test for that in the assertion below.
     *
     * @this {FPUX86}
     * @param {number} n (one or more of the above error status bits)
     * @return {boolean} (true if unmasked exception exists, false if not)
     */
    setException(n)
    {
        if (DEBUG) this.println(this.idComponent + ".setException(" + Str.toHexWord(n) + ")");

        if (!this.isAtLeastModel(X86.FPU.MODEL_80387)) {
            n &= ~X86.FPU.STATUS.SF;                // the SF bit didn't exist on pre-80387 coprocessors
        }

        this.regStatus |= n;
        return this.checkException();
    }

    /**
     * getControl()
     *
     * @this {FPUX86}
     * @return {number}
     */
    getControl()
    {
        return this.regControl;
    }

    /**
     * setControl(n)
     *
     * NOTE: Be sure to use this function for all "wholesale" regControl updates, because it ensures that
     * unused bits cannot be set -- including bit 6, which could otherwise inadvertently mask the SF error
     * condition on 80387 and newer coprocessors.
     *
     * @this {FPUX86}
     * @param {number} n
     */
    setControl(n)
    {
        this.regControl = n & ~X86.FPU.CONTROL.UNUSED;
    }

    /**
     * clearStatus(n)
     *
     * @this {FPUX86}
     * @param {number} n
     */
    clearStatus(n)
    {
        this.regStatus &= ~n;
        this.checkException();
    }

    /**
     * getStatus()
     *
     * @this {FPUX86}
     * @return {number} regStatus merged with iST
     */
    getStatus()
    {
        /*
         * As long as we never store any ST bits in regStatus, they should always be zero, so in
         * order to return the complete regStatus, all we need to do is shift and "or" the bits from iST.
         */
        return this.regStatus | (this.iST << X86.FPU.STATUS.ST_SHIFT);
    }

    /**
     * setStatus(n)
     *
     * NOTE: Be sure to use this function for all "wholesale" regStatus updates, because it ensures that
     * the ST bits get propagated to the internal iST register.  Setting individual EXC bits should be done
     * through the fault() interface, and clearing individual EXC or BUSY bits should be done through
     * clearStatus().  Both functions, including this function, call checkException() after updating regStatus.
     *
     * @this {FPUX86}
     * @param {number} n
     */
    setStatus(n)
    {
        this.regStatus = n & ~X86.FPU.STATUS.ST;
        this.iST = (n & X86.FPU.STATUS.ST) >> X86.FPU.STATUS.ST_SHIFT;
        this.checkException();
    }

    /**
     * checkOperand(v)
     *
     * @this {FPUX86}
     * @param {number|null} v
     * @return {boolean} (true if no exception, false otherwise)
     */
    checkOperand(v)
    {
        return isNaN(v)? !this.setException(X86.FPU.STATUS.IE) : true;
    }

    /**
     * checkResult(v)
     *
     * @this {FPUX86}
     * @param {number} v
     * @return {boolean} (true if no exception, false otherwise)
     */
    checkResult(v)
    {
        return !isFinite(v)? !this.setException(v === Infinity? X86.FPU.STATUS.OE : X86.FPU.STATUS.UE) : true;
    }

    /**
     * doAdd(operand1, operand2)
     *
     * @this {FPUX86}
     * @param {number|null} operand1
     * @param {number|null} operand2
     * @return {number|null}
     */
    doAdd(operand1, operand2)
    {
        let result = null;
        if (operand1 != null && operand2 != null) {
            result = operand1 + operand2;
            if (!this.checkResult(result)) result = null;
        }
        return result;
    }

    /**
     * doSubtract(operand1, operand2)
     *
     * @this {FPUX86}
     * @param {number|null} operand1
     * @param {number|null} operand2
     * @return {number|null}
     */
    doSubtract(operand1, operand2)
    {
        let result = null;
        if (operand1 != null && operand2 != null) {
            result = operand1 - operand2;
            if (!this.checkResult(result)) result = null;
        }
        return result;
    }

    /**
     * doMultiply(operand1, operand2)
     *
     * @this {FPUX86}
     * @param {number|null} operand1
     * @param {number|null} operand2
     * @return {number|null}
     */
    doMultiply(operand1, operand2)
    {
        let result = null;
        if (operand1 != null && operand2 != null) {
            result = operand1 * operand2;
            if (!this.checkResult(result)) result = null;
        }
        return result;
    }

    /**
     * doDivide(dividend, divisor)
     *
     * TODO: IE exceptions: infinity / infinity, 0 / 0, 0 / pseudo-zero, or divisor is denormal or unnormal.
     *
     * @this {FPUX86}
     * @param {number|null} dividend
     * @param {number|null} divisor
     * @return {number|null}
     */
    doDivide(dividend, divisor)
    {
        let quotient = null;
        if (dividend != null && divisor != null) {
            if (divisor || !this.setException(X86.FPU.STATUS.DE)) {
                quotient = dividend / divisor;
                if (!this.checkResult(quotient)) quotient = null;
            }
        }
        return quotient;
    }

    /**
     * doCompare(operand1, operand2)
     *
     * @this {FPUX86}
     * @param {number|null} operand1
     * @param {number|null} operand2
     * @return {boolean}
     */
    doCompare(operand1, operand2)
    {
        if (operand1 != null && operand2 != null) {
            let cc = 0;             // default value used when result > 0
            if (!isNaN(operand1) && !isNaN(operand2)) {
                let result = operand1 - operand2;
                if (result < 0) {
                    cc = X86.FPU.STATUS.C0;
                } else if (result === 0) {
                    cc = X86.FPU.STATUS.C3;
                }
            } else {
                cc = X86.FPU.STATUS.C0 | X86.FPU.STATUS.C2 | X86.FPU.STATUS.C3;
            }
            this.regStatus = (this.regStatus & ~X86.FPU.STATUS.CC) | cc;
            return true;
        }
        return false;
    }

    /**
     * doSquareRoot(operand)
     *
     * @this {FPUX86}
     * @param {number|null} operand
     * @return {number|null}
     */
    doSquareRoot(operand)
    {
        let result = null;
        /*
         * Happily, -0 is ALSO >= 0.  Also happily, Math.sqrt(-0) returns -0.
         */
        if (operand >= 0 || !this.setException(X86.FPU.STATUS.IE)) {
            result = Math.sqrt(operand);
            if (!this.checkResult(result)) result = null;
        }
        return result;
    }

    /**
     * roundValue(operand, max)
     *
     * NOTE: The max parameter is EXCLUSIVE, not inclusive (ie, the maximum positive value is < max).
     *
     * Also, callers that expect intTmpLR[] to be loaded with the result *must* also specify a max parameter;
     * callers performing internal rounding and using just the return value may omit max to skip loading intTmpLR[].
     *
     * @this {FPUX86}
     * @param {number|null} operand
     * @param {number} [max] (ie, 0x8000, 0x80000000, or 0x8000000000000000)
     * @return {number|null} (rounded result, or null if there was an unmasked exception)
     */
    roundValue(operand, max)
    {
        if (operand == null) return null;

        let rc = (this.regControl & X86.FPU.CONTROL.RC.MASK), result;

        if (rc == X86.FPU.CONTROL.RC.NEAR) {
            result = Math.round(operand);
            if (result - operand === 0.5 && (result % 2)) result--;
        }
        else if (rc == X86.FPU.CONTROL.RC.DOWN || rc == X86.FPU.CONTROL.RC.CHOP && operand > 0) {
            result = Math.floor(operand);
        }
        else {  // X86.FPU.CONTROL.RC.UP or X86.FPU.CONTROL.RC.CHOP && operand <= 0
            result = Math.ceil(operand);
        }

        if (max) {
            if (result >= max) {
                if (this.setException(X86.FPU.STATUS.IE)) return null;
                result = -max;      // apparently, the masked response is to return the most negative integer (not max - 1)
            }
            else if (result < -max) {
                if (this.setException(X86.FPU.STATUS.IE)) return null;
                result = -max;
            }
            this.intTmpLR[0] = result|0;
            if (max > FPUX86.MAX_INT32) {
                this.intTmpLR[1] = (result / 0x100000000)|0;
                if (!this.intTmpLR[1] && result < 0) this.intTmpLR[1] = -1;
            }
        }
        return result;
    }

    /**
     * truncateValue(v)
     *
     * @this {FPUX86}
     * @param {number} v
     * @return {number}
     */
    truncateValue(v)
    {
        return v > 0? Math.floor(v) : Math.ceil(v);
    }

    /**
     * getTag(iReg)
     *
     * @this {FPUX86}
     * @param {number} iReg (register index)
     * @return {number} tag value for register
     */
    getTag(iReg)
    {
        let bitUsed = (1 << iReg);
        let tag = X86.FPU.TAGS.EMPTY;
        if (this.regUsed & bitUsed) {
            let f = this.regStack[iReg];
            tag = X86.FPU.TAGS.VALID;
            if (f === 0.0) {
                tag = X86.FPU.TAGS.ZERO;
            }
            else if (!isFinite(f)) {
                tag = X86.FPU.TAGS.SPECIAL;
            }
        }
        return tag;
    }

    /**
     * getTags()
     *
     * @this {FPUX86}
     * @return {number} tag values for all registers
     */
    getTags()
    {
        let tags = 0;
        for (let iReg = this.regStack.length - 1; iReg >= 0; iReg--) {
            tags <<= 2;
            tags |= this.getTag(iReg);
        }
        return tags;
    }

    /**
     * setTag(iReg, tag)
     *
     * @this {FPUX86}
     * @param {number} iReg (register index)
     * @param {number} tag value for register (EMPTY is the only supported value)
     */
    setTag(iReg, tag)
    {

        this.regUsed &= ~(1 << iReg);
    }

    /**
     * setTags(n)
     *
     * All we need to update here are which physical registers are marked "empty"; the rest of the tags
     * are generated on the fly based on actual values in the registers.
     *
     * @this {FPUX86}
     * @param {number} n (16-bit tag word, containing 8 2-bit tags)
     */
    setTags(n)
    {
        this.regUsed = 0;
        for (let bitUsed = 0x1; bitUsed <= 0x80; bitUsed <<= 1) {
            let tag = n & X86.FPU.TAGS.MASK;
            if (tag != X86.FPU.TAGS.EMPTY) {
                this.regUsed |= bitUsed;
            }
            n >>= 2;
        }
    }

    /**
     * getWI(i)
     *
     * Gets a "word-integer" (WI aka INT16) from ST(i)
     *
     * @this {FPUX86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @return {boolean} true if intTmpLR was loaded, false if not
     */
    getWI(i)
    {
        return this.roundValue(this.getST(i), FPUX86.MAX_INT16) != null;
    }

    /**
     * getSI(i)
     *
     * Gets a "short-integer" (SI aka INT32) from ST(i)
     *
     * @this {FPUX86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @return {boolean} true if intTmpLR was loaded, false if not
     */
    getSI(i)
    {
        return this.roundValue(this.getST(i), FPUX86.MAX_INT32) != null;
    }

    /**
     * getLI(i)
     *
     * Gets a "long-integer" (LI aka INT64) from ST(i)
     *
     * @this {FPUX86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @return {boolean} true if intTmpLR was loaded, false if not
     */
    getLI(i)
    {
        return this.roundValue(this.getST(i), FPUX86.MAX_INT64) != null;
    }

    /**
     * getSR(i)
     *
     * @this {FPUX86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @return {boolean} true if regTmpSR was loaded, false if not
     */
    getSR(i)
    {
        let iReg = (this.iST + i) & 7;
        if (this.regUsed & (1 << iReg)) {
            this.regTmpSR[0] = this.regStack[iReg];
            return true;
        } else if (!this.setException(X86.FPU.STATUS.IE)) {
            this.regTmpSR[0] = this.regIndefinite[0];
            return true;
        }
        return false;
    }

    /**
     * getLR(i)
     *
     * @this {FPUX86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @return {boolean} true if regTmpLR was loaded, false if not
     */
    getLR(i)
    {
        let iReg = (this.iST + i) & 7;
        if (this.regUsed & (1 << iReg)) {
            this.regTmpLR[0] = this.regStack[iReg];
            return true;
        } else if (!this.setException(X86.FPU.STATUS.IE)) {
            this.regTmpLR[0] = this.regIndefinite[0];
            return true;
        }
        return false;
    }

    /**
     * getST(i)
     *
     * @this {FPUX86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @return {number|null} v
     */
    getST(i)
    {
        let v = null;
        let iReg = (this.iST + i) & 7;
        if (this.regUsed & (1 << iReg)) {
            v = this.regStack[iReg];
        } else if (!this.setException(X86.FPU.STATUS.IE)) {
            v = this.regIndefinite[0];
        }
        return v;
    }

    /**
     * getSTSign(i)
     *
     * Returns zero if sign bit clear, and non-zero (negative) if sign bit set.  This is safer
     * than comparing getST() to zero, because JavaScript comparisons involving NaNs are meaningless.
     *
     * For internal use only; ignores whether the register is empty, and performs no exception checks.
     *
     * @this {FPUX86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @return {number}
     */
    getSTSign(i)
    {
        let iInt = ((this.iST + i) & 7) << 1;
        return this.intStack[iInt + 1] & (0x80000000|0);
    }

    /**
     * setST(i, v)
     *
     * @this {FPUX86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @param {number|null} v
     * @return {boolean}
     */
    setST(i, v)
    {
        if (v != null && this.checkOperand(v)) {
            let iReg = (this.iST + i) & 7;
            this.regStack[iReg] = v;
            this.regUsed |= (1 << iReg);
            return true;
        }
        return false;
    }

    /**
     * getTR(i, fSafe)
     *
     * @this {FPUX86}
     * @param {number} i (stack index, 0-7)
     * @param {boolean} [fSafe] (true to ignore all exception criteria; used by FSAVE)
     * @return {Array.<number>|null} ("temp-real" aka TR, as an array of three 32-bit integers)
     */
    getTR(i, fSafe)
    {
        let a = null;
        let iReg = (this.iST + i) & 7;
        if (fSafe || this.regUsed & (1 << iReg) || !this.setException(X86.FPU.STATUS.IE)) {
            let iInt = iReg << 1;
            a = this.getTRFromLR(this.intStack[iInt], this.intStack[iInt + 1]);
        }
        return a;
    }

    /**
     * setTR(i, a)
     *
     * Sets ST(i) to the TR ("long-real") in a[].
     *
     * @this {FPUX86}
     * @param {number} i (stack index, 0-7)
     * @param {Array.<number>|null} a
     */
    setTR(i, a)
    {
        if (a) this.setST(i, this.getLRFromTR(a));
    }

    /**
     * getWIFromEA()
     *
     * Returns the (16-bit) "word-integer" value located at regEA.
     *
     * @this {FPUX86}
     * @return {number} v
     */
    getWIFromEA()
    {

        return (this.cpu.getShort(this.cpu.regEA) << 16) >> 16;
    }

    /**
     * getSIFromEA()
     *
     * Returns the (32-bit) "short-integer" value located at regEA.
     *
     * @this {FPUX86}
     * @return {number} v
     */
    getSIFromEA()
    {

        return this.cpu.getLong(this.cpu.regEA);
    }

    /**
     * getLIFromEA()
     *
     * Returns the (64-bit) "long-integer" value located at regEA.
     *
     * @this {FPUX86}
     * @return {number} v
     */
    getLIFromEA()
    {

        let lo = this.cpu.getLong(this.cpu.regEA);
        let hi = this.cpu.getLong(this.cpu.regEA + 4);
        return (hi * 0x100000000) + (lo >>> 0);
    }

    /**
     * getSRFromEA()
     *
     * Sets the internal regTmpSR register to the (32-bit) "short-real" value located at regEA.
     *
     * @this {FPUX86}
     * @return {number} v
     */
    getSRFromEA()
    {

        this.intTmpSR[0] = this.cpu.getLong(this.cpu.regEA);
        return this.regTmpSR[0];
    }

    /**
     * getLRFromEA()
     *
     * Sets the internal regTmpLR register to the (64-bit) "long-real" value located at regEA.
     *
     * @this {FPUX86}
     * @return {number} v
     */
    getLRFromEA()
    {

        this.intTmpLR[0] = this.cpu.getLong(this.cpu.regEA);
        this.intTmpLR[1] = this.cpu.getLong(this.cpu.regEA + 4);
        return this.regTmpLR[0];
    }

    /**
     * getTRFromEA()
     *
     * Sets the internal intTmpTR register to the (80-bit) "temp-real" value located at regEA.
     *
     * @this {FPUX86}
     * @return {Array.<number>} intTmpTR
     */
    getTRFromEA()
    {

        this.intTmpTR[0] = this.cpu.getLong(this.cpu.regEA);
        this.intTmpTR[1] = this.cpu.getLong(this.cpu.regEA + 4);
        this.intTmpTR[2] = this.cpu.getShort(this.cpu.regEA + 8);
        return this.intTmpTR;
    }

    /**
     * setEAFromWI()
     *
     * Stores the (16-bit) "word-integer" value in the internal intTmpLR register to the address in regEA.
     *
     * @this {FPUX86}
     */
    setEAFromWI()
    {

        this.cpu.setShort(this.cpu.regEA, this.intTmpLR[0]);
    }

    /**
     * setEAFromSI()
     *
     * Stores the (32-bit) "short-integer" value in the internal intTmpLR register to the address in regEA.
     *
     * @this {FPUX86}
     */
    setEAFromSI()
    {

        this.cpu.setLong(this.cpu.regEA, this.intTmpLR[0]);
    }

    /**
     * setEAFromLI()
     *
     * Stores the (64-bit) "long-integer" value in the internal intTmpLR register to the address in regEA.
     *
     * @this {FPUX86}
     */
    setEAFromLI()
    {

        this.cpu.setLong(this.cpu.regEA, this.intTmpLR[0]);
        this.cpu.setLong(this.cpu.regEA + 4, this.intTmpLR[1]);
    }

    /**
     * setEAFromTR()
     *
     * Stores the (80-bit) "temp-real" value in the internal intTmpTR register to the address in regEA.
     *
     * @this {FPUX86}
     */
    setEAFromTR()
    {

        this.cpu.setLong(this.cpu.regEA, this.intTmpTR[0]);
        this.cpu.setLong(this.cpu.regEA + 4, this.intTmpTR[1]);
        this.cpu.setShort(this.cpu.regEA + 8, this.intTmpTR[2]);
    }

    /**
     * getLRFromTR(a)
     *
     * Since we must use the "long-real" (64-bit) format internally, rather than the "temp-real" (80-bit) format,
     * this function converts a 64-bit value to an 80-bit value.  The major differences: 1) the former uses a 52-bit
     * fraction and 11-bit exponent, while the latter uses a 64-bit fraction and 15-bit exponent; 2) the former
     * does NOT store a leading 1 with the fraction, whereas the latter does.
     *
     * @this {FPUX86}
     * @param {Array.<number>} a (eg, intTmpTR)
     * @return {number} v
     */
    getLRFromTR(a)
    {
        let loTR = a[0], hiTR = a[1];
        let signLR = (a[2] & 0x8000) >> 4, expLR = a[2] & 0x7fff;
        /*
         * We have no choice but to chop off the bottom 11 TR bits in order to fit in an LR....
         */
        let loLR = (loTR >>> 11) | (hiTR << 21), hiLR = (hiTR >> 11) & 0xfffff;

        if (expLR == 0x7fff) {
            /*
             * Convert an TR NaN to a LR NaN.
             */
            expLR = 0x7ff;
        }
        else if (expLR) {
            /*
             * We have a normal (biased) TR exponent which we must now convert to a (biased) LR exponent;
             * subtract the TR bias (0x3fff) and add the LR bias (0x3ff); additionally, we have a problem
             * that getTRFromLR() did not: if the TR exponent is too large to fit in an LR exponent, then we
             * have convert the result to +/- infinity.
             */
            expLR += 0x3ff - 0x3fff;
            if (expLR <= 0) {
                expLR = 0x7ff;
                loLR = hiLR = 0;
            }
        }

        this.intTmpLR[0] = loLR;
        this.intTmpLR[1] = hiLR | ((signLR | expLR) << 20);
        return this.regTmpLR[0];
    }

    /**
     * getTRFromLR(loLR, hiLR)
     *
     * Since we must use the "long-real" (64-bit) format internally, rather than the "temp-real" (80-bit) format,
     * this function converts a 64-bit value to an 80-bit value.  The major differences: 1) the former uses a 52-bit
     * fraction and 11-bit exponent, while the latter uses a 64-bit fraction and 15-bit exponent; 2) the former
     * does NOT store a leading 1 with the fraction, whereas the latter does.
     *
     * @this {FPUX86}
     * @param {number} loLR
     * @param {number} hiLR
     * @return {Array.<number>} (intTmpTR)
     */
    getTRFromLR(loLR, hiLR)
    {
        let expTR = (hiLR >> 20) & 0x07ff;
        let signTR = (hiLR >> 16) & 0x8000;
        let loTR = loLR << 11, hiTR = 0x80000000 | ((hiLR & 0x000fffff) << 11) | (loLR >>> 21);

        if (expTR == 0x07ff) {
            /*
             * Convert an LR NaN to a TR NaN.  NaNs encompass +/- infinity, which in the LR
             * world are fractions of all zeros.  NaNs also encompass indefinite, which in the LR
             * world are negative numbers with only the high fraction bit set.  So, in both cases,
             * our default TR value (ie, with zeros shifted into the bottom 11 bits) should be fine;
             * we simply need to change the exponent to the maximum TR value.
             */
            expTR = 0x7fff;
        }
        else if (!expTR) {
            /*
             * An LR with an exponent of zero could be an actual +/- zero, if the fraction is zero,
             * or it could be a denormal, if the fraction is non-zero.  In both cases, the only
             * change we need to make the TR form is clearing the leading 1 bit.
             */
            hiTR &= 0x7fffffff;
        }
        else {
            /*
             * We have a normal (biased) LR exponent which we must now convert to a (biased) TR exponent;
             * subtract the LR bias (0x3ff) and add the TR bias (0x3fff).
             */
            expTR += 0x3fff - 0x3ff;
        }

        this.intTmpTR[0] = loTR;
        this.intTmpTR[1] = hiTR;
        this.intTmpTR[2] = signTR | expTR;
        return this.intTmpTR;
    }

    /**
     * decodeBCD()
     *
     * @this {FPUX86}
     * @param {number} i (32-bit integer containing n BCD digits)
     * @param {number} n (number of BCD digits to decode)
     * @return {number} (binary value representing the specified number of BCD digits)
     */
    decodeBCD(i, n)
    {
        let v = 0, m = 1;

        while (n--) {
            let d = i & 0xf;

            v += d * m;
            m *= 10;
            i >>= 4;
        }
        return v;
    }

    /**
     * encodeBCD()
     *
     * @this {FPUX86}
     * @param {number} v (binary value from which to extract n BCD digits)
     * @param {number} n (number of BCD digits to extract)
     * @return {number} (integer containing the requested number of BCD digits)
     */
    encodeBCD(v, n)
    {
        let i = 0, s = 0;

        while (n--) {
            i |= (v % 10) << s;
            v /= 10;
            s += 4;
        }
        return i;
    }

    /**
     * popValue()
     *
     * @this {FPUX86}
     * @return {number|null} v
     */
    popValue()
    {
        let v = null;
        let bitUsed = (1 << this.iST);
        if (!(this.regUsed & bitUsed)) {
            this.regStatus &= ~X86.FPU.STATUS.C1;       // clear C1 to indicate stack underflow (80287XL and up)
            if (this.setException(X86.FPU.STATUS.SF | X86.FPU.STATUS.IE)) return v;
        }
        this.regUsed &= ~bitUsed;
        v = this.regStack[this.iST];
        this.iST = (this.iST + 1) & 7;
        return v;
    }

    /**
     * pushValue(v)
     *
     * @this {FPUX86}
     * @param {number|null} v
     */
    pushValue(v)
    {
        if (v == null) return;
        let iReg = (this.iST - 1) & 7;
        let bitUsed = (1 << iReg);
        if (this.regUsed & bitUsed) {
            this.regStatus |= X86.FPU.STATUS.C1;        // set C1 to indicate stack overflow (80287XL and up)
            if (this.setException(X86.FPU.STATUS.SF | X86.FPU.STATUS.IE)) return;
        }
        if (!this.checkOperand(v)) {
            if (this.setException(X86.FPU.STATUS.IE)) return;
            v = NaN;
        }
        this.regStack[this.iST = iReg] = v;
        this.regUsed |= bitUsed;
    }

    /**
     * loadEnv(addr)
     *
     * @this {FPUX86}
     * @param {number} addr
     * @return {number} updated addr
     */
    loadEnv(addr)
    {
        let w;
        let cpu = this.cpu;

        this.setControl(cpu.getWord(addr));
        this.setStatus(cpu.getWord(addr += cpu.sizeData));
        this.setTags(cpu.getWord(addr += cpu.sizeData));

        if (!(cpu.regCR0 & X86.CR0.MSW.PE) || (cpu.regPS & X86.PS.VM)) {
            this.regCodeOff = cpu.getWord(addr += cpu.sizeData);
            w = cpu.getWord(addr += cpu.sizeData);
            this.regOpcode = w & 0x7ff;
            this.regCodeOff |= (w & ~0xfff) << 4;
            this.regCodeSel = -1;
            this.regDataOff = cpu.getWord(addr += cpu.sizeData);
            this.regDataOff |= (cpu.getWord(addr += cpu.sizeData) & ~0xfff) << 4;
            this.regDataSel = -1;
        } else {
            this.regCodeOff = cpu.getWord(addr += cpu.sizeData);
            w = cpu.getWord(addr += cpu.sizeData);
            this.regCodeSel = w & 0xffff;
            this.regOpcode = (w >> 16) & 0x7ff;
            this.regDataOff = cpu.getWord(addr += cpu.sizeData);
            this.regDataSel = cpu.getWord(addr += cpu.sizeData) & 0xffff;
        }
        return addr + cpu.sizeData;
    }

    /**
     * saveEnv(addr)
     *
     * @this {FPUX86}
     * @param {number} addr
     * @return {number} updated addr
     */
    saveEnv(addr)
    {
        let cpu = this.cpu;

        cpu.setWord(addr, this.regControl);
        cpu.setWord(addr += cpu.sizeData, this.getStatus());
        cpu.setWord(addr += cpu.sizeData, this.getTags());

        if (!(cpu.regCR0 & X86.CR0.MSW.PE) || (cpu.regPS & X86.PS.VM)) {
            let off = (this.regCodeSel << 4) + this.regCodeOff;
            cpu.setWord(addr += cpu.sizeData, off);
            cpu.setWord(addr += cpu.sizeData, ((off >> 4) & ~0xfff) | this.regOpcode);
            off = (this.regDataSel << 4) + this.regDataOff;
            cpu.setWord(addr += cpu.sizeData, off);
            cpu.setWord(addr += cpu.sizeData, ((off >> 4) & ~0xfff));
        } else {
            cpu.setWord(addr += cpu.sizeData, this.regCodeOff);
            cpu.setWord(addr += cpu.sizeData, this.regCodeSel | (this.regOpcode << 16));
            cpu.setWord(addr += cpu.sizeData, this.regDataOff);
            cpu.setWord(addr += cpu.sizeData, this.regDataSel);
        }
        return addr + cpu.sizeData;
    }

    /**
     * opFPU(bOpcode, bModRM, dst, src)
     *
     * This is called by the CPU's ESC opcode handlers, after each instruction has been fully decoded.
     *
     * @this {FPUX86}
     * @param {number} bOpcode (0xD8-0xDF)
     * @param {number} bModRM
     * @param {number} dst
     * @param {number} src
     */
    opFPU(bOpcode, bModRM, dst, src)
    {
        let mod = (bModRM >> 6) & 3;
        let reg = (bModRM >> 3) & 7;
        this.iStack = (bModRM & 7);

        /*
         * Combine mod and reg into one decodable value: put mod in the high nibble
         * and reg in the low nibble, after first collapsing all mod values < 3 to zero.
         */
        let modReg = (mod < 3? 0 : 0x30) + reg;

        /*
         * All values >= 0x34 imply mod == 3 and reg >= 4, so now we shift reg into the high
         * nibble and iStack into the low, yielding values >= 0x40.
         */
        if ((bOpcode == X86.OPCODE.ESC1 || bOpcode == X86.OPCODE.ESC3) && modReg >= 0x34) {
            modReg = (reg << 4) | this.iStack;
        }

        let fnOp = FPUX86.aaOps[bOpcode][modReg];
        if (fnOp) {
            /*
             * A handful of FPU instructions must preserve (at least some of) the "exception" registers,
             * so if the current function is NOT one of those, then update all the "exception" registers.
             */
            if (FPUX86.afnPreserveExceptions.indexOf(fnOp) < 0) {
                let cpu = this.cpu;
                let off = cpu.opLIP;
                /*
                 * WARNING: opLIP points to any prefixes preceding the ESC instruction, but the 8087 always
                 * points to the ESC instruction.  Technically, that's a bug, but it's also a reality, so we
                 * check for preceding prefixes and bump the instruction pointer accordingly.  This isn't a
                 * perfect solution, because it doesn't account for multiple (redundant) prefixes, but it
                 * should be adequate.
                 */
                if (this.isModel(X86.FPU.MODEL_8087)) {
                    if (cpu.opPrefixes & X86.OPFLAG.SEG) off++;
                    if (cpu.opPrefixes & X86.OPFLAG.LOCK) off++;
                }
                this.regCodeSel = cpu.segCS.sel;
                this.regCodeOff = off - cpu.segCS.base;
                if (cpu.regEA !== X86.ADDR_INVALID) {
                    this.regDataSel = cpu.segEA.sel;
                    this.regDataOff = cpu.regEA - cpu.segEA.base;
                }
                this.regOpcode = ((bOpcode & 7) << 8) | bModRM;
            }
            /*
             * Finally, perform the FPU operation.
             */
            fnOp.call(this);
        }
        else {
            /*
             * This is a gray area, at least until aaOps has been filled in for all supported coprocessors;
             * but for now, we'll treat all unrecognized operations as "no operation", as opposed to unimplemented.
             */
            this.opNone();
        }
    }

    /**
     * opWAIT()
     *
     * This is called by the CPU's WAIT opcode handler, giving us the opportunity to synchronize the FPU with the CPU,
     * charge an appropriate number of cycles, and return true.  In this context, it's considered an FWAIT instruction,
     * but technically, it's the same opcode.
     *
     * If we choose to do nothing, then we must return false, so that the CPU can charge a default number of cycles.
     *
     * @this {FPUX86}
     * @return {boolean} true if implemented, false if not
     */
    opWAIT()
    {
        return false;
    }

    /**
     * readFPUStack(i)
     *
     * Returns the following information for the requested FPU stack element, relative to ST:
     *
     *      a[0]: physical stack position (0-7)
     *      a[1]: corresponding tag value
     *      a[2]: 64-bit "long-real" (LR) value
     *      a[3]: bits 0-31 of 64-bit "long-real" (LR)
     *      a[4]: bits 32-63 of 64-bit "long-real" (LR)
     *      a[5]: bits 0-31 of 80-bit "temp-real" (TR)
     *      a[6]: bits 32-63 of 80-bit "temp-real" (TR)
     *      a[7]: bits 64-79 of 80-bit "temp-real" (TR) (in bits 0-15)
     *
     * Used by the Debugger for its floating-point register ("rfp") command.  For other FPU registers,
     * the Debugger calls getStatus() and getControl() directly.
     *
     * NOTE: The "temp-real" values are fake; we manufacture them on demand from 64-bit "long-real" values
     * actually stored in the stack; see getTRFromLR().
     *
     * @this {FPUX86}
     * @param {number} i (stack index, relative to ST)
     * @return {Array.<number>|null} (an array of information as described above, or null if invalid element)
     */
    readFPUStack(i)
    {
        let a = null;
        if (i < this.regStack.length) {
            a = [];
            let iReg = (this.iST + i) & 7;
            a[0] = iReg;
            a[1] = this.getTag(iReg);
            a[2] = this.regStack[iReg];
            let iInt = iReg << 1;
            a[3] = this.intStack[iInt];
            a[4] = this.intStack[iInt + 1];
            let aTR = this.getTRFromLR(a[3], a[4]);
            a[5] = aTR[0]; a[6] = aTR[1]; a[7] = aTR[2];
        }
        return a;
    }

    /**
     * getRandomInt(min, max)
     *
     * Used with old test code to verify that any randomly-constructed "long-real" (REAL64) could be converted
     * to a "temp-real" (REAL80) and back again losslessly, otherwise a bug in either getTRFromLR() or getLRFromTR()
     * might exist.  That test code can be resurrected from the repo; this code is being retained for future tests.
     *
     * NOTE: If either min or max is a value containing 32 or more significant bits AND bit 31 is set AND it has passed
     * through some bitwise operation(s), then that value may end up being negative, so you may end up with an inverted
     * range, or a range that's smaller or larger than intended.
     *
     * @this {FPUX86}
     * @param {number} min (inclusive)
     * @param {number} max (inclusive)
     * @return {number}
     *
     getRandomInt(min, max)
     {
         max -= min;
         if (max < 0) {      // compensate for inverted ranges (ie, where min > max)
             min += max;
             max = -max;
         }
         return Math.floor(Math.random() * (max + 1)) + min;
     }
     */

    /**
     * FPUX86.init()
     *
     * This function operates on every HTML element of class "fpu", extracting the
     * JSON-encoded parameters for the FPUX86 constructor from the element's "data-value"
     * attribute, invoking the constructor to create an FPUX86 component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeFPUs = Component.getElementsByClass(document, PCX86.APPCLASS, "fpu");
        for (let iFPU = 0; iFPU < aeFPUs.length; iFPU++) {
            let eFPU = aeFPUs[iFPU];
            let parmsFPU = Component.getComponentParms(eFPU);
            let fpu = new FPUX86(parmsFPU);
            Component.bindComponentControls(fpu, eFPU, PCX86.APPCLASS);
        }
    }
}

/**
 * F2XM1()
 *
 * F2XM1 (2 to the x minus 1) calculates the function 2^x - 1 and returns the result to ST(0).
 *
 * On the 8087 and 80287, the value in ST(0) must satisfy the inequality 0 <= ST(0) <= 0.5.  On the 80287XL and
 * later coprocessors, the permissible range is greater, and ST(0) must satisfy the inequality -1 <= ST(0) <= 1.
 * If ST(0) is out of range, the result is undefined, even though no exception is raised.
 *
 * The F2XM1 instruction is designed to provide an accurate result even when x is close to zero. To obtain 2^x,
 * simply add 1.0 to the result returned by F2XM1.
 *
 * This instruction is useful in performing exponentiation of values other than 2 as shown in the following formulas:
 *
 *      10^x = 2^(x * log2(10))
 *      e^x = 2^(x * log2(e))
 *      y^x = 2^(x * log2(y))
 *
 * Note that the NPX has dedicated instructions for loading the constants log2(10) and log2(e).  The FYL2X instruction
 * may be used to calculate x * log2(y).
 *
 * See also: FYL2X, FLDL2T, FLDL2E.
 *
 * @this {FPUX86}
 */
FPUX86.F2XM1 = function()
{
    this.setST(0, Math.pow(2, this.getST(0)) - 1);
};

/**
 * FABS()
 *
 * @this {FPUX86}
 */
FPUX86.FABS = function()
{
    /*
     * TODO: This could be implemented more efficiently by simply clearing the sign bit of ST(0).
     */
    this.setST(0, Math.abs(this.getST(0)));
};

/**
 * FADDlr()
 *
 * @this {FPUX86}
 */
FPUX86.FADDlr = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getLRFromEA()));
};

/**
 * FADDsr()
 *
 * Encoding 0xD8,reg=0x00 ("FADD short-real"): ST(0) <- ST(0) + REAL32
 *
 * @this {FPUX86}
 */
FPUX86.FADDsr = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getSRFromEA()));
};

/**
 * FADDst()
 *
 * @this {FPUX86}
 */
FPUX86.FADDst = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getST(this.iStack)));
};

/**
 * FADDsti()
 *
 * @this {FPUX86}
 */
FPUX86.FADDsti = function()
{
    this.setST(this.iStack, this.doAdd(this.getST(this.iStack), this.getST(0)));
};

/**
 * FADDPsti()
 *
 * @this {FPUX86}
 */
FPUX86.FADDPsti = function()
{
    if (this.setST(this.iStack, this.doAdd(this.getST(this.iStack), this.getST(0)))) this.popValue();
};

/**
 * FBLDpd()
 *
 * @this {FPUX86}
 */
FPUX86.FBLDpd = function()
{
    let a = this.getTRFromEA();
    /*
     * a[0] contains the 8 least-significant BCD digits, a[1] contains the next 8, and a[2] contains
     * the next 2 (bit 15 of a[2] is the sign bit, and bits 8-14 of a[2] are unused).
     */
    let v = this.decodeBCD(a[0], 8) + this.decodeBCD(a[1], 8) * 100000000 + this.decodeBCD(a[2], 2) * 10000000000000000;
    if (a[2] & 0x8000) v = -v;
    this.pushValue(v);
};

/**
 * FBSTPpd()
 *
 * @this {FPUX86}
 */
FPUX86.FBSTPpd = function()
{
    /*
     * TODO: Verify the operation of FBSTP (eg, does it signal an exception if abs(value) >= 1000000000000000000?)
     */
    let v = this.roundValue(this.popValue());
    if (v != null) {
        /*
         * intTmpTR[0] will contain the 8 least-significant BCD digits, intTmpTR[1] will contain the next 8,
         * and intTmpTR[2] will contain the next 2 (bit 15 of intTmpTR[2] will be the sign bit, and bits 8-14 of
         * intTmpTR[2] will be unused).
         */
        this.intTmpTR[0] = this.encodeBCD(v, 8);
        this.intTmpTR[1] = this.encodeBCD(v / 100000000, 8);
        this.intTmpTR[2] = this.encodeBCD(v / 10000000000000000, 2);
        if (v < 0) this.intTmpTR[2] |= 0x8000;
        this.setEAFromTR();
    }
};

/**
 * FCHS()
 *
 * @this {FPUX86}
 */
FPUX86.FCHS = function()
{
    /*
     * TODO: This could be implemented more efficiently by simply inverting the sign bit of ST(0).
     */
    this.setST(0, -this.getST(0));
};

/**
 * FCLEX()
 *
 * NOTE: Although we explicitly clear the BUSY bit, there shouldn't be any code setting it, because
 * we're never "busy" (all floating-point operations are performed synchronously).  Conversely, there's
 * no need to explicitly clear the ES bit, because clearStatus() will call checkException(), which
 * updates ES and clears/sets FPU interrupt status as appropriate.
 *
 * @this {FPUX86}
 */
FPUX86.FCLEX = function()
{
    this.clearStatus(X86.FPU.STATUS.EXC | X86.FPU.STATUS.BUSY);
};

/**
 * FCOMlr()
 *
 * Encoding 0xDC,mod<3,reg=2 ("FCOM long-real"): Evaluate ST(0) - REAL64
 *
 * @this {FPUX86}
 */
FPUX86.FCOMlr = function()
{
    this.doCompare(this.getST(0), this.getLRFromEA());
};

/**
 * FCOMsr()
 *
 * Encoding 0xD8,mod<3,reg=2 ("FCOM short-real"): Evaluate ST(0) - REAL32
 *
 * @this {FPUX86}
 */
FPUX86.FCOMsr = function()
{
    this.doCompare(this.getST(0), this.getSRFromEA());
};

/**
 * FCOMst()
 *
 * Encoding 0xD8,mod=3,reg=2 ("FCOM ST(i)"): Evaluate ST(0) - ST(i)
 *
 * @this {FPUX86}
 */
FPUX86.FCOMst = function()
{
    this.doCompare(this.getST(0), this.getST(this.iStack));
};

/**
 * FCOM8087()
 *
 * NOTE: This is used with encoding(s) (0xDC,0xD0-0xD7) that were valid for the 8087 and 80287
 * but may no longer be valid as of the 80387.
 *
 * TODO: Determine if this form subtracted the operands in the same order, or if it requires an FCOMsti(),
 * which, like the other *sti() functions, uses ST(0) as the second operand rather than the first.
 *
 * @this {FPUX86}
 */
FPUX86.FCOM8087 = function()
{
    this.opObsolete();
    FPUX86.FCOMst.call(this);
};

/**
 * FCOMPlr()
 *
 * Encoding 0xDC,mod<3,reg=3 ("FCOM long-real"): Evaluate ST(0) - REAL64, POP
 *
 * @this {FPUX86}
 */
FPUX86.FCOMPlr = function()
{
    if (this.doCompare(this.getST(0), this.getLRFromEA())) this.popValue();
};

/**
 * FCOMPsr()
 *
 * Encoding 0xD8,mod<3,reg=3 ("FCOM short-real"): Evaluate ST(0) - REAL32, POP
 *
 * @this {FPUX86}
 */
FPUX86.FCOMPsr = function()
{
    if (this.doCompare(this.getST(0), this.getSRFromEA())) this.popValue();
};

/**
 * FCOMPst()
 *
 * Encoding 0xD8,mod=3,reg=3 ("FCOMP ST(i)"): Evaluate ST(0) - ST(i), POP
 *
 * @this {FPUX86}
 */
FPUX86.FCOMPst = function()
{
    if (this.doCompare(this.getST(0), this.getST(this.iStack))) this.popValue();
};

/**
 * FCOMP8087()
 *
 * NOTE: This is used with encodings (0xDC,0xD8-0xDF and 0xDE,0xD0-0xD7) that were valid for the 8087
 * and 80287 but may no longer be valid as of the 80387.
 *
 * TODO: Determine if this form subtracted the operands in the same order, or if it requires an FCOMPsti(),
 * which, like the other *sti() functions, uses ST(0) as the second operand rather than the first.
 *
 * @this {FPUX86}
 */
FPUX86.FCOMP8087 = function()
{
    this.opObsolete();
    FPUX86.FCOMPst.call(this);
};

/**
 * FCOMPP()
 *
 * @this {FPUX86}
 */
FPUX86.FCOMPP = function()
{
    if (this.doCompare(this.getST(0), this.getST(1)) && this.popValue() != null) this.popValue();
};

/**
 * FDECSTP()
 *
 * @this {FPUX86}
 */
FPUX86.FDECSTP = function()
{
    this.iST = (this.iST - 1) & 0x7;
    this.regStatus &= ~X86.FPU.STATUS.C1;
};

/**
 * FDISI8087()
 *
 * @this {FPUX86}
 */
FPUX86.FDISI8087 = function()
{
    if (this.isModel(X86.FPU.MODEL_8087)) {
        this.regControl |= X86.FPU.CONTROL.IEM;
    }
};

/**
 * FDIVlr()
 *
 * @this {FPUX86}
 */
FPUX86.FDIVlr = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getLRFromEA()));
};

/**
 * FDIVsr()
 *
 * @this {FPUX86}
 */
FPUX86.FDIVsr = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getSRFromEA()));
};

/**
 * FDIVst()
 *
 * Encoding 0xD8,0xF0-0xF7 ("FDIV ST,ST(i)"): ST(0) <- ST(0) / ST(i)
 *
 * @this {FPUX86}
 */
FPUX86.FDIVst = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getST(this.iStack)));
};

/**
 * FDIVsti()
 *
 * Encoding 0xDC,0xF8-0xFF ("FDIV ST(i),ST"): ST(i) <- ST(i) / ST(0)
 *
 * @this {FPUX86}
 */
FPUX86.FDIVsti = function()
{
    this.setST(this.iStack, this.doDivide(this.getST(this.iStack), this.getST(0)));
};

/**
 * FDIVPsti()
 *
 * Encoding 0xDE,0xF8-0xFF ("FDIVP ST(i),ST"): ST(i) <- ST(i) / ST(0), POP
 *
 * @this {FPUX86}
 */
FPUX86.FDIVPsti = function()
{
    if (this.setST(this.iStack, this.doDivide(this.getST(this.iStack), this.getST(0)))) this.popValue();
};

/**
 * FDIVRlr()
 *
 * @this {FPUX86}
 */
FPUX86.FDIVRlr = function()
{
    this.setST(0, this.doDivide(this.getLRFromEA(), this.getST(0)));
};

/**
 * FDIVRsr()
 *
 * @this {FPUX86}
 */
FPUX86.FDIVRsr = function()
{
    this.setST(0, this.doDivide(this.getSRFromEA(), this.getST(0)));
};

/**
 * FDIVRst()
 *
 * Encoding 0xD8,0xF8-0xFF ("FDIVR ST,ST(i)"): ST(0) <- ST(i) / ST(0)
 *
 * @this {FPUX86}
 */
FPUX86.FDIVRst = function()
{
    this.setST(0, this.doDivide(this.getST(this.iStack), this.getST(0)));
};

/**
 * FDIVRsti()
 *
 * Encoding 0xDC,0xF0-0xF7 ("FDIVR ST(i),ST"): ST(i) <- ST(0) / ST(i)
 *
 * @this {FPUX86}
 */
FPUX86.FDIVRsti = function()
{
    this.setST(this.iStack, this.doDivide(this.getST(0), this.getST(this.iStack)));
};

/**
 * FDIVRPsti()
 *
 * Encoding 0xDE,0xF0-0xE7 ("FDIVRP ST(i),ST"): ST(i) <- ST(0) / ST(i), POP
 *
 * @this {FPUX86}
 */
FPUX86.FDIVRPsti = function()
{
    if (this.setST(this.iStack, this.doDivide(this.getST(0), this.getST(this.iStack)))) this.popValue();
};

/**
 * FENI8087()
 *
 * @this {FPUX86}
 */
FPUX86.FENI8087 = function()
{
    if (this.isModel(X86.FPU.MODEL_8087)) {
        this.regControl &= ~X86.FPU.CONTROL.IEM;
    }
};

/**
 * FFREEsti()
 *
 * @this {FPUX86}
 */
FPUX86.FFREEsti = function()
{
    this.setTag(this.iST, X86.FPU.TAGS.EMPTY);
};

/**
 * FFREEP8087()
 *
 * NOTE: This is used with an encoding (0xDF,0xC0-0xC7) that was valid for the 8087 and 80287
 * but may no longer be valid as of the 80387.  Also, if the older documentation is to be believed,
 * this instruction has no modern counterpart, as FFREE doesn't pop the stack.
 *
 * @this {FPUX86}
 */
FPUX86.FFREEP8087 = function()
{
    this.opObsolete();
    FPUX86.FFREEsti.call(this);
    this.popValue();
};

/**
 * FIADD16()
 *
 * @this {FPUX86}
 */
FPUX86.FIADD16 = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getWIFromEA()));
};

/**
 * FIADD32()
 *
 * @this {FPUX86}
 */
FPUX86.FIADD32 = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getSIFromEA()));
};

/**
 * FICOM16()
 *
 * @this {FPUX86}
 */
FPUX86.FICOM16 = function()
{
    this.doCompare(this.getST(0), this.getWIFromEA());
};

/**
 * FICOM32()
 *
 * @this {FPUX86}
 */
FPUX86.FICOM32 = function()
{
    this.doCompare(this.getST(0), this.getSIFromEA());
};

/**
 * FICOMP16()
 *
 * @this {FPUX86}
 */
FPUX86.FICOMP16 = function()
{
    if (this.doCompare(this.getST(0), this.getWIFromEA())) this.popValue();
};

/**
 * FICOMP32()
 *
 * @this {FPUX86}
 */
FPUX86.FICOMP32 = function()
{
    if (this.doCompare(this.getST(0), this.getSIFromEA())) this.popValue();
};

/**
 * FIDIV16()
 *
 * @this {FPUX86}
 */
FPUX86.FIDIV16 = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getWIFromEA()));
};

/**
 * FIDIV32()
 *
 * @this {FPUX86}
 */
FPUX86.FIDIV32 = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getSIFromEA()));
};

/**
 * FIDIVR16()
 *
 * @this {FPUX86}
 */
FPUX86.FIDIVR16 = function()
{
    this.setST(0, this.doDivide(this.getWIFromEA(), this.getST(0)));
};

/**
 * FIDIVR32()
 *
 * @this {FPUX86}
 */
FPUX86.FIDIVR32 = function()
{
    this.setST(0, this.doDivide(this.getSIFromEA(), this.getST(0)));
};

/**
 * FILD16()
 *
 * @this {FPUX86}
 */
FPUX86.FILD16 = function()
{
    this.pushValue(this.getWIFromEA());
};

/**
 * FILD32()
 *
 * @this {FPUX86}
 */
FPUX86.FILD32 = function()
{
    this.pushValue(this.getSIFromEA());
};

/**
 * FILD64()
 *
 * @this {FPUX86}
 */
FPUX86.FILD64 = function()
{
    this.pushValue(this.getLIFromEA());
};

/**
 * FIMUL16()
 *
 * @this {FPUX86}
 */
FPUX86.FIMUL16 = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getWIFromEA()));
};

/**
 * FIMUL32()
 *
 * @this {FPUX86}
 */
FPUX86.FIMUL32 = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getSIFromEA()));
};

/**
 * FINCSTP()
 *
 * @this {FPUX86}
 */
FPUX86.FINCSTP = function()
{
    this.iST = (this.iST + 1) & 0x7;
    this.regStatus &= ~X86.FPU.STATUS.C1;
};

/**
 * FINIT()
 *
 * @this {FPUX86}
 */
FPUX86.FINIT = function()
{
    this.resetFPU();
};

/**
 * FIST16()
 *
 * @this {FPUX86}
 */
FPUX86.FIST16 = function()
{
    if (this.getWI(0)) this.setEAFromWI();
};

/**
 * FIST32()
 *
 * @this {FPUX86}
 */
FPUX86.FIST32 = function()
{
    if (this.getSI(0)) this.setEAFromSI();
};

/**
 * FISTP16()
 *
 * @this {FPUX86}
 */
FPUX86.FISTP16 = function()
{
    if (this.getWI(0)) {
        this.setEAFromWI();
        this.popValue();
    }
};

/**
 * FISTP32()
 *
 * @this {FPUX86}
 */
FPUX86.FISTP32 = function()
{
    if (this.getSI(0)) {
        this.setEAFromSI();
        this.popValue();
    }
};

/**
 * FISTP64()
 *
 * @this {FPUX86}
 */
FPUX86.FISTP64 = function()
{
    if (this.getLI(0)) {
        this.setEAFromLI();
        this.popValue();
    }
};

/**
 * FISUB16()
 *
 * @this {FPUX86}
 */
FPUX86.FISUB16 = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getWIFromEA()));
};

/**
 * FISUB32()
 *
 * @this {FPUX86}
 */
FPUX86.FISUB32 = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getSIFromEA()));
};

/**
 * FISUBR16()
 *
 * @this {FPUX86}
 */
FPUX86.FISUBR16 = function()
{
    this.setST(0, this.doSubtract(this.getWIFromEA(), this.getST(0)));
};

/**
 * FISUBR32()
 *
 * @this {FPUX86}
 */
FPUX86.FISUBR32 = function()
{
    this.setST(0, this.doSubtract(this.getSIFromEA(), this.getST(0)));
};

/**
 * FLDlr()
 *
 * The FLD instruction loads the source operand, converts it to temporary real format (if required),
 * and pushes the resulting value onto the floating-point stack.
 *
 * The load operation is accomplished by decrementing the top-of-stack pointer (TOP) and copying the
 * source operand to the new stack top. If the source operand is a float ing-point register, the index of
 * the register is taken before TOP is changed. The source operand may also be a short real, long real,
 * or temporary real memory operand. Short real and long real operands are converted automatically.
 *
 * Note that coding the instruction FLD ST(0) duplicates the value at the stack top.
 *
 * On the 8087 and 80287, the FLD real80 instruction will raise the denormal exception if the memory
 * operand is a denormal. The 80287XL and later coprocessors will not, since the operation is not arithmetic.
 *
 * On the 8087 and 80287, a denormal will be converted to an unnormal by FLD; on the 80287XL and later
 * coprocessors, the number will be converted to temporary real. If the next instruction is an FXTRACT or FXAM,
 * the 8087/80827 and 80287XL/80387/ 80486 results will be different.
 *
 * On the 8087 and 80287, the FLD real32 and FLD real64 instructions will not raise an exception when loading
 * a signaling NaN; on the 80287XL and later coprocessors, loading a signaling NaN raises the invalid operation
 * exception.
 *
 * @this {FPUX86}
 */
FPUX86.FLDlr = function()
{
    this.pushValue(this.getLRFromEA());
};

/**
 * FLDsr()
 *
 * @this {FPUX86}
 */
FPUX86.FLDsr = function()
{
    this.pushValue(this.getSRFromEA());
};

/**
 * FLDsti()
 *
 * @this {FPUX86}
 */
FPUX86.FLDsti = function()
{
    this.pushValue(this.getST(this.iStack));
};

/**
 * FLDtr()
 *
 * @this {FPUX86}
 */
FPUX86.FLDtr = function()
{
    this.pushValue(this.getLRFromTR(this.getTRFromEA()));
};

/**
 * FLDCW()
 *
 * @this {FPUX86}
 */
FPUX86.FLDCW = function()
{

    this.setControl(this.cpu.getShort(this.cpu.regEA));
};

/**
 * FLDENV()
 *
 * @this {FPUX86}
 */
FPUX86.FLDENV = function()
{

    this.loadEnv(this.cpu.regEA);
};

/**
 * FLD1()
 *
 * The FLD1 instruction loads the constant +1.0 from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * See also: FLDLG2, FLDLN2, FLDL2E, FLDL2T, FLDPI, and FLD1.
 *
 * @this {FPUX86}
 */
FPUX86.FLD1 = function()
{
    this.pushValue(1.0);
};

/**
 * FLDL2T()
 *
 * The FLDL2T instruction loads the constant log2(10) from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of this constant.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0), round down (toward
 * -infinity), or round to nearest or even, the result will be the same as on the 8087 and 80287.  If RC is set for
 * round up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLG2, FLDLN2, FLDL2E, FLDPI, FLD1, and FLDZ.
 *
 * @this {FPUX86}
 */
FPUX86.FLDL2T = function()
{
    this.pushValue(FPUX86.regL2T);
};

/**
 * FLDL2E()
 *
 * The FLDL2E instruction loads the constant log2(e) from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of this constant.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0) or round down (toward
 * -infinity), the result is the same as on the 8087 and 80827.  If RC is set for round to nearest or even, or round
 * up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLG2, FLDLN2, FLDL2T, FLDPI, FLD1, and FLDZ.
 *
 * @this {FPUX86}
 */
FPUX86.FLDL2E = function()
{
    this.pushValue(FPUX86.regL2E);
};

/**
 * FLDPI()
 *
 * The FLDPI instruction loads the constant Pi from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of these constants.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0) or round down (toward
 * -infinity), the result is the same as on the 8087 and 80827.  If RC is set for round to nearest or even, or round
 * up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLG2, FLDLN2, FLDL2E, FLDL2T, FLD1, and FLDZ.
 *
 * @this {FPUX86}
 */
FPUX86.FLDPI = function()
{
    this.pushValue(FPUX86.regPI);
};

/**
 * FLDLG2()
 *
 * The FLDLG2 instruction loads the constant log10(2) from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of this constant.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0) or round down (toward
 * -infinity), the result is the same as on the 8087 and 80827.  If RC is set for round to nearest or even, or round
 * up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLN2, FLDL2E, FLDL2T, FLDPI, FLD1, and FLDZ.
 *
 * @this {FPUX86}
 */
FPUX86.FLDLG2 = function()
{
    this.pushValue(FPUX86.regLG2);
};

/**
 * FLDLN2()
 *
 * The FLDLN2 instruction loads the constant loge(2) from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of this constant.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0) or round down (toward
 * -infinity), the result will be the same as on the 8087 and 80827.  If RC is set for round to nearest or even, or
 * round up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLG2, FLDL2E, FLDL2T, FLDPI, FLD1, and FLDZ.
 *
 * @this {FPUX86}
 */
FPUX86.FLDLN2 = function()
{
    this.pushValue(FPUX86.regLN2);
};

/**
 * FLDZ()
 *
 * The FLDZ instruction loads the constant +0.0 from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * See also: FLDLG2, FLDLN2, FLDL2E, FLDL2T, FLDPI, and FLD1.
 *
 * @this {FPUX86}
 */
FPUX86.FLDZ = function()
{
    this.pushValue(0.0);
};

/**
 * FMULlr()
 *
 * @this {FPUX86}
 */
FPUX86.FMULlr = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getLRFromEA()));
};

/**
 * FMULsr()
 *
 * Encoding 0xD8,reg=0x01 ("FMUL short-real"): ST(0) <- ST(0) * REAL32
 *
 * @this {FPUX86}
 */
FPUX86.FMULsr = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getSRFromEA()));
};

/**
 * FMULst()
 *
 * @this {FPUX86}
 */
FPUX86.FMULst = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getST(this.iStack)));
};

/**
 * FMULsti()
 *
 * @this {FPUX86}
 */
FPUX86.FMULsti = function()
{
    this.setST(this.iStack, this.doMultiply(this.getST(this.iStack), this.getST(0)));
};

/**
 * FMULPsti()
 *
 * @this {FPUX86}
 */
FPUX86.FMULPsti = function()
{
    if (this.setST(this.iStack, this.doMultiply(this.getST(this.iStack), this.getST(0)))) this.popValue();
};

/**
 * FNOP()
 *
 * @this {FPUX86}
 */
FPUX86.FNOP = function()
{
};

/**
 * FPATAN()
 *
 * FPATAN calculates the partial arctangent of ST(0) divided by ST(1):
 *
 *      ST(1) = tan^-1( ST(1) / ST(0) )
 *
 * On the 8087 and 80287, the arguments must satisfy the inequality 0 <= ST(1) < ST(0) < +infinity.
 * On the 80287XL and later coprocessors, the range of the operands is unrestricted.  The result is
 * returned to ST(1), and the stack is popped, destroying both operands and leaving the result in ST(0).
 *
 * @this {FPUX86}
 */
FPUX86.FPATAN = function()
{
    if (this.setST(1, Math.atan2(this.getST(1), this.getST(0)))) this.popValue();
};

/**
 * FPTAN()
 *
 * FPTAN calculates the partial tangent of ST(0):
 *
 *      y / x = tan( ST(0) )
 *
 * The result of the operation is a ratio.  y replaces the argument on the stack, and x is pushed onto the stack,
 * where it becomes the new ST(0).
 *
 * On the 8087 and 80287, the FPTAN function assumes that its argument is valid and in-range.  No argument checking
 * is performed.  The value of ST(0) must satisfy the inequality -pi/4 <= ST(0) <= pi/4.  In the case of an invalid
 * argument, the result is undefined and no error is signaled.
 *
 * On the 80287XL and later coprocessors, if value of ST(0) satisfies the condition -2^63 < ST(0) < 2^63, it will
 * automatically be reduced to within range.  If the operand is outside this range, however, C2 is set to 1 to indicate
 * that the function is incomplete, and ST(0) is left unchanged.
 *
 * The 80287XL, 80387, and 80486 always push a value of +1.0 for x. The value of x pushed by the 8087 and 80287 may be
 * any real number.  In either case, the ratio is the same. The cotangent can be calculated by executing FDIVR immediately
 * after FPTAN.  The following code will leave the 8087 and 80287 in the same state as the later coprocessors:
 *
 *      FDIV
 *      FLD1
 *
 * ST(7) must be empty before this instruction is executed to avoid an invalid operation exception.  If the invalid
 * operation exception is masked, the 8087 and 80287 leave the original operand unchanged, but push it to ST(1).  On the
 * 80287XL and later coprocessors, both ST(0) and ST(1) will contain quiet NaNs.  On the 80287XL and later coprocessors,
 * if condition code bit C2 is 0 and the precision exception is raised, then C1=1 if the last bit was rounded up. C1 is
 * undefined for the 8087 and 80287.
 *
 * @this {FPUX86}
 */
FPUX86.FPTAN = function()
{
    if (this.setST(0, Math.tan(this.getST(0)))) this.pushValue(1.0);
};

/**
 * FPREM()
 *
 * FPREM performs modulo division of ST(0) by ST(1) and returns the result to ST(0).
 *
 * The FPREM instruction is used to reduce the real operand in ST(0) to a value whose magnitude is less than the
 * magnitude of ST(1).  FPREM produces an exact result, so the precision exception is never raised and the rounding
 * control has no effect.  The sign of the remainder is the same as the sign of the original operand.
 *
 * The remaindering operation is performed by iterative scaled subtractions and can reduce the exponent of ST(0) by
 * no more than 63 in one execution.  If the remainder is less than ST(1) (the modulus), the function is complete and
 * C2 in the status word is cleared.
 *
 * If the modulo function is incomplete, C2 is set to 1, and the result in ST(0) is termed the partial remainder.
 * C2 can be inspected by storing the status word and re-executing the instruction until C2 is clear. Alternately,
 * ST(0) can be compared to ST(1).  If ST(0) > ST(1), then FPREM must be executed again.  If ST(0) = ST(1), then the
 * remainder is 0.
 *
 * FPREM is important for reducing arguments to the periodic transcendental functions such as FPTAN.  Because FPREM
 * produces an exact result, no round-off error is introduced into the calculation.
 *
 * When reduction is complete, the three least-significant bits of the quotient are stored in the condition code bits
 * C3, C1, and C0, respectively.  When arguments to the tangent function are reduced by pi/4, this result can be used
 * to identify the octant that contained the original angle.
 *
 * The FPREM function operates differently than specified by the IEEE 754 standard when rounding the quotient to form
 * a partial remainder (see the algorithm).  The FPREM1 function (80287XL and up) is provided for compatibility with
 * that standard.
 *
 * The FPREM instruction can also be used to normalize ST(0).  If ST(0) is unnormal and ST(1) is greater than ST(0),
 * FPREM will normalize ST(0).  On the 8087 and 80287, operation on a denormal operand raises the invalid operation
 * exception.  Underflow is not possible.  On the 80287XL and later coprocessors, operation on a denormal is supported
 * and an underflow exception can occur.
 *
 * ALGORITHM:
 *
 *      t = EXPONENT(ST) - EXPONENT(ST(1))
 *      IF (t < 64) THEN
 *          q = R0UND(ST(0) / ST(1), CHOP)
 *          ST(0) = ST(0) - (ST(1) * q)
 *          C2 = 0
 *          C0 = BIT 2 of q
 *          C1 = BIT 1 of q
 *          C3 = BIT 0 of q
 *      ELSE
 *          n = a number between 32 and 63
 *          q = ROUND((ST(0) / ST(1)) / 2^(t-n), CHOP)
 *          ST(0) = ST(0) - (ST(1) * q * 2^(t-n))
 *          C2 = 1
 *      ENDIF
 *
 * TODO: Determine the extent to which the JavaScript MOD operator differs from the above algorithm.
 *
 * ERRATA: On the 8087 and 80287, the condition code bits C3, C1, and C0 are incorrect when performing a reduction of
 * 64^n + m, where n >= 1, and m=1 or m=2.  A bug fix should be implemented in software.
 *
 * @this {FPUX86}
 */
FPUX86.FPREM = function()
{
    this.setST(0, this.getST(0) % this.getST(1));
};

/**
 * FRSTOR()
 *
 * @this {FPUX86}
 */
FPUX86.FRSTOR = function()
{
    let cpu = this.cpu;
    let addr = this.loadEnv(cpu.regEA);
    let a = this.intTmpTR;
    for (let i = 0; i < this.regStack.length; i++) {
        a[0] = cpu.getLong(addr);
        a[1] = cpu.getLong(addr += 4);
        a[2] = cpu.getShort(addr += 4);
        this.setTR(i, a);
        addr += 2;
    }
};

/**
 * FRNDINT()
 *
 * @this {FPUX86}
 */
FPUX86.FRNDINT = function()
{
    this.setST(0, this.roundValue(this.getST(0), FPUX86.MAX_INT64));
};

/**
 * FSAVE()
 *
 * @this {FPUX86}
 */
FPUX86.FSAVE = function()
{
    let cpu = this.cpu;
    let addr = this.saveEnv(cpu.regEA);
    for (let i = 0; i < this.regStack.length; i++) {
        let a = this.getTR(i, true);
        cpu.setLong(addr, a[0]);
        cpu.setLong(addr += 4, a[1]);
        cpu.setShort(addr += 4, a[2]);
        addr += 2;
    }
    this.resetFPU();
};

/**
 * FSCALE()
 *
 * FSCALE interprets the value in ST(1) as an integer and adds this number to the exponent of the number in ST(0).
 *
 * The FSCALE instruction provides a means of quickly performing multiplication or division by powers of two.
 * This operation is often required when scaling array indexes.
 *
 * On the 8087 and 80287, FSCALE assumes that the scale factor in ST(1) is an integer that satisfies the inequality
 * -2^15 <= ST(1) < +2^15.  If ST(1) is not an integer value, the value is chopped to the next smallest integer in
 * magnitude (chopped toward zero).  If the value is out of range or 0 < ST(1) < 1, FSCALE produces an undefined
 * result and doesn't signal an exception.  Typically, the value in ST(0) is unchanged but should not be depended on.
 *
 * On the 80287XL and later coprocessors, there is no limit on the range of the scale factor in ST(1). The value in
 * ST(1) is still chopped toward zero.  If ST(1) is 0, ST(0) is unchanged.
 *
 * @this {FPUX86}
 */
FPUX86.FSCALE = function()
{
    let x = this.getST(0);
    let y = this.getST(1);
    if (x != null && y != null) this.setST(0, x * Math.pow(2, this.truncateValue(y)));
};

/**
 * FSETPM287()
 *
 * @this {FPUX86}
 */
FPUX86.FSETPM287 = function()
{
    if (this.isModel(X86.FPU.MODEL_80287)) {
        this.opUnimplemented();
    }
};

/**
 * FSINCOS387()
 *
 * @this {FPUX86}
 */
FPUX86.FSINCOS387 = function()
{
    if (this.isAtLeastModel(X86.FPU.MODEL_80287XL)) {
        this.opUnimplemented();
    }
};

/**
 * FSQRT()
 *
 * @this {FPUX86}
 */
FPUX86.FSQRT = function()
{
    this.setST(0, this.doSquareRoot(this.getST(0)));
};

/**
 * FSTlr()
 *
 * @this {FPUX86}
 */
FPUX86.FSTlr = function()
{
    if (this.getLR(0)) this.setEAFromLR();
};

/**
 * FSTsr()
 *
 * @this {FPUX86}
 */
FPUX86.FSTsr = function()
{
    if (this.getSR(0)) this.setEAFromSR();
};

/**
 * FSTsti()
 *
 * @this {FPUX86}
 */
FPUX86.FSTsti = function()
{
    this.setST(this.iStack, this.getST(0));
};

/**
 * FSTENV()
 *
 * @this {FPUX86}
 */
FPUX86.FSTENV = function()
{

    this.saveEnv(this.cpu.regEA);
    this.regControl |= X86.FPU.CONTROL.EXC;     // mask all exceptions (but do not set IEM)
};

/**
 * FSTPlr()
 *
 * @this {FPUX86}
 */
FPUX86.FSTPlr = function()
{
    if (this.getLR(0)) {
        this.setEAFromLR();
        this.popValue();
    }
};

/**
 * FSTPsr()
 *
 * @this {FPUX86}
 */
FPUX86.FSTPsr = function()
{
    if (this.getSR(0)) {
        this.setEAFromSR();
        this.popValue();
    }
};

/**
 * FSTPsti()
 *
 * @this {FPUX86}
 */
FPUX86.FSTPsti = function()
{
    if (this.setST(this.iStack, this.getST(0))) this.popValue();
};

/**
 * FSTP8087()
 *
 * NOTE: This is used with encodings (0xD9,0xD8-0xDF and 0xDF,0xD0-0xDF) that were valid for the 8087 and 80287
 * but may no longer be valid as of the 80387.
 *
 * @this {FPUX86}
 */
FPUX86.FSTP8087 = function()
{
    this.opObsolete();
    FPUX86.FSTPsti.call(this);
};

/**
 * FSTPtr()
 *
 * @this {FPUX86}
 */
FPUX86.FSTPtr = function()
{
    if (this.getTR(0)) {
        this.setEAFromTR();
        this.popValue();
    }
};

/**
 * FSTCW()
 *
 * @this {FPUX86}
 */
FPUX86.FSTCW = function()
{

    this.cpu.setShort(this.cpu.regEA, this.regControl);
};

/**
 * FSTSW()
 *
 * @this {FPUX86}
 */
FPUX86.FSTSW = function()
{

    this.cpu.setShort(this.cpu.regEA, this.getStatus());
};

/**
 * FSTSWAX287()
 *
 * @this {FPUX86}
 */
FPUX86.FSTSWAX287 = function()
{
    if (this.isAtLeastModel(X86.FPU.MODEL_80287)) {
        this.cpu.regEAX = (this.cpu.regEAX & ~0xffff) | this.getStatus();
    }
};

/**
 * FSUBlr()
 *
 * @this {FPUX86}
 */
FPUX86.FSUBlr = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getLRFromEA()));
};

/**
 * FSUBsr()
 *
 * @this {FPUX86}
 */
FPUX86.FSUBsr = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getSRFromEA()));
};

/**
 * FSUBst()
 *
 * Encoding 0xD8,0xE0-0xE7 ("FSUB ST,ST(i)"): ST(0) <- ST(0) - ST(i)
 *
 * @this {FPUX86}
 */
FPUX86.FSUBst = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getST(this.iStack)));
};

/**
 * FSUBsti()
 *
 * Encoding 0xDC,0xE8-0xEF ("FSUB ST(i),ST"): ST(i) <- ST(i) - ST(0)
 *
 * @this {FPUX86}
 */
FPUX86.FSUBsti = function()
{
    this.setST(this.iStack, this.doSubtract(this.getST(this.iStack), this.getST(0)));
};

/**
 * FSUBPsti()
 *
 * Encoding 0xDE,0xE8-0xEF ("FSUBP ST(i),ST"): ST(i) <- ST(i) - ST(0), POP
 *
 * @this {FPUX86}
 */
FPUX86.FSUBPsti = function()
{
    if (this.setST(this.iStack, this.doSubtract(this.getST(this.iStack), this.getST(0)))) this.popValue();
};

/**
 * FSUBRlr()
 *
 * @this {FPUX86}
 */
FPUX86.FSUBRlr = function()
{
    this.setST(0, this.doSubtract(this.getLRFromEA(), this.getST(0)));
};

/**
 * FSUBRsr()
 *
 * @this {FPUX86}
 */
FPUX86.FSUBRsr = function()
{
    this.setST(0, this.doSubtract(this.getSRFromEA(), this.getST(0)));
};

/**
 * FSUBRst()
 *
 * Encoding 0xD8,0xE8-0xEF ("FSUBR ST,ST(i)"): ST(0) <- ST(i) - ST(0)
 *
 * @this {FPUX86}
 */
FPUX86.FSUBRst = function()
{
    this.setST(0, this.doSubtract(this.getST(this.iStack), this.getST(0)));
};

/**
 * FSUBRsti()
 *
 * Encoding 0xDC,0xE0-0xE7 ("FSUBR ST(i),ST"): ST(i) <- ST(0) - ST(i)
 *
 * @this {FPUX86}
 */
FPUX86.FSUBRsti = function()
{
    this.setST(this.iStack, this.doSubtract(this.getST(0), this.getST(this.iStack)));
};

/**
 * FSUBRPsti()
 *
 * Encoding 0xDE,0xE0-0xE7 ("FSUBRP ST(i),ST"): ST(i) <- ST(0) - ST(i), POP
 *
 * @this {FPUX86}
 */
FPUX86.FSUBRPsti = function()
{
    if (this.setST(this.iStack, this.doSubtract(this.getST(0), this.getST(this.iStack)))) this.popValue();
};

/**
 * FTST()
 *
 * @this {FPUX86}
 */
FPUX86.FTST = function()
{
    this.doCompare(this.getST(0), 0);
};

/**
 * FXAM()
 *
 * @this {FPUX86}
 */
FPUX86.FXAM = function()
{
    this.regStatus &= ~X86.FPU.STATUS.CC;

    if (this.getSTSign(0)) {
        this.regStatus |= X86.FPU.STATUS.C1;
    }
    if (this.getTag(this.iST) == X86.FPU.TAGS.EMPTY) {
        this.regStatus |= X86.FPU.STATUS.C0 | X86.FPU.STATUS.C3;
    }
    else {
        let v = this.getST(0);
        if (isNaN(v)) {
            this.regStatus |= X86.FPU.STATUS.C0;
        }
        else if (v === 0) {                                 // this equals -0, too (WTF, strict equality?)
            this.regStatus |= X86.FPU.STATUS.C3;
        }
        else if (v === Infinity || v === -Infinity) {       // these are so divergent that even non-strict equality doesn't consider them equal
            this.regStatus |= X86.FPU.STATUS.C0 | X86.FPU.STATUS.C2;
        }
        else {
            this.regStatus |= X86.FPU.STATUS.C2;
        }
    }
};

/**
 * FXCHsti()
 *
 * @this {FPUX86}
 */
FPUX86.FXCHsti = function()
{
    let tmp = this.getST(0);
    this.setST(0, this.getST(this.iStack));
    this.setST(this.iStack, tmp);
};

/**
 * FXCH8087()
 *
 * NOTE: This is used with encodings (0xDD,0xC8-0xCF and 0xDF,0xC8-0xCF) that were valid for the 8087 and 80287
 * but may no longer be valid as of the 80387.
 *
 * @this {FPUX86}
 */
FPUX86.FXCH8087 = function()
{
    this.opObsolete();
    FPUX86.FXCHsti.call(this);
};

/**
 * FXTRACT()
 *
 * FXTRACT splits the value encoded in ST(0) into two separate numbers representing the actual value of the
 * fraction (mantissa) and exponent fields.
 *
 * The FXTRACT instruction is used to decompose the two fields of the temporary real number in ST(0).  The exponent
 * replaces the value in ST(0), then the fraction is pushed onto the stack.  When execution is complete, ST(0)
 * contains the original fraction, expressed as a real number with a true exponent of 0 (0x3FFF in biased form),
 * and ST(1) contains the value of the original operand's true (unbiased) exponent expressed as a real number.
 *
 * If ST(0) is 0, the 8087 and 80287 will leave zeros in both ST(0) and ST(1); both zeros will have the same sign as
 * the original operand.  If ST(0) is +infinity, the invalid operation exception is raised.
 *
 * On the 80287XL and later coprocessors, if ST(0) is 0, the zero-divide exception is reported and ST(1) is set to
 * -infinity.  If ST(0) is +infinity, no exception is reported.
 *
 * The FXTRACT instruction may be thought of as the complement to the FSCALE instruction, which combines a separate
 * fraction and exponent into a single value.
 *
 * ALGORITHM:
 *
 *      IF (ST(0) = 0) THEN
 *          DEC TOP
 *          ST(0) = ST(1)
 *      ELSE
 *          temp = ST(0)
 *          ST(0) = EXPONENT(ST(0))     ; stored as true exponent
 *          DEC TOP
 *          ST(0) = FRACTION(ST(0))
 *      ENDIF
 *
 * @this {FPUX86}
 */
FPUX86.FXTRACT = function()
{
    let v = this.getST(0);
    if (v != null) {
        this.regTmpLR[0] = v;
        this.setST(0, ((this.intTmpLR[1] >> 20) & 0x7ff) - 0x3ff);
        this.intTmpLR[1] = (this.intTmpLR[1] | 0x3ff00000) & ~0x40000000;
        this.pushValue(this.regTmpLR[0]);
    }
};

/**
 * FYL2X()
 *
 * FYL2X (y log base 2 of x) calculates:
 *
 *      ST(1) = ST(1) * log2(ST(0))
 *
 * The operands must satisfy the inequalities 0 < ST(0) < +infinity and -infinity < ST(1) < +infinity.  FYL2X pops
 * the stack and returns the result to the new ST(0).  Both original operands are destroyed.
 *
 * The FYL2X function is designed to optimize the calculation of a log to a base, n, other than two.  In such a case,
 * the following multiplication is required; ie:
 *
 *      logn(x) = logn(2) * log2(x)
 *
 * @this {FPUX86}
 */
FPUX86.FYL2X = function()
{
    if (this.setST(1, this.getST(1) * Math.log(this.getST(0)) / Math.LN2)) this.popValue();
};

/**
 * FYL2XP1()
 *
 * FYL2XP1 (y log base 2 of x plus 1) calculates:
 *
 *      ST(1) = ST(1) * log2(ST(0) + 1)
 *
 * The operands must satisfy the inequalities -(1-sqrt(2)/2) < ST(0) < (1-sqrt(2)/2) and -infinity < ST(1) < +infinity.
 * FYL2XP1 pops the stack and returns the result to the new ST(0).  Both original operands are destroyed.
 *
 * The FYL2XP1 function provides greater accuracy than FYL2X in computing the log of a number that is very close to 1.
 *
 * FYL2XP1 is typically used when computing compound interest, for example, which requires the calculation of a logarithm
 * of 1.0 + n where 0 < n < 0.29.  If 1.0 was added to n, significant digits might be lost.  By using FYL2XP1, the result
 * will be as accurate as n to within three units of temporary real precision.
 *
 * @this {FPUX86}
 */
FPUX86.FYL2XP1 = function()
{
    if (this.setST(1, this.getST(1) * Math.log(this.getST(0) + 1.0) / Math.LN2)) this.popValue();
};

/*
 * Class constants
 *
 * TODO: When loading any of the following 5 constants, the 80287XL and newer coprocessors apply rounding control.
 */

/** @const */
FPUX86.regL2T = Math.log(10) / Math.LN2;        // log2(10) (use Math.log2() if we ever switch to ES6)

/** @const */
FPUX86.regL2E = Math.LOG2E;                     // log2(e)

/** @const */
FPUX86.regPI  = Math.PI;                        // pi

/** @const */
FPUX86.regLG2 = Math.log(2) / Math.LN10;        // log10(2) (use Math.log10() if we ever switch to ES6)

/** @const */
FPUX86.regLN2 = Math.LN2;                       // log(2)

/** @const */
FPUX86.MAX_INT16 = 0x8000;

/** @const */
FPUX86.MAX_INT32 = 0x80000000;

/** @const */
FPUX86.MAX_INT64 = Math.pow(2, 63);


/*
 * FPU operation lookup table (be sure to keep the following table in sync with Debugger.aaaOpFPUDescs).
 *
 * The second lookup value corresponds to bits in the ModRegRM byte that follows the ESC byte (0xD8-0xDF).
 *
 * Here's a little cheat-sheet for how the 2nd lookup values relate to ModRegRM values; see opFPU() for details.
 *
 *      Lookup  ModRegRM value(s)
 *      ------  -------------------------------
 *      0x00:   0x00-0x07, 0x40-0x47, 0x80-0x87
 *      0x01:   0x08-0x0F, 0x48-0x4F, 0x88-0x8F
 *      0x02:   0x10-0x17, 0x50-0x57, 0x90-0x97
 *      0x03:   0x18-0x1F, 0x58-0x5F, 0x98-0x9F
 *      0x04:   0x20-0x27, 0x60-0x67, 0xA0-0xA7
 *      0x05:   0x28-0x2F, 0x68-0x6F, 0xA8-0xAF
 *      0x06:   0x30-0x37, 0x70-0x77, 0xB0-0xB7
 *      0x07:   0x38-0x3F, 0x78-0x7F, 0xB8-0xBF
 *      0x30:   0xC0-0xC7
 *      0x31:   0xC8-0xCF
 *      0x32:   0xD0-0xD7
 *      0x33:   0xD8-0xDF
 *      0x34:   0xE0-0xE7
 *      0x35:   0xE8-0xEF
 *      0x36:   0xF0-0xF7
 *      0x37:   0xF8-0xFF
 *
 * ESC bytes 0xD9 and 0xDB use the RM field to further describe the operation when the ModRegRM value >= 0xE0.
 * In those cases, we shift the Reg value into the high nibble and the RM value into the low nibble, resulting in
 * the following lookup values (which look a lot like hex-encoded octal):
 *
 *      0x40:   0xE0
 *      0x41:   0xE1
 *      ...     ...
 *      0x46:   0xE6
 *      0x47:   0xE7
 *
 *      0x50:   0xE8
 *      0x51:   0xE9
 *      ...     ...
 *      0x56:   0xEE
 *      0x57:   0xEF
 *
 *      0x60:   0xF0
 *      0x61:   0xF1
 *      ...     ...
 *      0x66:   0xF6
 *      0x67:   0xF7
 *
 *      0x70:   0xF8
 *      0x71:   0xF9
 *      ...     ...
 *      0x76:   0xFE
 *      0x77:   0xFF
 */
FPUX86.aaOps = {
    0xD8: {
        0x00: FPUX86.FADDsr,    0x01: FPUX86.FMULsr,    0x02: FPUX86.FCOMsr,    0x03: FPUX86.FCOMPsr,
        0x04: FPUX86.FSUBsr,    0x05: FPUX86.FSUBRsr,   0x06: FPUX86.FDIVsr,    0x07: FPUX86.FDIVsr,
        0x30: FPUX86.FADDst,    0x31: FPUX86.FMULst,    0x32: FPUX86.FCOMst,    0x33: FPUX86.FCOMPst,
        0x34: FPUX86.FSUBst,    0x35: FPUX86.FSUBRst,   0x36: FPUX86.FDIVst,    0x37: FPUX86.FDIVRst
    },
    0xD9: {
        0x00: FPUX86.FLDsr,                             0x02: FPUX86.FSTsr,     0x03: FPUX86.FSTPsr,
        0x04: FPUX86.FLDENV,    0x05: FPUX86.FLDCW,     0x06: FPUX86.FSTENV,    0x07: FPUX86.FSTCW,
        0x30: FPUX86.FLDsti,    0x31: FPUX86.FXCHsti,   0x32: FPUX86.FNOP,      0x33: FPUX86.FSTP8087,
        0x40: FPUX86.FCHS,      0x41: FPUX86.FABS,
        0x44: FPUX86.FTST,      0x45: FPUX86.FXAM,
        0x50: FPUX86.FLD1,      0x51: FPUX86.FLDL2T,    0x52: FPUX86.FLDL2E,    0x53: FPUX86.FLDPI,
        0x54: FPUX86.FLDLG2,    0x55: FPUX86.FLDLN2,    0x56: FPUX86.FLDZ,
        0x60: FPUX86.F2XM1,     0x61: FPUX86.FYL2X,     0x62: FPUX86.FPTAN,     0x63: FPUX86.FPATAN,
        0x64: FPUX86.FXTRACT,                           0x66: FPUX86.FDECSTP,   0x67: FPUX86.FINCSTP,
        0x70: FPUX86.FPREM,     0x71: FPUX86.FYL2XP1,   0x72: FPUX86.FSQRT,
        0x74: FPUX86.FRNDINT,   0x75: FPUX86.FSCALE
    },
    0xDA: {
        0x00: FPUX86.FIADD32,   0x01: FPUX86.FIMUL32,   0x02: FPUX86.FICOM32,   0x03: FPUX86.FICOMP32,
        0x04: FPUX86.FISUB32,   0x05: FPUX86.FISUBR32,  0x06: FPUX86.FIDIV32,   0x07: FPUX86.FIDIVR32
    },
    0xDB: {
        0x00: FPUX86.FILD32,    0x02: FPUX86.FIST32,    0x03: FPUX86.FISTP32,
                                0x05: FPUX86.FLDtr,                             0x07: FPUX86.FSTPtr,
        0x40: FPUX86.FENI8087,  0x41: FPUX86.FDISI8087, 0x42: FPUX86.FCLEX,     0x43: FPUX86.FINIT,
        0x44: FPUX86.FSETPM287,
        0x73: FPUX86.FSINCOS387
    },
    0xDC: {
        0x00: FPUX86.FADDlr,    0x01: FPUX86.FMULlr,    0x02: FPUX86.FCOMlr,    0x03: FPUX86.FCOMPlr,
        0x04: FPUX86.FSUBlr,    0x05: FPUX86.FSUBRlr,   0x06: FPUX86.FDIVlr,    0x07: FPUX86.FDIVRlr,
        0x30: FPUX86.FADDsti,   0x31: FPUX86.FMULsti,   0x32: FPUX86.FCOM8087,  0x33: FPUX86.FCOMP8087,
        /*
         * Intel's original 8087 datasheet had these forms of SUB and SUBR (and DIV and DIVR) swapped.
         */
        0x34: FPUX86.FSUBRsti,  0x35: FPUX86.FSUBsti,   0x36: FPUX86.FDIVRsti,  0x37: FPUX86.FDIVsti
    },
    0xDD: {
        0x00: FPUX86.FLDlr,                             0x02: FPUX86.FSTlr,     0x03: FPUX86.FSTPlr,
        0x04: FPUX86.FRSTOR,                            0x06: FPUX86.FSAVE,     0x07: FPUX86.FSTSW,
        0x30: FPUX86.FFREEsti,  0x31: FPUX86.FXCH8087,  0x32: FPUX86.FSTsti,    0x33: FPUX86.FSTPsti
    },
    0xDE: {
        0x00: FPUX86.FIADD16,   0x01: FPUX86.FIMUL16,   0x02: FPUX86.FICOM16,   0x03: FPUX86.FICOMP16,
        0x04: FPUX86.FISUB16,   0x05: FPUX86.FISUBR16,  0x06: FPUX86.FIDIV16,   0x07: FPUX86.FIDIVR16,
        0x30: FPUX86.FADDPsti,  0x31: FPUX86.FMULPsti,  0x32: FPUX86.FCOMP8087, 0x33: FPUX86.FCOMPP,
        /*
         * Intel's original 8087 datasheet had these forms of SUBP and SUBRP (and DIVP and DIVRP) swapped.
         */
        0x34: FPUX86.FSUBRPsti, 0x35: FPUX86.FSUBPsti,  0x36: FPUX86.FDIVRPsti, 0x37: FPUX86.FDIVPsti
    },
    0xDF: {
        0x00: FPUX86.FILD16,                            0x02: FPUX86.FIST16,    0x03: FPUX86.FISTP16,
        0x04: FPUX86.FBLDpd,    0x05: FPUX86.FILD64,    0x06: FPUX86.FBSTPpd,   0x07: FPUX86.FISTP64,
        0x30: FPUX86.FFREEP8087,0x31: FPUX86.FXCH8087,  0x32: FPUX86.FSTP8087,  0x33: FPUX86.FSTP8087,
        0x34: FPUX86.FSTSWAX287
    }
};

/*
 * An array of FPUX86 functions documented as preserving the "exception" registers.
 */
FPUX86.afnPreserveExceptions = [
    FPUX86.FCLEX,   FPUX86.FINIT,   FPUX86.FLDCW,   FPUX86.FLDENV,  FPUX86.FRSTOR,
    FPUX86.FSAVE,   FPUX86.FSTCW,   FPUX86.FSTENV,  FPUX86.FSTSW,   FPUX86.FSTSWAX287
];

/*
 * Initialize every FPU module on the page
 */
Web.onInit(FPUX86.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/segx86.js (C) Jeff Parsons 2012-2018
 */


/*
 * NOTE: The protected-mode support in this module was initially added for 80286 support, and is
 * currently being upgraded for 80386 support.  In a perfect world, all 80386-related support would
 * be disabled/skipped whenever the processor is merely an 80286.  And in fact, that's the case
 * with some of the early changes (eg, skipping X86.DESC.EXT.BASE2431 and X86.DESC.EXT.LIMIT1619
 * fields unless the processor is an 80386).
 *
 * However, the reality is that I won't always be that strict, either because I'm lazy or I don't
 * want to risk a run-time performance hit or (more pragmatically) because any 80286 code you're likely
 * to run probably won't attempt to use descriptor types or other features unique to the 80386 anyway,
 * so the extra paranoia may not be worth the effort.  Ultimately, I would like to see the code tailor
 * itself to the current CPU model, generally with model-specific functions, but that's a lot of work.
 */

/**
 * class SegX86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class SegX86 {
    /**
     * SegX86(cpu, sName)
     *
     * @this {SegX86}
     * @param {CPUX86} cpu
     * @param {number} id
     * @param {string} [sName] segment register name
     * @param {boolean} [fProt] true if segment register used exclusively in protected-mode (eg, segLDT)
     */
    constructor(cpu, id, sName, fProt)
    {
        this.cpu = cpu;
        /**
         * @type {DebuggerX86}
         */
        this.dbg = cpu.dbg;
        this.id = id;
        this.sName = sName || "";
        this.sel = 0;
        this.limit = 0xffff;
        this.offMax = this.limit + 1;
        this.base = 0;
        this.acc = this.type = 0;
        this.ext = 0;
        this.cpl = this.dpl = 0;
        this.addrDesc = X86.ADDR_INVALID;
        this.sizeData = this.sizeAddr = 2;
        this.maskData = this.maskAddr = 0xffff;

        this.loadV86 = this.loadReal;
        this.checkReadV86 = this.checkReadWriteReal;
        this.checkWriteV86 = this.checkReadWriteReal;

        /*
         * Preallocated object for "probed" segment loads
         */
        this.probe = {
            sel: -1, base: 0, limit: 0, acc: 0, type: 0, ext: 0, addrDesc: X86.ADDR_INVALID
        };

        /*
         * The following properties are used for CODE segments only (ie, segCS); if the process of loading
         * CS also requires a stack switch, then fStackSwitch will be set to true; additionally, if the stack
         * switch was the result of a CALL (ie, fCall is true) and one or more (up to 32) parameters are on
         * the old stack, they will be copied to awParms, and then once the stack is switched, the parameters
         * will be pushed from awParms onto the new stack.
         *
         * The typical ways of loading a new segment into CS are JMPF, CALLF (or INT), and RETF (or IRET),
         * via CPU functions setCSIP() and helpINT(), which use segCS.loadCode() and segCS.loadIDT(), respectively.
         *
         * loadCode() requires an fCall value: null means NO privilege level transition may occur, true
         * allows a stack switch and a privilege transition to a numerically lower privilege, and false allows
         * a stack restore and a privilege transition to a numerically greater privilege.
         *
         * loadIDT() sets fCall to true unconditionally in protected-mode (fCall has no meaning in real-mode).
         */
        if (this.id == 1 /* SegX86.ID.CODE */) {        // don't use SegX86.ID.CODE until it's defined, or the Closure Compiler won't inline it
            this.offIP = 0;
            this.fCall = null;
            this.fStackSwitch = false;
            this.awParms = new Array(32);
            this.aCallBreaks = [];
        }

        this.updateMode(true, fProt);

        if (this.id == 0 /* SegX86.ID.NULL */) {
            this.checkRead = this.checkReadWriteNone;
            this.checkWrite = this.checkReadWriteNone;
        }
    }

    /**
     * addCallBreak(fn)
     *
     * Returns a "call break" address in an [off, sel] array.  The given function, fn(), is called
     * whenever that address is called, and if fn() returns false, then the call is skipped.  Otherwise,
     * the call is performed (ie, the old CS:[E]IP is pushed on the stack, and CS:[E]IP is set to the
     * "call break" address.  Which is probably a bad idea, so your function should probably always
     * return false.  Just sayin'.  TODO: Should probably just force all "call break" calls to be skipped.
     *
     * @this {SegX86}
     * @param {function()} fn
     * @return {Array.<number>} containing offset and selector of call-break address
     */
    addCallBreak(fn)
    {
        this.aCallBreaks.push(fn);
        return [this.aCallBreaks.length, SegX86.CALLBREAK_SEL];
    }

    /**
     * loadCode(off, sel, fCall)
     *
     * A simple wrapper function that encapsulates setting offIP and fCall for segCS loads.
     *
     * @this {SegX86}
     * @param {number} off
     * @param {number} sel
     * @param {boolean|undefined} fCall is true if CALLF in progress, false if RETF/IRET in progress, undefined otherwise
     * @return {number} base address of selected segment, or X86.ADDR_INVALID if error
     */
    loadCode(off, sel, fCall)
    {
        this.offIP = off;
        this.fCall = fCall;
        return this.load(sel);
    }

    /**
     * loadReal(sel, fProbe)
     *
     * The default segment load() function for real-mode.
     *
     * @this {SegX86}
     * @param {number} sel
     * @param {boolean} [fProbe] (here only to make the function signatures of loadReal() and loadProt() match)
     * @return {number} base address of selected segment
     */
    loadReal(sel, fProbe)
    {
        this.sel = sel & 0xffff;
        /*
         * Loading a new value into a segment register in real-mode alters ONLY the selector and the base;
         * all other attributes (eg, limit, operand size, address size, etc) are unchanged.  If you run any
         * code that switches to protected-mode, loads a 32-bit code segment, and then switches back to
         * real-mode, it is THAT code's responsibility to load a 16-bit segment into CS before returning to
         * real-mode; otherwise, your machine will probably be toast.
         */
        return this.base = this.sel << 4;
    }

    /**
     * loadProt(sel, fProbe)
     *
     * This replaces the segment's default load() function whenever the segment is notified via updateMode() by the
     * CPU's setProtMode() that the processor is now in protected-mode.
     *
     * Segments in protected-mode are referenced by selectors, which are indexes into descriptor tables (GDT or LDT)
     * whose descriptors are 4-word (8-byte) entries:
     *
     *      word 0: segment limit (0-15)
     *      word 1: base address low
     *      word 2: base address high (0-7), segment type (8-11), descriptor type (12), DPL (13-14), present bit (15)
     *      word 3: used only on 80386 and up (should be set to zero for upward compatibility)
     *
     * See X86.DESC for offset and bit definitions.
     *
     * IDT descriptor entries are handled separately by loadIDT(), which is mapped to loadIDTReal() or loadIDTProt().
     *
     * @this {SegX86}
     * @param {number} sel
     * @param {boolean} [fProbe]
     * @return {number} base address of selected segment, or X86.ADDR_INVALID if error
     */
    loadProt(sel, fProbe)
    {
        let addrDT;
        let addrDTLimit;
        let cpu = this.cpu;

        /*
         * Some instructions (eg, CALLF) load a 32-bit value for the selector, while others (eg, LDS) do not;
         * however, in ALL cases, only the low 16 bits are significant.
         */
        sel &= 0xffff;

        if (!(sel & X86.SEL.LDT)) {
            addrDT = cpu.addrGDT;
            addrDTLimit = cpu.addrGDTLimit;
        } else {
            addrDT = cpu.segLDT.base;
            addrDTLimit = (addrDT + cpu.segLDT.limit)|0;
        }
        /*
         * The ROM BIOS POST executes some test code in protected-mode without properly initializing the LDT,
         * which has no bearing on the ROM's own code, because it never loads any LDT selectors, but if at the same
         * time our Debugger attempts to validate a selector in one of its breakpoints, that could cause some grief.
         *
         * Fortunately, the Debugger now has its own interface, probeDesc(), so that should no longer be a concern.
         */
        if (addrDT) {
            let addrDesc = (addrDT + (sel & X86.SEL.MASK))|0;
            if ((addrDTLimit - addrDesc)|0 >= 7) {
                /*
                 * TODO: This is the first of many steps toward accurately counting cycles in protected mode;
                 * I simply noted that "POP segreg" takes 5 cycles in real mode and 20 in protected mode, so I'm
                 * starting with a 15-cycle difference.  Obviously the difference will vary with the instruction,
                 * and will be much greater whenever the load fails.
                 */
                cpu.nStepCycles -= 15;
                return this.loadDesc8(addrDesc, sel, fProbe);
            }
            if (this.id < SegX86.ID.VER) {
                X86.helpFault.call(cpu, fProbe && this.id == SegX86.ID.STACK? X86.EXCEPTION.TS_FAULT : X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * loadIDTReal(nIDT)
     *
     * @this {SegX86}
     * @param {number} nIDT
     * @return {number} address from selected vector
     */
    loadIDTReal(nIDT)
    {
        let cpu = this.cpu;
        /*
         * NOTE: The COMPAQ DeskPro 386 ROM loads the IDTR for the real-mode IDT with a limit of 0xffff instead
         * of the normal 0x3ff.  A limit higher than 0x3ff is OK, since all real-mode IDT entries are 4 bytes, and
         * there's no way to issue an interrupt with a vector > 0xff.  Just something to be aware of.
         */

        /*
         * Intel documentation for INT/INTO under "REAL ADDRESS MODE EXCEPTIONS" says:
         *
         *      "[T]he 80286 will shut down if the SP = 1, 3, or 5 before executing the INT or INTO instruction--due to lack of stack space"
         *
         * TODO: Verify that 80286 real-mode actually enforces the above.  See http://www.pcjs.org/pubs/pc/reference/intel/80286/progref/#page-260
         */
        let addrIDT = cpu.addrIDT + (nIDT << 2);
        let off = cpu.getShort(addrIDT);
        cpu.regPS &= ~(X86.PS.TF | X86.PS.IF);
        return (this.load(cpu.getShort(addrIDT + 2)) + off)|0;
    }

    /**
     * loadIDTProt(nIDT)
     *
     * @this {SegX86}
     * @param {number} nIDT
     * @return {number} address from selected vector, or X86.ADDR_INVALID if error
     */
    loadIDTProt(nIDT)
    {
        let cpu = this.cpu;


        nIDT <<= 3;
        let addrDesc = (cpu.addrIDT + nIDT)|0;
        if (((cpu.addrIDTLimit - addrDesc)|0) >= 7) {
            this.fCall = true;
            let addr = this.loadDesc8(addrDesc, nIDT);
            if (addr !== X86.ADDR_INVALID) addr += this.offIP;
            return addr;
        }
        X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, nIDT | X86.ERRCODE.IDT);
        return X86.ADDR_INVALID;
    }

    /**
     * checkReadWriteNone(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address
     */
    checkReadWriteNone(off, cb)
    {
        return (this.base + off)|0;
    }

    /**
     * checkReadWriteReal(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address
     */
    checkReadWriteReal(off, cb)
    {
        /*
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb > this.offMax) {
            if (this.cpu.model <= X86.MODEL_8088) {
                this.cpu.opFlags |= X86.OPFLAG.WRAP;
            } else {
                X86.helpFault.call(this.cpu, X86.EXCEPTION.GP_FAULT);
            }
        }
        return (this.base + off)|0;
    }

    /**
     * checkReadProt(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address if valid, or X86.ADDR_INVALID if not
     */
    checkReadProt(off, cb)
    {
        /*
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb <= this.offMax) {
            return (this.base + off)|0;
        }
        return this.checkReadProtDisallowed(off, cb);
    }

    /**
     * checkReadProtDown(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkReadProtDown(off, cb)
    {
        /*
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb > this.offMax) {
            return (this.base + off)|0;
        }
        return this.checkReadProtDisallowed(off, cb);
    }

    /**
     * checkReadProtDisallowed(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkReadProtDisallowed(off, cb)
    {
        X86.helpFault.call(this.cpu, X86.EXCEPTION.GP_FAULT, 0);
        return X86.ADDR_INVALID;
    }

    /**
     * checkWriteProt(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkWriteProt(off, cb)
    {
        /*
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb <= this.offMax) {
            return (this.base + off)|0;
        }
        return this.checkWriteProtDisallowed(off, cb);
    }

    /**
     * checkWriteProtDown(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkWriteProtDown(off, cb)
    {
        /*
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb > this.offMax) {
            return (this.base + off)|0;
        }
        return this.checkWriteProtDisallowed(off, cb);
    }

    /**
     * checkWriteProtDisallowed(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkWriteProtDisallowed(off, cb)
    {
        X86.helpFault.call(this.cpu, X86.EXCEPTION.GP_FAULT, 0);
        return X86.ADDR_INVALID;
    }

    /**
     * checkReadDebugger(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address if valid, or X86.ADDR_INVALID if error
     */
    checkReadDebugger(off, cb)
    {
        /*
         * The Debugger doesn't have separate "check" interfaces for real and protected mode,
         * since it's not performance-critical.  If addrDesc is invalid, then we assume real mode.
         *
         * TODO: This doesn't actually check the segment for readability.
         */
        if (DEBUGGER) {
            if (this.addrDesc === X86.ADDR_INVALID ||
                this.fExpDown && (off >>> 0) + cb > this.offMax ||
                !this.fExpDown && (off >>> 0) + cb <= this.offMax) {
                return (this.base + off)|0;
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * checkWriteDebugger(off, cb)
     *
     * @this {SegX86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @return {number} corresponding linear address if valid, or X86.ADDR_INVALID if error
     */
    checkWriteDebugger(off, cb)
    {
        /*
         * The Debugger doesn't have separate "check" interfaces for real and protected mode,
         * since it's not performance-critical.  If addrDesc is invalid, then we assume real mode.
         *
         * TODO: This doesn't actually check the segment for writability.
         */
        if (DEBUGGER) {
            if (this.addrDesc === X86.ADDR_INVALID ||
                this.fExpDown && (off >>> 0) + cb > this.offMax ||
                !this.fExpDown && (off >>> 0) + cb <= this.offMax) {
                return (this.base + off)|0;
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * loadDesc(sel, acc, base, limit)
     *
     * Used to manually load a segment register from the data provided (see LOADALL386).
     *
     * @this {SegX86}
     * @param {number} sel
     * @param {number} acc
     * @param {number} base
     * @param {number} limit
     */
    loadDesc(sel, acc, base, limit)
    {
        this.sel = sel;
        this.base = base;
        this.limit = limit;
        this.offMax = (limit >>> 0) + 1;
        this.acc = acc;
        this.type = (acc & X86.DESC.ACC.TYPE.MASK);
        this.ext = (acc >> 16) & (X86.DESC.EXT.BIG | X86.DESC.EXT.LIMITPAGES);

        let addrDT = (sel & X86.SEL.LDT)? this.cpu.segLDT.base : this.cpu.addrGDT;
        this.addrDesc = (addrDT + (sel & X86.SEL.MASK))|0;

        /*
         * NOTE: This code must take care to leave the mode of the TSS, LDT, and VER segment registers alone;
         * in particular, we must not allow a real-mode LOADALL to modify their mode, because the rest of PCx86
         * assumes that their mode will never change (they were allocated with fProt set to true).
         */
        if (this.id < SegX86.ID.TSS) this.updateMode(true);

        if (DEBUG) this.messageSeg(sel, base, limit, this.type);
    }

    /**
     * loadDesc6(addrDesc, sel)
     *
     * Used to load a protected-mode selector that refers to a 6-byte "descriptor cache" entry (see LOADALL286):
     *
     *      word 0: base address low
     *      word 1: base address high (0-7), segment type (8-11), descriptor type (12), DPL (13-14), present bit (15)
     *      word 2: segment limit (0-15)
     *
     * @this {SegX86}
     * @param {number} addrDesc is the descriptor address
     * @param {number} sel is the associated selector
     * @return {number} base address of selected segment
     */
    loadDesc6(addrDesc, sel)
    {
        let cpu = this.cpu;
        let acc = cpu.getShort(addrDesc + 2);
        let base = cpu.getShort(addrDesc) | ((acc & 0xff) << 16);
        let limit = cpu.getShort(addrDesc + 4);

        this.sel = sel;
        this.base = base;
        this.limit = limit;
        this.offMax = (limit >>> 0) + 1;
        this.acc = acc;
        this.type = (acc & X86.DESC.ACC.TYPE.MASK);
        this.ext = 0;
        this.addrDesc = addrDesc;

        /*
         * NOTE: This code must take care to leave the mode of the TSS, LDT, and VER segment registers alone;
         * in particular, we must not allow a real-mode LOADALL to modify their mode, because the rest of PCx86
         * assumes that their mode will never change (they were allocated with fProt set to true).
         */
        if (this.id < SegX86.ID.TSS) this.updateMode(true);

        if (DEBUG) this.messageSeg(sel, base, limit, this.type);

        return base;
    }

    /**
     * loadDesc8(addrDesc, sel, fProbe)
     *
     * Used to load a protected-mode selector that refers to an 8-byte "descriptor table" (GDT, LDT, IDT) entry:
     *
     *      word 0: segment limit (0-15)
     *      word 1: base address low
     *      word 2: base address high (0-7), segment type (8-11), descriptor type (12), DPL (13-14), present bit (15)
     *      word 3: used only on 80386 and up (should be set to zero for upward compatibility)
     *
     * See X86.DESC for offset and bit definitions.
     *
     * When fProbe is set, we do NOT modify the public properties of the SegX86 object (see class SegX86 above).
     * We will generate a fault if any of the usual error conditions are detected (and return X86.ADDR_INVALID), but
     * otherwise, we merely stash all the descriptor values it reads in the SegX86's private "probe" object.
     *
     * Probed loads allow us to deal with complex segment load operations (ie, those involving an implied stack-switch
     * or task-switch), by allowing us to probe all the new selectors and generate the necessary faults before modifying
     * any segment registers; if all the probes succeed, then the original load can proceed.
     *
     * The next non-probed load of a probed selector will move those probed descriptor values into the SegX86 object,
     * saving us from having to reload and reparse the descriptor.  However, if a different selector is loaded between
     * the probed and non-probed loads, the probed data is tossed.
     *
     * @this {SegX86}
     * @param {number} addrDesc is the descriptor address
     * @param {number} sel is the associated selector, or nIDT*8 if IDT descriptor
     * @param {boolean} [fProbe] (true if this is a probe)
     * @return {number} base address of selected segment, or X86.ADDR_INVALID if error
     */
    loadDesc8(addrDesc, sel, fProbe)
    {
        let cpu = this.cpu;

        /*
         * If the previous load was a successful "probed" load of the same segment, then we simply load
         * up all the cached descriptor values from the probe and return.
         */
        if (!fProbe && sel === this.probe.sel) {
            this.sel = sel;
            this.base = this.probe.base;
            this.limit = this.probe.limit;
            this.offMax = (this.probe.limit >>> 0) + 1;
            this.acc = this.probe.acc;
            this.type = this.probe.type;
            this.ext = this.probe.ext;
            this.addrDesc = this.probe.addrDesc;
            this.probe.sel = -1;
            this.updateMode(true, true, false);
            return this.base;
        }

        /*
         * Any other load, probed or otherwise, should "flush" the probe cache, by setting probe.sel to -1.
         */
        this.probe.sel = -1;

        /*
         * Load the descriptor from memory.
         */
        let limit = cpu.getShort(addrDesc + X86.DESC.LIMIT.OFFSET), limitOrig;
        let acc = cpu.getShort(addrDesc + X86.DESC.ACC.OFFSET);
        let type = (acc & X86.DESC.ACC.TYPE.MASK);
        let base = cpu.getShort(addrDesc + X86.DESC.BASE.OFFSET) | ((acc & X86.DESC.ACC.BASE1623) << 16);
        let ext = cpu.getShort(addrDesc + X86.DESC.EXT.OFFSET);
        let selMasked = sel & X86.SEL.MASK;

        if (I386 && cpu.model >= X86.MODEL_80386) {
            limitOrig = limit;
            base |= (ext & X86.DESC.EXT.BASE2431) << 16;
            limit |= (ext & X86.DESC.EXT.LIMIT1619) << 16;
            if (ext & X86.DESC.EXT.LIMITPAGES) limit = (limit << 12) | 0xfff;
        }

        switch (this.id) {

        case SegX86.ID.CODE:

            /*
             * NOTE: Since we are SegX86.ID.CODE, we can use this.cpl instead of the more convoluted
             * this.cpu.segCS.cpl.
             */
            let fCall = this.fCall;
            this.fStackSwitch = false;

            /*
             * This special bit of code is currently used only by the Debugger, when it needs to inject
             * a 16:32 callback address into the machine that it can intercept calls to.  We call these
             * "call break" addresses, because they're essentially breakpoints that only operate when
             * a particular address is called; specifically, an address with selector 0x0001 and an offset
             * that forms a (1-based) index into the aCallBreaks function table.
             *
             * In protected-mode, any null selector, including 0x0001 (null with an RPL of 1), is
             * an invalid CS selector, and while it's not inconceivable that an operating system might
             * use such a selector for some strange purpose, I've not seen such an operating system.
             * And in any case, those operating systems are not likely to trigger the Debugger's call to
             * addCallBreak(), so no call breaks will be generated, and this code will never execute.
             *
             * TODO: If we ever need this to be mode-independent, it can be moved somewhere where it will
             * trigger for both real and protected-mode code segment loads, because CALLBREAK_SEL (0x0001)
             * is also a very unlikely real-mode CS value (but again, not inconceivable).  I think this is
             * a reasonable solution, and it's likely the best we can do without injecting code into the
             * machine that we could address -- and even then, it would not be a mode-independent address.
             */
            if (fCall && sel == SegX86.CALLBREAK_SEL && this.aCallBreaks.length) {
                let iBreak = this.offIP - 1;
                let fnCallBreak = this.aCallBreaks[iBreak];

                if (fnCallBreak && !fnCallBreak()) {
                    return X86.ADDR_INVALID;
                }
            }

            let rpl = sel & X86.SEL.RPL;
            let dpl = (acc & X86.DESC.ACC.DPL.MASK) >> X86.DESC.ACC.DPL.SHIFT;

            let sizeGate = -1, selCode, cplOld, cplNew, fIDT;
            let addrTSS, offSP, lenSP, regSPPrev, regSSPrev, regPSClear, regSP;

            if (!selMasked) {
                /*
                 * selMasked is really the descriptor table offset, and a zero offset is fine for the IDT,
                 * and it's probably fine for the LDT, but it's definitely NOT fine for the GDT, because
                 * that's a reference to the null selector.  A null selector is allowed in DS, ES, FS, or GS,
                 * but never CS or SS.  Since there's no parameter that tells us which table we're using,
                 * we have to check manually.
                 *
                 * If we ARE attempting to load a null selector from the GDT, then we zero type, ensuring that
                 * sizeGate will remain invalid (-1), triggering a GP_FAULT below.
                 */
                if (addrDesc >= cpu.addrGDT && addrDesc < cpu.addrGDTLimit) type = 0;
            }

            if (type >= X86.DESC.ACC.TYPE.CODE_EXECONLY) {
                /*
                 * There are three basic ways to load a new code segment (ignoring special cases like LOADALL):
                 *
                 *      1) CALLF (fCall is true)
                 *      2) RETF (fCall is false)
                 *      3) JMPF (fCall is undefined)
                 *
                 * Also, note that if fProbe is set, we're being called on behalf of a gate, in which case the
                 * gate logic will examine the relative privileges.
                 */
                if (fProbe != null) {
                    sizeGate = 0;
                }
                else if (fCall !== false) {
                    /*
                     * We deal with CALLF/JMPF first.  We've already ascertained that the selector type is a
                     * segment, not a gate, so the next important distinction is CONFORMING vs. non-CONFORMING.
                     *
                     * For a CONFORMING target, we must verify that its DPL <= CPL.  For a non-CONFORMING target,
                     * we must verify that RPL <= CPL and DPL == CPL.  Assuming both those tests pass, we must also
                     * ensure that the current CPL is recorded as the new RPL (that is, the RPL bits of sel must be
                     * updated).
                     */
                    if (type & X86.DESC.ACC.TYPE.CONFORMING) {
                        if (dpl <= this.cpl) {
                            sizeGate = 0;
                        }
                    } else {
                        if (rpl <= this.cpl && dpl == this.cpl) {
                            sizeGate = 0;
                        }
                    }
                    if (!sizeGate) {
                        sel = (sel & ~X86.SEL.RPL) | (this.cpl & X86.SEL.RPL);
                    }
                }
                else {
                    /*
                     * We deal with RETF next.  For starters, we must verify that RPL >= CPL.  Moreover, if
                     * RPL > CPL, then we have a privilege level change that requires a stack switch, assuming
                     * the stack selector is acceptable.
                     */
                    if (rpl >= this.cpl) {
                        if (rpl > this.cpl) {
                            /*
                             * TODO: See if we can defer calling setSS() and setSP() until AFTER the final checks
                             * below, because if, for example, the new CS is not PRESENT, we must generate a fault,
                             * which in turn must restore the original stack, which means helpRETF() must snapshot
                             * the stack registers.
                             */
                            regSP = cpu.popWord();
                            cpu.setSS(cpu.popWord(), true);
                            cpu.setSP(regSP);
                            this.fStackSwitch = true;
                        }
                        sizeGate = 0;
                    }
                }
            }
            else if (type == X86.DESC.ACC.TYPE.TSS286 || type == X86.DESC.ACC.TYPE.TSS386) {
                if (!this.switchTSS(sel, fCall)) {
                    return X86.ADDR_INVALID;
                }
                return this.base;
            }
            else if (type == X86.DESC.ACC.TYPE.GATE_CALL) {
                sizeGate = 2;
                regPSClear = 0;
                if (rpl < this.cpl) rpl = this.cpl;     // set RPL to max(RPL,CPL) for call gates
            }
            else if (type == X86.DESC.ACC.TYPE.GATE386_CALL) {
                sizeGate = 4;
                regPSClear = 0;
                if (rpl < this.cpl) rpl = this.cpl;     // set RPL to max(RPL,CPL) for call gates
            }
            else if (type == X86.DESC.ACC.TYPE.GATE286_INT) {
                sizeGate = 2;
                regPSClear = (X86.PS.VM | X86.PS.NT | X86.PS.TF | X86.PS.IF);

            }
            else if (type == X86.DESC.ACC.TYPE.GATE386_INT) {
                sizeGate = 4;
                regPSClear = (X86.PS.VM | X86.PS.NT | X86.PS.TF | X86.PS.IF);

            }
            else if (type == X86.DESC.ACC.TYPE.GATE286_TRAP) {
                sizeGate = 2;
                regPSClear = (X86.PS.VM | X86.PS.NT | X86.PS.TF);

            }
            else if (type == X86.DESC.ACC.TYPE.GATE386_TRAP) {
                sizeGate = 4;
                regPSClear = (X86.PS.VM | X86.PS.NT | X86.PS.TF);

            }
            else if (type == X86.DESC.ACC.TYPE.GATE_TASK) {
                if (!this.switchTSS(base & 0xffff, fCall)) {
                    return X86.ADDR_INVALID;
                }
                return this.base;
            }

            if (sizeGate > 0 && !(acc & X86.DESC.ACC.PRESENT)) sizeGate = 0;

            if (sizeGate > 0) {
                /*
                 * Note that since GATE_INT/GATE_TRAP descriptors should appear in the IDT only, that means sel
                 * will actually be nIDT * 8, which means the rpl will always be zero; additionally, the nWords
                 * portion of ACC should always be zero, but that's really dependent on the descriptor being properly
                 * set (which we assert above).
                 */
                cplOld = this.cpl;
                fIDT = (addrDesc == cpu.addrIDT + sel);

                /*
                 * Software interrupts (where fIDT is true and cpu.nFault < 0) require an additional test:
                 * if DPL < CPL, then we must fall into the GP_FAULT code at the end of this case.
                 */
                if (rpl <= dpl && (!fIDT || cpu.nFault >= 0 || cplOld <= dpl))  {

                    /*
                     * For gates, there is no "base" and "limit", but rather "selector" and "offset"; the selector
                     * is located where the first 16 bits of base are normally stored, and the offset comes from the
                     * original limit and ext fields.
                     *
                     * TODO: Verify the PRESENT bit of the gate descriptor, and issue NP_FAULT as appropriate.
                     */
                    selCode = base & 0xffff;
                    if (I386 && (type & X86.DESC.ACC.TYPE.NONSEG_386)) {
                        limit = limitOrig | (ext << 16);
                    }

                    let selStack = 0, offStack = 0;
                    cplNew = (selCode & X86.SEL.RPL);

                    /*
                     * If a stack switch is required, we must perform "probed" loads of both the new selCode
                     * and selStack segments, so that if either probe fails, a fault will be generated while the
                     * old code segment is still loaded.
                     */
                    if (cplNew < cplOld) {
                        /*
                         * Intel pseudo-code suggests that selStack should be "probed" before selCode, but it also
                         * implies that we need to have the DPL of selCode in order to select the correct selStack,
                         * so who knows...?
                         */
                        if (this.loadProt(selCode, true) === X86.ADDR_INVALID) {
                            return X86.ADDR_INVALID;
                        }
                        /*
                         * Intel pseudo-code suggests that the TSS stack pointer offset is based on the DPL of selCode
                         * rather than the RPL of selCode.  TODO: Check for instances where DPL and RPL of selCode differ,
                         * and then figure out which should really be used.
                         */
                        addrTSS = cpu.segTSS.base;
                        if (!I386 || !(cpu.segTSS.type & X86.DESC.ACC.TYPE.NONSEG_386)) {
                            offSP = (cplNew << 2) + X86.TSS286.CPL0_SP;
                            lenSP = 2;
                        } else {
                            offSP = (cplNew << 3) + X86.TSS386.CPL0_ESP;
                            lenSP = 4;
                        }
                        selStack = cpu.getShort(addrTSS + offSP + lenSP);

                        /*
                         * Intel pseudo-code indicates at least FIVE discrete selStack tests that could trigger
                         * a TS_FAULT at this point:
                         *
                         *      1) Selector must not be null else #TS(O)
                         *      2) Selector index must be within its descriptor table limits else #TS (SS selector)
                         *      3) Selector's RPL must equal DPL of code segment else #TS (SS selector)
                         *      4) Stack segment DPL must equal DPL of code segment else #TS (SS selector)
                         *      5) Descriptor must indicate writable data segment else #TS (SS selector)
                         */
                        if (!selStack) {
                            X86.helpFault.call(cpu, X86.EXCEPTION.TS_FAULT, selStack);
                            return X86.ADDR_INVALID;
                        }

                        if (cpu.segSS.loadProt(selStack, true) === X86.ADDR_INVALID) {
                            return X86.ADDR_INVALID;
                        }
                        /*
                         * Both probes succeeded, so we can proceed with "normal" loads for both selCode and
                         * selStack (which should automatically use the values cached by the "probed" loads above).
                         */
                        offStack = (lenSP == 2)? cpu.getShort(addrTSS + offSP) : cpu.getLong(addrTSS + offSP);
                    }

                    /*
                     * Now that we're past all the probes, it should be safe to clear all flags that need clearing.
                     */
                    let regPS = cpu.regPS;
                    cpu.regPS &= ~regPSClear;
                    if (regPS & X86.PS.VM) {
                        cpu.setProtMode(true, false);
                    }

                    /*
                     * TODO: Consider whether we can skip this loadProt() call if this.sel already contains selCode
                     * (and the previous mode matches, which might require we cache the mode in the SegX86 object, too).
                     */
                    if (this.loadProt(selCode, false) === X86.ADDR_INVALID) {
                        return X86.ADDR_INVALID;
                    }

                    cpu.setDataSize(sizeGate);

                    this.offIP = limit;

                    //

                    if (cplNew < cplOld) {

                        if (fCall !== true) {

                            return X86.ADDR_INVALID;
                        }

                        regSP = cpu.getSP();
                        let i = 0, nWords = (acc & 0x1f);
                        while (nWords--) {
                            this.awParms[i++] = cpu.getSOWord(cpu.segSS, regSP);
                            regSP += 2;
                        }

                        regSSPrev = cpu.getSS();
                        regSPPrev = cpu.getSP();

                        cpu.setSS(selStack, true);
                        cpu.setSP(offStack);

                        if (regPS & X86.PS.VM) {
                            /*
                             * Frames coming from V86-mode ALWAYS contain 32-bit values, and look like this:
                             *
                             *      low:    EIP
                             *              CS (upper 16 bits undefined)
                             *              EFLAGS
                             *              ESP
                             *              SS (upper 16 bits undefined)
                             *              ES (upper 16 bits undefined)
                             *              DS (upper 16 bits undefined)
                             *              FS (upper 16 bits undefined)
                             *      high:   GS (upper 16 bits undefined)
                             *
                             * Our caller (eg, helpINT()) will take care of pushing the final bits (EFLAGS, CS, and EIP).
                             */
                            cpu.setDataSize(4);

                            cpu.pushData(cpu.segGS.sel, 4, 2);
                            cpu.setGS(0);
                            cpu.pushData(cpu.segFS.sel, 4, 2);
                            cpu.setFS(0);
                            cpu.pushData(cpu.segDS.sel, 4, 2);
                            cpu.setDS(0);
                            cpu.pushData(cpu.segES.sel, 4, 2);
                            cpu.setES(0);
                        }
                        cpu.pushData(regSSPrev, cpu.sizeData, 2);
                        cpu.pushWord(regSPPrev);
                        while (i) cpu.pushWord(this.awParms[--i]);
                        this.fStackSwitch = true;
                    }
                    return this.base;
                }
            }

            if (sizeGate != 0) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, (sel & X86.ERRCODE.SELMASK) | (fIDT? X86.ERRCODE.IDT : 0));
                return X86.ADDR_INVALID;
            }

            if (!(acc & X86.DESC.ACC.PRESENT)) {
                X86.helpFault.call(cpu, X86.EXCEPTION.NP_FAULT, (sel & X86.ERRCODE.SELMASK) | (fIDT? X86.ERRCODE.IDT : 0));
                return X86.ADDR_INVALID;
            }
            break;

        case SegX86.ID.DATA:
            if (selMasked) {
                /*
                 * OS/2 1.0 faults on segments with "empty descriptors" multiple times during boot; for example:
                 *
                 *      Fault 0x0B (0x002C) on opcode 0x8E at 3190:3A05 (%112625)
                 *      AX=0000 BX=0970 CX=0300 DX=0300 SP=0ABE BP=0ABA SI=0000 DI=001A
                 *      SS=0038[175CE0,0B5F] DS=19C0[177300,2C5F] ES=001F[1743A0,07FF] A20=ON
                 *      CS=3190[10EC20,B89F] LD=0028[174BC0,003F] GD=[11A4E0,490F] ID=[11F61A,03FF]
                 *      TR=0010 MS=0000FFF3 PS=3256 V0 D0 I1 T0 S0 Z1 A1 P1 C0
                 *      3190:3A05 8E4604          MOV      ES,[BP+04]
                 *      ## dw ss:bp+4 l1
                 *      0038:0ABE  002F  19C0  0000  067C  07FC  0AD2  0010  C420   /.....|....... .
                 *      ## ds 2f
                 *      dumpDesc(0x002F): %174BE8
                 *      base=000000 limit=0000 type=0x00 (undefined) ext=0x0000 dpl=0x00
                 *
                 * And Windows 95 Setup, during the "Analyzing Your Computer" phase, will fault on an attempt to load
                 * a GDT selector of type LDT (why it does this is a mystery I've not yet investigated):
                 *
                 *      Fault 0x0D (0x26F0) on opcode 0x8E @039F:039B (%199E9B)
                 *      EAX=0000149F EBX=00000100 ECX=000026F3 EDX=0020149F
                 *      ESP=0000AA34 EBP=0000AA3C ESI=000026E7 EDI=00000080
                 *      SS=155F[002AC9D0,C0BF] DS=149F[0031B470,9B1F] ES=0237[000C0000,FFFF]
                 *      CS=039F[00199B00,2ABF] FS=0000[00000000,0000] GS=0000[00000000,0000]
                 *      LD=0038[00FA4C50,FFEF] GD=[00FA0800,011F] ID=[00FA0000,07FF] TR=0088 A20=ON
                 *      CR0=0000FFF1 CR2=00000000 CR3=00000000 PS=00003246 V0 D0 I1 T0 S0 Z1 A0 P1 C0
                 *      039F:039B 8EC1            MOV      ES,CX
                 *      ## ds cx
                 *      dumpDesc(0x26F3): %00FA2EF0
                 *      base=0006C726 limit=0000 type=0x02 (ldt,not present) ext=0x0000 dpl=0x00
                 *
                 * In both cases, the segment type is not valid for the target segment register *and* the PRESENT bit
                 * is clear.  OS/2 doesn't seem to care whether I report an NP_FAULT or GP_FAULT, but Windows 95 definitely
                 * cares: it will resolve the fault only if a GP_FAULT is reported.  And Intel's 80386 Programmers Reference
                 * implies that, yes, GP_FAULT checks are supposed to be performed *before* NP_FAULT checks.
                 */
                if (type < X86.DESC.ACC.TYPE.SEG || (type & (X86.DESC.ACC.TYPE.CODE | X86.DESC.ACC.TYPE.READABLE)) == X86.DESC.ACC.TYPE.CODE) {
                    X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
                    return X86.ADDR_INVALID;
                }
                /*
                 * TODO: This would be a good place to perform some additional access rights checks, too.
                 */
                if (!(acc & X86.DESC.ACC.PRESENT)) {
                    X86.helpFault.call(cpu, X86.EXCEPTION.NP_FAULT, sel & X86.ERRCODE.SELMASK);
                    return X86.ADDR_INVALID;
                }
            }
            break;

        case SegX86.ID.STACK:
            if (!selMasked || type < X86.DESC.ACC.TYPE.SEG || (type & (X86.DESC.ACC.TYPE.CODE | X86.DESC.ACC.TYPE.WRITABLE)) != X86.DESC.ACC.TYPE.WRITABLE) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
                return X86.ADDR_INVALID;
            }
            if (!(acc & X86.DESC.ACC.PRESENT)) {
                X86.helpFault.call(cpu, X86.EXCEPTION.SS_FAULT, sel & X86.ERRCODE.SELMASK);
                return X86.ADDR_INVALID;
            }
            break;

        case SegX86.ID.TSS:
            let typeTSS = type & ~X86.DESC.ACC.TYPE.TSS_BUSY;
            if (!selMasked || typeTSS != X86.DESC.ACC.TYPE.TSS286 && typeTSS != X86.DESC.ACC.TYPE.TSS386) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
                return X86.ADDR_INVALID;
            }
            /*
             * For more efficient IOPM lookups, we cache the starting linear address in segTSS.addrIOPM, and the
             * last valid address in segTSS.addrIOPMLimit.
             */
            if (typeTSS == X86.DESC.ACC.TYPE.TSS386) {
                this.addrIOPM = (base + cpu.getShort(base + X86.TSS386.TASK_IOPM + 2))|0;
                this.addrIOPMLimit = (base + this.limit)|0;
            }
            break;

        case SegX86.ID.VER:
            /*
             * For LSL, we must support any descriptor marked X86.DESC.ACC.TYPE.SEG, as well as TSS and LDT descriptors.
             */
            if (!(type & X86.DESC.ACC.TYPE.SEG) && type > X86.DESC.ACC.TYPE.TSS286_BUSY && type != X86.DESC.ACC.TYPE.TSS386 && type != X86.DESC.ACC.TYPE.TSS386_BUSY) {
                return X86.ADDR_INVALID;
            }
            break;

        default:
            /*
             * The only other cases are:
              *
              *     SegX86.ID.NULL, SegX86.ID.LDT, and SegX86.ID.DBG
              *
              * which correspond to segNULL, segLDT and segDebugger; however, segLDT is the only one that might require further validation (TODO: Investigate).
             */
            break;
        }

        if (fProbe) {
            this.probe.sel = sel;
            this.probe.base = base;
            this.probe.limit = limit;
            this.probe.acc = acc;
            this.probe.type = type;
            this.probe.ext = ext;
            this.probe.addrDesc = addrDesc;
        } else {
            this.sel = sel;
            this.base = base;
            this.limit = limit;
            this.offMax = (limit >>> 0) + 1;
            this.acc = acc;
            this.type = type;
            this.ext = ext;
            this.addrDesc = addrDesc;
            /*
             * A quick recap of what updateMode(fLoad=true, fProt=true, fV86=false) actually updates:
             *
             *      cpl
             *      dpl
             *      dataSize
             *      dataMask
             *      addrSize
             *      addrMask
             *      fExpDown
             *      load()
             *      loadIDT()
             *      checkRead()
             *      checkWrite()
             */
            this.updateMode(true, true, false);
        }

        if (DEBUG) this.messageSeg(sel, base, limit, type, ext);

        return base;
    }

    /**
     * switchTSS(selNew, fNest)
     *
     * Implements TSS (Task State Segment) task switching.
     *
     * NOTES: This typically occurs during double-fault processing, because the IDT entry for DF_FAULT normally
     * contains a task gate.  Interestingly, if we force a GP_FAULT to occur at a sufficiently early point in the
     * OS/2 1.0 initialization code, OS/2 does a nice job of displaying the GP fault and then shutting down:
     *
     *      0090:067B FB            STI
     *      0090:067C EBFD          JMP      067B
     *
     * but it may not have yet reprogrammed the master PIC to re-vector hardware interrupts to IDT entries 0x50-0x57,
     * so when the next timer interrupt (IRQ 0) occurs, it vectors through IDT entry 0x08, which is the DF_FAULT
     * vector. A spurious double-fault is generated, and a clean shutdown turns into a messy crash.
     *
     * Of course, that all could have been avoided if IBM had heeded Intel's advice and not used Intel-reserved IDT
     * entries for PC interrupts.
     *
     * TODO: Add TSS validity checks and appropriate generation of TS_FAULT exceptions; the only rudimentary checks
     * we currently perform are of the GP_FAULT variety.
     *
     * @this {SegX86}
     * @param {number} selNew
     * @param {boolean|null} [fNest] is true if nesting, false if un-nesting, null if neither
     * @return {boolean} true if successful, false if error
     */
    switchTSS(selNew, fNest)
    {
        let cpu = this.cpu;


        let cplOld = this.cpl;
        let selOld = cpu.segTSS.sel;
        let addrOld = cpu.segTSS.base;

        if (!fNest) {
            /*
             * TODO: Verify that it is (always) correct to require that the BUSY bit be currently set.
             */
            if (!(cpu.segTSS.type & X86.DESC.ACC.TYPE.TSS_BUSY)) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, selNew & X86.ERRCODE.SELMASK);
                return false;
            }
            /*
             * TODO: Should I be more paranoid about writing our cached ACC value back into the descriptor?
             */
            cpu.setShort(cpu.segTSS.addrDesc + X86.DESC.ACC.OFFSET, cpu.segTSS.acc &= ~X86.DESC.ACC.TYPE.TSS_BUSY);
        }

        if (cpu.segTSS.load(selNew) === X86.ADDR_INVALID) {
            return false;
        }

        let addrNew = cpu.segTSS.base;
        if (DEBUG && DEBUGGER && this.dbg && this.dbg.messageEnabled(Messages.TSS)) {
            this.dbg.message((fNest? "Task switch" : "Task return") + ": TR " + Str.toHexWord(selOld) + " (%" + Str.toHex(addrOld, 6) + "), new TR " + Str.toHexWord(selNew) + " (%" + Str.toHex(addrNew, 6) + ")");
        }

        if (fNest !== false) {
            if (cpu.segTSS.type & X86.DESC.ACC.TYPE.TSS_BUSY) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, selNew & X86.ERRCODE.SELMASK);
                return false;
            }
            cpu.setShort(cpu.segTSS.addrDesc + X86.DESC.ACC.OFFSET, cpu.segTSS.acc |= X86.DESC.ACC.TYPE.TSS_BUSY);
        }

        /*
         * Now that we're done checking the TSS_BUSY bit in the TYPE field (which is a subset of the ACC field),
         * sync any changes made above in the ACC field to the TYPE field.
         */
        cpu.segTSS.type = (cpu.segTSS.type & ~X86.DESC.ACC.TYPE.TSS_BUSY) | (cpu.segTSS.acc & X86.DESC.ACC.TYPE.TSS_BUSY);

        /*
         * Update the old TSS
         */
        let offSS, offSP;
        if (cpu.segTSS.type == X86.DESC.ACC.TYPE.TSS286 || cpu.segTSS.type == X86.DESC.ACC.TYPE.TSS286_BUSY) {
            cpu.setShort(addrOld + X86.TSS286.TASK_IP, cpu.getIP());
            cpu.setShort(addrOld + X86.TSS286.TASK_PS, cpu.getPS());
            cpu.setShort(addrOld + X86.TSS286.TASK_AX, cpu.regEAX);
            cpu.setShort(addrOld + X86.TSS286.TASK_CX, cpu.regECX);
            cpu.setShort(addrOld + X86.TSS286.TASK_DX, cpu.regEDX);
            cpu.setShort(addrOld + X86.TSS286.TASK_BX, cpu.regEBX);
            cpu.setShort(addrOld + X86.TSS286.TASK_SP, cpu.getSP());
            cpu.setShort(addrOld + X86.TSS286.TASK_BP, cpu.regEBP);
            cpu.setShort(addrOld + X86.TSS286.TASK_SI, cpu.regESI);
            cpu.setShort(addrOld + X86.TSS286.TASK_DI, cpu.regEDI);
            cpu.setShort(addrOld + X86.TSS286.TASK_ES, cpu.segES.sel);
            cpu.setShort(addrOld + X86.TSS286.TASK_CS, cpu.segCS.sel);
            cpu.setShort(addrOld + X86.TSS286.TASK_SS, cpu.segSS.sel);
            cpu.setShort(addrOld + X86.TSS286.TASK_DS, cpu.segDS.sel);
            /*
             * Reload all registers from the new TSS; it's important to reload the LDTR sooner
             * rather than later, so that as segment registers are reloaded, any LDT selectors will
             * will be located in the correct table.
             */
            cpu.segLDT.load(cpu.getShort(addrNew + X86.TSS286.TASK_LDT));
            cpu.setPS(cpu.getShort(addrNew + X86.TSS286.TASK_PS) | (fNest? X86.PS.NT : 0));

            cpu.regEAX = cpu.getShort(addrNew + X86.TSS286.TASK_AX);
            cpu.regECX = cpu.getShort(addrNew + X86.TSS286.TASK_CX);
            cpu.regEDX = cpu.getShort(addrNew + X86.TSS286.TASK_DX);
            cpu.regEBX = cpu.getShort(addrNew + X86.TSS286.TASK_BX);
            cpu.regEBP = cpu.getShort(addrNew + X86.TSS286.TASK_BP);
            cpu.regESI = cpu.getShort(addrNew + X86.TSS286.TASK_SI);
            cpu.regEDI = cpu.getShort(addrNew + X86.TSS286.TASK_DI);
            cpu.segES.load(cpu.getShort(addrNew + X86.TSS286.TASK_ES));
            cpu.segDS.load(cpu.getShort(addrNew + X86.TSS286.TASK_DS));
            cpu.setCSIP(cpu.getShort(addrNew + X86.TSS286.TASK_IP), cpu.getShort(addrNew + X86.TSS286.TASK_CS));
            offSS = X86.TSS286.TASK_SS;
            offSP = X86.TSS286.TASK_SP;
            if (this.cpl < cplOld) {
                offSP = (this.cpl << 2) + X86.TSS286.CPL0_SP;
                offSS = offSP + 2;
            }
            cpu.setSS(cpu.getShort(addrNew + offSS), true);
            cpu.setSP(cpu.getShort(addrNew + offSP));
        } else {

            cpu.setLong(addrOld + X86.TSS386.TASK_CR3, cpu.regCR3);
            cpu.setLong(addrOld + X86.TSS386.TASK_EIP, cpu.getIP());
            cpu.setLong(addrOld + X86.TSS386.TASK_PS,  cpu.getPS());
            cpu.setLong(addrOld + X86.TSS386.TASK_EAX, cpu.regEAX);
            cpu.setLong(addrOld + X86.TSS386.TASK_ECX, cpu.regECX);
            cpu.setLong(addrOld + X86.TSS386.TASK_EDX, cpu.regEDX);
            cpu.setLong(addrOld + X86.TSS386.TASK_EBX, cpu.regEBX);
            cpu.setLong(addrOld + X86.TSS386.TASK_ESP, cpu.getSP());
            cpu.setLong(addrOld + X86.TSS386.TASK_EBP, cpu.regEBP);
            cpu.setLong(addrOld + X86.TSS386.TASK_ESI, cpu.regESI);
            cpu.setLong(addrOld + X86.TSS386.TASK_EDI, cpu.regEDI);
            cpu.setLong(addrOld + X86.TSS386.TASK_ES,  cpu.segES.sel);
            cpu.setLong(addrOld + X86.TSS386.TASK_CS,  cpu.segCS.sel);
            cpu.setLong(addrOld + X86.TSS386.TASK_SS,  cpu.segSS.sel);
            cpu.setLong(addrOld + X86.TSS386.TASK_DS,  cpu.segDS.sel);

            /*
             * segFS and segGS exist only on 80386 machines
             */

            cpu.setLong(addrOld + X86.TSS386.TASK_FS,  cpu.segFS.sel);
            cpu.setLong(addrOld + X86.TSS386.TASK_GS,  cpu.segGS.sel);

            /*
             * Reload all registers from the new TSS; it's important to reload the LDTR sooner
             * rather than later, so that as segment registers are reloaded, any LDT selectors will
             * will be located in the correct table.
             */
            X86.helpLoadCR3.call(cpu, cpu.getLong(addrNew + X86.TSS386.TASK_CR3));
            cpu.segLDT.load(cpu.getShort(addrNew + X86.TSS386.TASK_LDT));
            cpu.setPS(cpu.getLong(addrNew + X86.TSS386.TASK_PS) | (fNest? X86.PS.NT : 0));

            cpu.regEAX = cpu.getLong(addrNew + X86.TSS386.TASK_EAX);
            cpu.regECX = cpu.getLong(addrNew + X86.TSS386.TASK_ECX);
            cpu.regEDX = cpu.getLong(addrNew + X86.TSS386.TASK_EDX);
            cpu.regEBX = cpu.getLong(addrNew + X86.TSS386.TASK_EBX);
            cpu.regEBP = cpu.getLong(addrNew + X86.TSS386.TASK_EBP);
            cpu.regESI = cpu.getLong(addrNew + X86.TSS386.TASK_ESI);
            cpu.regEDI = cpu.getLong(addrNew + X86.TSS386.TASK_EDI);
            cpu.segES.load(cpu.getShort(addrNew + X86.TSS386.TASK_ES));
            cpu.segDS.load(cpu.getShort(addrNew + X86.TSS386.TASK_DS));

            /*
             * segFS and segGS exist only on 80386 machines
             */

            cpu.segFS.load(cpu.getShort(addrNew + X86.TSS386.TASK_FS));
            cpu.segGS.load(cpu.getShort(addrNew + X86.TSS386.TASK_GS));

            cpu.setCSIP(cpu.getLong(addrNew + X86.TSS386.TASK_EIP), cpu.getShort(addrNew + X86.TSS386.TASK_CS));
            offSS = X86.TSS386.TASK_SS;
            offSP = X86.TSS386.TASK_ESP;
            if (this.cpl < cplOld) {
                offSP = (this.cpl << 3) + X86.TSS386.CPL0_ESP;
                offSS = offSP + 4;
            }
            cpu.setSS(cpu.getShort(addrNew + offSS), true);
            cpu.setSP(cpu.getLong(addrNew + offSP));
        }

        /*
         * Fortunately, X86.TSS286.PREV_TSS and X86.TSS386.PREV_TSS refer to the same TSS offset.
         */
        if (fNest) cpu.setShort(addrNew + X86.TSS286.PREV_TSS, selOld);

        cpu.regCR0 |= X86.CR0.MSW.TS;
        return true;
    }

    /**
     * setBase(addr)
     *
     * This is used in unusual situations where the base must be set independently; normally, the base is
     * set according to the selector provided to load(), but there are a few cases where setBase() is required.
     *
     * For example, in resetRegs(), the real-mode CS selector must be reset to 0xF000 for an 80286 or 80386,
     * but the CS base must be set to 0x00FF0000 or 0xFFFF0000, respectively.  To simplify life for setBase()
     * callers, we allow them to specify 32-bit bases, which we then truncate to 24 bits as needed.
     *
     * WARNING: Since the CPU must maintain regLIP as the sum of the CS base and the current IP, all calls
     * to segCS.setBase() need to go through cpu.setCSBase().
     *
     * @this {SegX86}
     * @param {number} addr
     * @return {number} addr, truncated as needed
     */
    setBase(addr)
    {
        if (this.cpu.model < X86.MODEL_80386) addr &= 0xffffff;
        return this.base = addr;
    }

    /**
     * save()
     *
     * Early versions of PCx86 saved only segment selectors, since that's all that mattered in real-mode;
     * newer versions need to save/restore all the "core" properties of the SegX86 object (ie, properties other
     * than those that updateMode() will take care of restoring later).
     *
     * @this {SegX86}
     * @return {Array}
     */
    save()
    {
        return [
            this.sel,
            this.base,
            this.limit,
            this.acc,
            this.id,
            this.sName,
            this.cpl,
            this.dpl,
            this.addrDesc,
            this.sizeAddr,
            this.maskAddr,
            this.sizeData,
            this.maskData,
            this.type,
            this.offMax
        ];
    }

    /**
     * restore(a)
     *
     * Early versions of PCx86 saved only segment selectors, since that's all that mattered in real-mode;
     * newer versions need to save/restore all the "core" properties of the SegX86 object (ie, properties other
     * than those that updateMode() will take care of restoring later).
     *
     * @this {SegX86}
     * @param {Array|number} a
     */
    restore(a)
    {
        if (typeof a == "number") {
            this.load(a);
        } else {
            this.sel      = a[0];
            this.base     = a[1];
            this.limit    = a[2];
            this.acc      = a[3];
            this.id       = a[4];
            this.sName    = a[5];
            this.cpl      = a[6];
            this.dpl      = a[7];
            this.addrDesc = a[8];
            this.sizeAddr = a[9]  || 2;
            this.maskAddr = a[10] || 0xffff;
            this.sizeData = a[11] || 2;
            this.maskData = a[12] || 0xffff;
            this.type     = a[13] || (this.acc & X86.DESC.ACC.TYPE.MASK);
            this.offMax   = a[14] || (this.limit >>> 0) + 1;
        }
    }

    /**
     * updateMode(fLoad, fProt, fV86)
     *
     * Ensures that the segment register's access (ie, load and check methods) matches the specified (or current)
     * operating mode (real or protected).
     *
     * @this {SegX86}
     * @param {boolean} [fLoad] true if the segment was just (re)loaded, false if not
     * @param {boolean} [fProt] true for protected-mode access, false for real-mode access, undefined for current mode
     * @param {boolean} [fV86] true for V86-mode access, false for protected-mode access, undefined for current mode
     */
    updateMode(fLoad, fProt, fV86)
    {
        if (fProt === undefined) {
            fProt = !!(this.cpu.regCR0 & X86.CR0.MSW.PE);
        }

        /*
         * The fExpDown property is used for STACK segments only (ie, segSS); we want to make it easier for
         * setSS() to set stack lower and upper limits, which requires knowing whether or not the segment is
         * marked as EXPDOWN.
         */
        this.fExpDown = false;

        if (fProt) {
            this.load = this.loadProt;
            this.loadIDT = this.loadIDTProt;
            this.checkRead = this.checkReadProt;
            this.checkWrite = this.checkWriteProt;

            if (fV86 === undefined) {
                fV86 = !!(this.cpu.regPS & X86.PS.VM);
            }

            if (fV86) {
                this.load = this.loadV86;
                this.checkRead = this.checkReadV86;
                this.checkWrite = this.checkWriteV86;
                /*
                 * One important feature of V86-mode (as compared to real-mode) are that other segment attributes
                 * (eg, limit, operand size, address size, etc) ARE updated, whereas in real-mode, segment attributes
                 * remain set to whatever was in effect in protected-mode.
                 */
                this.cpl = this.dpl = 3;
                this.sizeData = this.sizeAddr = 2;
                this.maskData = this.maskAddr = 0xffff;
                this.limit = 0xffff;
                this.offMax = this.limit + 1;
                this.sizeAddr = this.sizeData;
                this.addrDesc = X86.ADDR_INVALID;
                this.fStackSwitch = false;
                return;
            }

            /*
             * TODO: For null GDT selectors, should we rely on the descriptor being invalid, or should we assume that
             * the null descriptor might contain uninitialized (or other) data?  I'm assuming the latter, hence the
             * following null selector test.  However, if we're not going to consult the descriptor, is there anything
             * else we should (or should not) be doing for null GDT selectors?
             */
            if (!(this.sel & ~X86.SEL.RPL)) {
                this.checkRead = this.checkReadProtDisallowed;
                this.checkWrite = this.checkWriteProtDisallowed;

            }
            else if (this.type & X86.DESC.ACC.TYPE.SEG) {
                /*
                 * If the READABLE bit of CODE_READABLE is not set, then disallow reads.
                 */
                if ((this.type & X86.DESC.ACC.TYPE.CODE_READABLE) == X86.DESC.ACC.TYPE.CODE_EXECONLY) {
                    this.checkRead = this.checkReadProtDisallowed;
                }
                /*
                 * If the CODE bit is set, or the the WRITABLE bit is not set, then disallow writes.
                 */
                if ((this.type & X86.DESC.ACC.TYPE.CODE) || !(this.type & X86.DESC.ACC.TYPE.WRITABLE)) {
                    this.checkWrite = this.checkWriteProtDisallowed;
                }
                /*
                 * If the CODE bit is not set *and* the EXPDOWN bit is set, then invert the limit check.
                 */
                if ((this.type & (X86.DESC.ACC.TYPE.CODE | X86.DESC.ACC.TYPE.EXPDOWN)) == X86.DESC.ACC.TYPE.EXPDOWN) {
                    if (this.checkRead == this.checkReadProt) this.checkRead = this.checkReadProtDown;
                    if (this.checkWrite == this.checkWriteProt) this.checkWrite = this.checkWriteProtDown;
                    this.fExpDown = true;
                }
                if (fLoad && this.id < SegX86.ID.VER) {
                    /*
                     * We must update the descriptor's ACCESSED bit whenever the segment is "accessed" (ie,
                     * loaded); unlike the ACCESSED and DIRTY bits in PTEs, a descriptor ACCESSED bit is only
                     * updated on loads, not on every memory access.
                     *
                     * We compute the address of the descriptor byte containing the ACCESSED bit (offset 0x5);
                     * note that it's perfectly normal for addrDesc to occasionally be invalid (eg, when the CPU
                     * is creating protected-mode-only segment registers like LDT and TSS, or when the CPU has
                     * transitioned from real-mode to protected-mode and new selector(s) have not been loaded yet).
                     *
                     * NOTE: I do NOT update the ACCESSED bit for null GDT selectors, because I'm assuming the
                     * hardware does not update it either.  In fact, I've seen code that uses the null GDT descriptor
                     * for other purposes, on the assumption that that descriptor is completely unused.
                     */
                    if ((this.sel & ~X86.SEL.RPL) && this.addrDesc !== X86.ADDR_INVALID) {
                        let addrType = this.addrDesc + X86.DESC.ACC.TYPE.OFFSET;
                        let bType = this.cpu.getByte(addrType);
                        /*
                         * This code used to ALWAYS call setByte(), but that's a waste of time if ACCESSED is already
                         * set.  TODO: It would also be nice if we could simply use the cached type value, and eliminate
                         * the getByte() call; that seems a bit risky, but I think we should still try it someday.
                         */
                        if (!(bType & (X86.DESC.ACC.TYPE.ACCESSED >> 8))) {
                            this.cpu.setByte(addrType, bType | (X86.DESC.ACC.TYPE.ACCESSED >> 8));
                        }
                    }
                }
            }

            /*
             * TODO: For non-SEG descriptors, are there other checks or functions we should establish?
             */

            /*
             * Any update to the following properties must occur only on segment loads, not simply when
             * we're updating segment registers as part of a mode change.
             */
            if (fLoad) {
                this.cpl = this.sel & X86.SEL.RPL;
                this.dpl = (this.acc & X86.DESC.ACC.DPL.MASK) >> X86.DESC.ACC.DPL.SHIFT;
                if (this.cpu.model < X86.MODEL_80386 || !(this.ext & X86.DESC.EXT.BIG)) {
                    this.sizeData = 2;
                    this.maskData = 0xffff;
                } else {
                    this.sizeData = 4;
                    this.maskData = (0xffffffff|0);
                }
                this.sizeAddr = this.sizeData;
                this.maskAddr = this.maskData;
            }
            return;
        }
        /*
         * One important feature of real-mode (as compared to V86-mode) are that other segment attributes
         * (eg, limit, operand size, address size, etc) are NOT updated, enabling features like "big real-mode"
         * (aka "unreal mode"), which is used by system software like HIMEM.SYS to access extended memory from
         * real-mode.
         */
        this.load = this.loadReal;
        this.loadIDT = this.loadIDTReal;
        this.checkRead = this.checkReadWriteReal;
        this.checkWrite = this.checkReadWriteReal;
        this.cpl = this.dpl = 0;
        this.addrDesc = X86.ADDR_INVALID;
        this.fStackSwitch = false;
    }

    /**
     * messageSeg(sel, base, limit, type, ext)
     *
     * @this {SegX86}
     * @param {number} sel
     * @param {number} base
     * @param {number} limit
     * @param {number} type
     * @param {number} [ext]
     */
    messageSeg(sel, base, limit, type, ext)
    {
        if (DEBUG) {
            if (DEBUGGER && this.dbg && this.dbg.messageEnabled(Messages.SEG)) {
                let ch = (this.sName.length < 3? " " : "");
                let sDPL = " dpl=" + this.dpl;
                if (this.id == SegX86.ID.CODE) sDPL += " cpl=" + this.cpl;
                this.dbg.message("loadSeg(" + this.sName + "):" + ch + "sel=" + Str.toHexWord(sel) + " base=" + Str.toHex(base) + " limit=" + Str.toHexWord(limit) + " type=" + Str.toHexWord(type) + sDPL, true);
            }
            /*
             * Unless I've got a bug that's causing descriptor corruption, it appears that Windows 3.0 may be setting the
             * EXT field of descriptors, even when the processor is an 80286; eg, the EXT field below has been set to 0x000F:
             *
             *      ## ds 1bd
             *      dumpSel(0x01BD): %1101B8
             *      %001101B8  FFFF  C090  B317  000F
             *
             * So I've disabled this assert (I had already disabled the "base !== X86.ADDR_INVALID" check).
             *
             *
             */
        }
    }

    /**
     * probeDesc(sel)
     *
     * This is a neutered version of loadProt() designed for the Debugger.
     *
     * @this {SegX86}
     * @param {number} sel
     * @return {number} base address of selected segment, or X86.ADDR_INVALID if error
     */
    probeDesc(sel)
    {
        if (DEBUGGER) {
            let addrDT;
            let addrDTLimit;
            let cpu = this.cpu;

            sel &= 0xffff;

            if (!(sel & X86.SEL.LDT)) {
                addrDT = cpu.addrGDT;
                addrDTLimit = cpu.addrGDTLimit;
            } else {
                addrDT = cpu.segLDT.base;
                addrDTLimit = (addrDT + cpu.segLDT.limit)|0;
            }

            let addrDesc = (addrDT + (sel & X86.SEL.MASK))|0;

            if ((addrDTLimit - addrDesc)|0 >= 7) {

                /*
                 * Load the descriptor from memory using probeAddr().
                 */
                let limit = cpu.probeAddr(addrDesc + X86.DESC.LIMIT.OFFSET, 2);
                let acc = cpu.probeAddr(addrDesc + X86.DESC.ACC.OFFSET, 2);
                let type = (acc & X86.DESC.ACC.TYPE.MASK);
                let base = cpu.probeAddr(addrDesc + X86.DESC.BASE.OFFSET, 2) | ((acc & X86.DESC.ACC.BASE1623) << 16);
                let ext = cpu.probeAddr(addrDesc + X86.DESC.EXT.OFFSET, 2);

                if (I386 && cpu.model >= X86.MODEL_80386) {
                    base |= (ext & X86.DESC.EXT.BASE2431) << 16;
                    limit |= (ext & X86.DESC.EXT.LIMIT1619) << 16;
                    if (ext & X86.DESC.EXT.LIMITPAGES) limit = (limit << 12) | 0xfff;
                }

                this.sel = sel;
                this.base = base;
                this.limit = limit;
                this.offMax = (limit >>> 0) + 1;
                this.acc = acc;
                this.type = type;
                this.ext = ext;
                this.addrDesc = addrDesc;
                this.updateMode(true, true, false);
                return base;
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * loadAcc(sel, fGDT)
     *
     * this {SegX86}
     * param {number} sel (protected-mode only)
     * param {boolean} [fGDT] is true if sel must be in the GDT
     * return {number} ACC field from descriptor, or X86.DESC.ACC.INVALID if error
     *
     loadAcc(sel, fGDT)
     {
         let addrDT;
         let addrDTLimit;
         let cpu = this.cpu;

         if (!(sel & X86.SEL.LDT)) {
             addrDT = cpu.addrGDT;
             addrDTLimit = cpu.addrGDTLimit;
         } else if (!fGDT) {
             addrDT = cpu.segLDT.base;
             addrDTLimit = (addrDT + cpu.segLDT.limit)|0;
         }
         if (addrDT !== undefined) {
             let addrDesc = (addrDT + (sel & X86.SEL.MASK))|0;
             if (((addrDTLimit - addrDesc)|0) >= 7) {
                 return cpu.getShort(addrDesc + X86.DESC.ACC.OFFSET);
             }
         }
         X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
         return X86.DESC.ACC.INVALID;
     }
     */
}

SegX86.ID = {
    NULL:   0,          // "NULL"
    CODE:   1,          // "CS"
    DATA:   2,          // "DS", "ES", "FS", "GS"
    STACK:  3,          // "SS"
    TSS:    4,          // "TSS"
    LDT:    5,          // "LDT"
    VER:    6,          // "VER"
    DBG:    7           // "DBG"
};

SegX86.CALLBREAK_SEL = 0x0001;



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/x86func.js (C) Jeff Parsons 2012-2018
 */


/**
 * fnADCb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnADCb = function(dst, src)
{
    let b = (dst + src + this.getCarry())|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b & 0xff;
};

/**
 * fnADCw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnADCw = function(dst, src)
{
    let w = (dst + src + this.getCarry())|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return w & this.maskData;
};

/**
 * fnADDb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnADDb = function(dst, src)
{
    let b = (dst + src)|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b & 0xff;
};

/**
 * fnADDw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnADDw = function(dst, src)
{
    let w = (dst + src)|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return w & this.maskData;
};

/**
 * fnANDb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnANDb = function(dst, src)
{
    let b = dst & src;
    this.setLogicResult(b, X86.RESULT.BYTE);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b;
};

/**
 * fnANDw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnANDw = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return this.setLogicResult(dst & src, this.typeData) & this.maskData;
};

/**
 * fnARPL(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnARPL = function(dst, src)
{
    this.nStepCycles -= (10 + (this.regEA === X86.ADDR_INVALID? 0 : 1));
    if ((dst & X86.SEL.RPL) < (src & X86.SEL.RPL)) {
        dst = (dst & ~X86.SEL.RPL) | (src & X86.SEL.RPL);
        this.setZF();
        return dst;
    }
    this.clearZF();
    return dst;
};

/**
 * fnBOUND(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBOUND = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        /*
         * Generate UD_FAULT (INT 0x06: Invalid Opcode) if src is not a memory operand.
         */
        X86.opInvalid.call(this);
        return dst;
    }
    /*
     * Note that BOUND performs signed comparisons, so we must transform all arguments into signed values.
     */
    let wIndex = dst;
    let wLower = this.getWord(this.regEA);
    let wUpper = this.getWord(this.regEA + this.sizeData);
    if (this.sizeData == 2) {
        wIndex = (dst << 16) >> 16;
        wLower = (wLower << 16) >> 16;
        wUpper = (wUpper << 16) >> 16;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesBound;
    if (wIndex < wLower || wIndex > wUpper) {
        /*
         * The INT 0x05 handler must be called with CS:IP pointing to the BOUND instruction.
         *
         * TODO: Determine the cycle cost when a BOUND exception is triggered, over and above nCyclesBound,
         * and then call X86.helpFault(X86.EXCEPTION.BR_FAULT, null, nCycles).
         */
        X86.helpFault.call(this, X86.EXCEPTION.BR_FAULT);
    }
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnBSF(dst, src)
 *
 * Scan src starting at bit 0.  If a set bit is found, the bit index is stored in dst and ZF is cleared;
 * otherwise, ZF is set and dst is unchanged.
 *
 * NOTES: Early versions of the 80386 manuals misstated how ZF was set/cleared.  Also, Intel insists that
 * dst is undefined whenever ZF is set, but in fact, the 80386 leaves dst unchanged when that happens;
 * unfortunately, some early 80486s would always modify dst, so it is unsafe to rely on dst when ZF is set.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBSF = function(dst, src)
{
    let n = 0;
    if (!src) {
        this.setZF();
    } else {
        this.clearZF();
        let bit = 0x1;
        while (bit & this.maskData) {
            if (src & bit) {
                dst = n;
                break;
            }
            bit <<= 1;
            n++;                // TODO: Determine if n should be incremented before the bailout for an accurate cycle count
        }
    }
    this.nStepCycles -= 11 + n * 3;
    return dst;
};

/**
 * fnBSR(dst, src)
 *
 * Scan src starting from the highest bit.  If a set bit is found, the bit index is stored in dst and ZF is
 * cleared; otherwise, ZF is set and dst is unchanged.
 *
 * NOTES: Early versions of the 80386 manuals misstated how ZF was set/cleared.  Also, Intel insists that
 * dst is undefined whenever ZF is set, but in fact, the 80386 leaves dst unchanged when that happens;
 * unfortunately, some early 80486s would always modify dst, so it is unsafe to rely on dst when ZF is set.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBSR = function(dst, src)
{
    let n = 0;
    if (!src) {
        this.setZF();
    } else {
        this.clearZF();
        let i = (this.sizeData == 2? 15 : 31), bit = 1 << i;
        while (bit) {
            if (src & bit) {
                dst = i;
                break;
            }
            bit >>>= 1;
            n++; i--;           // TODO: Determine if n should be incremented before the bailout for an accurate cycle count
        }

    }
    this.nStepCycles -= 11 + n * 3;
    return dst;
};

/**
 * fnBT(dst, src)
 *
 * In this form of BT, src is an immediate operand (OR dst is register operand); immediate operands
 * are supposed to be masked with either 0xf or 0x1f for 16-bit or 32-bit operands, respectively.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBT = function(dst, src)
{
    let bit = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & bit) this.setCF(); else this.clearCF();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnBTC(dst, src)
 *
 * In this form of BTC, src is an immediate operand (OR dst is register operand); immediate operands
 * are supposed to be masked with either 0xf or 0x1f for 16-bit or 32-bit operands, respectively.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBTC = function(dst, src)
{
    let bit = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & bit) this.setCF(); else this.clearCF();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 6 : 8);
    return dst ^ bit;
};

/**
 * fnBTR(dst, src)
 *
 * In this form of BTR, src is an immediate operand (OR dst is register operand); immediate operands
 * are supposed to be masked with either 0xf or 0x1f for 16-bit or 32-bit operands, respectively.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBTR = function(dst, src)
{
    let bit = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & bit) this.setCF(); else this.clearCF();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 6 : 8);
    return dst & ~bit;
};

/**
 * fnBTS(dst, src)
 *
 * In this form of BTS, src is an immediate operand (OR dst is register operand); immediate operands
 * are supposed to be masked with either 0xf or 0x1f for 16-bit or 32-bit operands, respectively.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBTS = function(dst, src)
{
    let bit = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & bit) this.setCF(); else this.clearCF();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 6 : 8);
    return dst | bit;
};

/**
 * fnBTMem(dst, src)
 *
 * In this form of BT, src is a register operand, which is NOT truncated if dst is a memory operand;
 * however, if dst is also a register operand, then we defer to the simpler function, fnBT().
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBTMem = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnBT.call(this, dst, src);
    }
    /*
     * TODO: Consider a worker function that performs the following block of code for: BT, BTC, BTR, and BTS.
     * It's somewhat inconvenient, because it needs to provide two results: an updated src AND an updated dst.
     *
     * src is usually positive BUT can also be negative (as the IA32 spec says: "The offset operand then selects
     * a bit position within the range â231 to 231 â 1 for a register offset and 0 to 31 for an immediate offset.")
     */
    let max = this.sizeData << 3;
    if (src >= max || src < -max) {
        /*
         * Now we need to divide src by 16 or 32, according to the OPERAND size, which means shifting it right
         * by either 4 or 5 bits.  That gives us a short or long INDEX, which we then multiply by the OPERAND size
         * to obtain to the corresponding short or long OFFSET that we must add to the original EA offset.
         */
        let i = src >> (this.sizeData == 2? 4 : 5);
        dst = this.getEAWord(this.segEA, this.offEA + i * this.sizeData);
    }
    /*
     * Now we convert src from a bit index to a bit mask.
     */
    src = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & src) this.setCF(); else this.clearCF();

    this.nStepCycles -= 6;
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnBTCMem(dst, src)
 *
 * In this form of BTC, src is a register operand, which is NOT truncated if dst is a memory operand;
 * however, if dst is also a register operand, then we defer to the simpler function, fnBTC().
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBTCMem = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnBTC.call(this, dst, src);
    }
    /*
     * src is usually positive BUT can also be negative (as the IA32 spec says: "The offset operand then selects
     * a bit position within the range â231 to 231 â 1 for a register offset and 0 to 31 for an immediate offset.")
     */
    let max = this.sizeData << 3;
    if (src >= max || src < -max) {
        /*
         * Now we need to divide src by 16 or 32, according to the OPERAND size, which means shifting it right
         * by either 4 or 5 bits.  That gives us a short or long INDEX, which we then multiply by the OPERAND size
         * to obtain to the corresponding short or long OFFSET that we must add to the original EA offset.
         */
        let i = src >> (this.sizeData == 2? 4 : 5);
        dst = this.getEAWord(this.segEA, this.offEA + i * this.sizeData);
    }
    /*
     * Now we convert src from a bit index to a bit mask.
     */
    src = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & src) this.setCF(); else this.clearCF();

    this.nStepCycles -= 8;
    return dst ^ src;
};

/**
 * fnBTRMem(dst, src)
 *
 * In this form of BTR, src is a register operand, which is NOT truncated if dst is a memory operand;
 * however, if dst is also a register operand, then we defer to the simpler function, fnBTR().
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBTRMem = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnBTR.call(this, dst, src);
    }
    /*
     * src is usually positive BUT can also be negative (as the IA32 spec says: "The offset operand then selects
     * a bit position within the range â231 to 231 â 1 for a register offset and 0 to 31 for an immediate offset.")
     */
    let max = this.sizeData << 3;
    if (src >= max || src < -max) {
        /*
         * Now we need to divide src by 16 or 32, according to the OPERAND size, which means shifting it right
         * by either 4 or 5 bits.  That gives us a short or long INDEX, which we then multiply by the OPERAND size
         * to obtain to the corresponding short or long OFFSET that we must add to the original EA offset.
         */
        let i = src >> (this.sizeData == 2? 4 : 5);
        dst = this.getEAWord(this.segEA, this.offEA + i * this.sizeData);
    }
    /*
     * Now we convert src from a bit index to a bit mask.
     */
    src = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & src) this.setCF(); else this.clearCF();

    this.nStepCycles -= 8;
    return dst & ~src;
};

/**
 * fnBTSMem(dst, src)
 *
 * In this form of BTS, src is a register operand, which is NOT truncated if dst is a memory operand;
 * however, if dst is also a register operand, then we defer to the simpler function, fnBTS().
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnBTSMem = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnBTS.call(this, dst, src);
    }
    /*
     * src is usually positive BUT can also be negative (as the IA32 spec says: "The offset operand then selects
     * a bit position within the range â231 to 231 â 1 for a register offset and 0 to 31 for an immediate offset.")
     */
    let max = this.sizeData << 3;
    if (src >= max || src < -max) {
        /*
         * Now we need to divide src by 16 or 32, according to the OPERAND size, which means shifting it right
         * by either 4 or 5 bits.  That gives us a short or long INDEX, which we then multiply by the OPERAND size
         * to obtain to the corresponding short or long OFFSET that we must add to the original EA offset.
         */
        let i = src >> (this.sizeData == 2? 4 : 5);
        dst = this.getEAWord(this.segEA, this.offEA + i * this.sizeData);
    }
    /*
     * Now we convert src from a bit index to a bit mask.
     */
    src = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & src) this.setCF(); else this.clearCF();

    this.nStepCycles -= 8;
    return dst | src;
};

/**
 * fnCALLw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnCALLw = function(dst, src)
{
    this.pushWord(this.getIP());
    this.setIP(dst);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesCallWR : this.cycleCounts.nOpCyclesCallWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnCALLFdw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnCALLFdw = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnGRPUndefined.call(this, dst, src);
    }
    /*
     * Originally, we would snapshot regLSP into opLSP because helpCALLF() could trigger a segment fault,
     * but additionally, the stack segment could trigger either a segment fault or a page fault; indeed,
     * any operation that performs multiple stack modifications must take this precaution and snapshot regLSP.
     */
    this.opLSP = this.regLSP;

    X86.helpCALLF.call(this, dst, this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesCallDM;
    this.opFlags |= X86.OPFLAG.NOWRITE;

    this.opLSP = X86.ADDR_INVALID;
    return dst;
};

/**
 * fnCMPb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number} dst unchanged
 */
X86.fnCMPb = function(dst, src)
{
    let b = (dst - src)|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesCompareRM) : this.cycleCounts.nOpCyclesArithRM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnCMPw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number} dst unchanged
 */
X86.fnCMPw = function(dst, src)
{
    let w = (dst - src)|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesCompareRM) : this.cycleCounts.nOpCyclesArithRM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnDECb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnDECb = function(dst, src)
{
    let b = (dst - 1)|0;
    this.setArithResult(dst, 1, b, X86.RESULT.BYTE | X86.RESULT.NOTCF, true);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIncR : this.cycleCounts.nOpCyclesIncM);
    return b & 0xff;
};

/**
 * fnDECw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnDECw = function(dst, src)
{
    let w = (dst - 1)|0;
    this.setArithResult(dst, 1, w, this.typeData | X86.RESULT.NOTCF, true);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIncR : this.cycleCounts.nOpCyclesIncM);
    return w & this.maskData;
};

/**
 * fnDIVb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (the divisor)
 * @param {number} src (null; AX is the implied src)
 * @return {number} (we return dst unchanged, since it's actually AX that's modified)
 */
X86.fnDIVb = function(dst, src)
{
    /*
     * Detect zero divisor
     */
    if (!dst) {
        X86.helpDIVOverflow.call(this);
        return dst;
    }

    /*
     * Detect too-small divisor (quotient overflow)
     */
    let result = ((src = this.regEAX & 0xffff) / dst);
    if (result > 0xff) {
        X86.helpDIVOverflow.call(this);
        return dst;
    }

    this.regMDLo = (result & 0xff) | (((src % dst) & 0xff) << 8);
    this.fMDSet = true;

    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesDivBR : this.cycleCounts.nOpCyclesDivBM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnDIVw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (the divisor)
 * @param {number} src (null; DX:AX or EDX:EAX is the implied src)
 * @return {number} (we return dst unchanged, since it's actually DX:AX that's modified)
 */
X86.fnDIVw = function(dst, src)
{
    if (this.sizeData == 2) {
        /*
         * Detect zero divisor
         */
        if (!dst) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }
        /*
         * Detect too-small divisor (quotient overflow)
         *
         * WARNING: We CANNOT simply do "src = (this.regEDX << 16) | this.regEAX", because if bit 15 of DX
         * is set, JavaScript will create a negative 32-bit number.  So we instead use non-bitwise operators
         * to force JavaScript to create a floating-point value that won't suffer from 32-bit-math side-effects.
         */
        src = (this.regEDX & 0xffff) * 0x10000 + (this.regEAX & 0xffff);
        let result = (src / dst);
        if (result >= 0x10000) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }
        this.regMDLo = (result & 0xffff);
        this.regMDHi = (src % dst) & 0xffff;
    }
    else {
        if (!X86.helpDIV32.call(this, this.regEAX, this.regEDX, dst)) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }
        this.regMDLo |= 0;
        this.regMDHi |= 0;
    }

    this.fMDSet = true;

    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesDivWR : this.cycleCounts.nOpCyclesDivWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnESC(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number} dst unchanged
 */
X86.fnESC = function(dst, src)
{
    if (this.fpu) {
        this.fpu.opFPU(this.bOpcode, this.bModRM, dst, src);
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 2 : 8);
    return dst;
};

/**
 * fnGRPFault(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnGRPFault = function(dst, src)
{
    /*
     * This should NEVER be called on 8086/8088 CPUs, and yet we preset some of the handlers in aOpGrpPOPw,
     * aOpGrp4b, and aOpGrp4w to call it.  initProcessor() DOES patch aOpGrp4b[0x07] and aOpGrp4w[0x07] to
     * fnGRPInvalid, but that's it.
     *
     * However, given the infrequency of this call, it's simpler to continue presetting all the handlers in
     * aOpGrpPOPw to their post-8086 default, and deal with the appropriate 8086 behavior here (which for now,
     * is to call fnGRPUndefined instead).
     */
    if (this.model < X86.MODEL_80186) {
        return X86.fnGRPUndefined.call(this, dst, src);
    }
    X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
    return dst;
};

/**
 * fnGRPInvalid(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnGRPInvalid = function(dst, src)
{
    X86.opInvalid.call(this);
    return dst;
};

/**
 * fnGRPUndefined(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnGRPUndefined = function(dst, src)
{
    X86.opUndefined.call(this);
    return dst;
};

/**
 * fnIDIVb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (the divisor)
 * @param {number} src (null; AX is the implied src)
 * @return {number} (we return dst unchanged, since it's actually AX that's modified)
 */
X86.fnIDIVb = function(dst, src)
{
    /*
     * Detect zero divisor
     */
    if (!dst) {
        X86.helpDIVOverflow.call(this);
        return dst;
    }

    /*
     * Detect too-small divisor (quotient overflow)
     */
    let div = ((dst << 24) >> 24);
    let result = ((src = (this.regEAX << 16) >> 16) / div)|0;

    /*
     * Note the following difference, from "AP-186: Introduction to the 80186 Microprocessor, March 1983":
     *
     *      "The 8086 will cause a divide error whenever the absolute value of the quotient is greater then 7FFFH
     *      (for word operations) or if the absolute value of the quotient is greater than 7FH (for byte operations).
     *      The 80186 has expanded the range of negative numbers allowed as a quotient by 1 to include 8000H and 80H.
     *      These numbers represent the most negative numbers representable using 2's complement arithmetic (equaling
     *      -32768 and -128 in decimal, respectively)."
     */
    if (result != ((result << 24) >> 24) || this.model == X86.MODEL_8086 && result == -128) {
        X86.helpDIVOverflow.call(this);
        return dst;
    }

    this.regMDLo = (result & 0xff) | (((src % div) & 0xff) << 8);
    this.fMDSet = true;

    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIDivBR : this.cycleCounts.nOpCyclesIDivBM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnIDIVw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (the divisor)
 * @param {number} src (null; DX:AX or EDX:EAX is the implied src)
 * @return {number} (we return dst unchanged, since it's actually DX:AX that's modified)
 */
X86.fnIDIVw = function(dst, src)
{
    if (this.sizeData == 2) {
        /*
         * Detect zero divisor
         */
        if (!dst) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }

        /*
         * Detect too-small divisor (quotient overflow)
         */
        let div = ((dst << 16) >> 16);
        let result = ((src = (this.regEDX << 16) | (this.regEAX & 0xffff)) / div)|0;

        /*
         * Note the following difference, from "AP-186: Introduction to the 80186 Microprocessor, March 1983":
         *
         *      "The 8086 will cause a divide error whenever the absolute value of the quotient is greater then 7FFFH
         *      (for word operations) or if the absolute value of the quotient is greater than 7FH (for byte operations).
         *      The 80186 has expanded the range of negative numbers allowed as a quotient by 1 to include 8000H and 80H.
         *      These numbers represent the most negative numbers representable using 2's complement arithmetic (equaling
         *      -32768 and -128 in decimal, respectively)."
         */
        if (result != ((result << 16) >> 16) || this.model == X86.MODEL_8086 && result == -32768) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }

        this.regMDLo = (result & 0xffff);
        this.regMDHi = (src % div) & 0xffff;
    }
    else {
        if (!X86.helpIDIV32.call(this, this.regEAX, this.regEDX, dst)) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }
        this.regMDLo |= 0;
        this.regMDHi |= 0;
    }

    this.fMDSet = true;

    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIDivWR : this.cycleCounts.nOpCyclesIDivWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnIMUL8(dst, src)
 *
 * 80286_and_80287_Programmers_Reference_Manual_1987.pdf, p.B-44 (p.254) notes that:
 *
 *      "The low 16 bits of the product of a 16-bit signed multiply are the same as those of an
 *      unsigned multiply. The three operand IMUL instruction can be used for unsigned operands as well."
 *
 * However, we still sign-extend the operands before multiplying, making it easier to range-check the result.
 *
 * (80186/80188 and up)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnIMUL8 = function(dst, src)
{
    /*
     * NOTE: getIPDisp() already sign-extends the dst parameter, so fnIMULrw() needlessly sign-extends it again;
     * a small price to pay for a common function.
     */
    let result = X86.fnIMULrw.call(this, this.getIPDisp(), src);

    /*
     * NOTE: The above function already accounted for the 80386 cycle count, so we are simply accounting for the
     * increased time on an 80286; the 80186/80188 have even larger values, but we'll worry about that another day.
     */
    if (this.model < X86.MODEL_80386) this.nStepCycles -= 12;
    return result;
};

/**
 * fnIMULn(dst, src)
 *
 * 80286_and_80287_Programmers_Reference_Manual_1987.pdf, p.B-44 (p.254) notes that:
 *
 *      "The low 16 bits of the product of a 16-bit signed multiply are the same as those of an
 *      unsigned multiply. The three operand IMUL instruction can be used for unsigned operands as well."
 *
 * However, we still sign-extend the operands before multiplying, making it easier to range-check the result.
 *
 * (80186/80188 and up)
 *
 * @this {CPUX86}
 * @param {number} dst (not used)
 * @param {number} src
 * @return {number}
 */
X86.fnIMULn = function(dst, src)
{
    let result;
    dst = this.getIPWord();

    if (this.sizeData == 2) {
        result = X86.fnIMULrw.call(this, dst, src);
    } else {
        result = X86.fnIMULrd.call(this, dst, src);
    }

    /*
     * NOTE: The above functions already accounted for 80386 cycle counts, so we are simply accounting for the
     * increased time on an 80286; the 80186/80188 have even larger values, but we'll worry about that another day.
     */
    if (this.model < X86.MODEL_80386) this.nStepCycles -= 12;
    return result;
};

/**
 * fnIMUL32(dst, src)
 *
 * This sets regMDHi:regMDLo to the 64-bit result of dst * src, both of which are treated as signed.
 *
 * @this {CPUX86}
 * @param {number} dst (any 32-bit number, treated as signed)
 * @param {number} src (any 32-bit number, treated as signed)
 */
X86.fnIMUL32 = function(dst, src)
{
    let fNeg = false;
    if (src < 0) {
        src = -src|0;
        fNeg = !fNeg;
    }
    if (dst < 0) {
        dst = -dst|0;
        fNeg = !fNeg;
    }
    X86.fnMUL32.call(this, dst, src);
    if (fNeg) {
        this.regMDLo = (~this.regMDLo + 1)|0;
        this.regMDHi = (~this.regMDHi + (this.regMDLo? 0 : 1))|0;
    }
};

/**
 * fnIMULb(dst, src)
 *
 * This 16-bit multiplication must indicate when the upper 8 bits are simply a sign-extension of the
 * lower 8 bits (carry clear) and when the upper 8 bits contain significant bits (carry set).  The latter
 * will occur whenever a positive result is > 127 (0x007f) and whenever a negative result is < -128
 * (0xff80).
 *
 * Example 1: 16 * 4 = 64 (0x0040): carry is clear
 * Example 2: 16 * 8 = 128 (0x0080): carry is set (the sign bit no longer fits in the lower 8 bits)
 * Example 3: 16 * -8 (0xf8) = -128 (0xff80): carry is clear (the sign bit *still* fits in the lower 8 bits)
 * Example 4: 16 * -16 (0xf0) = -256 (0xff00): carry is set (the sign bit no longer fits in the lower 8 bits)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null; AL is the implied src)
 * @return {number} (we return dst unchanged, since it's actually AX that's modified)
 */
X86.fnIMULb = function(dst, src)
{
    let result = (((this.regEAX << 24) >> 24) * ((dst << 24) >> 24))|0;
    this.regMDLo = result & 0xffff;
    if (result > 127 || result < -128) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    if (this.model <= X86.MODEL_8088) {
        this.clearZF();         // differentiate ourselves from a NEC V20
    }
    this.fMDSet = true;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIMulBR : this.cycleCounts.nOpCyclesIMulBM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnIMULw(dst, src)
 *
 * regMDHi:regMDLo = dst * regEAX
 *
 * This 32-bit multiplication must indicate when the upper 16 bits are simply a sign-extension of the
 * lower 16 bits (carry clear) and when the upper 16 bits contain significant bits (carry set).  The latter
 * will occur whenever a positive result is > 32767 (0x00007fff) and whenever a negative result is < -32768
 * (0xffff8000).
 *
 * Example 1: 256 * 64 = 16384 (0x00004000): carry is clear
 * Example 2: 256 * 128 = 32768 (0x00008000): carry is set (the sign bit no longer fits in the lower 16 bits)
 * Example 3: 256 * -128 (0xff80) = -32768 (0xffff8000): carry is clear (the sign bit *still* fits in the lower 16 bits)
 * Example 4: 256 * -256 (0xff00) = -65536 (0xffff0000): carry is set (the sign bit no longer fits in the lower 16 bits)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null; AX or EAX is the implied src)
 * @return {number} (we return dst unchanged, since it's actually DX:AX or EDX:EAX that's modified)
 */
X86.fnIMULw = function(dst, src)
{
    let fOverflow;
    if (this.sizeData == 2) {
        src = this.regEAX & 0xffff;
        let result = (((src << 16) >> 16) * ((dst << 16) >> 16))|0;
        this.regMDLo = result & 0xffff;
        this.regMDHi = (result >> 16) & 0xffff;
        fOverflow = (result > 32767 || result < -32768);
    } else {
        X86.fnIMUL32.call(this, dst, this.regEAX);
        fOverflow = (this.regMDHi != (this.regMDLo >> 31));
    }
    if (fOverflow) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    if (this.model <= X86.MODEL_8088) {
        this.clearZF();         // differentiate ourselves from a NEC V20
    }
    this.fMDSet = true;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIMulWR : this.cycleCounts.nOpCyclesIMulWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnIMULrw(dst, src)
 *
 * This function exists for 16-bit IMUL instructions that produce a 16-bit result instead of a 32-bit result
 * (and don't implicitly use the accumulator).
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnIMULrw = function(dst, src)
{
    /*
     * Unlike fnIMULrd() below, we can use normal JavaScript multiplication, because there's no danger of
     * overflowing the floating-point result and losing accuracy in the bottom 16 bits.
     */
    let result = (((dst << 16) >> 16) * ((src << 16) >> 16))|0;
    if (result > 32767 || result < -32768) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    result &= 0xffff;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 9 : 12);
    return result;
};

/**
 * fnIMULrd(dst, src)
 *
 * This function exists for 32-bit IMUL instructions that produce a 32-bit result instead of a 64-bit result
 * (and don't implicitly use the accumulator).
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnIMULrd = function(dst, src)
{
    /*
     * The following code works, but I've stopped using it because it produces different results from an actual CPU
     * when overflow occurs; the bottom 32 bits of the result are still supposed to be accurate.
     *
     * And unfortunately, we cannot achieve that level of compatibility using normal JavaScript multiplication,
     * because the result may be too large to fit in a JavaScript floating-point variable, which means we could lose
     * accuracy in the bottom 32 bits, which would defeat what we're trying to achieve here.  So we must use the
     * slower fnIMUL32() function.
     *
     *      let result = dst * src;
     *      if (result > 2147483647 || result < -2147483648) {
     *          this.setCF(); this.setOF();
     *      } else {
     *          this.clearCF(); this.clearOF();
     *      }
     *      result |= 0;
     */
    X86.fnIMUL32.call(this, dst, src);
    let fOverflow = (this.regMDHi != (this.regMDLo >> 31));
    if (fOverflow) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 9 : 12);
    return this.regMDLo;
};

/**
 * fnINCb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnINCb = function(dst, src)
{
    let b = (dst + 1)|0;
    this.setArithResult(dst, 1, b, X86.RESULT.BYTE | X86.RESULT.NOTCF);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIncR : this.cycleCounts.nOpCyclesIncM);
    return b & 0xff;
};

/**
 * fnINCw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnINCw = function(dst, src)
{
    let w = (dst + 1)|0;
    this.setArithResult(dst, 1, w, this.typeData | X86.RESULT.NOTCF);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIncR : this.cycleCounts.nOpCyclesIncM);
    return w & this.maskData;
};

/**
 * fnJMPw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnJMPw = function(dst, src)
{
    this.setIP(dst);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesJmpWR : this.cycleCounts.nOpCyclesJmpWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnJMPFdw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnJMPFdw = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnGRPUndefined.call(this, dst, src);
    }
    this.setCSIP(dst, this.getShort(this.regEA + this.sizeData));
    if (MAXDEBUG && this.cIntReturn) this.checkIntReturn(this.regLIP);
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpDM;
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnLAR(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnLAR = function(dst, src)
{
    this.nStepCycles -= (14 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    /*
     * Currently, segVER.load() will return an error only if the selector is beyond the bounds of the
     * descriptor table or the descriptor is not for a segment.
     *
     * TODO: This instruction's 80286 documentation does not discuss conforming code segments; determine
     * if we need a special check for them.
     */
    this.clearZF();
    if (this.segVER.load(src) !== X86.ADDR_INVALID) {
        if (this.segVER.dpl >= this.nCPL && this.segVER.dpl >= (src & X86.SEL.RPL)) {
            this.setZF();
            dst = this.segVER.acc & ~X86.DESC.ACC.BASE1623;
            if (this.sizeData > 2) {
                dst |= ((this.segVER.ext & ~X86.DESC.EXT.BASE2431) << 16);
            }
        }
    }
    return dst;
};

/**
 * fnLDS(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnLDS = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setDS(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLEA(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnLEA = function(dst, src)
{
    /*
     * TODO: Until I bite the bullet and choose a truly invalid value for X86.ADDR_INVALID (eg, null),
     * this code must be disabled, because otherwise an instruction like "LEA ECX,[EAX-1]" will fail when
     * EAX is zero.  And we can't have that.
     *
    if (this.regEA === X86.ADDR_INVALID) {
        //
        // TODO: After reading http://www.os2museum.com/wp/undocumented-8086-opcodes/, it seems that this
        // form of LEA (eg, "LEA AX,DX") simply returns the last calculated EA.  Since we always reset regEA
        // at the start of a new instruction, we would need to preserve the previous EA if we want to mimic
        // that (undocumented) behavior.
        //
        // And for completeness, we would have to extend EA tracking beyond the usual ModRM instructions
        // (eg, XLAT, instructions that modify the stack pointer, and string instructions).  Anything else?
        //
        X86.opUndefined.call(this);
        return dst;
    }
    */
    this.nStepCycles -= this.cycleCounts.nOpCyclesLEA;
    return this.regEA;
};

/**
 * fnLES(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnLES = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setES(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLFS(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnLFS = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setFS(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLGDT(dst, src)
 *
 * op=0x0F,0x01,reg=0x2 (GRP7:LGDT)
 *
 * The 80286 LGDT instruction assumes a 40-bit operand: a 16-bit limit followed by a 24-bit base address;
 * the ModRM decoder has already supplied the first word of the operand (in dst), which corresponds to
 * the limit, so we must fetch the remaining bits ourselves.
 *
 * The 80386 LGDT instruction assumes a 48-bit operand: a 16-bit limit followed by a 32-bit base address,
 * but it ignores the last 8 bits of the base address if the OPERAND size is 16 bits; we interpret that to
 * mean that the 24-bit base address should be zero-extended to 32 bits.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnLGDT = function(dst, src)
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (this.regEA === X86.ADDR_INVALID || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
    } else {
        /*
         * Hopefully it won't hurt to always fetch a 32-bit base address (even on an 80286), which we then
         * mask appropriately.
         */
        this.addrGDT = this.getLong(this.regEA + 2) & (this.maskData | (this.maskData << 8));
        /*
         * An idiosyncrasy of our ModRM decoders is that, if the OPERAND size is 32 bits, then it will have
         * fetched a 32-bit dst operand; we mask off those extra bits now.
         */
        dst &= 0xffff;
        this.addrGDTLimit = this.addrGDT + dst;
        this.opFlags |= X86.OPFLAG.NOWRITE;
        this.nStepCycles -= 11;
    }
    return dst;
};

/**
 * fnLGS(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnLGS = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setGS(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLIDT(dst, src)
 *
 * op=0x0F,0x01,reg=0x3 (GRP7:LIDT)
 *
 * The 80286 LIDT instruction assumes a 40-bit operand: a 16-bit limit followed by a 24-bit base address;
 * the ModRM decoder has already supplied the first word of the operand (in dst), which corresponds to
 * the limit, so we must fetch the remaining bits ourselves.
 *
 * The 80386 LIDT instruction assumes a 48-bit operand: a 16-bit limit followed by a 32-bit base address,
 * but it ignores the last 8 bits of the base address if the OPERAND size is 16 bits; we interpret that to
 * mean that the 24-bit base address should be zero-extended to 32 bits.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnLIDT = function(dst, src)
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (this.regEA === X86.ADDR_INVALID || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
    } else {
        /*
         * Hopefully it won't hurt to always fetch a 32-bit base address (even on an 80286), which we then
         * mask appropriately.
         */
        this.addrIDT = this.getLong(this.regEA + 2) & (this.maskData | (this.maskData << 8));
        /*
         * An idiosyncrasy of our ModRM decoders is that, if the OPERAND size is 32 bits, then it will have
         * fetched a 32-bit dst operand; we mask off those extra bits now.
         */
        dst &= 0xffff;
        this.addrIDTLimit = this.addrIDT + dst;
        this.opFlags |= X86.OPFLAG.NOWRITE;
        this.nStepCycles -= 12;
    }
    return dst;
};

/**
 * fnLLDT(dst, src)
 *
 * op=0x0F,0x00,reg=0x2 (GRP6:LLDT)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnLLDT = function(dst, src)
{
    this.opFlags |= X86.OPFLAG.NOWRITE;
    this.segLDT.load(dst);
    this.nStepCycles -= (17 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    return dst;
};

/**
 * fnLMSW(dst, src)
 *
 * op=0x0F,0x01,reg=0x6 (GRP7:LMSW)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnLMSW = function(dst, src)
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
    } else {
        this.setMSW(dst);
        this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
        this.opFlags |= X86.OPFLAG.NOWRITE;
    }
    return dst;
};

/**
 * fnLSL(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (the selector)
 * @return {number}
 */
X86.fnLSL = function(dst, src)
{
    /*
     * TODO: Is this an invalid operation if regEAWrite is set?  dst is required to be a register.
     */
    this.nStepCycles -= (14 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    /*
     * Currently, segVER.load() will return an error only if the selector is beyond the bounds of the
     * descriptor table or the descriptor is not for a segment.
     *
     * TODO: LSL is explicitly documented as ALSO requiring a non-null selector, so we check X86.SEL.MASK;
     * are there any other instructions that were, um, less explicit but also require a non-null selector?
     */
    if ((src & X86.SEL.MASK) && this.segVER.load(src) !== X86.ADDR_INVALID) {
        let fConforming = ((this.segVER.acc & X86.DESC.ACC.TYPE.CODE_CONFORMING) == X86.DESC.ACC.TYPE.CODE_CONFORMING);
        if ((fConforming || this.segVER.dpl >= this.nCPL) && this.segVER.dpl >= (src & X86.SEL.RPL)) {
            this.setZF();
            return this.segVER.limit;
        }
    }
    this.clearZF();
    return dst;
};

/**
 * fnLSS(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnLSS = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setSS(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLTR(dst, src)
 *
 * op=0x0F,0x00,reg=0x3 (GRP6:LTR)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnLTR = function(dst, src)
{
    this.opFlags |= X86.OPFLAG.NOWRITE;
    if (this.segTSS.load(dst) !== X86.ADDR_INVALID) {
        this.setShort(this.segTSS.addrDesc + X86.DESC.ACC.OFFSET, this.segTSS.acc |= X86.DESC.ACC.TYPE.TSS_BUSY);
        this.segTSS.type |= X86.DESC.ACC.TYPE.TSS_BUSY;
    }
    this.nStepCycles -= (17 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    return dst;
};

/**
 * fnMOV(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @return {number} dst (updated value, from src)
 */
X86.fnMOV = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesMovRR : this.cycleCounts.nOpCyclesMovRM) : this.cycleCounts.nOpCyclesMovMR);
    return src;
};

/**
 * fnMOVXb(dst, src)
 *
 * Helper for opMOVSXb() and opMOVZXb() (which also take care of updating nStepCycles, so we don't have to)
 *
 * @this {CPUX86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @return {number} dst (updated value, from src)
 */
X86.fnMOVXb = function(dst, src)
{
    /*
     * The ModRegByte handlers update the registers in the 1st column, but we need to update those in the 2nd column.
     *
     *      000:    AL      ->      000:    AX
     *      001:    CL      ->      001:    CX
     *      010:    DL      ->      010:    DX
     *      011:    BL      ->      011:    BX
     *      100:    AH      ->      100:    SP
     *      101:    CH      ->      101:    BP
     *      110:    DH      ->      110:    SI
     *      111:    BH      ->      111:    DI
     */
    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x4:
        this.regXX = this.regEAX;
        break;
    case 0x5:
        this.regXX = this.regECX;
        break;
    case 0x6:
        this.regXX = this.regEDX;
        break;
    case 0x7:
        this.regXX = this.regEBX;
        break;
    }
    return src;
};

/**
 * fnMOVXw(dst, src)
 *
 * Helper for opMOVSXw() and opMOVZXw() (which also take care of updating nStepCycles, so we don't have to)
 *
 * @this {CPUX86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @return {number} dst (updated value, from src)
 */
X86.fnMOVXw = function(dst, src)
{
    return src;
};

/**
 * fnMOVn(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @return {number} dst (updated value, from src)
 */
X86.fnMOVn = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesMovRI : this.cycleCounts.nOpCyclesMovMI);
    return src;
};

/**
 * fnMOVsrw(dst, src)
 *
 * This helper saves the contents of the general-purpose register that will be overwritten, so that the caller
 * can restore it after moving the updated value to the correct segment register.
 *
 * @this {CPUX86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @return {number} dst (updated value, from src)
 */
X86.fnMOVsrw = function(dst, src)
{
    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        this.regXX = this.regEAX;
        break;
    case 0x2:
        this.regXX = this.regEDX;
        break;
    case 0x3:
        this.regXX = this.regEBX;
        break;
    default:
        if (this.model == X86.MODEL_80286 || this.model == X86.MODEL_80386 && reg != 0x4 && reg != 0x5) {
            X86.opInvalid.call(this);
            break;
        }
        switch(reg) {
        case 0x1:           // MOV to CS is undocumented on 8086/8088/80186/80188, and invalid on 80286 and up
            this.regXX = this.regECX;
            break;
        case 0x4:           // this form of MOV to ES is undocumented on 8086/8088/80186/80188, invalid on 80286, and uses FS starting with 80386
            this.regXX = this.getSP();
            break;
        case 0x5:           // this form of MOV to CS is undocumented on 8086/8088/80186/80188, invalid on 80286, and uses GS starting with 80386
            this.regXX = this.regEBP;
            break;
        case 0x6:           // this form of MOV to SS is undocumented on 8086/8088/80186/80188, invalid on 80286 and up
            this.regXX = this.regESI;
            break;
        case 0x7:           // this form of MOV to DS is undocumented on 8086/8088/80186/80188, invalid on 80286 and up
            this.regXX = this.regEDI;
            break;
        default:
            break;
        }
        break;
    }
    /*
     * We could just return src, but nStepCycles needs to be updated, too.
     */
    return X86.fnMOV.call(this, dst, src);
};

/**
 * fnMOVwsr(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @return {number} dst
 */
X86.fnMOVwsr = function(dst, src)
{
    let reg = (this.bModRM >> 3) & 0x7;

    switch (reg) {
    case 0x0:
        src = this.segES.sel;
        break;
    case 0x1:
        src = this.segCS.sel;
        break;
    case 0x2:
        src = this.segSS.sel;
        break;
    case 0x3:
        src = this.segDS.sel;
        break;
    case 0x4:
        if (I386 && this.model >= X86.MODEL_80386) {
            src = this.segFS.sel;
            break;
        }
        X86.opInvalid.call(this);
        src = dst;
        break;
    case 0x5:
        if (I386 && this.model >= X86.MODEL_80386) {
            src = this.segGS.sel;
            break;
        }
        /* falls through */
    default:
        X86.opInvalid.call(this);
        src = dst;
        break;
    }

    /*
     * When a 32-bit OPERAND size is in effect, segment register writes via opMOVwsr() must write 32 bits
     * (zero-extended) if the destination is a register, but only 16 bits if the destination is memory,
     * hence the setDataSize(2) below.
     *
     * The only other caller, opMOVrc(), is not affected, because it writes only to register destinations.
     */
    if (this.regEAWrite !== X86.ADDR_INVALID) {
        this.setDataSize(2);
    }
    /*
     * We could just return src, but nStepCycles needs to be updated, too.
     */
    return X86.fnMOV.call(this, dst, src);
};

/**
 * fnMULb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number} (we return dst unchanged, since it's actually AX that's modified)
 */
X86.fnMULb = function(dst, src)
{
    this.regMDLo = ((this.regEAX & 0xff) * dst) & 0xffff;
    if (this.regMDLo & 0xff00) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    if (this.model <= X86.MODEL_8088) {
        this.clearZF();         // differentiate ourselves from a NEC V20
    }
    this.fMDSet = true;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesMulBR : this.cycleCounts.nOpCyclesMulBM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnMUL32(dst, src)
 *
 * This sets regMDHi:regMDLo to the 64-bit result of dst * src, both of which are treated as unsigned.
 *
 * The algorithm is based on the traditional "by hand" multiplication method, by treating the two inputs
 * (dst and src) as two 2-digit numbers, where each digit is a base-65536 digit.
 *
 * @this {CPUX86}
 * @param {number} dst (any 32-bit number, treated as unsigned)
 * @param {number} src (any 32-bit number, treated as unsigned)
 */
X86.fnMUL32 = function(dst, src)
{
    if (!(dst & ~0xffff) && !(src & ~0xffff)) {
        this.regMDLo = (dst * src)|0;
        this.regMDHi = 0;
    }
    else {
        let srcLo = src & 0xffff;
        let srcHi = src >>> 16;
        let dstLo = dst & 0xffff;
        let dstHi = dst >>> 16;

        let mul00 = srcLo * dstLo;
        let mul16 = ((mul00 >>> 16) + (srcHi * dstLo));
        let mul32 = mul16 >>> 16;
        mul16 = ((mul16 & 0xffff) + (srcLo * dstHi));
        mul32 += ((mul16 >>> 16) + (srcHi * dstHi));

        this.regMDLo = (mul16 << 16) | (mul00 & 0xffff);
        this.regMDHi = mul32|0;
    }
};

/**
 * fnMULw(dst, src)
 *
 * regMDHi:regMDLo = dst * regEAX
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null; AX or EAX is the implied src)
 * @return {number} (we return dst unchanged, since it's actually DX:AX that's modified)
 */
X86.fnMULw = function(dst, src)
{
    if (this.sizeData == 2) {
        src = this.regEAX & 0xffff;
        let result = (src * dst)|0;
        this.regMDLo = result & 0xffff;
        this.regMDHi = (result >> 16) & 0xffff;
    } else {
        X86.fnMUL32.call(this, dst, this.regEAX);
        if (this.stepping == X86.STEPPING_80386_B1) {
            if (this.regEAX == 0x0417A000 && dst == 0x00000081) {
                /*
                 * Normally, the result should be 0x20FE7A000 (ie, regMDHi should be 0x2).
                 * I'm not sure what a typical B1 stepping failure looked like, so I'll set regMDHi to 0.
                 *
                 * If you want a B1 stepping without this 32-bit multiplication flaw, select the B2 stepping.
                 */

                this.regMDHi = 0;
            }
        }
    }

    if (this.regMDHi) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    if (this.model <= X86.MODEL_8088) {
        this.clearZF();         // differentiate ourselves from a NEC V20
    }
    this.fMDSet = true;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesMulWR : this.cycleCounts.nOpCyclesMulWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnNEGb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnNEGb = function(dst, src)
{
    let b = (-dst)|0;
    this.setArithResult(0, dst, b, X86.RESULT.BYTE | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesNegR : this.cycleCounts.nOpCyclesNegM);
    return b & 0xff;
};

/**
 * fnNEGw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnNEGw = function(dst, src)
{
    let w = (-dst)|0;
    this.setArithResult(0, dst, w, this.typeData | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesNegR : this.cycleCounts.nOpCyclesNegM);
    return w & this.maskData;
};

/**
 * fnNOTb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnNOTb = function(dst, src)
{
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesNegR : this.cycleCounts.nOpCyclesNegM);
    return dst ^ 0xff;
};

/**
 * fnNOTw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnNOTw = function(dst, src)
{
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesNegR : this.cycleCounts.nOpCyclesNegM);
    return dst ^ this.maskData;
};

/**
 * fnORb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnORb = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return this.setLogicResult(dst | src, X86.RESULT.BYTE);
};

/**
 * fnORw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnORw = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return this.setLogicResult(dst | src, this.typeData) & this.maskData;
};

/**
 * fnPOPw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @return {number} dst (updated value, from src)
 */
X86.fnPOPw = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesPopReg : this.cycleCounts.nOpCyclesPopMem);
    return src;
};

/**
 * fnPUSHw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnPUSHw = function(dst, src)
{
    let w = dst;
    if (this.opFlags & X86.OPFLAG.PUSHSP) {
        /*
         * This is the one case where must actually modify dst, so that the ModRM function will
         * not put a stale value back into the SP register.
         */
        dst = (dst - 2) & 0xffff;
        /*
         * And on the 8086/8088, the value we just calculated also happens to be the value that must
         * be pushed.
         */
        if (this.model < X86.MODEL_80286) w = dst;
    }
    this.pushWord(w);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesPushReg : this.cycleCounts.nOpCyclesPushMem);
    /*
     * The PUSH is the only write that needs to occur; dst was the source operand and does not need to be rewritten.
     */
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnRCLb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRCLb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = this.getCarry();
        count %= 9;
        if (!count) {
            carry <<= 7;
        } else {
            result = ((dst << count) | (carry << (count - 1)) | (dst >> (9 - count))) & 0xff;
            carry = dst << (count - 1);
        }
        this.setRotateResult(result, carry, X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnRCLw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRCLw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = this.getCarry();
        count %= 17;
        if (!count) {
            carry <<= 15;
        } else {
            result = ((dst << count) | (carry << (count - 1)) | (dst >> (17 - count))) & 0xffff;
            carry = dst << (count - 1);
        }
        this.setRotateResult(result, carry, X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnRCLd(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRCLd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;     // this 32-bit-only function could mask with 0x1f directly
    if (count) {
        let carry = this.getCarry();
        /*
         * JavaScript Alert: much like a post-8086 Intel CPU, JavaScript shift counts are mod 32,
         * so "dst >>> 32" is equivalent to "dst >>> 0", which doesn't shift any bits at all.  To
         * compensate, we shift one bit less than the maximum, and then shift one bit farther.
         */
        result = (dst << count) | (carry << (count - 1)) | ((dst >>> (32 - count)) >>> 1);
        carry = dst << (count - 1);
        this.setRotateResult(result, carry, X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnRCRb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRCRb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = this.getCarry();
        count %= 9;
        if (!count) {
            carry <<= 7;
        } else {
            result = ((dst >> count) | (carry << (8 - count)) | (dst << (9 - count))) & 0xff;
            carry = dst << (8 - count);
        }
        this.setRotateResult(result, carry, X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnRCRw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRCRw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = this.getCarry();
        count %= 17;
        if (!count) {
            carry <<= 15;
        } else {
            result = ((dst >> count) | (carry << (16 - count)) | (dst << (17 - count))) & 0xffff;
            carry = dst << (16 - count);
        }
        this.setRotateResult(result, carry, X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnRCRd(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRCRd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;     // this 32-bit-only function could mask with 0x1f directly
    if (count) {
        let carry = this.getCarry();
        /*
         * JavaScript Alert: much like a post-8086 Intel CPU, JavaScript shift counts are mod 32,
         * so "dst << 32" is equivalent to "dst << 0", which doesn't shift any bits at all.  To
         * compensate, we shift one bit less than the maximum, and then shift one bit farther.
         */
        result = (dst >>> count) | (carry << (32 - count)) | ((dst << (32 - count)) << 1);
        carry = dst << (32 - count);
        this.setRotateResult(result, carry, X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnROLb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnROLb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry;
        count &= 0x7;
        if (!count) {
            carry = dst << 7;
        } else {
            carry = dst << (count - 1);
            result = ((dst << count) | (dst >> (8 - count))) & 0xff;
        }
        this.setRotateResult(result, carry, X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnROLw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnROLw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry;
        count &= 0xf;
        if (!count) {
            carry = dst << 15;
        } else {
            carry = dst << (count - 1);
            result = ((dst << count) | (dst >> (16 - count))) & 0xffff;
        }
        this.setRotateResult(result, carry, X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnROLd(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnROLd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = dst << (count - 1);
        result = (dst << count) | (dst >>> (32 - count));
        this.setRotateResult(result, carry, X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnRORb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRORb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry;
        count &= 0x7;
        if (!count) {
            carry = dst;
        } else {
            carry = dst << (8 - count);
            result = ((dst >>> count) | carry) & 0xff;
        }
        this.setRotateResult(result, carry, X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnRORw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRORw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry;
        count &= 0xf;
        if (!count) {
            carry = dst;
        } else {
            carry = dst << (16 - count);
            result = ((dst >>> count) | carry) & 0xffff;
        }
        this.setRotateResult(result, carry, X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnRORd(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @return {number}
 */
X86.fnRORd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = dst << (32 - count);
        result = (dst >>> count) | carry;
        this.setRotateResult(result, carry, X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnSARb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSARb = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        if (count > 9) count = 9;
        let carry = ((dst << 24) >> 24) >> (count - 1);
        dst = (carry >> 1) & 0xff;
        this.setLogicResult(dst, X86.RESULT.BYTE, carry & 0x1);
    }
    return dst;
};

/**
 * fnSARw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSARw = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        if (count > 17) count = 17;
        let carry = ((dst << 16) >> 16) >> (count - 1);
        dst = (carry >> 1) & 0xffff;
        this.setLogicResult(dst, X86.RESULT.WORD, carry & 0x1);
    }
    return dst;
};

/**
 * fnSARd(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSARd = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = dst >> (count - 1);
        dst = (carry >> 1);
        this.setLogicResult(dst, X86.RESULT.DWORD, carry & 0x1);
    }
    return dst;
};

/**
 * fnSBBb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSBBb = function(dst, src)
{
    let b = (dst - src - this.getCarry())|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b & 0xff;
};

/**
 * fnSBBw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSBBw = function(dst, src)
{
    let w = (dst - src - this.getCarry())|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return w & this.maskData;
};

/**
 * fnSETO(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETO = function(dst, src)
{
    return (this.getOF()? 1 : 0);
};

/**
 * fnSETNO(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETNO = function(dst, src)
{
    return (this.getOF()? 0 : 1);
};

/**
 * fnSETC(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETC = function(dst, src)
{
    return (this.getCF()? 1 : 0);
};

/**
 * fnSETNC(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETNC = function(dst, src)
{
    return (this.getCF()? 0 : 1);
};

/**
 * fnSETZ(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETZ = function(dst, src)
{
    return (this.getZF()? 1 : 0);
};

/**
 * fnSETNZ(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETNZ = function(dst, src)
{
    return (this.getZF()? 0 : 1);
};

/**
 * fnSETBE(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETBE = function(dst, src)
{
    return (this.getCF() || this.getZF()? 1 : 0);
};

/**
 * fnSETNBE(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETNBE = function(dst, src)
{
    return (this.getCF() || this.getZF()? 0 : 1);
};

/**
 * fnSETS(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETS = function(dst, src)
{
    return (this.getSF()? 1 : 0);
};

/**
 * fnSETNS(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETNS = function(dst, src)
{
    return (this.getSF()? 0 : 1);
};

/**
 * fnSETP(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETP = function(dst, src)
{
    return (this.getPF()? 1 : 0);
};

/**
 * fnSETNP(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETNP = function(dst, src)
{
    return (this.getPF()? 0 : 1);
};

/**
 * fnSETL(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETL = function(dst, src)
{
    return (!this.getSF() != !this.getOF()? 1 : 0);
};

/**
 * fnSETNL(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETNL = function(dst, src)
{
    return (!this.getSF() != !this.getOF()? 0 : 1);
};

/**
 * fnSETLE(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETLE = function(dst, src)
{
    return (this.getZF() || !this.getSF() != !this.getOF()? 1 : 0);
};

/**
 * fnSETNLE(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @return {number}
 */
X86.fnSETNLE = function(dst, src)
{
    return (this.getZF() || !this.getSF() != !this.getOF()? 0 : 1);
};

/**
 * fnSGDT(dst, src)
 *
 * op=0x0F,0x01,reg=0x0 (GRP7:SGDT)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnSGDT = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opInvalid.call(this);
    } else {
        /*
         * We don't need to set the first word of the operand, because the ModRM group decoder that calls us
         * does that automatically with the value we return (dst).
         */
        dst = this.addrGDTLimit - this.addrGDT;


        let addr = this.addrGDT;
        if (this.model == X86.MODEL_80286) {
            /*
             * We previously left the 6th byte of the target operand "undefined".  But it turns out we have to set
             * it to *something*, because there's processor detection in PC-DOS 7.0 (at least in the SETUP portion)
             * that looks like this:
             *
             *      145E:4B84 9C            PUSHF
             *      145E:4B85 55            PUSH     BP
             *      145E:4B86 8BEC          MOV      BP,SP
             *      145E:4B88 B80000        MOV      AX,0000
             *      145E:4B8B 50            PUSH     AX
             *      145E:4B8C 9D            POPF
             *      145E:4B8D 9C            PUSHF
             *      145E:4B8E 58            POP      AX
             *      145E:4B8F 2500F0        AND      AX,F000
             *      145E:4B92 3D00F0        CMP      AX,F000
             *      145E:4B95 7511          JNZ      4BA8
             *      145E:4BA8 C8060000      ENTER    0006,00
             *      145E:4BAC 0F0146FA      SGDT     [BP-06]
             *      145E:4BB0 807EFFFF      CMP      [BP-01],FF
             *      145E:4BB4 C9            LEAVE
             *      145E:4BB5 BA8603        MOV      DX,0386
             *      145E:4BB8 7503          JNZ      4BBD
             *      145E:4BBA BA8602        MOV      DX,0286
             *      145E:4BBD 89163004      MOV      [0430],DX
             *      145E:4BC1 5D            POP      BP
             *      145E:4BC2 9D            POPF
             *      145E:4BC3 CB            RETF
             *
             * This code is expecting SGDT on an 80286 to set the 6th "undefined" byte to 0xFF, so that's what we do.
             */
            addr |= (0xff000000|0);
        }
        else if (this.model >= X86.MODEL_80386) {
            /*
             * The 80386 added another wrinkle: Intel's documentation claimed that the 6th byte is either set to zero
             * or the high byte of the BASE field, depending on the OPERAND size; from the "INTEL 80386 PROGRAMMER'S
             * REFERENCE MANUAL 1986":
             *
             *      The LIMIT field of the [GDTR or IDTR] register is assigned to the first word at the effective address.
             *      If the operand-size attribute is 32 bits, the next three bytes are assigned the BASE field of the
             *      register, and the fourth byte is written with zero. The last byte is undefined. Otherwise, if the
             *      operand-size attribute is 16 bits, the next 4 bytes are assigned the 32-bit BASE field of the register.
             *
             * However, Intel obviously meant the reverse (ie, that the BASE field is truncated when using a 16-bit
             * OPERAND size, not when using a 32-bit OPERAND size).
             */
            if (this.sizeData == 2) {
                /*
                 * Thanks to Michal Necasek, we now know that the: "386 in reality does not pay attention to the operand
                 * size (despite Intel's claims to the contrary). In fact Windows 3.11/Win32s relies on it -- at least in
                 * some configurations, it will execute SGDT in 16-bit code and will crash if all 6 bytes aren't stored."
                 *
                 * Based on the above information, we no longer mask the 6th byte on the 80386 when the OPERAND size is 2.
                 *
                 *      addr &= 0x00ffffff;
                 */
            } else {
                /*
                 * When the OPERAND size is 4, our ModRM group decoder will call setLong(dst) rather than setShort(dst);
                 * we could fix that by calling setDataSize(2), but it seems safer/simpler to set the high bits (16-31)
                 * of dst to match the low bits (0-15) of addr, so that the caller will harmlessly rewrite what we are
                 * already writing with the setLong() below.
                 */
                dst |= (addr << 16);
            }
        }
        this.setLong(this.regEA + 2, addr);
        this.nStepCycles -= 11;
    }
    return dst;
};

/**
 * fnSHLb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSHLb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = 0;
        if (count > 8) {
            result = 0;
        } else {
            carry = dst << (count - 1);
            result = (carry << 1) & 0xff;
        }
        this.setLogicResult(result, X86.RESULT.BYTE, carry & X86.RESULT.BYTE, (result ^ carry) & X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnSHLw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSHLw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = 0;
        if (count > 16) {
            result = 0;
        } else {
            carry = dst << (count - 1);
            result = (carry << 1) & 0xffff;
        }
        this.setLogicResult(result, X86.RESULT.WORD, carry & X86.RESULT.WORD, (result ^ carry) & X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnSHLd(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSHLd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;     // this 32-bit-only function could mask with 0x1f directly
    if (count) {
        let carry = dst << (count - 1);
        result = (carry << 1);
        this.setLogicResult(result, X86.RESULT.DWORD, carry & X86.RESULT.DWORD, (result ^ carry) & X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnSHLDwi(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSHLDwi = function(dst, src)
{
    return X86.helpSHLDw.call(this, dst, src, this.getIPByte());
};

/**
 * fnSHLDdi(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSHLDdi = function(dst, src)
{
    return X86.helpSHLDd.call(this, dst, src, this.getIPByte());
};

/**
 * fnSHLDwCL(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSHLDwCL = function(dst, src)
{
    return X86.helpSHLDw.call(this, dst, src, this.regECX & 0x1f);
};

/**
 * fnSHLDdCL(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSHLDdCL = function(dst, src)
{
    return X86.helpSHLDd.call(this, dst, src, this.regECX & 0x1f);
};

/**
 * fnSHRb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSHRb = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = (count > 8? 0 : (dst >>> (count - 1)));
        dst = (carry >>> 1) & 0xff;
        this.setLogicResult(dst, X86.RESULT.BYTE, carry & 0x1, dst & X86.RESULT.BYTE);
    }
    return dst;
};

/**
 * fnSHRw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSHRw = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = (count > 16? 0 : (dst >>> (count - 1)));
        dst = (carry >>> 1) & 0xffff;
        this.setLogicResult(dst, X86.RESULT.WORD, carry & 0x1, dst & X86.RESULT.WORD);
    }
    return dst;
};

/**
 * fnSHRd(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @return {number}
 */
X86.fnSHRd = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = (dst >>> (count - 1));
        dst = (carry >>> 1);
        this.setLogicResult(dst, X86.RESULT.DWORD, carry & 0x1, dst & X86.RESULT.DWORD);
    }
    return dst;
};

/**
 * fnSHRDwi(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSHRDwi = function(dst, src)
{
    return X86.helpSHRDw.call(this, dst, src, this.getIPByte());
};

/**
 * fnSHRDdi(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSHRDdi = function(dst, src)
{
    return X86.helpSHRDd.call(this, dst, src, this.getIPByte());
};

/**
 * fnSHRDwCL(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSHRDwCL = function(dst, src)
{
    return X86.helpSHRDw.call(this, dst, src, this.regECX & 0x1f);
};

/**
 * fnSHRDdCL(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSHRDdCL = function(dst, src)
{
    return X86.helpSHRDd.call(this, dst, src, this.regECX & 0x1f);
};

/**
 * fnSIDT(dst, src)
 *
 * op=0x0F,0x01,reg=0x1 (GRP7:SIDT)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnSIDT = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opInvalid.call(this);
    } else {
        /*
         * We don't need to set the first word of the operand, because the ModRM group decoder that calls us
         * does that automatically with the value we return (dst).
         */
        dst = this.addrIDTLimit - this.addrIDT;

        /*
         * As with SGDT, the 6th byte is technically "undefined" on an 80286, but we now set it to 0xFF, for the
         * same reasons discussed in SGDT (above).
         */
        let addr = this.addrIDT;
        if (this.model == X86.MODEL_80286) {
            addr |= (0xff000000|0);
        }
        else if (this.model >= X86.MODEL_80386) {
            if (this.sizeData == 2) {
                /*
                 * Based on the SGDT information above, we no longer mask the 6th byte when the OPERAND size is 2.
                 *
                 *      addr &= 0x00ffffff;
                 */
            } else {
                dst |= (addr << 16);
            }
        }
        this.setLong(this.regEA + 2, addr);
        this.nStepCycles -= 12;
    }
    return dst;
};

/**
 * fnSLDT(dst, src)
 *
 * op=0x0F,0x00,reg=0x0 (GRP6:SLDT)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnSLDT = function(dst, src)
{
    this.nStepCycles -= (2 + (this.regEA === X86.ADDR_INVALID? 0 : 1));
    return this.segLDT.sel;
};

/**
 * fnSMSW(dst, src)
 *
 * TODO: I've seen a claim that SMSW can be used with an operand size override to obtain the entire CR0.
 * I don't dispute that, and since I don't mask the return value, that should be possible here; however, it
 * should still be confirmed on real hardware at some point.  Note that this differs from LMSW, which is
 * REQUIRED to mask the source operand.
 *
 * op=0x0F,0x01,reg=0x4 (GRP7:SMSW)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnSMSW = function(dst, src)
{
    this.nStepCycles -= (2 + (this.regEA === X86.ADDR_INVALID? 0 : 1));
    return this.regCR0;
};

/**
 * fnSTR(dst, src)
 *
 * op=0x0F,0x00,reg=0x1 (GRP6:STR)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnSTR = function(dst, src)
{
    this.nStepCycles -= (2 + (this.regEA === X86.ADDR_INVALID? 0 : 1));
    return this.segTSS.sel;
};

/**
 * fnSUBb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSUBb = function(dst, src)
{
    let b = (dst - src)|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b & 0xff;
};

/**
 * fnSUBw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnSUBw = function(dst, src)
{
    let w = (dst - src)|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return w & this.maskData;
};

/**
 * fnTESTib(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null; we have to supply the source ourselves)
 * @return {number}
 */
X86.fnTESTib = function(dst, src)
{
    src = this.getIPByte();
    this.setLogicResult(dst & src, X86.RESULT.BYTE);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesTestRI : this.cycleCounts.nOpCyclesTestMI);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnTESTiw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null; we have to supply the source ourselves)
 * @return {number}
 */
X86.fnTESTiw = function(dst, src)
{
    src = this.getIPWord();
    this.setLogicResult(dst & src, this.typeData);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesTestRI : this.cycleCounts.nOpCyclesTestMI);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnTESTb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnTESTb = function(dst, src)
{
    this.setLogicResult(dst & src, X86.RESULT.BYTE);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesTestRR : this.cycleCounts.nOpCyclesTestRM) : this.cycleCounts.nOpCyclesTestRM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnTESTw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnTESTw = function(dst, src)
{
    this.setLogicResult(dst & src, this.typeData);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesTestRR : this.cycleCounts.nOpCyclesTestRM) : this.cycleCounts.nOpCyclesTestRM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnVERR(dst, src)
 *
 * op=0x0F,0x00,reg=0x4 (GRP6:VERR)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnVERR = function(dst, src)
{
    this.opFlags |= X86.OPFLAG.NOWRITE;
    /*
     * Currently, segVER.load() will return an error only if the selector is beyond the bounds of the
     * descriptor table or the descriptor is not for a segment.
     */
    this.nStepCycles -= (14 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    if (this.segVER.load(dst) !== X86.ADDR_INVALID) {
        /*
         * Verify that this is a readable segment; that is, of these four combinations (code+readable,
         * code+nonreadable, data+writable, date+nonwritable), make sure we're not the second combination.
         */
        if ((this.segVER.acc & (X86.DESC.ACC.TYPE.READABLE | X86.DESC.ACC.TYPE.CODE)) != X86.DESC.ACC.TYPE.CODE) {
            /*
             * For VERR, if the code segment is readable and conforming, the descriptor privilege level
             * (DPL) can be any value.
             *
             * Otherwise, DPL must be greater than or equal to (have less or the same privilege as) both the
             * current privilege level and the selector's RPL.
             */
            if (this.segVER.dpl >= this.nCPL && this.segVER.dpl >= (dst & X86.SEL.RPL) ||
                (this.segVER.acc & X86.DESC.ACC.TYPE.CODE_CONFORMING) == X86.DESC.ACC.TYPE.CODE_CONFORMING) {
                this.setZF();
                return dst;
            }
        }
    }
    this.clearZF();
    if (DEBUG && (this.sizeData > 2 || this.sizeAddr > 2)) this.stopCPU();
    return dst;
};

/**
 * fnVERW(dst, src)
 *
 * op=0x0F,0x00,reg=0x5 (GRP6:VERW)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src (null)
 * @return {number}
 */
X86.fnVERW = function(dst, src)
{
    this.opFlags |= X86.OPFLAG.NOWRITE;
    /*
     * Currently, segVER.load() will return an error only if the selector is beyond the bounds of the
     * descriptor table or the descriptor is not for a segment.
     */
    this.nStepCycles -= (14 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    if (this.segVER.load(dst) !== X86.ADDR_INVALID) {
        /*
         * Verify that this is a writable data segment
         */
        if ((this.segVER.acc & (X86.DESC.ACC.TYPE.WRITABLE | X86.DESC.ACC.TYPE.CODE)) == X86.DESC.ACC.TYPE.WRITABLE) {
            /*
             * DPL must be greater than or equal to (have less or the same privilege as) both the current
             * privilege level and the selector's RPL.
             */
            if (this.segVER.dpl >= this.nCPL && this.segVER.dpl >= (dst & X86.SEL.RPL)) {
                this.setZF();
                return dst;
            }
        }
    }
    this.clearZF();
    if (DEBUG && (this.sizeData > 2 || this.sizeAddr > 2)) this.stopCPU();
    return dst;
};

/**
 * fnIBTS(dst, src)
 *
 * As best I can determine, this function copies the specified bits from src (starting at bit 0 for CL
 * bits) to dst (starting at bit offset in AX).  For register operands, that's simple enough.
 *
 * TODO: If dst refers to a memory location, then the bit index may refer to higher memory locations, just
 * like the BT/BTC/BTR/BTS instructions.  For an instruction that no one was really able to use, except
 * as a CPU stepping discriminator, that doesn't seem worth the effort.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnIBTS = function(dst, src)
{
    let shift = (this.regEAX & this.maskData);
    let mask = ((1 << (this.regECX & 0x1f)) - 1);
    return (dst & ~(mask << shift)) | ((src & mask) << shift);
};

/**
 * fnXBTS(dst, src)
 *
 * As best I can determine, this function copies the specified bits from src (starting at the bit offset
 * in AX, for the bit length in CL) to dst (starting at bit 0).  For register operands, that's simple enough.
 *
 * TODO: If src refers to a memory location, then the bit index may refer to higher memory locations, just
 * like the BT/BTC/BTR/BTS instructions.  For an instruction that no one was really able to use, except
 * as a CPU stepping discriminator, that doesn't seem worth the effort.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnXBTS = function(dst, src)
{
    /*
     * Shift src right by the bit offset in [E]AX, then apply a mask equal to the number of bits in CL,
     * then mask the resulting bit string with the current OPERAND size.
     */
    return ((src >> (this.regEAX & this.maskData)) & ((1 << (this.regECX & 0x1f)) - 1)) & this.maskData;
};

/**
 * fnXCHGrb(dst, src)
 *
 * If an instruction like "XCHG AL,AH" was a traditional "op dst,src" instruction, dst would contain AL,
 * src would contain AH, and we would return src, which the caller would then store in AL, and we'd be done.
 *
 * However, that's only half of what XCHG does, so THIS function must perform the other half; in the previous
 * example, that means storing the original AL (dst) into AH (src).
 *
 * BACKTRACK support is incomplete without also passing bti values as parameters, because the caller will
 * store btiAH in btiAL, but the original btiAL will be lost.  Similarly, if src is a memory operand, the
 * caller will store btiEALo in btiAL, but again, the original btiAL will be lost.
 *
 * BACKTRACK support for memory operands could be fixed by decoding the dst register in order to determine the
 * corresponding bti and then temporarily storing it in btiEALo around the setEAByte() call below.  Register-only
 * XCHGs would require a more extensive hack.  For now, I'm going to live with one-way BACKTRACK support here.
 *
 * TODO: Implement full BACKTRACK support for XCHG instructions.
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnXCHGrb = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        /*
         * Decode which register was src
         */

        switch (this.bModRM & 0x7) {
        case 0x0:       // AL
            this.regEAX = (this.regEAX & ~0xff) | dst;
            break;
        case 0x1:       // CL
            this.regECX = (this.regECX & ~0xff) | dst;
            break;
        case 0x2:       // DL
            this.regEDX = (this.regEDX & ~0xff) | dst;
            break;
        case 0x3:       // BL
            this.regEBX = (this.regEBX & ~0xff) | dst;
            break;
        case 0x4:       // AH
            this.regEAX = (this.regEAX & ~0xff00) | (dst << 8);
            break;
        case 0x5:       // CH
            this.regECX = (this.regECX & ~0xff00) | (dst << 8);
            break;
        case 0x6:       // DH
            this.regEDX = (this.regEDX & ~0xff00) | (dst << 8);
            break;
        case 0x7:       // BH
            this.regEBX = (this.regEBX & ~0xff00) | (dst << 8);
            break;
        default:
            break;      // there IS no other case, but JavaScript inspections don't know that
        }
        this.nStepCycles -= this.cycleCounts.nOpCyclesXchgRR;
    } else {
        /*
         * This is a case where the ModRM decoder that's calling us didn't know it should have set regEAWrite,
         * so we compensate by updating regEAWrite.  However, setEAWord() has since been changed to revalidate
         * the write using segEA:offEA, so updating regEAWrite here isn't strictly necessary.
         */
        this.regEAWrite = this.regEA;
        this.setEAByte(dst);
        this.nStepCycles -= this.cycleCounts.nOpCyclesXchgRM;
    }
    return src;
};

/**
 * fnXCHGrw(dst, src)
 *
 * If an instruction like "XCHG AX,DX" was a traditional "op dst,src" instruction, dst would contain AX,
 * src would contain DX, and we would return src, which the caller would then store in AX, and we'd be done.
 *
 * However, that's only half of what XCHG does, so THIS function must perform the other half; in the previous
 * example, that means storing the original AX (dst) into DX (src).
 *
 * TODO: Implement full BACKTRACK support for XCHG instructions (see fnXCHGrb comments).
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnXCHGrw = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        /*
         * Decode which register was src
         */

        switch (this.bModRM & 0x7) {
        case 0x0:       // [E]AX
            this.regEAX = (this.regEAX & ~this.maskData) | dst;
            break;
        case 0x1:       // [E]CX
            this.regECX = (this.regECX & ~this.maskData) | dst;
            break;
        case 0x2:       // [E]DX
            this.regEDX = (this.regEDX & ~this.maskData) | dst;
            break;
        case 0x3:       // [E]BX
            this.regEBX = (this.regEBX & ~this.maskData) | dst;
            break;
        case 0x4:       // [E]SP
            this.setSP((this.getSP() & ~this.maskData) | dst);
            break;
        case 0x5:       // [E]BP
            this.regEBP = (this.regEBX & ~this.maskData) | dst;
            break;
        case 0x6:       // [E]SI
            this.regESI = (this.regESI & ~this.maskData) | dst;
            break;
        case 0x7:       // [E]DI
            this.regEDI = (this.regEDI & ~this.maskData) | dst;
            break;
        default:
            break;      // there IS no other case, but JavaScript inspections don't know that
        }
        this.nStepCycles -= this.cycleCounts.nOpCyclesXchgRR;
    } else {
        /*
         * This is a case where the ModRM decoder that's calling us didn't know it should have set regEAWrite,
         * so we compensate by updating regEAWrite.  However, setEAWord() has since been changed to revalidate
         * the write using segEA:offEA, so updating regEAWrite here isn't strictly necessary.
         */
        this.regEAWrite = this.regEA;
        this.setEAWord(dst);
        this.nStepCycles -= this.cycleCounts.nOpCyclesXchgRM;
    }
    return src;
};

/**
 * fnXORb(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnXORb = function(dst, src)
{
    let b = dst ^ src;
    this.setLogicResult(b, X86.RESULT.BYTE);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b;
};

/**
 * fnXORw(dst, src)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @return {number}
 */
X86.fnXORw = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return this.setLogicResult(dst ^ src, this.typeData) & this.maskData;
};

/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/x86help.js (C) Jeff Parsons 2012-2018
 */


/**
 * helpAdd64(r64Dst, r64Src)
 *
 * Adds r64Src to r64Dst.
 *
 * @param {Array.<number>} r64Dst is a 64-bit value
 * @param {Array.<number>} r64Src is a 64-bit value
 */
X86.helpAdd64 = function(r64Dst, r64Src)
{
    r64Dst[0] += r64Src[0];
    r64Dst[1] += r64Src[1];
    if (r64Dst[0] > 0xffffffff) {
        r64Dst[0] >>>= 0;       // truncate r64Dst[0] to 32 bits AND keep it unsigned
        r64Dst[1]++;
    }
};

/**
 * helpCmp64(r64Dst, r64Src)
 *
 * Compares r64Dst to r64Src, by computing r64Dst - r64Src.
 *
 * @param {Array.<number>} r64Dst is a 64-bit value
 * @param {Array.<number>} r64Src is a 64-bit value
 * @return {number} > 0 if r64Dst > r64Src, == 0 if r64Dst == r64Src, < 0 if r64Dst < r64Src
 */
X86.helpCmp64 = function(r64Dst, r64Src)
{
    let result = r64Dst[1] - r64Src[1];
    if (!result) result = r64Dst[0] - r64Src[0];
    return result;
};

/**
 * helpSet64(r64Dst, lo, hi)
 *
 * @param {Array.<number>} r64Dst
 * @param {number} lo
 * @param {number} hi
 * @return {Array.<number>}
 */
X86.helpSet64 = function(r64Dst, lo, hi)
{
    r64Dst[0] = lo >>> 0;
    r64Dst[1] = hi >>> 0;
    return r64Dst;
};

/**
 * helpShr64(r64Dst)
 *
 * Shifts r64Dst right one bit.
 *
 * @param {Array.<number>} r64Dst is a 64-bit value
 */
X86.helpShr64 = function(r64Dst)
{
    r64Dst[0] >>>= 1;
    if (r64Dst[1] & 0x1) {
        r64Dst[0] = (r64Dst[0] | 0x80000000) >>> 0;
    }
    r64Dst[1] >>>= 1;
};

/**
 * helpSub64(r64Dst, r64Src)
 *
 * Subtracts r64Src from r64Dst.
 *
 * @param {Array.<number>} r64Dst is a 64-bit value
 * @param {Array.<number>} r64Src is a 64-bit value
 */
X86.helpSub64 = function(r64Dst, r64Src)
{
    r64Dst[0] -= r64Src[0];
    r64Dst[1] -= r64Src[1];
    if (r64Dst[0] < 0) {
        r64Dst[0] >>>= 0;       // truncate r64Dst[0] to 32 bits AND keep it unsigned
        r64Dst[1]--;
    }
};

/**
 * helpDECreg(w)
 *
 * @this {CPUX86}
 * @param {number} w
 * @return {number}
 */
X86.helpDECreg = function(w)
{
    let result = (w - 1)|0;
    this.setArithResult(w, 1, result, this.typeData | X86.RESULT.NOTCF, true);
    this.nStepCycles -= 2;                          // the register form of DEC takes 2 cycles on all CPUs
    return (w & ~this.maskData) | (result & this.maskData);
};

/**
 * helpDIV32(dstLo, dstHi, src)
 *
 * This sets regMDLo to dstHi:dstLo / src, and regMDHi to dstHi:dstLo % src; all inputs are treated as unsigned.
 *
 * Refer to: http://lxr.linux.no/linux+v2.6.22/lib/div64.c
 *
 * @this {CPUX86}
 * @param {number} dstLo (low 32-bit portion of dividend)
 * @param {number} dstHi (high 32-bit portion of dividend)
 * @param {number} src (32-bit divisor)
 * @return {boolean} true if successful, false if overflow (ie, the divisor was either zero or too small)
 */
X86.helpDIV32 = function(dstLo, dstHi, src)
{
    src >>>= 0;

    if (!src || src <= (dstHi >>> 0)) {
        return false;
    }

    let result = 0, bit = 1;

    let r64Div = X86.helpSet64(this.r64Div, src, 0);
    let r64Rem = X86.helpSet64(this.r64Rem, dstLo, dstHi);

    while (X86.helpCmp64(r64Rem, r64Div) > 0) {
        X86.helpAdd64(r64Div, r64Div);
        bit += bit;
    }
    do {
        if (X86.helpCmp64(r64Rem, r64Div) >= 0) {
            X86.helpSub64(r64Rem, r64Div);
            result += bit;
        }
        X86.helpShr64(r64Div);
        bit /= 2;
    } while (bit >= 1);



    this.regMDLo = result;      // result is the quotient, which callers expect in the low MD register
    this.regMDHi = r64Rem[0];   // r64Rem[0] is the remainder, which callers expect in the high MD register
    return true;
};

/**
 * helpIDIV32(dstLo, dstHi, src)
 *
 * This sets regMDLo to dstHi:dstLo / src, and regMDHi to dstHi:dstLo % src; all inputs are treated as signed.
 *
 * Refer to: http://lxr.linux.no/linux+v2.6.22/lib/div64.c
 *
 * @this {CPUX86}
 * @param {number} dstLo (low 32-bit portion of dividend)
 * @param {number} dstHi (high 32-bit portion of dividend)
 * @param {number} src (32-bit divisor)
 * @return {boolean} true if successful, false if overflow (ie, the divisor was either zero or too small)
 */
X86.helpIDIV32 = function(dstLo, dstHi, src)
{
    let bNegLo = 0, bNegHi = 0;
    /*
     *      dividend    divisor       quotient    remainder
     *        (dst)      (src)          (lo)         (hi)
     *      --------    -------       --------    ---------
     *         +           +     ->       +           +
     *         +           -     ->       -           +
     *         -           +     ->       -           -
     *         -           -     ->       +           -
     */
    if (src < 0) {
        src = -src|0;
        bNegLo = 1 - bNegLo;
    }
    if (dstHi < 0) {
        dstLo = -dstLo|0;
        dstHi = (~dstHi + (dstLo? 0 : 1))|0;
        bNegHi = 1;
        bNegLo = 1 - bNegLo;
    }
    if (!X86.helpDIV32.call(this, dstLo, dstHi, src) || this.regMDLo > 0x7fffffff+bNegLo || this.regMDHi > 0x7fffffff+bNegHi) {
        return false;
    }
    if (bNegLo) this.regMDLo = -this.regMDLo;
    if (bNegHi) this.regMDHi = -this.regMDHi;
    return true;
};

/**
 * helpINCreg(w)
 *
 * @this {CPUX86}
 * @param {number} w
 * @return {number}
 */
X86.helpINCreg = function(w)
{
    let result = (w + 1)|0;
    this.setArithResult(w, 1, result, this.typeData | X86.RESULT.NOTCF);
    this.nStepCycles -= 2;                          // the register form of INC takes 2 cycles on all CPUs
    return (w & ~this.maskData) | (result & this.maskData);
};

/**
 * helpLoadCR0(l)
 *
 * This is called by an 80386 control instruction (ie, MOV CR0,reg).
 *
 * @this {CPUX86}
 * @param {number} l
 */
X86.helpLoadCR0 = function(l)
{
    this.regCR0 = l | X86.CR0.ON;
    this.setProtMode();
    if (this.regCR0 & X86.CR0.PG) {
        /*
         * TODO: Determine if setting X86.CR0.PG when already set should really act as a flush;
         * I'm not currently worried about it, because I'm assuming CR0 is not rewritten that often.
         */
        this.enablePageBlocks();
    } else {
        this.disablePageBlocks();
    }
};

/**
 * helpLoadCR3(l)
 *
 * This is called by an 80386 control instruction (ie, MOV CR3,reg) or an 80386 task switch.
 *
 * @this {CPUX86}
 * @param {number} l
 */
X86.helpLoadCR3 = function(l)
{
    this.regCR3 = l;
    /*
     * Normal use of regCR3 involves adding a 0-4K (12-bit) offset to obtain a page directory entry,
     * so let's ensure that the low 12 bits of regCR3 are always zero.
     */

    this.flushPageBlocks();
};

/**
 * helpSETcc()
 *
 * @this {CPUX86}
 * @param {function(number,number)} fnSet
 */
X86.helpSETcc = function(fnSet)
{
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModMemByte.call(this, fnSet);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 4 : 5);
};

/**
 * helpSHLDw(dst, src, count)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @param {number} count (0-31)
 * @return {number}
 */
X86.helpSHLDw = function(dst, src, count)
{
    if (count) {
        if (count > 16) {
            dst = src;
            count -= 16;
        }
        let carry = dst << (count - 1);
        dst = ((carry << 1) | (src >>> (16 - count))) & 0xffff;
        this.setLogicResult(dst, X86.RESULT.WORD, carry & X86.RESULT.WORD);
    }
    return dst;
};

/**
 * helpSHLDd(dst, src, count)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @param {number} count
 * @return {number}
 */
X86.helpSHLDd = function(dst, src, count)
{
    if (count) {
        let carry = dst << (count - 1);
        dst = (carry << 1) | (src >>> (32 - count));
        this.setLogicResult(dst, X86.RESULT.DWORD, carry & X86.RESULT.DWORD);
    }
    return dst;
};

/**
 * helpSHRDw(dst, src, count)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @param {number} count (0-31)
 * @return {number}
 */
X86.helpSHRDw = function(dst, src, count)
{
    if (count) {
        if (count > 16) {
            dst = src;
            count -= 16;
        }
        let carry = dst >>> (count - 1);
        dst = ((carry >>> 1) | (src << (16 - count))) & 0xffff;
        this.setLogicResult(dst, X86.RESULT.WORD, carry & 0x1);
    }
    return dst;
};

/**
 * helpSHRDd(dst, src, count)
 *
 * @this {CPUX86}
 * @param {number} dst
 * @param {number} src
 * @param {number} count
 * @return {number}
 */
X86.helpSHRDd = function(dst, src, count)
{
    if (count) {
        let carry = dst >>> (count - 1);
        dst = (carry >>> 1) | (src << (32 - count));
        this.setLogicResult(dst, X86.RESULT.DWORD, carry & 0x1);
    }
    return dst;
};

/**
 * helpSRC1()
 *
 * @this {CPUX86}
 * @return {number}
 */
X86.helpSRC1 = function()
{
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 2 : this.cycleCounts.nOpCyclesShift1M);
    return 1;
};

/**
 * helpSRCCL()
 *
 * @this {CPUX86}
 * @return {number}
 */
X86.helpSRCCL = function()
{
    let count = this.regECX & 0xff;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesShiftCR : this.cycleCounts.nOpCyclesShiftCM) + (count << this.cycleCounts.nOpCyclesShiftCS);
    return count;
};

/**
 * helpSRCByte()
 *
 * @this {CPUX86}
 * @return {number}
 */
X86.helpSRCByte = function()
{
    let count = this.getIPByte();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesShiftCR : this.cycleCounts.nOpCyclesShiftCM) + (count << this.cycleCounts.nOpCyclesShiftCS);
    return count;
};

/**
 * helpSRCNone()
 *
 * @this {CPUX86}
 * @return {number|null}
 */
X86.helpSRCNone = function()
{
    return null;
};

/**
 * helpSRCxx()
 *
 * This is used by opPOPmw(), because the actual pop must occur BEFORE the effective address (EA)
 * calculation.  So opPOPmw() does the pop, saves the popped value in regXX, and this passes src function
 * to the EA worker.
 *
 * @this {CPUX86}
 * @return {number} regXX
 */
X86.helpSRCxx = function()
{
    return this.regXX;
};

/**
 * helpCALLF(off, sel)
 *
 * For protected-mode, this function must attempt to load the new code segment first, because if the new segment
 * requires a change in privilege level, the return address must be pushed on the NEW stack, not the current stack.
 *
 * Also, we rely on a new function, pushData(), instead of pushWord(), to accommodate the outgoing segment size,
 * which may differ from the incoming segment.  For example, when a 32-bit code segment performs a 16:32 call to a
 * 16-bit code segment, we must push 32-bit segment and offset values.
 *
 * TODO: Since setCSIP() already informs the segCS load() function when it's making a call, the load() function
 * could automatically push the old CS and IP values *before* segCS is updated -- which would be a better time to do
 * those pushes AND eliminate the need for pushData().  Unfortunately, load() is also used by loadIDT(), and loadIDT()
 * has different requirements (eg, pushing flags first), so it's not a trivial change.
 *
 * @this {CPUX86}
 * @param {number} off
 * @param {number} sel
 */
X86.helpCALLF = function(off, sel)
{
    /*
     * Since we always push the return address AFTER calling setCSIP(), and since either push could trigger
     * a fault (eg, segment fault, page fault, etc), we must not only snapshot regSS and regLSP, but also regCS,
     * so that helpFault() can always make CALLF restartable.
     */
    this.opCS = this.getCS();
    this.opSS = this.getSS();
    this.opLSP = this.regLSP;
    let oldIP = this.getIP();
    let oldSize = (I386? this.sizeData : 2);
    if (this.setCSIP(off, sel, true) != null) {
        /*
         * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
         * into the 2 lower bytes, and leave the 2 upper bytes untouched; at least, that's the case for all other
         * segment register writes, so we assume this case is no different.  Hence, the hard-coded size of 2.
         */
        this.pushData(this.opCS, oldSize, 2);
        this.pushData(oldIP, oldSize, oldSize);
    }
    this.opLSP = X86.ADDR_INVALID;
    this.opCS = this.opSS = -1;
};

/**
 * helpINT(nIDT, nError, nCycles)
 *
 * NOTE: We no longer use setCSIP(), because it always loads the new CS using segCS.load(), which only knows
 * how to load GDT and LDT descriptors, whereas interrupts must use setCS.loadIDT(), which deals exclusively
 * with IDT descriptors.
 *
 * @this {CPUX86}
 * @param {number} nIDT
 * @param {number|null} [nError]
 * @param {number} [nCycles] (in addition to the default of nOpCyclesInt)
 */
X86.helpINT = function(nIDT, nError, nCycles)
{
    /*
     * TODO: We assess the cycle cost up front, because otherwise, if loadIDT() fails, no cost may be assessed.
     */
    this.nStepCycles -= this.cycleCounts.nOpCyclesInt + (nCycles || 0);
    let oldPS = this.getPS();
    let oldCS = this.getCS();
    let oldIP = this.getIP();
    let addr = this.segCS.loadIDT(nIDT);
    if (addr !== X86.ADDR_INVALID) {
        /*
         * TODO: Determine if we should use pushData() instead of pushWord() for oldCS and nError, to deal with
         * the same 32-bit 80386 compatibility issue that helpCALLF(), opPUSHCS(), et al must deal with; namely, that
         * 32-bit segment register writes (and, reportedly, 32-bit error codes) don't modify the upper 16 bits.
         *
         * Also, note that helpCALLF() is using the OPERAND size in effect *before* CS is loaded, whereas here we're
         * using the OPERAND size in effect *after* CS is loaded.  Is that correct?  And does an explicit OPERAND
         * size override on an "INT" instruction have any effect on that behavior?  Is that even allowed?
         */
        this.pushWord(oldPS);
        this.pushWord(oldCS);
        this.pushWord(oldIP);
        if (nError != null) this.pushWord(nError);
        this.nFault = -1;
        this.setLIP(addr);
    }
};

/**
 * helpIRET()
 *
 * @this {CPUX86}
 */
X86.helpIRET = function()
{
    this.opSS = this.getSS();
    this.opLSP = this.regLSP;

    this.nStepCycles -= this.cycleCounts.nOpCyclesIRet;

    if ((this.regCR0 & X86.CR0.MSW.PE) && (this.regPS & X86.PS.NT)) {
        let addrNew = this.segTSS.base;
        /*
         * Fortunately, X86.TSS286.PREV_TSS and X86.TSS386.PREV_TSS refer to the same TSS offset.
         * TODO: Update switchTS() to assess a cycle cost; currently, all we assess is what's shown above.
         */
        let sel = this.getShort(addrNew + X86.TSS286.PREV_TSS);
        this.segCS.switchTSS(sel, false);
    }
    else {
        let cpl = this.nCPL;
        let newIP = this.popWord();
        let newCS = this.popWord();
        let newPS = this.popWord();

        if (I386) {
            if (this.regPS & X86.PS.VM) {
                /*
                 * On the 80386, in V86-mode, RF is the only defined EFLAGS bit above bit 15 that may be changed by IRETD.
                 * This is less restrictive than POPFD, which cannot change ANY bits above bit 15; see opPOPF() for details.
                 */
                newPS = (newPS & (0xffff | X86.PS.RF)) | (this.regPS & ~(0xffff | X86.PS.RF));
            }
            else {
                if (newPS & X86.PS.VM) {
                    /*
                     * As noted in loadDesc8(), where the V86-mode frame we're about to pop was originally pushed,
                     * these frames ALWAYS contain 32-bit values, so make sure that sizeData reflects that.
                     */

                    /*
                     * We have to assume that a full V86-mode interrupt frame was on the protected-mode stack; namely:
                     *
                     *      low:    EIP
                     *              CS (padded to 32 bits)
                     *              EFLAGS
                     *              ESP
                     *              SS (padded to 32 bits)
                     *              ES (padded to 32 bits)
                     *              DS (padded to 32 bits)
                     *              FS (padded to 32 bits)
                     *      high:   GS (padded to 32 bits)
                     *
                     * We've already popped EIP, CS, and EFLAGS into newIP, newCS and newPS, respectively, so we must now
                     * pop the rest, while we're still in protected-mode, before the switch to V86-mode alters the current
                     * operand size (among other things).
                     */
                    let newSP = this.popWord();
                    let newSS = this.popWord();
                    let newES = this.popWord();
                    let newDS = this.popWord();
                    let newFS = this.popWord();
                    let newGS = this.popWord();
                    this.setProtMode(true, true);       // flip the switch to V86-mode now
                    this.setSS(newSS);
                    this.setSP(newSP);
                    this.setES(newES);
                    this.setDS(newDS);
                    this.setFS(newFS);
                    this.setGS(newGS);
                }
            }
        }

        if (this.setCSIP(newIP, newCS, false) != null) {
            this.setPS(newPS, cpl);
            if (this.cIntReturn) this.checkIntReturn(this.regLIP);
        }
    }

    this.opLSP = X86.ADDR_INVALID;
    this.opSS = -1;
};

/**
 * helpRETF(n)
 *
 * For protected-mode, this function must pop any arguments off the current stack AND whatever stack
 * we may have switched to; setCSIP() returns true if a stack switch occurred, false if not, and null
 * if an error occurred.
 *
 * @this {CPUX86}
 * @param {number} n
 */
X86.helpRETF = function(n)
{
    this.opSS = this.getSS();
    this.opLSP = this.regLSP;

    let newIP = this.popWord();
    let newCS = this.popWord();

    if (n) this.setSP(this.getSP() + n);            // TODO: optimize

    if (this.setCSIP(newIP, newCS, false)) {        // returns true if a stack switch occurred
        /*
         * Fool me once, shame on... whatever.  If setCSIP() indicates a stack switch occurred,
         * make sure we're in protected mode, because automatic stack switches can't occur in real mode.
         */


        if (n) this.setSP(this.getSP() + n);        // TODO: optimize

        /*
         * As per Intel documentation: "If any of [the DS or ES] registers refer to segments whose DPL is
         * less than the new CPL (excluding conforming code segments), the segment register is loaded with
         * the null selector."
         *
         * TODO: I'm not clear on whether a conforming code segment must also be marked readable, so I'm playing
         * it safe and using CODE_CONFORMING instead of CODE_CONFORMING_READABLE.  Also, for the record, I've not
         * seen this situation occur yet (eg, in OS/2 1.0).
         */
        X86.zeroSeg.call(this, this.segDS);
        X86.zeroSeg.call(this, this.segES);
        if (I386 && this.model >= X86.MODEL_80386) {
            X86.zeroSeg.call(this, this.segFS);
            X86.zeroSeg.call(this, this.segGS);
        }
    }
    if (n == 2 && this.cIntReturn) this.checkIntReturn(this.regLIP);

    this.opLSP = X86.ADDR_INVALID;
    this.opSS = -1;
};

/**
 * helpDIVOverflow()
 *
 * @this {CPUX86}
 */
X86.helpDIVOverflow = function()
{
    /*
     * Divide error exceptions are traps on the 8086 and faults on later processors.  I question the value of that
     * change, because it implies that someone might actually want to restart a failing divide.  The only reasonable
     * explanation I can see for the change is to enable the exception handler to accurately record the address of
     * the failing divide, which seems like a very minor benefit.  It doesn't change the fact that, on any processor,
     * the exception handler's only reasonable recourse is to unwind execution to a safe point (or terminate the app).
     *
     * TODO: Determine the proper cycle cost.
     */
    if (this.model == X86.MODEL_8086) {
        X86.helpTrap.call(this, X86.EXCEPTION.DE_EXC, 2);
    } else {
        X86.helpFault.call(this, X86.EXCEPTION.DE_EXC, null, 2);
    }
};

/**
 * helpInterrupt(nIDT, nCycles)
 *
 * Helper to dispatch external interrupts.  nCycles defaults to 11 for the 8086/8088
 * if no alternate value is specified.
 *
 * @this {CPUX86}
 * @param {number} nIDT
 * @param {number} [nCycles] (number of cycles in addition to the default of nOpCyclesInt)
 */
X86.helpInterrupt = function(nIDT, nCycles)
{
    this.nFault = nIDT;
    if (nCycles === undefined) nCycles = 11;
    X86.helpINT.call(this, nIDT, null, nCycles);
};

/**
 * helpTrap(nIDT, nCycles)
 *
 * Helper to dispatch traps (ie, exceptions that occur AFTER the instruction, with NO error code)
 *
 * @this {CPUX86}
 * @param {number} nIDT
 * @param {number} [nCycles] (number of cycles in addition to the default of nOpCyclesInt)
 */
X86.helpTrap = function(nIDT, nCycles)
{
    this.nFault = -1;
    X86.helpINT.call(this, nIDT, null, nCycles);
};

/**
 * helpFault(nFault, nError, nCycles, fHalt)
 *
 * Helper to dispatch faults (ie, exceptions that occur DURING an instruction and MAY generate an error code)
 *
 * @this {CPUX86}
 * @param {number} nFault
 * @param {number|null} [nError] (if omitted, no error code will be pushed)
 * @param {number} [nCycles] cycle count to pass through to helpINT(), if any
 * @param {boolean} [fHalt] (true to halt the CPU, false to not, undefined if "it depends")
 */
X86.helpFault = function(nFault, nError, nCycles, fHalt)
{
    let fDispatch = false;

    if (!this.flags.complete) {
        /*
         * Prior to each new burst of instructions, stepCPU() sets fComplete to true, and the only (normal) way
         * for fComplete to become false is through stopCPU(), which isn't ordinarily called, except by the Debugger.
         */
        this.setLIP(this.opLIP);
    }
    else if (this.model >= X86.MODEL_80186) {

        fDispatch = true;

        if (this.nFault < 0) {
            /*
             * Single-fault (error code is passed through, and the responsible instruction is restartable.
             *
             * TODO: The following opCS/opLIP/opSS/opLSP checks are primarily required for 80386-based machines
             * with paging enabled, because page faults introduce a new set of complex faults that our current
             * segment load "probes" are insufficient to catch.  So as a stop-gap measure, we rely on these four
             * "snapshot" registers to resolve the general instruction restartability problem (for now).
             *
             * If you want to closely examine the underlying causes of these more complex faults, set breakpoints
             * where indicated below, and examine the stack trace.
             */
            if (this.opCS != -1) {
                if (this.opCS !== this.segCS.sel) {
                    /*
                     * HACK: We slam the RPL into this.segCS.cpl to ensure that loading the original CS segment doesn't
                     * fail.  For example, if we faulted in the middle of a ring transition that loaded CS with a higher
                     * privilege (lower CPL) code segment, then our attempt here to reload the lower privilege (higher CPL)
                     * code segment could be viewed as a privilege violation (which it would be outside this context).
                     */
                    this.segCS.cpl = this.opCS & 0x3;           // set breakpoint here to inspect complex faults
                    this.setCS(this.opCS);
                }
                this.opCS = -1;
            }
            if (this.opLIP !== this.regLIP) {
                this.setLIP(this.opLIP);                        // set breakpoint here to inspect complex faults

            }
            if (this.opSS != -1) {
                if (this.opSS !== this.segSS.sel) {
                    this.setSS(this.opSS);                      // set breakpoint here to inspect complex faults
                }
                this.opSS = -1;
            }
            if (this.opLSP !== X86.ADDR_INVALID) {
                if (this.opLSP !== this.regLSP) {               // set breakpoint below to inspect complex faults
                    this.setSP((this.regESP & ~this.segSS.maskAddr) | (this.opLSP - this.segSS.base));

                }
                this.opLSP = X86.ADDR_INVALID;
            }
        }
        else if (this.nFault != X86.EXCEPTION.DF_FAULT) {
            /*
             * Double-fault (error code is always zero, and the responsible instruction is not restartable).
             */
            nError = 0;
            nFault = X86.EXCEPTION.DF_FAULT;
        }
        else {
            /*
             * This is a triple-fault (usually referred to in Intel literature as a "shutdown", but it's actually a
             * "reset").  There's nothing to "dispatch" in this case, but we still want to let helpCheckFault() see
             * the triple-fault.  However, regardless what helpCheckFault() returns, we must leave via "throw -1",
             * because we need to blow off whatever context triggered the triple-fault; that was less critical when
             * all we dealt with were 80286-based triple-faults (at least the "normal" triple-faults that OS/2 would
             * generate), but for any other unexpected triple-faults, "dispatching" a throw is critical.
             */
            nError = 0;
            nFault = -1;
            fHalt = false;
            this.resetRegs();
        }
    }

    if (X86.helpCheckFault.call(this, nFault, nError, fHalt) || nFault < 0) {
        /*
         * If this is a fault that would normally be dispatched BUT helpCheckFault() wants us to halt,
         * then we throw a bogus fault number (-1), simply to interrupt the current instruction in exactly
         * the same way that a dispatched fault would interrupt it.
         */
        if (fDispatch) throw -1;
    }

    if (fDispatch) {

        this.nFault = nFault;
        X86.helpINT.call(this, nFault, nError, nCycles);

        /*
         * REP'eated instructions that rewind regLIP to opLIP used to screw up this dispatch,
         * so now we slip the new regLIP into opLIP, effectively turning their action into a no-op.
         */
        this.opLIP = this.regLIP;

        /*
         * X86.OPFLAG.FAULT flag is used by selected opcodes to provide an early exit, restore register(s),
         * or whatever is needed to help ensure instruction restartability; there is currently no general
         * mechanism for snapping and restoring all registers for any instruction that might fault.
         *
         * X86.EXCEPTION.DB_EXC exceptions set their own special flag, X86.OPFLAG.DBEXC, to prevent redundant
         * DEBUG exceptions, so we don't need to set OPFLAG.FAULT in that case, because a DEBUG exception
         * doesn't actually prevent an instruction from executing (and therefore doesn't need to be restarted).
         */
        if (nFault == X86.EXCEPTION.DB_EXC) {
            this.opFlags |= X86.OPFLAG.DBEXC;
        } else {

            this.opFlags |= X86.OPFLAG.FAULT;
        }

        /*
         * Since this fault is likely being issued in the context of an instruction that hasn't finished
         * executing, if we don't do anything to interrupt that execution (eg, throw a JavaScript exception),
         * then we would need to shut off all further reads/writes for the current instruction.
         *
         * That's easy for any EA-based memory accesses: simply set both the NOREAD and NOWRITE flags.
         * However, there are also direct, non-EA-based memory accesses to consider.  A perfect example is
         * opPUSHA(): if a GP fault occurs on any PUSH other than the last, a subsequent PUSH is likely to
         * cause another fault, which we will misinterpret as a double-fault -- unless the handler for
         * such an opcode checks this.opFlags for X86.OPFLAG.FAULT after each step of the operation.
         *
         *      this.opFlags |= (X86.OPFLAG.NOREAD | X86.OPFLAG.NOWRITE);
         *
         * Fortunately, we now throw an exception that terminates the current instruction, so the above hack
         * should no longer be necessary.
         */
        throw nFault;
    }
};

/**
 * helpPageFault(addr, fPresent, fWrite)
 *
 * Helper to dispatch page faults.
 *
 * @this {CPUX86}
 * @param {number} addr
 * @param {boolean} fPresent
 * @param {boolean} fWrite
 */
X86.helpPageFault = function(addr, fPresent, fWrite)
{
    this.regCR2 = addr;
    let nError = 0;
    if (fPresent) nError |= X86.PTE.PRESENT;
    if (fWrite) nError |= X86.PTE.READWRITE;
    if (this.nCPL == 3) nError |= X86.PTE.USER;
    X86.helpFault.call(this, X86.EXCEPTION.PF_FAULT, nError);
};

/**
 * helpCheckFault(nFault, nError, fHalt)
 *
 * Aside from giving the Debugger an opportunity to report every fault, this also gives us the ability to
 * halt exception processing in tracks: return true to prevent the fault handler from being dispatched.
 *
 * At the moment, the only Debugger control you have over fault interception is setting MESSAGE.FAULT, which
 * will display faults as they occur, and MESSAGE.HALT, which will halt after any Debugger message, including
 * MESSAGE.FAULT.  If you want execution to continue after halting, clear MESSAGE.FAULT and/or MESSAGE.HALT,
 * or single-step over the offending instruction, which will allow the fault to be dispatched.
 *
 * @this {CPUX86}
 * @param {number} nFault
 * @param {number|null} [nError] (if omitted, no error code will be reported)
 * @param {boolean} [fHalt] (true to halt the CPU, false to not, undefined if "it depends")
 * @return {boolean|undefined} true to block the fault (often desirable when fHalt is true), otherwise dispatch it
 */
X86.helpCheckFault = function(nFault, nError, fHalt)
{
    let bitsMessage = Messages.FAULT;

    let bOpcode = this.probeAddr(this.regLIP);

    /*
     * OS/2 1.0 uses an INT3 (0xCC) opcode in conjunction with an invalid IDT to trigger a triple-fault
     * reset and return to real-mode, and these resets happen quite frequently during boot; for example,
     * OS/2 startup messages are displayed using a series of INT 0x10 BIOS calls for each character, and
     * each series of BIOS calls requires a round-trip mode switch.
     *
     * Since we really only want to halt on "bad" faults, not "good" (ie, intentional) faults, we take
     * advantage of the fact that all 3 faults comprising the triple-fault point to an INT3 (0xCC) opcode,
     * and so whenever we see that opcode, we ignore the caller's fHalt flag, and suppress FAULT messages
     * unless CPU messages are also enabled.
     *
     * When a triple fault shows up, nFault is -1; it displays as 0xff only because we use toHexByte().
     */
    if (bOpcode == X86.OPCODE.INT3 && !this.addrIDTLimit) {
        fHalt = false;
    }

    /*
     * There are a number of V86-mode exceptions we don't need to know about.  For starters, Windows 3.00
     * (and other versions of enhanced-mode Windows) use an ARPL to switch out of V86-mode, so we can ignore
     * those UD_FAULTs.
     *
     * Ditto for software interrupts, which will generate a GP_FAULT when the interrupt number (eg, 0x6D)
     * exceeds the protected-mode IDT's limit (eg, a limit of 0x2FF corresponds to a maximum interrupt number
     * of 0x5F).  Windows doesn't really care if its IDT is too small, because it has to simulate all software
     * interrupts in V86-mode regardless (they generate a GP_FAULT if IOPL < 3, and even when IOPL == 3, only
     * the protected-mode IDT handler gets to run).
     */
    if (this.regPS & X86.PS.VM) {
        if (nFault == X86.EXCEPTION.UD_FAULT && bOpcode == X86.OPCODE.ARPL ||
            nFault == X86.EXCEPTION.GP_FAULT && bOpcode == X86.OPCODE.INTN) {
            fHalt = false;
        }
    }
    // else if (DEBUG && nFault == X86.EXCEPTION.GP_FAULT && fHalt === undefined) fHalt = true;

    /*
     * If fHalt has been explicitly set to false, we also take that as a cue to disable fault messages
     * (which you can override by turning on CPU messages).
     */
    if (fHalt === false) {
        bitsMessage |= Messages.CPU;
    }

    /*
     * Similarly, the PC AT ROM BIOS deliberately generates a couple of GP faults as part of the POST
     * (Power-On Self Test); we don't want to ignore those, but we don't want to halt on them either.  We
     * detect those faults by virtue of the LIP being in the range 0x0F0000 to 0x0FFFFF.
     *
     * TODO: Be aware that this test can trigger false positives, such as when a V86-mode ARPL is hit; eg:
     *
     *      &FD82:22F7 6338            ARPL     [BX+SI],DI
     */
    if (this.regLIP >= 0x0F0000 && this.regLIP <= 0x0FFFFF) {
        fHalt = false;
    }

    /*
     * However, the foregoing notwithstanding, if MESSAGE.HALT is enabled along with all the other required
     * MESSAGE bits, then we want to halt regardless.
     */
    if (this.messageEnabled(bitsMessage | Messages.HALT)) {
        fHalt = true;
    }

    if (this.messageEnabled(bitsMessage) || fHalt) {

        let fRunning = this.flags.running;
        let sMessage = "Fault " + Str.toHexByte(nFault) + (nError != null? " (" + Str.toHexWord(nError) + ")" : "") + " on opcode " + Str.toHexByte(bOpcode);
        if (fHalt && fRunning) sMessage += " (blocked)";

        if (DEBUGGER && this.dbg) {
            this.printMessage(sMessage, fHalt || bitsMessage, true);
            if (fHalt) {
                /*
                 * By setting fHalt to fRunning (which is true while running but false while single-stepping),
                 * this allows a fault to be dispatched when you single-step over a faulting instruction; you can
                 * then continue single-stepping into the fault handler, or start running again.
                 *
                 * Note that we had to capture fRunning before calling printMessage(), because if MESSAGE.HALT
                 * is set, printMessage() will have already halted the CPU.
                 */
                fHalt = fRunning;
                this.dbg.stopCPU();
            }
        } else {
            /*
             * If there's no Debugger, then messageEnabled() must have returned false, which means that fHalt must
             * be true.  Which means we should shut the machine down.
             */

            this.notice(sMessage);
            this.stopCPU();
        }
    }
    return fHalt;
};

/**
 * zeroSeg(seg)
 *
 * Helper to zero a segment register whenever transitioning to a less privileged (numerically higher) level.
 *
 * @this {CPUX86}
 * @param {SegX86} seg
 */
X86.zeroSeg = function(seg)
{
    let acc = seg.acc & X86.DESC.ACC.TYPE.CODE_OR_DATA;
    if (seg.sel & X86.SEL.MASK) {
        if (acc == X86.DESC.ACC.TYPE.CODE_EXECONLY ||           // non-readable code segment (not allowed)
            acc == X86.DESC.ACC.TYPE.CODE_CONFORMING ||         // non-readable code segment (not allowed)
            acc < X86.DESC.ACC.TYPE.CODE_CONFORMING && seg.dpl < this.nCPL && seg.dpl < (seg.sel & X86.SEL.RPL)) {
            seg.load(0);
        }
    }
};

/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/x86mods.js (C) Jeff Parsons 2012-2018
 */


/*
 * Before 80386 support was added to PCx86, the approach to decoding ModRegRM bytes (which I usually
 * just call ModRM bytes) used one generated function per ModRM value.  This was optimal for 16-bit processors,
 * because the functions were small, and it was maximally efficient, turning the entire ModRM decoding operation
 * into one table lookup and function call.
 *
 * However, that approach didn't scale well for 32-bit processors, which had extended ModRM capabilities in both
 * the addressing mode dimension and the operand size dimension.  So I've rewritten ModRM decoding as 18 functions.
 * The first 9 are for 16-bit addressing modes, and the second 9 are for 32-bit addressing modes.  Within each
 * group of 9, there are 3 for 8-bit operands, 3 for 16-bit operands, and 3 for 32-bit operands.  And each group of 3
 * contains functions for register-source, memory-source, and group-source.
 *
 * Each of the 18 functions must do additional work to examine the ModRM bits, which makes decoding slightly slower,
 * but it's not really noticeable, and the speed difference didn't justify the additional generated code.  So one much
 * smaller file (x86mods.js) replaces a host of older files (x86modb.js, x86modw.js, x86modb16.js, x86modw16.js,
 * x86modb32.js, x86modw32.js, and x86modsib.js).
 *
 * You can dig up the older files from the repository if you're curious, or you can run /modules/pcx86/bin/x86gen.js to
 * get a sense of what they contained (x86gen.js created most of the code, but it still had to be massaged afterward).
 */

/**
 * modRegByte16(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegByte16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEAByteData(this.regEBX + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
        src = this.getEAByteData(this.regEBX + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x02:
        src = this.getEAByteStack(this.regEBP + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x03:
        src = this.getEAByteStack(this.regEBP + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x04:
        src = this.getEAByteData(this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x05:
        src = this.getEAByteData(this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        src = this.getEAByteData(this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x07:
        src = this.getEAByteData(this.regEBX);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x40:
        src = this.getEAByteData(this.regEBX + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
        src = this.getEAByteData(this.regEBX + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x42:
        src = this.getEAByteStack(this.regEBP + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x43:
        src = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x44:
        src = this.getEAByteData(this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x45:
        src = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x46:
        src = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x47:
        src = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x80:
        src = this.getEAByteData(this.regEBX + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x81:
        src = this.getEAByteData(this.regEBX + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x82:
        src = this.getEAByteStack(this.regEBP + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x83:
        src = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x84:
        src = this.getEAByteData(this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x85:
        src = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x86:
        src = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x87:
        src = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        src = this.regEAX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAL;
        break;
    case 0xC1:
        src = this.regECX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCL;
        break;
    case 0xC2:
        src = this.regEDX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDL;
        break;
    case 0xC3:
        src = this.regEBX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBL;
        break;
    case 0xC4:
        src = (this.regEAX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAH;
        break;
    case 0xC5:
        src = (this.regECX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCH;
        break;
    case 0xC6:
        src = (this.regEDX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDH;
        break;
    case 0xC7:
        src = (this.regEBX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBH;
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX & 0xff;
        break;
    case 0x1:
        dst = this.regECX & 0xff;
        break;
    case 0x2:
        dst = this.regEDX & 0xff;
        break;
    case 0x3:
        dst = this.regEBX & 0xff;
        break;
    case 0x4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0x5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0x6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0x7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;
        break;
    }

    let b = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiEALo;
        break;
    case 0x1:
        this.regECX = (this.regECX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiEALo;
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiEALo;
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiEALo;
        break;
    case 0x4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiEALo;
        break;
    case 0x5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiEALo;
        break;
    case 0x6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiEALo;
        break;
    case 0x7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiEALo;
        break;
    }
};

/**
 * modMemByte16(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemByte16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAByteData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAByteData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAByteStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAByteStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAByteData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAByteData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAByteData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAByteData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAByteData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAByteData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAByteStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAByteData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAByteData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAByteData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAByteStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAByteData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xff;
        break;
    case 0xC1:
        dst = this.regECX & 0xff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xff;
        break;
    case 0xC4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0xC5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0xC6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0xC7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAL;
        break;
    case 0x1:
        src = this.regECX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCL;
        break;
    case 0x2:
        src = this.regEDX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDL;
        break;
    case 0x3:
        src = this.regEBX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBL;
        break;
    case 0x4:
        src = (this.regEAX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAH;
        break;
    case 0x5:
        src = (this.regECX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCH;
        break;
    case 0x6:
        src = (this.regEDX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDH;
        break;
    case 0x7:
        src = (this.regEBX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBH;
        break;
    default:
        src = 0;
        break;
    }

    let b = fn.call(this, dst, src);

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiEALo;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiEALo;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiEALo;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiEALo;
        break;
    case 0xC4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiEALo;
        break;
    case 0xC5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiEALo;
        break;
    case 0xC6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiEALo;
        break;
    case 0xC7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiEALo;
        break;
    default:

        break;
    }
};

/**
 * modGrpByte16(afnGrp, fnSrc)
 *
 * @this {CPUX86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpByte16 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAByteData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAByteData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAByteStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAByteStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAByteData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAByteData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAByteData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAByteData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAByteData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAByteData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAByteStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAByteData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAByteData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAByteData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAByteStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAByteData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xff;
        break;
    case 0xC1:
        dst = this.regECX & 0xff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xff;
        break;
    case 0xC4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0xC5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0xC6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0xC7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let b = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xff) | b;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        break;
    case 0xC4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        break;
    case 0xC5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        break;
    case 0xC6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        break;
    case 0xC7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        break;
    }
};

/**
 * modRegShort16(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegShort16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEAShortData(this.regEBX + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
        src = this.getEAShortData(this.regEBX + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x02:
        src = this.getEAShortStack(this.regEBP + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x03:
        src = this.getEAShortStack(this.regEBP + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x04:
        src = this.getEAShortData(this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x05:
        src = this.getEAShortData(this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        src = this.getEAShortData(this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x07:
        src = this.getEAShortData(this.regEBX);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x40:
        src = this.getEAShortData(this.regEBX + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
        src = this.getEAShortData(this.regEBX + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x42:
        src = this.getEAShortStack(this.regEBP + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x43:
        src = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x44:
        src = this.getEAShortData(this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x45:
        src = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x46:
        src = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x47:
        src = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x80:
        src = this.getEAShortData(this.regEBX + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x81:
        src = this.getEAShortData(this.regEBX + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x82:
        src = this.getEAShortStack(this.regEBP + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x83:
        src = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x84:
        src = this.getEAShortData(this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x85:
        src = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x86:
        src = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x87:
        src = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        src = this.regEAX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0xC1:
        src = this.regECX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0xC2:
        src = this.regEDX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0xC3:
        src = this.regEBX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0xC4:
        src = this.getSP() & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0xC5:
        src = this.regEBP & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0xC6:
        src = this.regESI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0xC7:
        src = this.regEDI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX & 0xffff;
        break;
    case 0x1:
        dst = this.regECX & 0xffff;
        break;
    case 0x2:
        dst = this.regEDX & 0xffff;
        break;
    case 0x3:
        dst = this.regEBX & 0xffff;
        break;
    case 0x4:
        dst = this.getSP() & 0xffff;
        break;
    case 0x5:
        dst = this.regEBP & 0xffff;
        break;
    case 0x6:
        dst = this.regESI & 0xffff;
        break;
    case 0x7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;
        break;
    }

    let w = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0x1:
        this.regECX = (this.regECX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0x4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0x5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x6:
        this.regESI = (this.regESI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    }
};

/**
 * modMemShort16(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemShort16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAShortData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAShortData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAShortStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAShortStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAShortData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAShortData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAShortData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAShortData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAShortData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAShortData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAShortStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAShortData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAShortData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAShortData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAShortStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAShortData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xffff;
        break;
    case 0xC1:
        dst = this.regECX & 0xffff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xffff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xffff;
        break;
    case 0xC4:
        dst = this.getSP() & 0xffff;
        break;
    case 0xC5:
        dst = this.regEBP & 0xffff;
        break;
    case 0xC6:
        dst = this.regESI & 0xffff;
        break;
    case 0xC7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0x1:
        src = this.regECX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0x2:
        src = this.regEDX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0x3:
        src = this.regEBX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0x4:
        src = this.getSP() & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0x5:
        src = this.regEBP & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0x6:
        src = this.regESI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0x7:
        src = this.regEDI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;
        break;
    }

    let w = fn.call(this, dst, src);

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0xC5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC6:
        this.regESI = (this.regESI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    default:

        break;
    }
};

/**
 * modGrpShort16(afnGrp, fnSrc)
 *
 * @this {CPUX86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpShort16 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAShortData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAShortData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAShortStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAShortStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAShortData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAShortData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAShortData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAShortData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAShortData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAShortData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAShortStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAShortData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAShortData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAShortData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAShortStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAShortData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xffff;
        break;
    case 0xC1:
        dst = this.regECX & 0xffff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xffff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xffff;
        break;
    case 0xC4:
        dst = this.getSP() & 0xffff;
        break;
    case 0xC5:
        dst = this.regEBP & 0xffff;
        break;
    case 0xC6:
        dst = this.regESI & 0xffff;
        break;
    case 0xC7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let w = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xffff) | w;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        break;
    case 0xC4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0xC5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        break;
    case 0xC6:
        this.regESI = (this.regESI & ~0xffff) | w;
        break;
    case 0xC7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        break;
    }
};

/**
 * modRegLong16(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegLong16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEALongData(this.regEBX + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
        src = this.getEALongData(this.regEBX + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x02:
        src = this.getEALongStack(this.regEBP + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x03:
        src = this.getEALongStack(this.regEBP + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x04:
        src = this.getEALongData(this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x05:
        src = this.getEALongData(this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        src = this.getEALongData(this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x07:
        src = this.getEALongData(this.regEBX);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x40:
        src = this.getEALongData(this.regEBX + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
        src = this.getEALongData(this.regEBX + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x42:
        src = this.getEALongStack(this.regEBP + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x43:
        src = this.getEALongStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x44:
        src = this.getEALongData(this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x45:
        src = this.getEALongData(this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x46:
        src = this.getEALongStack(this.regEBP + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x47:
        src = this.getEALongData(this.regEBX + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x80:
        src = this.getEALongData(this.regEBX + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x81:
        src = this.getEALongData(this.regEBX + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x82:
        src = this.getEALongStack(this.regEBP + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x83:
        src = this.getEALongStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x84:
        src = this.getEALongData(this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x85:
        src = this.getEALongData(this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x86:
        src = this.getEALongStack(this.regEBP + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x87:
        src = this.getEALongData(this.regEBX + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        src = this.regEAX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0xC1:
        src = this.regECX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0xC2:
        src = this.regEDX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0xC3:
        src = this.regEBX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0xC4:
        src = this.getSP();
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0xC5:
        src = this.regEBP;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0xC6:
        src = this.regESI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0xC7:
        src = this.regEDI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX;
        break;
    case 0x1:
        dst = this.regECX;
        break;
    case 0x2:
        dst = this.regEDX;
        break;
    case 0x3:
        dst = this.regEBX;
        break;
    case 0x4:
        dst = this.getSP();
        break;
    case 0x5:
        dst = this.regEBP;
        break;
    case 0x6:
        dst = this.regESI;
        break;
    case 0x7:
        dst = this.regEDI;
        break;
    default:
        dst = 0;
        break;
    }

    let l = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = l;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0x1:
        this.regECX = l;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0x2:
        this.regEDX = l;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0x3:
        this.regEBX = l;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0x4:
        this.setSP(l);
        break;
    case 0x5:
        this.regEBP = l;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x6:
        this.regESI = l;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x7:
        this.regEDI = l;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    }
};

/**
 * modMemLong16(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemLong16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEALongData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEALongData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEALongStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEALongStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEALongData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEALongData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEALongData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEALongData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEALongData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEALongData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEALongStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEALongStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEALongData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEALongData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEALongStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEALongData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEALongData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEALongData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEALongStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEALongStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEALongData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEALongData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEALongStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEALongData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX;
        break;
    case 0xC1:
        dst = this.regECX;
        break;
    case 0xC2:
        dst = this.regEDX;
        break;
    case 0xC3:
        dst = this.regEBX;
        break;
    case 0xC4:
        dst = this.getSP();
        break;
    case 0xC5:
        dst = this.regEBP;
        break;
    case 0xC6:
        dst = this.regESI;
        break;
    case 0xC7:
        dst = this.regEDI;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0x1:
        src = this.regECX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0x2:
        src = this.regEDX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0x3:
        src = this.regEBX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0x4:
        src = this.getSP();
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0x5:
        src = this.regEBP;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0x6:
        src = this.regESI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0x7:
        src = this.regEDI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;
        break;
    }

    let l = fn.call(this, dst, src);

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = l;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC1:
        this.regECX = l;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC2:
        this.regEDX = l;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC3:
        this.regEBX = l;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC4:
        this.setSP(l);
        break;
    case 0xC5:
        this.regEBP = l;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC6:
        this.regESI = l;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC7:
        this.regEDI = l;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    default:

        break;
    }
};

/**
 * modGrpLong16(afnGrp, fnSrc)
 *
 * @this {CPUX86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpLong16 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEALongData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEALongData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEALongStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEALongStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEALongData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEALongData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEALongData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEALongData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEALongData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEALongData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEALongStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEALongStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEALongData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEALongData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEALongStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEALongData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEALongData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEALongData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEALongStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEALongStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEALongData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEALongData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEALongStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEALongData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX;
        break;
    case 0xC1:
        dst = this.regECX;
        break;
    case 0xC2:
        dst = this.regEDX;
        break;
    case 0xC3:
        dst = this.regEBX;
        break;
    case 0xC4:
        dst = this.getSP();
        break;
    case 0xC5:
        dst = this.regEBP;
        break;
    case 0xC6:
        dst = this.regESI;
        break;
    case 0xC7:
        dst = this.regEDI;
        break;
    default:

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let l = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = l;
        break;
    case 0xC1:
        this.regECX = l;
        break;
    case 0xC2:
        this.regEDX = l;
        break;
    case 0xC3:
        this.regEBX = l;
        break;
    case 0xC4:
        this.setSP(l);
        break;
    case 0xC5:
        this.regEBP = l;
        break;
    case 0xC6:
        this.regESI = l;
        break;
    case 0xC7:
        this.regEDI = l;
        break;
    }
};

/**
 * modRegByte32(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegByte32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEAByteData(this.regEAX);
        break;
    case 0x01:
        src = this.getEAByteData(this.regECX);
        break;
    case 0x02:
        src = this.getEAByteData(this.regEDX);
        break;
    case 0x03:
        src = this.getEAByteData(this.regEBX);
        break;
    case 0x04:
        src = this.getEAByteData(X86.modSIB.call(this, 0));
        break;
    case 0x05:
        src = this.getEAByteData(this.getIPAddr());
        break;
    case 0x06:
        src = this.getEAByteData(this.regESI);
        break;
    case 0x07:
        src = this.getEAByteData(this.regEDI);
        break;
    case 0x40:
        src = this.getEAByteData(this.regEAX + this.getIPDisp());
        break;
    case 0x41:
        src = this.getEAByteData(this.regECX + this.getIPDisp());
        break;
    case 0x42:
        src = this.getEAByteData(this.regEDX + this.getIPDisp());
        break;
    case 0x43:
        src = this.getEAByteData(this.regEBX + this.getIPDisp());
        break;
    case 0x44:
        src = this.getEAByteData(X86.modSIB.call(this, 1) + this.getIPDisp());
        break;
    case 0x45:
        src = this.getEAByteStack(this.regEBP + this.getIPDisp());
        break;
    case 0x46:
        src = this.getEAByteData(this.regESI + this.getIPDisp());
        break;
    case 0x47:
        src = this.getEAByteData(this.regEDI + this.getIPDisp());
        break;
    case 0x80:
        src = this.getEAByteData(this.regEAX + this.getIPAddr());
        break;
    case 0x81:
        src = this.getEAByteData(this.regECX + this.getIPAddr());
        break;
    case 0x82:
        src = this.getEAByteData(this.regEDX + this.getIPAddr());
        break;
    case 0x83:
        src = this.getEAByteData(this.regEBX + this.getIPAddr());
        break;
    case 0x84:
        src = this.getEAByteData(X86.modSIB.call(this, 2) + this.getIPAddr());
        break;
    case 0x85:
        src = this.getEAByteStack(this.regEBP + this.getIPAddr());
        break;
    case 0x86:
        src = this.getEAByteData(this.regESI + this.getIPAddr());
        break;
    case 0x87:
        src = this.getEAByteData(this.regEDI + this.getIPAddr());
        break;
    case 0xC0:
        src = this.regEAX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAL;
        break;
    case 0xC1:
        src = this.regECX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCL;
        break;
    case 0xC2:
        src = this.regEDX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDL;
        break;
    case 0xC3:
        src = this.regEBX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBL;
        break;
    case 0xC4:
        src = (this.regEAX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAH;
        break;
    case 0xC5:
        src = (this.regECX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCH;
        break;
    case 0xC6:
        src = (this.regEDX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDH;
        break;
    case 0xC7:
        src = (this.regEBX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBH;
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX & 0xff;
        break;
    case 0x1:
        dst = this.regECX & 0xff;
        break;
    case 0x2:
        dst = this.regEDX & 0xff;
        break;
    case 0x3:
        dst = this.regEBX & 0xff;
        break;
    case 0x4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0x5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0x6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0x7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;
        break;
    }

    let b = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiEALo;
        break;
    case 0x1:
        this.regECX = (this.regECX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiEALo;
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiEALo;
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiEALo;
        break;
    case 0x4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiEALo;
        break;
    case 0x5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiEALo;
        break;
    case 0x6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiEALo;
        break;
    case 0x7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiEALo;
        break;
    }
};

/**
 * modMemByte32(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemByte32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAByteData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAByteData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAByteData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAByteData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAByteData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAByteData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAByteData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAByteData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAByteData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAByteData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAByteData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAByteData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAByteData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAByteData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAByteData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAByteData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAByteData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAByteData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xff;
        break;
    case 0xC1:
        dst = this.regECX & 0xff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xff;
        break;
    case 0xC4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0xC5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0xC6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0xC7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAL;
        break;
    case 0x1:
        src = this.regECX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCL;
        break;
    case 0x2:
        src = this.regEDX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDL;
        break;
    case 0x3:
        src = this.regEBX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBL;
        break;
    case 0x4:
        src = (this.regEAX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAH;
        break;
    case 0x5:
        src = (this.regECX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCH;
        break;
    case 0x6:
        src = (this.regEDX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDH;
        break;
    case 0x7:
        src = (this.regEBX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBH;
        break;
    default:
        src = 0;
        break;
    }

    let b = fn.call(this, dst, src);

    switch(bModRM) {
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiEALo;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiEALo;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiEALo;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiEALo;
        break;
    case 0xC4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiEALo;
        break;
    case 0xC5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiEALo;
        break;
    case 0xC6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiEALo;
        break;
    case 0xC7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiEALo;
        break;
    default:
        this.setEAByte(b);
        break;
    }
};

/**
 * modGrpByte32(afnGrp, fnSrc)
 *
 * @this {CPUX86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpByte32 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAByteData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAByteData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAByteData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAByteData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAByteData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAByteData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAByteData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAByteData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAByteData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAByteData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAByteData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAByteData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAByteData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAByteData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAByteData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAByteData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAByteData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAByteData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xff;
        break;
    case 0xC1:
        dst = this.regECX & 0xff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xff;
        break;
    case 0xC4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0xC5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0xC6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0xC7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let b = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xff) | b;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        break;
    case 0xC4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        break;
    case 0xC5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        break;
    case 0xC6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        break;
    case 0xC7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        break;
    default:
        this.setEAByte(b);
        break;
    }
};

/**
 * modRegShort32(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegShort32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEAShortData(this.regEAX);
        break;
    case 0x01:
        src = this.getEAShortData(this.regECX);
        break;
    case 0x02:
        src = this.getEAShortData(this.regEDX);
        break;
    case 0x03:
        src = this.getEAShortData(this.regEBX);
        break;
    case 0x04:
        src = this.getEAShortData(X86.modSIB.call(this, 0));
        break;
    case 0x05:
        src = this.getEAShortData(this.getIPAddr());
        break;
    case 0x06:
        src = this.getEAShortData(this.regESI);
        break;
    case 0x07:
        src = this.getEAShortData(this.regEDI);
        break;
    case 0x40:
        src = this.getEAShortData(this.regEAX + this.getIPDisp());
        break;
    case 0x41:
        src = this.getEAShortData(this.regECX + this.getIPDisp());
        break;
    case 0x42:
        src = this.getEAShortData(this.regEDX + this.getIPDisp());
        break;
    case 0x43:
        src = this.getEAShortData(this.regEBX + this.getIPDisp());
        break;
    case 0x44:
        src = this.getEAShortData(X86.modSIB.call(this, 1) + this.getIPDisp());
        break;
    case 0x45:
        src = this.getEAShortStack(this.regEBP + this.getIPDisp());
        break;
    case 0x46:
        src = this.getEAShortData(this.regESI + this.getIPDisp());
        break;
    case 0x47:
        src = this.getEAShortData(this.regEDI + this.getIPDisp());
        break;
    case 0x80:
        src = this.getEAShortData(this.regEAX + this.getIPAddr());
        break;
    case 0x81:
        src = this.getEAShortData(this.regECX + this.getIPAddr());
        break;
    case 0x82:
        src = this.getEAShortData(this.regEDX + this.getIPAddr());
        break;
    case 0x83:
        src = this.getEAShortData(this.regEBX + this.getIPAddr());
        break;
    case 0x84:
        src = this.getEAShortData(X86.modSIB.call(this, 2) + this.getIPAddr());
        break;
    case 0x85:
        src = this.getEAShortStack(this.regEBP + this.getIPAddr());
        break;
    case 0x86:
        src = this.getEAShortData(this.regESI + this.getIPAddr());
        break;
    case 0x87:
        src = this.getEAShortData(this.regEDI + this.getIPAddr());
        break;
    case 0xC0:
        src = this.regEAX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0xC1:
        src = this.regECX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0xC2:
        src = this.regEDX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0xC3:
        src = this.regEBX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0xC4:
        src = this.getSP() & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0xC5:
        src = this.regEBP & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0xC6:
        src = this.regESI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0xC7:
        src = this.regEDI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX & 0xffff;
        break;
    case 0x1:
        dst = this.regECX & 0xffff;
        break;
    case 0x2:
        dst = this.regEDX & 0xffff;
        break;
    case 0x3:
        dst = this.regEBX & 0xffff;
        break;
    case 0x4:
        dst = this.getSP() & 0xffff;
        break;
    case 0x5:
        dst = this.regEBP & 0xffff;
        break;
    case 0x6:
        dst = this.regESI & 0xffff;
        break;
    case 0x7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;
        break;
    }

    let w = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0x1:
        this.regECX = (this.regECX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0x4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0x5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x6:
        this.regESI = (this.regESI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    }
};

/**
 * modMemShort32(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemShort32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAShortData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAShortData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAShortData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAShortData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAShortData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAShortData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAShortData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAShortData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAShortData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAShortData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAShortData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAShortData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAShortData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAShortData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAShortData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAShortData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAShortData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAShortData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xffff;
        break;
    case 0xC1:
        dst = this.regECX & 0xffff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xffff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xffff;
        break;
    case 0xC4:
        dst = this.getSP() & 0xffff;
        break;
    case 0xC5:
        dst = this.regEBP & 0xffff;
        break;
    case 0xC6:
        dst = this.regESI & 0xffff;
        break;
    case 0xC7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0x1:
        src = this.regECX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0x2:
        src = this.regEDX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0x3:
        src = this.regEBX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0x4:
        src = this.getSP() & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0x5:
        src = this.regEBP & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0x6:
        src = this.regESI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0x7:
        src = this.regEDI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;
        break;
    }

    let w = fn.call(this, dst, src);

    switch(bModRM) {
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0xC5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC6:
        this.regESI = (this.regESI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    default:
        this.setEAShort(w);
        break;
    }
};

/**
 * modGrpShort32(afnGrp, fnSrc)
 *
 * @this {CPUX86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpShort32 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAShortData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAShortData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAShortData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAShortData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAShortData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAShortData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAShortData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAShortData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAShortData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAShortData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAShortData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAShortData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAShortData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAShortData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAShortData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAShortData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAShortData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAShortData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xffff;
        break;
    case 0xC1:
        dst = this.regECX & 0xffff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xffff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xffff;
        break;
    case 0xC4:
        dst = this.getSP() & 0xffff;
        break;
    case 0xC5:
        dst = this.regEBP & 0xffff;
        break;
    case 0xC6:
        dst = this.regESI & 0xffff;
        break;
    case 0xC7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let w = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xffff) | w;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        break;
    case 0xC4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0xC5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        break;
    case 0xC6:
        this.regESI = (this.regESI & ~0xffff) | w;
        break;
    case 0xC7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        break;
    default:
        this.setEAShort(w);
        break;
    }
};

/**
 * modRegLong32(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegLong32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEALongData(this.regEAX);
        break;
    case 0x01:
        src = this.getEALongData(this.regECX);
        break;
    case 0x02:
        src = this.getEALongData(this.regEDX);
        break;
    case 0x03:
        src = this.getEALongData(this.regEBX);
        break;
    case 0x04:
        src = this.getEALongData(X86.modSIB.call(this, 0));
        break;
    case 0x05:
        src = this.getEALongData(this.getIPAddr());
        break;
    case 0x06:
        src = this.getEALongData(this.regESI);
        break;
    case 0x07:
        src = this.getEALongData(this.regEDI);
        break;
    case 0x40:
        src = this.getEALongData(this.regEAX + this.getIPDisp());
        break;
    case 0x41:
        src = this.getEALongData(this.regECX + this.getIPDisp());
        break;
    case 0x42:
        src = this.getEALongData(this.regEDX + this.getIPDisp());
        break;
    case 0x43:
        src = this.getEALongData(this.regEBX + this.getIPDisp());
        break;
    case 0x44:
        src = this.getEALongData(X86.modSIB.call(this, 1) + this.getIPDisp());
        break;
    case 0x45:
        src = this.getEALongStack(this.regEBP + this.getIPDisp());
        break;
    case 0x46:
        src = this.getEALongData(this.regESI + this.getIPDisp());
        break;
    case 0x47:
        src = this.getEALongData(this.regEDI + this.getIPDisp());
        break;
    case 0x80:
        src = this.getEALongData(this.regEAX + this.getIPAddr());
        break;
    case 0x81:
        src = this.getEALongData(this.regECX + this.getIPAddr());
        break;
    case 0x82:
        src = this.getEALongData(this.regEDX + this.getIPAddr());
        break;
    case 0x83:
        src = this.getEALongData(this.regEBX + this.getIPAddr());
        break;
    case 0x84:
        src = this.getEALongData(X86.modSIB.call(this, 2) + this.getIPAddr());
        break;
    case 0x85:
        src = this.getEALongStack(this.regEBP + this.getIPAddr());
        break;
    case 0x86:
        src = this.getEALongData(this.regESI + this.getIPAddr());
        break;
    case 0x87:
        src = this.getEALongData(this.regEDI + this.getIPAddr());
        break;
    case 0xC0:
        src = this.regEAX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0xC1:
        src = this.regECX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0xC2:
        src = this.regEDX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0xC3:
        src = this.regEBX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0xC4:
        src = this.getSP();
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0xC5:
        src = this.regEBP;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0xC6:
        src = this.regESI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0xC7:
        src = this.regEDI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX;
        break;
    case 0x1:
        dst = this.regECX;
        break;
    case 0x2:
        dst = this.regEDX;
        break;
    case 0x3:
        dst = this.regEBX;
        break;
    case 0x4:
        dst = this.getSP();
        break;
    case 0x5:
        dst = this.regEBP;
        break;
    case 0x6:
        dst = this.regESI;
        break;
    case 0x7:
        dst = this.regEDI;
        break;
    default:
        dst = 0;
        break;
    }

    let l = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = l;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0x1:
        this.regECX = l;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0x2:
        this.regEDX = l;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0x3:
        this.regEBX = l;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0x4:
        this.setSP(l);
        break;
    case 0x5:
        this.regEBP = l;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x6:
        this.regESI = l;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x7:
        this.regEDI = l;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    }
};

/**
 * modMemLong32(fn)
 *
 * @this {CPUX86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemLong32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEALongData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEALongData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEALongData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEALongData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEALongData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEALongData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEALongData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEALongData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEALongData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEALongData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEALongData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEALongData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEALongData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEALongStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEALongData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEALongData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEALongData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEALongData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEALongData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEALongData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEALongData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEALongStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEALongData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEALongData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX;
        break;
    case 0xC1:
        dst = this.regECX;
        break;
    case 0xC2:
        dst = this.regEDX;
        break;
    case 0xC3:
        dst = this.regEBX;
        break;
    case 0xC4:
        dst = this.getSP();
        break;
    case 0xC5:
        dst = this.regEBP;
        break;
    case 0xC6:
        dst = this.regESI;
        break;
    case 0xC7:
        dst = this.regEDI;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0x1:
        src = this.regECX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0x2:
        src = this.regEDX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0x3:
        src = this.regEBX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0x4:
        src = this.getSP();
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0x5:
        src = this.regEBP;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0x6:
        src = this.regESI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0x7:
        src = this.regEDI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;
        break;
    }

    let l = fn.call(this, dst, src);

    switch(bModRM) {
    case 0xC0:
        this.regEAX = l;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC1:
        this.regECX = l;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC2:
        this.regEDX = l;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC3:
        this.regEBX = l;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC4:
        this.setSP(l);
        break;
    case 0xC5:
        this.regEBP = l;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC6:
        this.regESI = l;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC7:
        this.regEDI = l;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    default:
        this.setEALong(l);
        break;
    }
};

/**
 * modGrpLong32(afnGrp, fnSrc)
 *
 * @this {CPUX86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpLong32 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEALongData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEALongData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEALongData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEALongData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEALongData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEALongData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEALongData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEALongData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEALongData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEALongData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEALongData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEALongData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEALongData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEALongStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEALongData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEALongData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEALongData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEALongData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEALongData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEALongData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEALongData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEALongStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEALongData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEALongData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX;
        break;
    case 0xC1:
        dst = this.regECX;
        break;
    case 0xC2:
        dst = this.regEDX;
        break;
    case 0xC3:
        dst = this.regEBX;
        break;
    case 0xC4:
        dst = this.getSP();
        break;
    case 0xC5:
        dst = this.regEBP;
        break;
    case 0xC6:
        dst = this.regESI;
        break;
    case 0xC7:
        dst = this.regEDI;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let l = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0xC0:
        this.regEAX = l;
        break;
    case 0xC1:
        this.regECX = l;
        break;
    case 0xC2:
        this.regEDX = l;
        break;
    case 0xC3:
        this.regEBX = l;
        break;
    case 0xC4:
        this.setSP(l);
        break;
    case 0xC5:
        this.regEBP = l;
        break;
    case 0xC6:
        this.regESI = l;
        break;
    case 0xC7:
        this.regEDI = l;
        break;
    default:
        this.setEALong(l);
        break;
    }
};

/**
 * modSIB(mod)
 *
 * @this {CPUX86}
 * @param {number} mod
 * @return {number}
 */
X86.modSIB = function(mod)
{
    let bSIB = this.getIPByte();
    let scale = bSIB >> 6, index, base;

    switch((bSIB >> 3) & 0x7) {
    case 0:
        index = this.regEAX;
        break;
    case 1:
        index = this.regECX;
        break;
    case 2:
        index = this.regEDX;
        break;
    case 3:
        index = this.regEBX;
        break;
    case 4:
        index = 0;
        break;
    case 5:
        index = this.regEBP;
        break;
    case 6:
        index = this.regESI;
        break;
    case 7:
        index = this.regEDI;
        break;
    }

    switch(bSIB & 0x07) {
    case 0:
        base = this.regEAX;
        break;
    case 1:
        base = this.regECX;
        break;
    case 2:
        base = this.regEDX;
        break;
    case 3:
        base = this.regEBX;
        break;
    case 4:
        base = this.getSP();
        this.segData = this.segStack;
        break;
    case 5:
        if (mod) {
            base = this.regEBP;
            this.segData = this.segStack;
        } else {
            base = this.getIPAddr();
        }
        break;
    case 6:
        base = this.regESI;
        break;
    case 7:
        base = this.regEDI;
        break;
    }

    return ((index << scale) + base)|0;
};

/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/x86ops.js (C) Jeff Parsons 2012-2018
 */


/**
 * op=0x00 (ADD byte,reg)
 *
 * @this {CPUX86}
 */
X86.opADDmb = function()
{
    this.decodeModMemByte.call(this, X86.fnADDb);
    /*
     * Opcode bytes 0x00 0x00 are sufficiently uncommon that it's more likely we've started
     * executing in the weeds, so if you're in DEBUG mode, we'll print a warning and stop the
     * CPU if a Debugger is available.
     *
     * Notice that we also test fRunning: this allows the Debugger to step over the instruction,
     * because its trace ("t") command doesn't "run" the CPU; it merely "steps" the CPU.
     */
    if (DEBUG && !this.bModRM && this.flags.running) {
        this.printMessage("suspicious opcode: 0x00 0x00", DEBUGGER || this.bitsMessage);
        if (DEBUGGER && this.dbg) this.dbg.stopCPU();
    }
};

/**
 * op=0x01 (ADD word,reg)
 *
 * @this {CPUX86}
 */
X86.opADDmw = function()
{
    this.decodeModMemWord.call(this, X86.fnADDw);
};

/**
 * op=0x02 (ADD reg,byte)
 *
 * @this {CPUX86}
 */
X86.opADDrb = function()
{
    this.decodeModRegByte.call(this, X86.fnADDb);
};

/**
 * op=0x03 (ADD reg,word)
 *
 * @this {CPUX86}
 */
X86.opADDrw = function()
{
    this.decodeModRegWord.call(this, X86.fnADDw);
};

/**
 * op=0x04 (ADD AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opADDALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnADDb.call(this, this.regEAX & 0xff, this.getIPByte());
    /*
     * NOTE: Whenever the result is "blended" value (eg, of btiAL and btiMem0), a new bti should be
     * allocated to reflect that fact; however, I'm leaving "perfect" BACKTRACK support for another day.
     */
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x05 (ADD AX,imm16 or ADD EAX,imm32)
 *
 * @this {CPUX86}
 */
X86.opADDAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnADDw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x06 (PUSH ES)
 *
 * @this {CPUX86}
 */
X86.opPUSHES = function()
{
    /*
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segES.sel);
    } else {
        this.pushData(this.segES.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * op=0x07 (POP ES)
 *
 * @this {CPUX86}
 */
X86.opPOPES = function()
{
    /*
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setES(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x08 (OR byte,reg)
 *
 * @this {CPUX86}
 */
X86.opORmb = function()
{
    this.decodeModMemByte.call(this, X86.fnORb);
};

/**
 * op=0x09 (OR word,reg)
 *
 * @this {CPUX86}
 */
X86.opORmw = function()
{
    this.decodeModMemWord.call(this, X86.fnORw);
};

/**
 * op=0x0A (OR reg,byte)
 *
 * @this {CPUX86}
 */
X86.opORrb = function()
{
    this.decodeModRegByte.call(this, X86.fnORb);
};

/**
 * op=0x0B (OR reg,word)
 *
 * @this {CPUX86}
 */
X86.opORrw = function()
{
    this.decodeModRegWord.call(this, X86.fnORw);
};

/**
 * op=0x0C (OR AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opORALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnORb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x0D (OR AX,imm16 or OR EAX,imm32)
 *
 * @this {CPUX86}
 */
X86.opORAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnORw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x0E (PUSH CS)
 *
 * @this {CPUX86}
 */
X86.opPUSHCS = function()
{
    /*
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segCS.sel);
    } else {
        this.pushData(this.segCS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * op=0x0F (POP CS) (undocumented on 8086/8088; replaced with opInvalid() on 80186/80188, and op0F() on 80286 and up)
 *
 * @this {CPUX86}
 */
X86.opPOPCS = function()
{
    /*
     * Because this is an 8088-only operation, we don't have to worry about taking a snapshot of regLSP first.
     */
    this.setCS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x0F (handler for two-byte opcodes; 80286 and up)
 *
 * @this {CPUX86}
 */
X86.op0F = function()
{
    this.aOps0F[this.getIPByte()].call(this);
};

/**
 * op=0x10 (ADC byte,reg)
 *
 * @this {CPUX86}
 */
X86.opADCmb = function()
{
    this.decodeModMemByte.call(this, X86.fnADCb);
};

/**
 * op=0x11 (ADC word,reg)
 *
 * @this {CPUX86}
 */
X86.opADCmw = function()
{
    this.decodeModMemWord.call(this, X86.fnADCw);
};

/**
 * op=0x12 (ADC reg,byte)
 *
 * @this {CPUX86}
 */
X86.opADCrb = function()
{
    this.decodeModRegByte.call(this, X86.fnADCb);
};

/**
 * op=0x13 (ADC reg,word)
 *
 * @this {CPUX86}
 */
X86.opADCrw = function()
{
    this.decodeModRegWord.call(this, X86.fnADCw);
};

/**
 * op=0x14 (ADC AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opADCALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnADCb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x15 (ADC AX,imm16 or ADC EAX,imm32)
 *
 * @this {CPUX86}
 */
X86.opADCAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnADCw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x16 (PUSH SS)
 *
 * @this {CPUX86}
 */
X86.opPUSHSS = function()
{
    /*
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segSS.sel);
    } else {
        this.pushData(this.segSS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * op=0x17 (POP SS)
 *
 * @this {CPUX86}
 */
X86.opPOPSS = function()
{
    /*
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setSS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x18 (SBB byte,reg)
 *
 * @this {CPUX86}
 */
X86.opSBBmb = function()
{
    this.decodeModMemByte.call(this, X86.fnSBBb);
};

/**
 * op=0x19 (SBB word,reg)
 *
 * @this {CPUX86}
 */
X86.opSBBmw = function()
{
    this.decodeModMemWord.call(this, X86.fnSBBw);
};

/**
 * op=0x1A (SBB reg,byte)
 *
 * @this {CPUX86}
 */
X86.opSBBrb = function()
{
    this.decodeModRegByte.call(this, X86.fnSBBb);
};

/**
 * op=0x1B (SBB reg,word)
 *
 * @this {CPUX86}
 */
X86.opSBBrw = function()
{
    this.decodeModRegWord.call(this, X86.fnSBBw);
};

/**
 * op=0x1C (SBB AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opSBBALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnSBBb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x1D (SBB AX,imm16 or SBB EAX,imm32)
 *
 * @this {CPUX86}
 */
X86.opSBBAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnSBBw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x1E (PUSH DS)
 *
 * @this {CPUX86}
 */
X86.opPUSHDS = function()
{
    /*
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segDS.sel);
    } else {
        this.pushData(this.segDS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * op=0x1F (POP DS)
 *
 * @this {CPUX86}
 */
X86.opPOPDS = function()
{
    /*
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setDS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x20 (AND byte,reg)
 *
 * @this {CPUX86}
 */
X86.opANDmb = function()
{
    this.decodeModMemByte.call(this, X86.fnANDb);
};

/**
 * op=0x21 (AND word,reg)
 *
 * @this {CPUX86}
 */
X86.opANDmw = function()
{
    this.decodeModMemWord.call(this, X86.fnANDw);
};

/**
 * op=0x22 (AND reg,byte)
 *
 * @this {CPUX86}
 */
X86.opANDrb = function()
{
    this.decodeModRegByte.call(this, X86.fnANDb);
};

/**
 * op=0x23 (AND reg,word)
 *
 * @this {CPUX86}
 */
X86.opANDrw = function()
{
    this.decodeModRegWord.call(this, X86.fnANDw);
};

/**
 * op=0x24 (AND AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opANDAL = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnANDb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x25 (AND AX,imm16 or AND EAX,imm32)
 *
 * @this {CPUX86}
 */
X86.opANDAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnANDw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x26 (ES:)
 *
 * @this {CPUX86}
 */
X86.opES = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segES;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x27 (DAA)
 *
 * @this {CPUX86}
 */
X86.opDAA = function()
{
    let AL = this.regEAX & 0xff;
    let AF = this.getAF();
    let CF = this.getCF();
    if ((AL & 0xf) > 9 || AF) {
        AL += 0x6;
        AF = X86.PS.AF;
    } else {
        AF = 0;
    }
    if (AL > 0x9f || CF) {
        AL += 0x60;
        CF = X86.PS.CF;
    } else {
        CF = 0;
    }
    let b = (AL & 0xff);
    this.regEAX = (this.regEAX & ~0xff) | b;
    this.setLogicResult(b, X86.RESULT.BYTE);
    if (CF) this.setCF(); else this.clearCF();
    if (AF) this.setAF(); else this.clearAF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;          // AAA and DAA have the same cycle times
};

/**
 * op=0x28 (SUB byte,reg)
 *
 * @this {CPUX86}
 */
X86.opSUBmb = function()
{
    this.decodeModMemByte.call(this, X86.fnSUBb);
};

/**
 * op=0x29 (SUB word,reg)
 *
 * @this {CPUX86}
 */
X86.opSUBmw = function()
{
    this.decodeModMemWord.call(this, X86.fnSUBw);
};

/**
 * op=0x2A (SUB reg,byte)
 *
 * @this {CPUX86}
 */
X86.opSUBrb = function()
{
    this.decodeModRegByte.call(this, X86.fnSUBb);
};

/**
 * op=0x2B (SUB reg,word)
 *
 * @this {CPUX86}
 */
X86.opSUBrw = function()
{
    this.decodeModRegWord.call(this, X86.fnSUBw);
};

/**
 * op=0x2C (SUB AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opSUBALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnSUBb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x2D (SUB AX,imm16 or SUB EAX,imm32)
 *
 * @this {CPUX86}
 */
X86.opSUBAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnSUBw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x2E (CS:)
 *
 * @this {CPUX86}
 */
X86.opCS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segCS;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x2F (DAS)
 *
 * @this {CPUX86}
 */
X86.opDAS = function()
{
    let AL = this.regEAX & 0xff;
    let AF = this.getAF();
    let CF = this.getCF();
    if ((AL & 0xf) > 9 || AF) {
        AL -= 0x6;
        AF = X86.PS.AF;
    } else {
        AF = 0;
    }
    if (AL > 0x9f || CF) {
        AL -= 0x60;
        CF = X86.PS.CF;
    } else {
        CF = 0;
    }
    let b = (AL & 0xff);
    this.regEAX = (this.regEAX & ~0xff) | b;
    this.setLogicResult(b, X86.RESULT.BYTE);
    if (CF) this.setCF(); else this.clearCF();
    if (AF) this.setAF(); else this.clearAF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;          // AAA and DAS have the same cycle times
};

/**
 * op=0x30 (XOR byte,reg)
 *
 * @this {CPUX86}
 */
X86.opXORmb = function()
{
    this.decodeModMemByte.call(this, X86.fnXORb);
};

/**
 * op=0x31 (XOR word,reg)
 *
 * @this {CPUX86}
 */
X86.opXORmw = function()
{
    this.decodeModMemWord.call(this, X86.fnXORw);
};

/**
 * op=0x32 (XOR reg,byte)
 *
 * @this {CPUX86}
 */
X86.opXORrb = function()
{
    this.decodeModRegByte.call(this, X86.fnXORb);
};

/**
 * op=0x33 (XOR reg,word)
 *
 * @this {CPUX86}
 */
X86.opXORrw = function()
{
    this.decodeModRegWord.call(this, X86.fnXORw);
};

/**
 * op=0x34 (XOR AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opXORALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnXORb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x35 (XOR AX,imm16 or XOR EAX,imm32)
 *
 * @this {CPUX86}
 */
X86.opXORAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnXORw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x36 (SS:)
 *
 * @this {CPUX86}
 */
X86.opSS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segSS;      // QUESTION: Is there a case where segStack would not already be segSS? (eg, multiple segment overrides?)
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x37 (AAA)
 *
 * @this {CPUX86}
 */
X86.opAAA = function()
{
    let CF, AF;
    let AL = this.regEAX & 0xff;
    let AH = (this.regEAX >> 8) & 0xff;
    if ((AL & 0xf) > 9 || this.getAF()) {
        AL += 6;
        /*
         * Simulate the fact that the 80286 and higher add 6 to AX rather than AL.
         */
        if (this.model >= X86.MODEL_80286 && AL > 0xff) AH++;
        AH++;
        CF = AF = 1;
    } else {
        CF = AF = 0;
    }
    this.regEAX = (this.regEAX & ~0xffff) | (((AH << 8) | AL) & 0xff0f);
    if (CF) this.setCF(); else this.clearCF();
    if (AF) this.setAF(); else this.clearAF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;
};

/**
 * op=0x38 (CMP byte,reg)
 *
 * @this {CPUX86}
 */
X86.opCMPmb = function()
{
    this.decodeModMemByte.call(this, X86.fnCMPb);
};

/**
 * op=0x39 (CMP word,reg)
 *
 * @this {CPUX86}
 */
X86.opCMPmw = function()
{
    this.decodeModMemWord.call(this, X86.fnCMPw);
};

/**
 * op=0x3A (CMP reg,byte)
 *
 * @this {CPUX86}
 */
X86.opCMPrb = function()
{
    this.decodeModRegByte.call(this, X86.fnCMPb);
};

/**
 * op=0x3B (CMP reg,word)
 *
 * @this {CPUX86}
 */
X86.opCMPrw = function()
{
    this.decodeModRegWord.call(this, X86.fnCMPw);
};

/**
 * op=0x3C (CMP AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opCMPALb = function()
{
    X86.fnCMPb.call(this, this.regEAX & 0xff, this.getIPByte());
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x3D (CMP AX,imm16 or CMP EAX,imm32)
 *
 * @this {CPUX86}
 */
X86.opCMPAX = function()
{
    X86.fnCMPw.call(this, this.regEAX & this.maskData, this.getIPWord());
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x3E (DS:)
 *
 * @this {CPUX86}
 */
X86.opDS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segDS;      // QUESTION: Is there a case where segData would not already be segDS? (eg, multiple segment overrides?)
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x3D (AAS)
 *
 * @this {CPUX86}
 */
X86.opAAS = function()
{
    let CF, AF;
    let AL = this.regEAX & 0xff;
    let AH = (this.regEAX >> 8) & 0xff;
    if ((AL & 0xf) > 9 || this.getAF()) {
        AL = (AL - 0x6) & 0xf;
        AH = (AH - 1) & 0xff;
        CF = AF = 1;
    } else {
        CF = AF = 0;
    }
    this.regEAX = (this.regEAX & ~0xffff) | ((AH << 8) | AL);
    if (CF) this.setCF(); else this.clearCF();
    if (AF) this.setAF(); else this.clearAF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;   // AAA and AAS have the same cycle times
};

/**
 * op=0x40 (INC [E]AX)
 *
 * @this {CPUX86}
 */
X86.opINCAX = function()
{
    this.regEAX = X86.helpINCreg.call(this, this.regEAX);
};

/**
 * op=0x41 (INC [E]CX)
 *
 * @this {CPUX86}
 */
X86.opINCCX = function()
{
    this.regECX = X86.helpINCreg.call(this, this.regECX);
};

/**
 * op=0x42 (INC [E]DX)
 *
 * @this {CPUX86}
 */
X86.opINCDX = function()
{
    this.regEDX = X86.helpINCreg.call(this, this.regEDX);
};

/**
 * op=0x43 (INC [E]BX)
 *
 * @this {CPUX86}
 */
X86.opINCBX = function()
{
    this.regEBX = X86.helpINCreg.call(this, this.regEBX);
};

/**
 * op=0x44 (INC [E]SP)
 *
 * @this {CPUX86}
 */
X86.opINCSP = function()
{
    this.setSP(X86.helpINCreg.call(this, this.getSP()));
};

/**
 * op=0x45 (INC [E]BP)
 *
 * @this {CPUX86}
 */
X86.opINCBP = function()
{
    this.regEBP = X86.helpINCreg.call(this, this.regEBP);
};

/**
 * op=0x46 (INC [E]SI)
 *
 * @this {CPUX86}
 */
X86.opINCSI = function()
{
    this.regESI = X86.helpINCreg.call(this, this.regESI);
};

/**
 * op=0x47 (INC [E]DI)
 *
 * @this {CPUX86}
 */
X86.opINCDI = function()
{
    this.regEDI = X86.helpINCreg.call(this, this.regEDI);
};

/**
 * op=0x48 (DEC [E]AX)
 *
 * @this {CPUX86}
 */
X86.opDECAX = function()
{
    this.regEAX = X86.helpDECreg.call(this, this.regEAX);
};

/**
 * op=0x49 (DEC [E]CX)
 *
 * @this {CPUX86}
 */
X86.opDECCX = function()
{
    this.regECX = X86.helpDECreg.call(this, this.regECX);
};

/**
 * op=0x4A (DEC [E]DX)
 *
 * @this {CPUX86}
 */
X86.opDECDX = function()
{
    this.regEDX = X86.helpDECreg.call(this, this.regEDX);
};

/**
 * op=0x4B (DEC [E]BX)
 *
 * @this {CPUX86}
 */
X86.opDECBX = function()
{
    this.regEBX = X86.helpDECreg.call(this, this.regEBX);
};

/**
 * op=0x4C (DEC [E]SP)
 *
 * @this {CPUX86}
 */
X86.opDECSP = function()
{
    this.setSP(X86.helpDECreg.call(this, this.getSP()));
};

/**
 * op=0x4D (DEC [E]BP)
 *
 * @this {CPUX86}
 */
X86.opDECBP = function()
{
    this.regEBP = X86.helpDECreg.call(this, this.regEBP);
};

/**
 * op=0x4E (DEC [E]SI)
 *
 * @this {CPUX86}
 */
X86.opDECSI = function()
{
    this.regESI = X86.helpDECreg.call(this, this.regESI);
};

/**`
 * op=0x4F (DEC [E]DI)
 *
 * @this {CPUX86}
 */
X86.opDECDI = function()
{
    this.regEDI = X86.helpDECreg.call(this, this.regEDI);
};

/**
 * op=0x50 (PUSH [E]AX)
 *
 * @this {CPUX86}
 */
X86.opPUSHAX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiAL; this.backTrack.btiMem1 = this.backTrack.btiAH;
    }
    this.pushWord(this.regEAX & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x51 (PUSH [E]CX)
 *
 * @this {CPUX86}
 */
X86.opPUSHCX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiCL; this.backTrack.btiMem1 = this.backTrack.btiCH;
    }
    this.pushWord(this.regECX & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x52 (PUSH [E]DX)
 *
 * @this {CPUX86}
 */
X86.opPUSHDX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiDL; this.backTrack.btiMem1 = this.backTrack.btiDH;
    }
    this.pushWord(this.regEDX & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x53 (PUSH [E]BX)
 *
 * @this {CPUX86}
 */
X86.opPUSHBX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiBL; this.backTrack.btiMem1 = this.backTrack.btiBH;
    }
    this.pushWord(this.regEBX & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x54 (PUSH SP)
 *
 * NOTE: Having an accurate implementation of "PUSH SP" for the 8086/8088 isn't just a nice idea, it affects real
 * code.  Case in point: early Microsoft C floating-point libraries relied on "PUSH SP" behavior to quickly determine
 * whether an 8088 (and therefore presumably an 8087) or an 80286 (and presumably an 80287) was being used; eg:
 *
 *      &0910:1E82 D93E1709        FSTCW    WORD [0917]
 *      &0910:1E86 CD3D            INT      3D
 *      &0E4E:06D3 50              PUSH     AX
 *      &0E4E:06D4 B83DA2          MOV      AX,A23D
 *      &0E4E:06D7 EB04            JMP      06DD
 *      &0E4E:06DD 55              PUSH     BP
 *      &0E4E:06DE 1E              PUSH     DS
 *      &0E4E:06DF 56              PUSH     SI
 *      &0E4E:06E0 8BEC            MOV      BP,SP
 *      &0E4E:06E2 C57608          LDS      SI,[BP+08]
 *      &0E4E:06E5 4E              DEC      SI
 *      &0E4E:06E6 4E              DEC      SI
 *      &0E4E:06E7 897608          MOV      [BP+08],SI
 *      &0E4E:06EA 2904            SUB      [SI],AX
 *      &0E4E:06EC 53              PUSH     BX
 *      &0E4E:06ED 33DB            XOR      BX,BX
 *      &0E4E:06EF 54              PUSH     SP          ; beginning of processor check
 *      &0E4E:06F0 58              POP      AX
 *      &0E4E:06F1 3BC4            CMP      AX,SP
 *      &0E4E:06F3 7528            JNZ      071D        ; jump if 8086/8088/80186/80188, no jump if 80286 or later
 *      &0E4E:06F5 8B4001          MOV      AX,[BX+SI+01]
 *      &0E4E:06F8 25FB30          AND      AX,30FB
 *      &0E4E:06FB 3DD930          CMP      AX,30D9
 *      &0E4E:06FE 7507            JNZ      0707
 *      &0E4E:0700 8A4002          MOV      AL,[BX+SI+02]
 *      &0E4E:0703 3CF0            CMP      AL,F0
 *      &0E4E:0705 7216            JC       071D
 *      &0E4E:0707 8B4001          MOV      AX,[BX+SI+01]
 *      &0E4E:070A 25FFFE          AND      AX,FEFF
 *      &0E4E:070D 3DDBE2          CMP      AX,E2DB
 *      &0E4E:0710 740B            JZ       071D
 *      &0E4E:0712 8B4001          MOV      AX,[BX+SI+01]
 *      &0E4E:0715 3DDFE0          CMP      AX,E0DF
 *      &0E4E:0718 7403            JZ       071D
 *      &0E4E:071A C60490          MOV      [SI],90
 *      &0E4E:071D 5B              POP      BX
 *      &0E4E:071E 5E              POP      SI
 *      &0E4E:071F 1F              POP      DS
 *      &0E4E:0720 5D              POP      BP
 *      &0E4E:0721 58              POP      AX
 *      &0E4E:0722 CF              IRET
 *
 * @this {CPUX86}
 */
X86.opPUSHSP_8086 = function()
{
    let w = (this.getSP() - 2) & 0xffff;
    this.pushWord(w);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x54 (PUSH [E]SP)
 *
 * @this {CPUX86}
 */
X86.opPUSHSP = function()
{
    this.pushWord(this.getSP() & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x55 (PUSH [E]BP)
 *
 * @this {CPUX86}
 */
X86.opPUSHBP = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiBPLo; this.backTrack.btiMem1 = this.backTrack.btiBPHi;
    }
    this.pushWord(this.regEBP & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x56 (PUSH [E]SI)
 *
 * @this {CPUX86}
 */
X86.opPUSHSI = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiSILo; this.backTrack.btiMem1 = this.backTrack.btiSIHi;
    }
    this.pushWord(this.regESI & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x57 (PUSH [E]DI)
 *
 * @this {CPUX86}
 */
X86.opPUSHDI = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiDILo; this.backTrack.btiMem1 = this.backTrack.btiDIHi;
    }
    this.pushWord(this.regEDI & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x58 (POP [E]AX)
 *
 * @this {CPUX86}
 */
X86.opPOPAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x59 (POP [E]CX)
 *
 * @this {CPUX86}
 */
X86.opPOPCX = function()
{
    this.regECX = (this.regECX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiCL = this.backTrack.btiMem0; this.backTrack.btiCH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5A (POP [E]DX)
 *
 * @this {CPUX86}
 */
X86.opPOPDX = function()
{
    this.regEDX = (this.regEDX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiDL = this.backTrack.btiMem0; this.backTrack.btiDH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5B (POP [E]BX)
 *
 * @this {CPUX86}
 */
X86.opPOPBX = function()
{
    this.regEBX = (this.regEBX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiBL = this.backTrack.btiMem0; this.backTrack.btiBH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5C (POP [E]SP)
 *
 * @this {CPUX86}
 */
X86.opPOPSP = function()
{
    this.setSP((this.getSP() & ~this.maskData) | this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5D (POP [E]BP)
 *
 * @this {CPUX86}
 */
X86.opPOPBP = function()
{
    this.regEBP = (this.regEBP & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiBPLo = this.backTrack.btiMem0; this.backTrack.btiBPHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5E (POP [E]SI)
 *
 * @this {CPUX86}
 */
X86.opPOPSI = function()
{
    this.regESI = (this.regESI & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiSILo = this.backTrack.btiMem0; this.backTrack.btiSIHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5F (POP [E]DI)
 *
 * @this {CPUX86}
 */
X86.opPOPDI = function()
{
    this.regEDI = (this.regEDI & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiDILo = this.backTrack.btiMem0; this.backTrack.btiDIHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x60 (PUSHA) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opPUSHA = function()
{
    /*
     * Any operation that performs multiple stack modifications must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    /*
     * TODO: regLSP needs to be pre-bounds-checked against regLSPLimitLow
     */
    let temp = this.getSP() & this.maskData;
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiAL; this.backTrack.btiMem1 = this.backTrack.btiAH;
    }
    this.pushWord(this.regEAX & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiCL; this.backTrack.btiMem1 = this.backTrack.btiCH;
    }
    this.pushWord(this.regECX & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiDL; this.backTrack.btiMem1 = this.backTrack.btiDH;
    }
    this.pushWord(this.regEDX & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiBL; this.backTrack.btiMem1 = this.backTrack.btiBH;
    }
    this.pushWord(this.regEBX & this.maskData);
    this.pushWord(temp);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiBPLo; this.backTrack.btiMem1 = this.backTrack.btiBPHi;
    }
    this.pushWord(this.regEBP & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiSILo; this.backTrack.btiMem1 = this.backTrack.btiSIHi;
    }
    this.pushWord(this.regESI & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiDILo; this.backTrack.btiMem1 = this.backTrack.btiDIHi;
    }
    this.pushWord(this.regEDI & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushAll;

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x61 (POPA) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opPOPA = function()
{
    /*
     * Any operation that performs multiple stack modifications must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    this.regEDI = (this.regEDI & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiDILo = this.backTrack.btiMem0; this.backTrack.btiDIHi = this.backTrack.btiMem1;
    }
    this.regESI = (this.regESI & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiSILo = this.backTrack.btiMem0; this.backTrack.btiSIHi = this.backTrack.btiMem1;
    }
    this.regEBP = (this.regEBP & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiBPLo = this.backTrack.btiMem0; this.backTrack.btiBPHi = this.backTrack.btiMem1;
    }
    /*
     * TODO: regLSP needs to be pre-bounds-checked against regLSPLimit at the start
     */
    this.setSP(this.getSP() + this.sizeData);
    // this.regLSP += (I386? this.sizeData : 2);
    this.regEBX = (this.regEBX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiBL = this.backTrack.btiMem0; this.backTrack.btiBH = this.backTrack.btiMem1;
    }
    this.regEDX = (this.regEDX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiDL = this.backTrack.btiMem0; this.backTrack.btiDH = this.backTrack.btiMem1;
    }
    this.regECX = (this.regECX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiCL = this.backTrack.btiMem0; this.backTrack.btiCH = this.backTrack.btiMem1;
    }
    this.regEAX = (this.regEAX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopAll;

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x62 (BOUND reg,word) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opBOUND = function()
{
    this.decodeModRegWord.call(this, X86.fnBOUND);
};

/**
 * op=0x63 (ARPL word,reg) (80286 and up)
 *
 * @this {CPUX86}
 */
X86.opARPL = function()
{
    /*
     * ARPL is one of several protected-mode instructions that are meaningless and not allowed in either real-mode
     * or V86-mode; others include LAR, LSL, VERR and VERW.  More meaningful but potentially harmful protected-mode
     * instructions that ARE allowed in real-mode but NOT in V86-mode include LIDT, LGDT, LMSW, CLTS, HLT, and
     * control register MOV instructions.
     *
     * ARPL is somewhat more noteworthy because enhanced-mode Windows (going back to at least Windows 3.00, and
     * possibly even the earliest versions of Windows/386) selected the ARPL opcode as a controlled means of exiting
     * V86-mode via the UD_FAULT exception.  Windows would use the same ARPL for all controlled exits, using different
     * segment:offset pointers to the ARPL to differentiate them.  ARPL was probably chosen because it could trigger
     * a UD_FAULT with a single byte (0x63); any subsequent address bytes would be irrelevant.
     *
     * Which is WHY we must perform the CPU mode tests below rather than in the fnARPL() worker; otherwise we could
     * generate additional (bogus) faults, based on the address of the first operand.
     *
     * TODO: You may have noticed that setProtMode() already swaps out a 0x0F opcode dispatch table for another based
     * on the mode, because none of the "GRP6" 0x0F opcodes (eg, SLDT, STR, LLDT, LTR, VERR and VERW) are allowed in
     * real-mode, and it was easy to swap all those handlers in/out with a single update.  We've extended that particular
     * swap to include V86-mode as well, but we might want to consider swapping out more opcode handlers in a similar
     * fashion, instead of using these in-line mode tests.
     */
    if (!(this.regCR0 & X86.CR0.MSW.PE) || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
        return;
    }
    this.decodeModMemWord.call(this, X86.fnARPL);
};

/**
 * op=0x64 (FS:)
 *
 * @this {CPUX86}
 */
X86.opFS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segFS;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x65 (GS:)
 *
 * @this {CPUX86}
 */
X86.opGS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segGS;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x66 (OS:) (80386 and up)
 *
 * TODO: Review other effective operand-size criteria, cycle count, etc.
 *
 * @this {CPUX86}
 */
X86.opOS = function()
{
    if (I386) {
        /*
         * See opAS() for a discussion of multiple prefixes, which applies equally to both
         * operand-size and address-size prefixes.
         *
         * The simple fix here is to skip the bulk of the operation if the prefix is redundant.
         */
        this.opFlags |= X86.OPFLAG.DATASIZE;
        if (!(this.opPrefixes & X86.OPFLAG.DATASIZE)) {
            this.sizeData ^= 0x6;               // that which is 2 shall become 4, and vice versa
            this.maskData ^= (0xffff0000|0);    // that which is 0x0000ffff shall become 0xffffffff, and vice versa
            this.updateDataSize();
        }
        this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
    }
};

/**
 * op=0x67 (AS:) (80386 and up)
 *
 * TODO: Review other effective address-size criteria, cycle count, etc.
 *
 * @this {CPUX86}
 */
X86.opAS = function()
{
    if (I386) {
        /*
         * Live and learn: multiple address-size prefixes can and do occur on a single instruction,
         * and contrary to my original assumption that the prefixes act independently, they do not.
         * During Windows 95 SETUP, the following instruction is executed:
         *
         *      06AF:1B4D 67672E          CS:
         *      06AF:1B50 FFA25A1B        JMP      [BP+SI+1B5A]
         *
         * which is in fact:
         *
         *      06AF:1B4D 67672E          CS:
         *      06AF:1B50 FFA25A1B0000    JMP      [EDX+00001B5A]
         *
         * The other interesting question is: why/how did this instruction get encoded that way?
         * All I can say is, there were no explicit prefixes in the source (BSG.ASM), so we'll chalk
         * it up to a glitch in MASM.
         *
         * The simple fix here is to skip the bulk of the operation if the prefix is redundant.
         */
        this.opFlags |= X86.OPFLAG.ADDRSIZE;
        if (!(this.opPrefixes & X86.OPFLAG.ADDRSIZE)) {
            this.sizeAddr ^= 0x06;              // that which is 2 shall become 4, and vice versa
            this.maskAddr ^= (0xffff0000|0);    // that which is 0x0000ffff shall become 0xffffffff, and vice versa
            this.updateAddrSize();
        }
        this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
    }
};

/**
 * op=0x68 (PUSH imm) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opPUSHn = function()
{
    this.pushWord(this.getIPWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x69 (IMUL reg,word,imm) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opIMULn = function()
{
    this.decodeModRegWord.call(this, X86.fnIMULn);
};

/**
 * op=0x6A (PUSH imm8) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opPUSH8 = function()
{
    if (BACKTRACK) this.backTrack.btiMem1 = 0;
    this.pushWord(this.getIPDisp());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x6B (IMUL reg,word,imm8) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opIMUL8 = function()
{
    this.decodeModRegWord.call(this, X86.fnIMUL8);
};

/**
 * op=0x6C (INSB) (80186/80188 and up)
 *
 * NOTE: Segment overrides are ignored for this instruction, so we must use segES instead of segData.
 *
 * @this {CPUX86}
 */
X86.opINSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    /*
     * NOTE: 5 + 4n is the cycle time for the 80286; the 80186/80188 has different values: 14 cycles for
     * an unrepeated INS, and 8 + 8n for a repeated INS.  However, accurate cycle times for the 80186/80188 is
     * low priority.
     */
    let nCycles = 5;

    /*
     * The (normal) REP prefix, if used, is REPNZ (0xf2), but either one works....
     */
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        if (this.opPrefixes & X86.OPFLAG.REPEAT) nCycles = 4;
    }

    if (nReps--) {
        let port = this.regEDX & 0xffff;
        if (!this.checkIOPM(port, 1, true)) return;
        let b = this.bus.checkPortInputNotify(port, 1, this.regLIP - nDelta - 1);
        this.setSOByte(this.segES, this.regEDI & maskAddr, b);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        if (BACKTRACK) this.backTrack.btiMem0 = this.backTrack.btiIO;
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0x6D (INSW) (80186/80188 and up)
 *
 * NOTE: Segment overrides are ignored for this instruction, so we must use segDS instead of segData.
 *
 * @this {CPUX86}
 */
X86.opINSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    /*
     * NOTE: 5 + 4n is the cycle time for the 80286; the 80186/80188 has different values: 14 cycles for
     * an unrepeated INS, and 8 + 8n for a repeated INS.  However, accurate cycle times for the 80186/80188 is
     * low priority.
     */
    let nCycles = 5;

    /*
     * The (normal) REP prefix, if used, is REPNZ (0xf2), but either one works....
     */
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        if (this.opPrefixes & X86.OPFLAG.REPEAT) nCycles = 4;
    }
    if (nReps--) {
        let port = this.regEDX & 0xffff;
        if (!this.checkIOPM(port, this.sizeData, true)) return;
        let w = this.bus.checkPortInputNotify(port, this.sizeData, this.regLIP - nDelta - 1);
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiIO;
            this.backTrack.btiMem1 = this.backTrack.btiIO;
        }
        this.setSOWord(this.segES, this.regEDI & maskAddr, w);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0x6E (OUTSB) (80186/80188 and up)
 *
 * NOTE: Segment overrides are ignored for this instruction, so we must use segDS instead of segData.
 *
 * @this {CPUX86}
 */
X86.opOUTSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    /*
     * NOTE: 5 + 4n is the cycle time for the 80286; the 80186/80188 has different values: 14 cycles for
     * an unrepeated INS, and 8 + 8n for a repeated INS.  TODO: Fix this someday.
     */
    let nCycles = 5;

    /*
     * The (normal) REP prefix, if used, is REPNZ (0xf2), but either one works....
     */
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        if (this.opPrefixes & X86.OPFLAG.REPEAT) nCycles = 4;
    }
    if (nReps--) {
        let port = this.regEDX & 0xffff;
        if (!this.checkIOPM(port, 1, false)) return;
        let b = this.getSOByte(this.segDS, this.regESI & maskAddr);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        if (BACKTRACK) this.backTrack.btiIO = this.backTrack.btiMem0;
        this.bus.checkPortOutputNotify(port, 1, b, this.regLIP - nDelta - 1);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0x6F (OUTSW) (80186/80188 and up)
 *
 * NOTE: Segment overrides are ignored for this instruction, so we must use segDS instead of segData.
 *
 * @this {CPUX86}
 */
X86.opOUTSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    /*
     * NOTE: 5 + 4n is the cycle time for the 80286; the 80186/80188 has different values: 14 cycles for
     * an unrepeated INS, and 8 + 8n for a repeated INS.  TODO: Fix this someday.
     */
    let nCycles = 5;

    /*
     * The (normal) REP prefix, if used, is REPNZ (0xf2), but either one works....
     */
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        if (this.opPrefixes & X86.OPFLAG.REPEAT) nCycles = 4;
    }
    if (nReps--) {
        let w = this.getSOWord(this.segDS, this.regESI & maskAddr);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        let port = this.regEDX & 0xffff;
        if (!this.checkIOPM(port, this.sizeData, false)) return;
        if (BACKTRACK) {
            this.backTrack.btiIO = this.backTrack.btiMem0;
            this.backTrack.btiIO = this.backTrack.btiMem1;
        }
        this.bus.checkPortOutputNotify(port, this.sizeData, w, this.regLIP - nDelta - 1);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0x70 (JO disp)
 *
 * @this {CPUX86}
 */
X86.opJO = function()
{
    let disp = this.getIPDisp();
    if (this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x71 (JNO disp)
 *
 * @this {CPUX86}
 */
X86.opJNO = function()
{
    let disp = this.getIPDisp();
    if (!this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x72 (JC disp, aka JB disp)
 *
 * @this {CPUX86}
 */
X86.opJC = function()
{
    let disp = this.getIPDisp();
    if (this.getCF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x73 (JNC disp, aka JAE disp)
 *
 * @this {CPUX86}
 */
X86.opJNC = function()
{
    let disp = this.getIPDisp();
    if (!this.getCF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x74 (JZ disp)
 *
 * @this {CPUX86}
 */
X86.opJZ = function()
{
    let disp = this.getIPDisp();
    if (this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x75 (JNZ disp)
 *
 * @this {CPUX86}
 */
X86.opJNZ = function()
{
    let disp = this.getIPDisp();
    if (!this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x76 (JBE disp)
 *
 * @this {CPUX86}
 */
X86.opJBE = function()
{
    let disp = this.getIPDisp();
    if (this.getCF() || this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x77 (JNBE disp, JA disp)
 *
 * @this {CPUX86}
 */
X86.opJNBE = function()
{
    let disp = this.getIPDisp();
    if (!this.getCF() && !this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x78 (JS disp)
 *
 * @this {CPUX86}
 */
X86.opJS = function()
{
    let disp = this.getIPDisp();
    if (this.getSF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x79 (JNS disp)
 *
 * @this {CPUX86}
 */
X86.opJNS = function()
{
    let disp = this.getIPDisp();
    if (!this.getSF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7A (JP disp)
 *
 * @this {CPUX86}
 */
X86.opJP = function()
{
    let disp = this.getIPDisp();
    if (this.getPF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7B (JNP disp)
 *
 * @this {CPUX86}
 */
X86.opJNP = function()
{
    let disp = this.getIPDisp();
    if (!this.getPF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7C (JL disp)
 *
 * @this {CPUX86}
 */
X86.opJL = function()
{
    let disp = this.getIPDisp();
    if (!this.getSF() != !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7D (JNL disp, aka JGE disp)
 *
 * @this {CPUX86}
 */
X86.opJNL = function()
{
    let disp = this.getIPDisp();
    if (!this.getSF() == !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7E (JLE disp)
 *
 * @this {CPUX86}
 */
X86.opJLE = function()
{
    let disp = this.getIPDisp();
    if (this.getZF() || !this.getSF() != !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7F (JNLE disp, aka JG disp)
 *
 * @this {CPUX86}
 */
X86.opJNLE = function()
{
    let disp = this.getIPDisp();
    if (!this.getZF() && !this.getSF() == !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x80/0x82 (GRP1 byte,imm8)
 *
 * @this {CPUX86}
 */
X86.opGRP1b = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp1b, this.getIPByte);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? 1 : this.cycleCounts.nOpCyclesArithMID);
};

/**
 * op=0x81 (GRP1 word,imm)
 *
 * @this {CPUX86}
 */
X86.opGRP1w = function()
{
    this.decodeModGrpWord.call(this, X86.aOpGrp1w, this.getIPWord);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? 1 : this.cycleCounts.nOpCyclesArithMID);
};

/**
 * op=0x83 (GRP1 word,disp)
 *
 * WARNING: This passes getIPDisp() as the fnSrc parameter, which returns a 32-bit signed value,
 * so the worker functions (ie, the functions listed in aOpGrp1w[]) MUST mask their result with maskData,
 * to avoid setting bits beyond the current operand size.
 *
 * @this {CPUX86}
 */
X86.opGRP1sw = function()
{
    this.decodeModGrpWord.call(this, X86.aOpGrp1w, this.getIPDisp);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? 1 : this.cycleCounts.nOpCyclesArithMID);
};

/**
 * op=0x84 (TEST reg,byte)
 *
 * @this {CPUX86}
 */
X86.opTESTrb = function()
{
    this.decodeModMemByte.call(this, X86.fnTESTb);
};

/**
 * op=0x85 (TEST reg,word)
 *
 * @this {CPUX86}
 */
X86.opTESTrw = function()
{
    this.decodeModMemWord.call(this, X86.fnTESTw);
};

/**
 * op=0x86 (XCHG reg,byte)
 *
 * NOTE: The XCHG instruction is unique in that both src and dst are both read and written;
 * see fnXCHGrb() for how we deal with this special case.
 *
 * @this {CPUX86}
 */
X86.opXCHGrb = function()
{
    /*
     * If the second operand is a register, then the ModRegByte decoder must use separate "get" and
     * "set" assignments, otherwise instructions like "XCHG DH,DL" will end up using a stale DL instead of
     * the updated DL.
     *
     * To be clear, a single assignment like this will fail:
     *
     *      opModRegByteF2: function(fn)
     *      {
     *          this.regEDX = (this.regEDX & 0xff) | (fn.call(this, this.regEDX >> 8, this.regEDX & 0xff) << 8);
     *      }
     *
     * which is why all affected decoders now use separate assignments; eg:
     *
     *      opModRegByteF2: function(fn)
     *      {
     *          let b = fn.call(this, this.regEDX >> 8, this.regEDX & 0xff);
     *          this.regEDX = (this.regEDX & 0xff) | (b << 8);
     *      }
     */
    this.decodeModRegByte.call(this, X86.fnXCHGrb);
};

/**
 * op=0x87 (XCHG reg,word)
 *
 * NOTE: The XCHG instruction is unique in that both src and dst are both read and written;
 * see fnXCHGrw() for how we deal with this special case.
 *
 * @this {CPUX86}
 */
X86.opXCHGrw = function()
{
    this.decodeModRegWord.call(this, X86.fnXCHGrw);
};

/**
 * op=0x88 (MOV byte,reg)
 *
 * @this {CPUX86}
 */
X86.opMOVmb = function()
{
    /*
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModMemByte.call(this, X86.fnMOV);
};

/**
 * op=0x89 (MOV word,reg)
 *
 * @this {CPUX86}
 */
X86.opMOVmw = function()
{
    /*
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModMemWord.call(this, X86.fnMOV);
};

/**
 * op=0x8A (MOV reg,byte)
 *
 * @this {CPUX86}
 */
X86.opMOVrb = function()
{
    this.decodeModRegByte.call(this, X86.fnMOV);
};

/**
 * op=0x8B (MOV reg,word)
 *
 * @this {CPUX86}
 */
X86.opMOVrw = function()
{
    this.decodeModRegWord.call(this, X86.fnMOV);
};

/**
 * op=0x8C (MOV word,sreg)
 *
 * NOTE: Since the ModRM decoders deal only with general-purpose registers, we rely on our helper
 * function (fnMOVwsr) to select the appropriate segment register and replace the decoder's src operand.
 *
 * @this {CPUX86}
 */
X86.opMOVwsr = function()
{
    /*
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModMemWord.call(this, X86.fnMOVwsr);
};

/**
 * op=0x8D (LEA reg,word)
 *
 * @this {CPUX86}
 */
X86.opLEA = function()
{
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.segData = this.segStack = this.segNULL;    // we can't have the EA calculation, if any, "polluted" by segment arithmetic
    this.decodeModRegWord.call(this, X86.fnLEA);
};

/**
 * op=0x8E (MOV sreg,word)
 *
 * NOTE: Since the ModRM decoders deal only with general-purpose registers, we rely on our
 * helper function (fnMOVsrw) to make a note of which general-purpose register will be overwritten,
 * so that we can restore it after moving the updated value to the correct segment register.
 *
 * @this {CPUX86}
 */
X86.opMOVsrw = function()
{
    let sel;
    this.decodeModRegWord.call(this, X86.fnMOVsrw);
    switch ((this.bModRM >> 3) & 0x7) {
    case 0x0:
        sel = this.regEAX;
        this.regEAX = this.regXX;
        this.setES(sel);
        break;
    case 0x1:
        sel = this.regECX;
        this.regECX = this.regXX;
        this.setCS(sel);
        break;
    case 0x2:
        sel = this.regEDX;
        this.regEDX = this.regXX;
        this.setSS(sel);
        break;
    case 0x3:
        sel = this.regEBX;
        this.regEBX = this.regXX;
        this.setDS(sel);
        break;
    case 0x4:
        sel = this.getSP();
        this.setSP(this.regXX);
        if (I386 && this.model >= X86.MODEL_80386) {
            this.setFS(sel);
        } else {
            this.setES(sel);
        }
        break;
    case 0x5:
        sel = this.regEBP;
        this.regEBP = this.regXX;
        if (I386 && this.model >= X86.MODEL_80386) {
            this.setGS(sel);
        } else {
            this.setCS(sel);
        }
        break;
    case 0x6:
        sel = this.regESI;
        this.regESI = this.regXX;
        this.setSS(sel);
        break;
    case 0x7:
        sel = this.regEDI;
        this.regEDI = this.regXX;
        this.setDS(sel);
        break;
    }
};

/**
 * op=0x8F (POP word)
 *
 * @this {CPUX86}
 */
X86.opPOPmw = function()
{
    /*
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;

    /*
     * If the word we're about to pop FROM the stack gets popped INTO a not-present page, this
     * instruction will not be restartable unless we snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    /*
     * A "clever" instruction like this:
     *
     *      #0117:651C 67668F442408    POP      DWORD [ESP+08]
     *
     * pops the DWORD from the top of the stack and places it at ESP+08, where ESP is the value
     * AFTER the pop, not before.  We used to (incorrectly) pass "popWord" as the fnSrc parameter
     * below; we now pop the word first, saving it in regXX, and then pass "helpSRCxx" as fnSrc,
     * which simply returns the contents of regXX.
     *
     * Also, in case you're wondering, fnPUSHw() (in aOpGrp4w) is the complement to this instruction,
     * but it doesn't require a similar work-around, because a push from memory accesses that memory
     * BEFORE the push, which occurs through our normal ModRM processing.
     */
    this.regXX = this.popWord();

    this.decodeModGrpWord.call(this, X86.aOpGrpPOPw, X86.helpSRCxx);

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x90 (NOP, aka XCHG AX,AX)
 *
 * @this {CPUX86}
 */
X86.opNOP = function()
{
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x91 (XCHG AX,CX)
 *
 * @this {CPUX86}
 */
X86.opXCHGCX = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regECX & this.maskData) : this.regECX);
    this.regECX = (I386? (this.regECX & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiCL; this.backTrack.btiCL = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiCH; this.backTrack.btiCH = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x92 (XCHG AX,DX)
 *
 * @this {CPUX86}
 */
X86.opXCHGDX = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regEDX & this.maskData) : this.regEDX);
    this.regEDX = (I386? (this.regEDX & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiDL; this.backTrack.btiDL = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiDH; this.backTrack.btiDH = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x93 (XCHG AX,BX)
 *
 * @this {CPUX86}
 */
X86.opXCHGBX = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regEBX & this.maskData) : this.regEBX);
    this.regEBX = (I386? (this.regEBX & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiBL; this.backTrack.btiBL = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiBH; this.backTrack.btiBH = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x94 (XCHG AX,SP)
 *
 * @this {CPUX86}
 */
X86.opXCHGSP = function()
{
    let temp = this.regEAX;
    let regESP = this.getSP();
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (regESP & this.maskData) : regESP);
    this.setSP((I386? (regESP & ~this.maskData) | (temp & this.maskData) : temp));
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiAH = 0;
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x95 (XCHG AX,BP)
 *
 * @this {CPUX86}
 */
X86.opXCHGBP = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regEBP & this.maskData) : this.regEBP);
    this.regEBP = (I386? (this.regEBP & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiBPLo; this.backTrack.btiBPLo = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiBPHi; this.backTrack.btiBPHi = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x96 (XCHG AX,SI)
 *
 * @this {CPUX86}
 */
X86.opXCHGSI = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regESI & this.maskData) : this.regESI);
    this.regESI = (I386? (this.regESI & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiSILo; this.backTrack.btiSILo = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiSIHi; this.backTrack.btiSIHi = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x97 (XCHG AX,DI)
 *
 * @this {CPUX86}
 */
X86.opXCHGDI = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regEDI & this.maskData) : this.regEDI);
    this.regEDI = (I386? (this.regEDI & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiDILo; this.backTrack.btiDILo = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiDIHi; this.backTrack.btiDIHi = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x98 (CBW/CWDE)
 *
 * NOTE: The 16-bit form (CBW) sign-extends AL into AX, whereas the 32-bit form (CWDE) sign-extends AX into EAX;
 * CWDE is similar to CWD, except that the destination is EAX rather than DX:AX.
 *
 * @this {CPUX86}
 */
X86.opCBW = function()
{
    if (this.sizeData == 2) {   // CBW
        this.regEAX = (this.regEAX & ~0xffff) | (((this.regEAX << 24) >> 24) & 0xffff);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiAL;
    }
    else {                      // CWDE
        this.regEAX = ((this.regEAX << 16) >> 16);
    }
    this.nStepCycles -= 2;                          // CBW takes 2 cycles on all CPUs through 80286
};

/**
 * op=0x99 (CWD/CDQ)
 *
 * NOTE: The 16-bit form (CWD) sign-extends AX, producing a 32-bit result in DX:AX, while the 32-bit form (CDQ)
 * sign-extends EAX, producing a 64-bit result in EDX:EAX.
 *
 * @this {CPUX86}
 */
X86.opCWD = function()
{
    if (this.sizeData == 2) {   // CWD
        this.regEDX = (this.regEDX & ~0xffff) | ((this.regEAX & 0x8000)? 0xffff : 0);
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiDH = this.backTrack.btiAH;
    }
    else {                      // CDQ
        this.regEDX = (this.regEAX & (0x80000000|0))? -1 : 0;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesCWD;
};

/**
 * op=0x9A (CALL seg:off)
 *
 * @this {CPUX86}
 */
X86.opCALLF = function()
{
    X86.helpCALLF.call(this, this.getIPWord(), this.getIPShort());
    this.nStepCycles -= this.cycleCounts.nOpCyclesCallF;
};

/**
 * op=0x9B (WAIT)
 *
 * @this {CPUX86}
 */
X86.opWAIT = function()
{
    if (!this.fpu || !this.fpu.opWAIT()) {
        this.nStepCycles -= 3;     // FPUX86.opWAIT() is required to charge some number of cycles if it returns true
    }
};

/**
 * op=0x9C (PUSHF/PUSHFD)
 *
 * @this {CPUX86}
 */
X86.opPUSHF = function()
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    let regPS = this.getPS();
    if (I386) {
        if ((regPS & X86.PS.VM) && this.nIOPL < 3) {
            if (DEBUG) this.printMessage("PUSHF in v86-mode (IOPL < 3)", this.bitsMessage, true);
            X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
            return;
        }
        /*
         * It doesn't matter whether this is PUSHF or PUSHFD: the VM and RF flags are never pushed, so
         * we should always clear them.  NOTE: This contradicts what the "INTEL 80386 PROGRAMMER'S REFERENCE
         * MANUAL 1986" says on page 81 (which we assume is wrong):
         *
         *      SYSTEMS FLAGS (INCLUDING THE IOPL FIELD, AND THE VM, RF, AND IF FLAGS) ARE PUSHED AND ARE
         *      VISIBLE TO APPLICATIONS PROGRAMS. HOWEVER, WHEN AN APPLICATIONS PROGRAM POPS THE FLAGS,
         *      THESE ITEMS ARE NOT CHANGED, REGARDLESS OF THE VALUES POPPED INTO THEM.
         *
         * This does, however, beg the question: how does code running in V86-mode detect that's in V86-mode
         * and not real-mode?  By using the SMSW instruction and checking the PE (protected-mode enabled) bit.
         * The SMSW instruction returns a subset of the CR0 bits, and unlike the MOV reg,CR0 instruction, is
         * allowed in V86-mode.  See fnSMSW() for more information.
         */
        regPS &= ~(X86.PS.VM | X86.PS.RF);
    }
    this.pushWord(regPS);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x9D (POPF/POPFD)
 *
 * @this {CPUX86}
 */
X86.opPOPF = function()
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
        if (DEBUG) this.printMessage("POPF in v86-mode (IOPL < 3)", this.bitsMessage, true);
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    /*
     * Regardless of mode, VM and RF (the only defined EFLAGS bit above bit 15) are never changed by POPFD.
     */
    let newPS = this.popWord();
    if (I386) newPS = (newPS & 0xffff) | (this.regPS & ~0xffff);
    this.setPS(newPS);
    /*
     * NOTE: I'm assuming that neither POPF nor IRET are required to set NOINTR like STI does.
     */
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x9E (SAHF)
 *
 * @this {CPUX86}
 */
X86.opSAHF = function()
{
    /*
     * NOTE: While it make seem more efficient to do this:
     *
     *      this.setPS((this.getPS() & ~X86.PS_SAHF) | ((this.regEAX >> 8) & X86.PS_SAHF));
     *
     * getPS() forces any "cached" flags to be resolved first, and setPS() must do extra work above
     * and beyond setting the arithmetic and logical flags, so on balance, the code below may be more
     * efficient, and may also avoid unexpected side-effects of updating the entire PS register.
     */
    let ah = (this.regEAX >> 8) & 0xff;
    if (ah & X86.PS.CF) this.setCF(); else this.clearCF();
    if (ah & X86.PS.PF) this.setPF(); else this.clearPF();
    if (ah & X86.PS.AF) this.setAF(); else this.clearAF();
    if (ah & X86.PS.ZF) this.setZF(); else this.clearZF();
    if (ah & X86.PS.SF) this.setSF(); else this.clearSF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;

};

/**
 * op=0x9F (LAHF)
 *
 * @this {CPUX86}
 */
X86.opLAHF = function()
{
    /*
     * Apparently, this simply uses the low 8 bits of PS as-is (ie, we don't need to mask with PS_SAHF).
     */
    this.regEAX = (this.regEAX & ~0xff00) | (this.getPS() & 0xff) << 8;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xA0 (MOV AL,mem)
 *
 * @this {CPUX86}
 */
X86.opMOVALm = function()
{
    this.regEAX = (this.regEAX & ~0xff) | this.getSOByte(this.segData, this.getIPAddr());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesMovAM;
};

/**
 * op=0xA1 (MOV [E]AX,mem)
 *
 * @this {CPUX86}
 */
X86.opMOVAXm = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | this.getSOWord(this.segData, this.getIPAddr());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesMovAM;
};

/**
 * op=0xA2 (MOV mem,AL)
 *
 * @this {CPUX86}
 */
X86.opMOVmAL = function()
{
    if (BACKTRACK) this.backTrack.btiMem0 = this.backTrack.btiAL;
    /*
     * setSOByte() truncates the value as appropriate
     */
    this.setSOByte(this.segData, this.getIPAddr(), this.regEAX);
    this.nStepCycles -= this.cycleCounts.nOpCyclesMovMA;
};

/**
 * op=0xA3 (MOV mem,AX)
 *
 * @this {CPUX86}
 */
X86.opMOVmAX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiAL; this.backTrack.btiMem1 = this.backTrack.btiAH;
    }
    /*
     * setSOWord() truncates the value as appropriate
     */
    this.setSOWord(this.segData, this.getIPAddr(), this.regEAX);
    this.nStepCycles -= this.cycleCounts.nOpCyclesMovMA;
};

/**
 * op=0xA4 (MOVSB)
 *
 * @this {CPUX86}
 */
X86.opMOVSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesMovS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesMovSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesMovSr0;
    }
    if (nReps--) {
        this.setSOByte(this.segES, this.regEDI & maskAddr, this.getSOByte(this.segData, this.regESI & maskAddr));
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        let nInc = ((this.regPS & X86.PS.DF)? -1 : 1);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + nInc) & maskAddr);
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + nInc) & maskAddr);
        this.nStepCycles -= nCycles;
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        if (nReps) this.rewindIP(true);
    }
};

/**
 * op=0xA5 (MOVSW)
 *
 * @this {CPUX86}
 */
X86.opMOVSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesMovS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesMovSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesMovSr0;
    }
    if (nReps--) {
        this.setSOWord(this.segES, this.regEDI & maskAddr, this.getSOWord(this.segData, this.regESI & maskAddr));
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        let nInc = ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + nInc) & maskAddr);
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + nInc) & maskAddr);
        this.nStepCycles -= nCycles;
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        if (nReps) this.rewindIP(true);
    }
};

/**
 * op=0xA6 (CMPSB)
 *
 * @this {CPUX86}
 */
X86.opCMPSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesCmpS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesCmpSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesCmpSr0;
    }
    if (nReps--) {
        let bDst = this.getEAByte(this.segData, this.regESI);
        let bSrc = this.getEAByte(this.segES, this.regEDI);
        this.regEAWrite = this.regEA;           // TODO: Is this necessary?
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        X86.fnCMPb.call(this, bDst, bSrc);
        let nInc = ((this.regPS & X86.PS.DF)? -1 : 1);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + nInc) & maskAddr);
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + nInc) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        /*
         * NOTE: As long as we're calling fnCMPb(), all our cycle times must be reduced by nOpCyclesArithRM
         */
        this.nStepCycles -= nCycles - this.cycleCounts.nOpCyclesArithRM;
        /*
         * Repetition continues while ZF matches bit 0 of the REP prefix.  getZF() returns 0x40 if ZF is
         * set, and OP_REPZ (which represents the REP prefix whose bit 0 is set) is 0x40 as well, so when those
         * two values are equal, we must continue.
         */
        if (nReps && this.getZF() == (this.opPrefixes & X86.OPFLAG.REPZ)) this.rewindIP(true);
    }
};

/**
 * op=0xA7 (CMPSW)
 *
 * @this {CPUX86}
 */
X86.opCMPSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesCmpS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesCmpSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesCmpSr0;
    }
    if (nReps--) {
        let wDst = this.getEAWord(this.segData, this.regESI & maskAddr);
        let wSrc = this.getEAWord(this.segES, this.regEDI & maskAddr);
        this.regEAWrite = this.regEA;           // TODO: Is this necessary?
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        X86.fnCMPw.call(this, wDst, wSrc);
        let nInc = ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + nInc) & maskAddr);
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + nInc) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        /*
         * NOTE: As long as we're calling fnCMPw(), all our cycle times must be reduced by nOpCyclesArithRM
         */
        this.nStepCycles -= nCycles - this.cycleCounts.nOpCyclesArithRM;
        /*
         * Repetition continues while ZF matches bit 0 of the REP prefix.  getZF() returns 0x40 if ZF is
         * set, and OP_REPZ (which represents the REP prefix whose bit 0 is set) is 0x40 as well, so when those
         * two values are equal, we must continue.
         */
        if (nReps && this.getZF() == (this.opPrefixes & X86.OPFLAG.REPZ)) this.rewindIP(true);
    }
};

/**
 * op=0xA8 (TEST AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opTESTALb = function()
{
    this.setLogicResult(this.regEAX & this.getIPByte(), X86.RESULT.BYTE);
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;
};

/**
 * op=0xA9 (TEST [E]AX,imm)
 *
 * @this {CPUX86}
 */
X86.opTESTAX = function()
{
    this.setLogicResult(this.regEAX & this.getIPWord(), this.typeData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;
};

/**
 * op=0xAA (STOSB)
 *
 * NOTES: Segment overrides are ignored for this instruction, so we must use segES instead of segData.
 *
 * @this {CPUX86}
 */
X86.opSTOSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesStoS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesStoSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesStoSr0;
    }
    if (nReps--) {
        this.setSOByte(this.segES, this.regEDI & maskAddr, this.regEAX);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        if (BACKTRACK) this.backTrack.btiMem0 = this.backTrack.btiAL;

        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);

        /*
         * Implement 80386 B1 Errata #7, to the extent that Windows 95 checked for it.  This test doesn't
         * detect every possible variation (for example, the ADDRESS override on the next instruction, if
         * it exists, may not be the first prefix byte), but it's adequate for our limited purpose.
         *
         * Note that this code alters maskAddr AFTER it's been used to update ECX, because in the case
         * of STOS, the errata reportedly affects only EDI.  The other instructions mentioned in the errata
         * trash different registers, so read the errata carefully.
         *
         * TODO: Extend this errata to STOSW, as well as MOVSB, MOVSW, INSB, and INSW.  Also, verify the
         * extent to which this errata existed on earlier 80386 steppings (I'm currently assuming A0-B1).
         */
        if (this.stepping >= X86.STEPPING_80386_A0 && this.stepping <= X86.STEPPING_80386_B2) {
            if (!(this.opPrefixes & X86.OPFLAG.ADDRSIZE) != (this.getByte(this.regLIP) != X86.OPCODE.AS)) {
                maskAddr ^= (0xffff0000|0);
            }
        }
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);

        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0xAB (STOSW)
 *
 * NOTES: Segment overrides are ignored for this instruction, so we must use segES instead of segData.
 *
 * @this {CPUX86}
 */
X86.opSTOSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesStoS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesStoSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesStoSr0;
    }
    if (nReps--) {
        this.setSOWord(this.segES, this.regEDI & maskAddr, this.regEAX);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiAL; this.backTrack.btiMem1 = this.backTrack.btiAH;
        }
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0xAC (LODSB)
 *
 * @this {CPUX86}
 */
X86.opLODSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesLodS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesLodSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesLodSr0;
    }
    if (nReps--) {
        let b = this.getSOByte(this.segData, this.regESI & maskAddr);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP(true);
    }
};

/**
 * op=0xAD (LODSW)
 *
 * @this {CPUX86}
 */
X86.opLODSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesLodS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesLodSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesLodSr0;
    }
    if (nReps--) {
        let w = this.getSOWord(this.segData, this.regESI & maskAddr);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEAX = (this.regEAX & ~this.maskData) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
        }
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP(true);
    }
};

/**
 * op=0xAE (SCASB)
 *
 * @this {CPUX86}
 */
X86.opSCASb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesScaS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesScaSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesScaSr0;
    }
    if (nReps--) {
        let bDst = this.regEAX & 0xff;
        let bSrc = this.getEAByte(this.segES, this.regEDI);
        this.regEAWrite = this.regEA;           // TODO: Is this necessary?
        X86.fnCMPb.call(this, bDst, bSrc);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        /*
         * NOTE: As long as we're calling fnCMPb(), all our cycle times must be reduced by nOpCyclesArithRM
         */
        this.nStepCycles -= nCycles - this.cycleCounts.nOpCyclesArithRM;
        /*
         * Repetition continues while ZF matches bit 0 of the REP prefix.  getZF() returns 0x40 if ZF is
         * set, and OP_REPZ (which represents the REP prefix whose bit 0 is set) is 0x40 as well, so when those
         * two values are equal, we must continue.
         */
        if (nReps && this.getZF() == (this.opPrefixes & X86.OPFLAG.REPZ)) this.rewindIP();
    }
};

/**
 * op=0xAF (SCASW)
 *
 * @this {CPUX86}
 */
X86.opSCASw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesScaS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesScaSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesScaSr0;
    }
    if (nReps--) {
        let wDst = this.regEAX & this.maskData;
        let wSrc = this.getEAWord(this.segES, this.regEDI & maskAddr);
        this.regEAWrite = this.regEA;           // TODO: Is this necessary?
        X86.fnCMPw.call(this, wDst, wSrc);
        /*
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        /*
         * NOTE: As long as we're calling fnCMPw(), all our cycle times must be reduced by nOpCyclesArithRM
         */
        this.nStepCycles -= nCycles - this.cycleCounts.nOpCyclesArithRM;
        /*
         * Repetition continues while ZF matches bit 0 of the REP prefix.  getZF() returns 0x40 if ZF is
         * set, and OP_REPZ (which represents the REP prefix whose bit 0 is set) is 0x40 as well, so when those
         * two values are equal, we must continue.
         */
        if (nReps && this.getZF() == (this.opPrefixes & X86.OPFLAG.REPZ)) this.rewindIP();
    }
};

/**
 * op=0xB0 (MOV AL,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | this.getIPByte();
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB1 (MOV CL,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVCLb = function()
{
    this.regECX = (this.regECX & ~0xff) | this.getIPByte();
    if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB2 (MOV DL,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVDLb = function()
{
    this.regEDX = (this.regEDX & ~0xff) | this.getIPByte();
    if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB3 (MOV BL,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVBLb = function()
{
    this.regEBX = (this.regEBX & ~0xff) | this.getIPByte();
    if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB4 (MOV AH,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVAHb = function()
{
    this.regEAX = (this.regEAX & ~0xff00) | (this.getIPByte() << 8);
    if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB5 (MOV CH,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVCHb = function()
{
    this.regECX = (this.regECX & ~0xff00) | (this.getIPByte() << 8);
    if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB6 (MOV DH,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVDHb = function()
{
    this.regEDX = (this.regEDX & ~0xff00) | (this.getIPByte() << 8);
    if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB7 (MOV BH,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVBHb = function()
{
    this.regEBX = (this.regEBX & ~0xff00) | (this.getIPByte() << 8);
    if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB8 (MOV [E]AX,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB9 (MOV [E]CX,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVCX = function()
{
    this.regECX = (this.regECX & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiCL = this.backTrack.btiMem0; this.backTrack.btiCH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBA (MOV [E]DX,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVDX = function()
{
    this.regEDX = (this.regEDX & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiDL = this.backTrack.btiMem0; this.backTrack.btiDH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBB (MOV [E]BX,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVBX = function()
{
    this.regEBX = (this.regEBX & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiBL = this.backTrack.btiMem0; this.backTrack.btiBH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBC (MOV [E]SP,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVSP = function()
{
    this.setSP((this.getSP() & ~this.maskData) | this.getIPWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBD (MOV [E]BP,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVBP = function()
{
    this.regEBP = (this.regEBP & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiBPLo = this.backTrack.btiMem0; this.backTrack.btiBPHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBE (MOV [E]SI,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVSI = function()
{
    this.regESI = (this.regESI & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiSILo = this.backTrack.btiMem0; this.backTrack.btiSIHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBF (MOV [E]DI,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVDI = function()
{
    this.regEDI = (this.regEDI & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiDILo = this.backTrack.btiMem0; this.backTrack.btiDIHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xC0 (GRP2 byte,imm8) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opGRP2bn = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp2b, X86.helpSRCByte);
};

/**
 * op=0xC1 (GRP2 word,imm) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opGRP2wn = function()
{
    this.decodeModGrpWord.call(this, this.sizeData == 2? X86.aOpGrp2w : X86.aOpGrp2d, X86.helpSRCByte);
};

/**
 * op=0xC2 (RET n)
 *
 * @this {CPUX86}
 */
X86.opRETn = function()
{
    let n = this.getIPShort();
    let newIP = this.popWord();
    this.setIP(newIP);
    if (n) this.setSP(this.getSP() + n);            // TODO: optimize
    this.nStepCycles -= this.cycleCounts.nOpCyclesRetn;
};

/**
 * op=0xC3 (RET)
 *
 * @this {CPUX86}
 */
X86.opRET = function()
{
    let newIP = this.popWord();
    this.setIP(newIP);
    this.nStepCycles -= this.cycleCounts.nOpCyclesRet;
};

/**
 * op=0xC4 (LES reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads ES from the next word.
 *
 * @this {CPUX86}
 */
X86.opLES = function()
{
    this.decodeModRegWord.call(this, X86.fnLES);
};

/**
 * op=0xC5 (LDS reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads DS from the next word.
 *
 * @this {CPUX86}
 */
X86.opLDS = function()
{
    this.decodeModRegWord.call(this, X86.fnLDS);
};

/**
 * op=0xC6 (MOV byte,imm8)
 *
 * @this {CPUX86}
 */
X86.opMOVb = function()
{
    /*
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModGrpByte.call(this, X86.aOpGrpMOVn, this.getIPByte);
};

/**
 * op=0xC7 (MOV word,imm)
 *
 * @this {CPUX86}
 */
X86.opMOVw = function()
{
    /*
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModGrpWord.call(this, X86.aOpGrpMOVn, this.getIPWord);
};

/**
 * op=0xC8 (ENTER imm16,imm8) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opENTER = function()
{
    /*
     * Any operation that performs multiple stack modifications must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    let wLocal = this.getIPShort();
    let bLevel = this.getIPByte() & 0x1f;
    /*
     * NOTE: 11 is the minimum cycle time for the 80286; the 80186/80188 has different cycle times: 15, 25 and
     * 22 + 16 * (bLevel - 1) for bLevel 0, 1 and > 1, respectively.  TODO: Fix this someday.
     */
    this.nStepCycles -= 11;
    this.pushWord(this.regEBP);
    let wFrame = this.getSP() & this.maskData;
    if (bLevel > 0) {
        this.nStepCycles -= (bLevel << 2) + (bLevel > 1? 1 : 0);
        while (--bLevel) {
            this.regEBP = (this.regEBP & ~this.maskData) | ((this.regEBP - this.sizeData) & this.maskData);
            this.pushWord(this.getSOWord(this.segSS, this.regEBP & this.maskData));
        }
        this.pushWord(wFrame);
    }
    this.regEBP = (this.regEBP & ~this.maskData) | wFrame;
    this.setSP((this.getSP() & ~this.segSS.maskAddr) | ((this.getSP() - wLocal) & this.segSS.maskAddr));

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0xC9 (LEAVE) (80186/80188 and up)
 *
 * @this {CPUX86}
 */
X86.opLEAVE = function()
{
    /*
     * Any operation that performs multiple stack modifications must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    this.setSP((this.getSP() & ~this.segSS.maskAddr) | (this.regEBP & this.segSS.maskAddr));

    this.regEBP = (this.regEBP & ~this.maskData) | (this.popWord() & this.maskData);
    /*
     * NOTE: 5 is the cycle time for the 80286; the 80186/80188 has a cycle time of 8.  TODO: Fix this someday.
     */
    this.nStepCycles -= 5;

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0xCA (RETF n)
 *
 * @this {CPUX86}
 */
X86.opRETFn = function()
{
    X86.helpRETF.call(this, this.getIPShort());
    this.nStepCycles -= this.cycleCounts.nOpCyclesRetFn;
};

/**
 * op=0xCB (RETF)
 *
 * @this {CPUX86}
 */
X86.opRETF = function()
{
    X86.helpRETF.call(this, 0);
    this.nStepCycles -= this.cycleCounts.nOpCyclesRetF;
};

/**
 * op=0xCC (INT 3)
 *
 * @this {CPUX86}
 */
X86.opINT3 = function()
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
        if (DEBUG) this.printMessage("INT 0x03 in v86-mode (IOPL < 3)", this.bitsMessage, true);
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    /*
     * Because INT3 is a trap, not a fault, we must use helpTrap() rather than helpFault().  Unfortunately, that
     * means you can't rely on the Debugger logic instead helpFault() to conditionally stop execution on an INT3,
     * so I've changed the Debugger's checkBreakpoint() function to stop execution on INT3 whenever both the
     * INT and HALT message bits are set; a simple "g" command allows you to continue.
     */
    X86.helpTrap.call(this, X86.EXCEPTION.BP_TRAP, this.cycleCounts.nOpCyclesInt3D);
};

/**
 * op=0xCD (INT n)
 *
 * @this {CPUX86}
 */
X86.opINTn = function()
{
    let nInt = this.getIPByte();
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
        if (DEBUG && this.messageEnabled()) this.printMessage("INT " + Str.toHexByte(nInt) + " in v86-mode (IOPL < 3)", true, true);
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    /*
     * checkIntNotify() checks for any notification handlers registered via addIntNotify(), calls them,
     * and returns false ONLY if a notification handler returned false (ie, requesting the interrupt be skipped).
     */
    if (this.checkIntNotify(nInt)) {
        X86.helpTrap.call(this, nInt, 0);
        return;
    }
    this.nStepCycles--;     // we don't need to assess the full cost of nOpCyclesInt, but we need to assess something...
};

/**
 * op=0xCE (INTO: INT 4 if OF set)
 *
 * @this {CPUX86}
 */
X86.opINTO = function()
{
    if (this.getOF()) {
        /*
         * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
         */
        if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
            if (DEBUG) this.printMessage("INTO in v86-mode (IOPL < 3)", this.bitsMessage, true);
            X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
            return;
        }
        X86.helpTrap.call(this, X86.EXCEPTION.OF_TRAP, this.cycleCounts.nOpCyclesIntOD);
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesIntOFall;
};

/**
 * op=0xCF (IRET)
 *
 * @this {CPUX86}
 */
X86.opIRET = function()
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
        if (DEBUG) this.printMessage("IRET in v86-mode (IOPL < 3)", this.bitsMessage, true);
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    X86.helpIRET.call(this);
};

/**
 * op=0xD0 (GRP2 byte,1)
 *
 * @this {CPUX86}
 */
X86.opGRP2b1 = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp2b, X86.helpSRC1);
};

/**
 * op=0xD1 (GRP2 word,1)
 *
 * @this {CPUX86}
 */
X86.opGRP2w1 = function()
{
    this.decodeModGrpWord.call(this, this.sizeData == 2? X86.aOpGrp2w : X86.aOpGrp2d, X86.helpSRC1);
};

/**
 * op=0xD2 (GRP2 byte,CL)
 *
 * @this {CPUX86}
 */
X86.opGRP2bCL = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp2b, X86.helpSRCCL);
};

/**
 * op=0xD3 (GRP2 word,CL)
 *
 * @this {CPUX86}
 */
X86.opGRP2wCL = function()
{
    this.decodeModGrpWord.call(this, this.sizeData == 2? X86.aOpGrp2w : X86.aOpGrp2d, X86.helpSRCCL);
};

/**
 * op=0xD4 0x0A (AAM)
 *
 * From "The 8086 Book":
 *
 *      1. Divide AL by 0x0A; store the quotient in AH and the remainder in AL
 *      2. Set PF, SF, and ZF based on the AL register (CF, OF, and AF are undefined)
 *
 * From "Undocumented Opcodes" (http://www.rcollins.org/secrets/opcodes/AAM.html):
 *
 *      AAM is shown as a two byte encoding used to divide AL by 10, putting the quotient in AH, and the remainder in AL.
 *      However, AAM is listed in the op code map as a single byte instruction. This leads one to wonder why a two-byte
 *      opcode is listed in the single-byte opcode map. In reality, the second byte is an undocumented operand to AAM.
 *      The operand is the divisor. In its documented incarnation, AAM is encoded as D4 0A. The operand 0A is the divisor.
 *      This divisor can be changed to any value between 0 and FF.
 *
 *      Using AAM in this manner is useful -- as it extends the CPU instruction set to include a DIV IMM8 instruction
 *      that is not available from any other form of the DIV instruction. The extended form of the AAM instruction is also
 *      useful because it sets the flags register according to the results, unlike the DIV or IDIV instruction.
 *
 *      According to Intel documentation, SF, ZF, and PF flags are set according to the result, while OF, AF, and CF
 *      are undefined. However, if AAM were used strictly as documented, then the Sign Flag (SF) could not be set under
 *      any circumstances, since anything divided by 10 will leave a remainder between 0 and 9. Obviously the remainder
 *      could never be between 128 and 255 (or -1 and -128 if you prefer) if used only as documented. Since AAM divides
 *      an 8 bit number by another 8-bit number, a carry or overflow could never occur. Therefore CF and OF always=0.
 *      Intel claims they are undefined, but my observations are consistent with my theory.
 *
 *      Contrary to documentation, AAM will generate exceptions in real mode, protected mode, and V86 mode. AAM can only
 *      generate Exception 0 -- divide by 0.
 *
 *      Finally, in the Pentium User's Manual, this heretofore undocumented form of AMM is described. Intel says:
 *
 *          Note: imm8 has the value of the instruction's second byte. The second byte under normally assembly [sic] of
 *          this instruction will be 0A, however, explicit modification of this byte will result in the operation described
 *          above and may alter results.
 *
 *      This instruction exists in this form on all Intel x86 processors. See the file [AAM.ASM](/docs/x86/ops/AAM/AAM.ASM)
 *      for diagnostics source code for this instruction.
 *
 * @this {CPUX86}
 */
X86.opAAM = function()
{
    let b = this.getIPByte();
    if (!b) {
        X86.helpDIVOverflow.call(this);
        return;
    }
    let AL = this.regEAX & 0xff;
    this.regEAX = (this.regEAX & ~0xffff) | ((AL / b) << 8) | (AL % b);
    /*
     * setLogicResult() is perfect, because it ensures that CF and OF are cleared as well (see above for why).
     */
    this.setLogicResult(this.regEAX, X86.RESULT.BYTE);
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAM;
};

/**
 * op=0xD5 (AAD)
 *
 * From "The 8086 Book":
 *
 *      1. Multiply AH by 0x0A, add AH to AL, and store 0x00 in AH
 *      2. Set PF, SF, and ZF based on the AL register (CF, OF, and AF are undefined)
 *
 * From "Undocumented Opcodes" (http://www.rcollins.org/secrets/opcodes/AAD.html):
 *
 *      This instruction is the multiplication counterpart to AAM. As is the case with AAM, AAD uses the second
 *      byte as an operand. This operand is the multiplicand for AAD. Like AAM, AAD provides a way to execute a MUL
 *      IMM8 that is unavailable through any other means in the CPU.
 *
 *      Unlike MUL, or IMUL, AAD sets all of the CPU status flags according to the result. Intel states that the
 *      Overflow Flag (OF), Auxiliary carry Flag (AF), and Carry Flag (CF) are undefined. This assertion is incorrect.
 *      These flags are fully defined, and are set consistently with respect to any other integer operations.
 *
 *      And again, like AMM, beginning with the Pentium, Intel has finally acknowledged the existence of the second
 *      byte of this instruction as its operand. Intel says:
 *
 *          Note: imm8 has the value of the instruction's second byte. The second byte under normally assembly [sic]
 *          of this instruction will be 0A, however, explicit modification of this byte will result in the operation
 *          described above and may alter results.
 *
 *      This instruction exists in this form on all Intel x86 processors. See the file [AAD.ASM](/docs/x86/ops/AAD/AAD.ASM)
 *      for diagnostics source code for this instruction.
 *
 * TODO: Confirm on real hardware that flags reflect the result of the final addition (ie, that the result of the
 * intermediate multiplication is irrelevant); it also might be nice to confirm that an operand override has no effect.
 *
 * @this {CPUX86}
 */
X86.opAAD = function()
{
    let dst = (this.regEAX & 0xff);
    let src = (((this.regEAX >> 8) & 0xff) * this.getIPByte())|0;
    let result = (dst + src)|0;
    this.regEAX = (this.regEAX & ~0xffff) | (result & 0xff);
    this.setArithResult(dst, src, result, X86.RESULT.BYTE | X86.RESULT.ALL);
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAD;
};

/**
 * op=0xD6 (SALC aka SETALC) (undocumented until Pentium Pro)
 *
 * Sets AL to 0xFF if CF=1, 0x00 otherwise; no flags are affected (similar to SBBÂ AL,AL, but without side-effects)
 *
 * WARNING: I have no idea how many clocks this instruction originally required, so for now, I'm going with a minimum of 2.
 *
 * @this {CPUX86}
 */
X86.opSALC = function()
{
    this.regEAX = (this.regEAX & ~0xff) | (this.getCF()? 0xFF : 0);
    this.nStepCycles -= 2;
};

/**
 * op=0xD7 (XLAT)
 *
 * @this {CPUX86}
 */
X86.opXLAT = function()
{
    /*
     * TODO: Verify whether XLAT wraps its address calculation....
     */
    this.regEAX = (this.regEAX & ~0xff) | this.getEAByte(this.segData, (this.regEBX + (this.regEAX & 0xff)));
    this.nStepCycles -= this.cycleCounts.nOpCyclesXLAT;
};

/**
 * opESC()
 *
 * @this {CPUX86}
 * @param {number} bOpcode
 */
X86.opESC = function(bOpcode)
{
    this.bOpcode = bOpcode;
    this.decodeModRegWord.call(this, X86.fnESC);
};

/**
 * op=0xD8 (ESC0)
 *
 * @this {CPUX86}
 */
X86.opESC0 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC0);
};

/**
 * op=0xD9 (ESC1)
 *
 * @this {CPUX86}
 */
X86.opESC1 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC1);
};

/**
 * op=0xDA (ESC2)
 *
 * @this {CPUX86}
 */
X86.opESC2 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC2);
};

/**
 * op=0xDB (ESC3)
 *
 * @this {CPUX86}
 */
X86.opESC3 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC3);
};

/**
 * op=0xDC (ESC4)
 *
 * @this {CPUX86}
 */
X86.opESC4 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC4);
};

/**
 * op=0xDD (ESC5)
 *
 * @this {CPUX86}
 */
X86.opESC5 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC5);
};

/**
 * op=0xDE (ESC6)
 *
 * @this {CPUX86}
 */
X86.opESC6 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC6);
};

/**
 * op=0xDF (ESC7)
 *
 * @this {CPUX86}
 */
X86.opESC7 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC7);
};

/**
 * op=0xE0 (LOOPNZ disp)
 *
 * NOTE: All the instructions in this group (LOOPNZ, LOOPZ, LOOP, and JCXZ) actually
 * rely on the ADDRESS override setting for determining whether CX or ECX will be used,
 * even though it seems counter-intuitive; ditto for the REP prefix.
 *
 * @this {CPUX86}
 */
X86.opLOOPNZ = function()
{
    let disp = this.getIPDisp();
    let n = (this.regECX - 1) & this.maskAddr;
    this.regECX = (this.regECX & ~this.maskAddr) | n;
    if (n && !this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesLoopNZ;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLoopFall;
};

/**
 * op=0xE1 (LOOPZ disp)
 *
 * NOTE: All the instructions in this group (LOOPNZ, LOOPZ, LOOP, and JCXZ) actually
 * rely on the ADDRESS override setting for determining whether CX or ECX will be used,
 * even though it seems counter-intuitive; ditto for the REP prefix.
 *
 * @this {CPUX86}
 */
X86.opLOOPZ = function()
{
    let disp = this.getIPDisp();
    let n = (this.regECX - 1) & this.maskAddr;
    this.regECX = (this.regECX & ~this.maskAddr) | n;
    if (n && this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesLoopZ;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLoopZFall;
};

/**
 * op=0xE2 (LOOP disp)
 *
 * NOTE: All the instructions in this group (LOOPNZ, LOOPZ, LOOP, and JCXZ) actually
 * rely on the ADDRESS override setting for determining whether CX or ECX will be used,
 * even though it seems counter-intuitive; ditto for the REP prefix.
 *
 * @this {CPUX86}
 */
X86.opLOOP = function()
{
    let disp = this.getIPDisp();
    let n = (this.regECX - 1) & this.maskAddr;
    this.regECX = (this.regECX & ~this.maskAddr) | n;
    if (n) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesLoop;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLoopFall;
};

/**
 * op=0xE3 (JCXZ/JECXZ disp)
 *
 * NOTE: All the instructions in this group (LOOPNZ, LOOPZ, LOOP, and JCXZ) actually
 * rely on the ADDRESS override setting for determining whether CX or ECX will be used,
 * even though it seems counter-intuitive; ditto for the REP prefix.
 *
 * @this {CPUX86}
 */
X86.opJCXZ = function()
{
    let disp = this.getIPDisp();
    if (!(this.regECX & this.maskAddr)) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesLoopZ;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLoopZFall;
};

/**
 * op=0xE4 (IN AL,port)
 *
 * @this {CPUX86}
 */
X86.opINb = function()
{
    let port = this.getIPByte();
    if (!this.checkIOPM(port, 1, true)) return;
    this.regEAX = (this.regEAX & ~0xff) | (this.bus.checkPortInputNotify(port, 1, this.regLIP - 2) & 0xff);
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiIO;
    this.nStepCycles -= this.cycleCounts.nOpCyclesInP;
};

/**
 * op=0xE5 (IN AX,port)
 *
 * @this {CPUX86}
 */
X86.opINw = function()
{
    let port = this.getIPByte();
    if (!this.checkIOPM(port, this.sizeData, true)) return;
    this.regEAX = (this.regEAX & ~this.maskData) | (this.bus.checkPortInputNotify(port, this.sizeData, this.regLIP - 2) & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiIO;
        this.backTrack.btiAH = this.backTrack.btiIO;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesInP;
};

/**
 * op=0xE6 (OUT port,AL)
 *
 * @this {CPUX86}
 */
X86.opOUTb = function()
{
    let port = this.getIPByte();
    if (!this.checkIOPM(port, 1, false)) return;
    this.bus.checkPortOutputNotify(port, 1, this.regEAX & 0xff, this.regLIP - 2);
    this.nStepCycles -= this.cycleCounts.nOpCyclesOutP;
};

/**
 * op=0xE7 (OUT port,AX)
 *
 * @this {CPUX86}
 */
X86.opOUTw = function()
{
    let port = this.getIPByte();
    if (!this.checkIOPM(port, this.sizeData, false)) return;
    this.bus.checkPortOutputNotify(port, this.sizeData, this.regEAX & this.maskData, this.regLIP - 2);
    this.nStepCycles -= this.cycleCounts.nOpCyclesOutP;
};

/**
 * op=0xE8 (CALL disp16)
 *
 * @this {CPUX86}
 */
X86.opCALL = function()
{
    let disp = this.getIPWord();
    let oldIP = this.getIP();
    let newIP = oldIP + disp;
    this.pushWord(oldIP);
    this.setIP(newIP);
    this.nStepCycles -= this.cycleCounts.nOpCyclesCall;
};

/**
 * op=0xE9 (JMP disp16)
 *
 * @this {CPUX86}
 */
X86.opJMP = function()
{
    let disp = this.getIPWord();
    this.setIP(this.getIP() + disp);
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmp;
};

/**
 * op=0xEA (JMP seg:off)
 *
 * @this {CPUX86}
 */
X86.opJMPF = function()
{
    this.setCSIP(this.getIPWord(), this.getIPShort());
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpF;
};

/**
 * op=0xEB (JMP short disp8)
 *
 * @this {CPUX86}
 */
X86.opJMPs = function()
{
    let disp = this.getIPDisp();
    this.setIP(this.getIP() + disp);
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmp;
};

/**
 * op=0xEC (IN AL,dx)
 *
 * @this {CPUX86}
 */
X86.opINDXb = function()
{
    let port = this.regEDX & 0xffff;
    if (!this.checkIOPM(port, 1, true)) return;
    this.regEAX = (this.regEAX & ~0xff) | (this.bus.checkPortInputNotify(port, 1, this.regLIP - 1) & 0xff);
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiIO;
    this.nStepCycles -= this.cycleCounts.nOpCyclesInDX;
};

/**
 * op=0xED (IN AX,dx)
 *
 * @this {CPUX86}
 */
X86.opINDXw = function()
{
    let port = this.regEDX & 0xffff;
    if (!this.checkIOPM(port, this.sizeData, true)) return;
    this.regEAX = (this.regEAX & ~this.maskData) | (this.bus.checkPortInputNotify(port, this.sizeData, this.regLIP - 1) & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiIO;
        this.backTrack.btiAH = this.backTrack.btiIO;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesInDX;
};

/**
 * op=0xEE (OUT dx,AL)
 *
 * @this {CPUX86}
 */
X86.opOUTDXb = function()
{
    let port = this.regEDX & 0xffff;
    if (!this.checkIOPM(port, 1, false)) return;
    if (BACKTRACK) this.backTrack.btiIO = this.backTrack.btiAL;
    this.bus.checkPortOutputNotify(port, 1, this.regEAX & 0xff, this.regLIP - 1);
    this.nStepCycles -= this.cycleCounts.nOpCyclesOutDX;
};

/**
 * op=0xEF (OUT dx,AX)
 *
 * @this {CPUX86}
 */
X86.opOUTDXw = function()
{
    let port = this.regEDX & 0xffff;
    if (!this.checkIOPM(port, 2, false)) return;
    if (BACKTRACK) {
        this.backTrack.btiIO = this.backTrack.btiAL;
        this.backTrack.btiIO = this.backTrack.btiAH;
    }
    this.bus.checkPortOutputNotify(port, this.sizeData, this.regEAX & this.maskData, this.regLIP - 1);
    this.nStepCycles -= this.cycleCounts.nOpCyclesOutDX;
};

/**
 * op=0xF0 (LOCK:)
 *
 * @this {CPUX86}
 */
X86.opLOCK = function()
{
    this.opFlags |= X86.OPFLAG.LOCK | X86.OPFLAG.NOINTR;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0xF1 (INT1; undocumented; 80386 and up)
 *
 * For the 8086/8088, we treat opcode 0xF1 as an alias for LOCK (0xF0).
 *
 * For the 80186 and 80286, and we treat it as undefined.  Starting with the 80386, this opcode is known as INT1
 * or ICEBP, since it effectively performs an INT 0x01 but is normally only performed with an ICE.
 *
 * @this {CPUX86}
 */
X86.opINT1 = function()
{
    /*
     * TODO: Verify this instruction's behavior.
     */
    X86.helpTrap.call(this, X86.EXCEPTION.DB_EXC, this.cycleCounts.nOpCyclesInt3D);
};

/**
 * op=0xF2 (REPNZ:) (repeat CMPS or SCAS until NZ; repeat MOVS, LODS, or STOS unconditionally)
 *
 * @this {CPUX86}
 */
X86.opREPNZ = function()
{
    this.opFlags |= X86.OPFLAG.REPNZ | X86.OPFLAG.NOINTR;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0xF3 (REPZ:) (repeat CMPS or SCAS until Z; repeat MOVS, LODS, or STOS unconditionally)
 *
 * @this {CPUX86}
 */
X86.opREPZ = function()
{
    this.opFlags |= X86.OPFLAG.REPZ | X86.OPFLAG.NOINTR;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0xF4 (HLT)
 *
 * @this {CPUX86}
 */
X86.opHLT = function()
{
    if (I386 && (this.regPS & X86.PS.VM)) {
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    /*
     * The CPU is never REALLY halted by a HLT instruction; instead, by setting X86.INTFLAG.HALT,
     * we are signalling to stepCPU() that it's free to end the current burst AND that it should not
     * execute any more instructions until checkINTR() indicates a hardware interrupt is requested.
     */
    this.intFlags |= X86.INTFLAG.HALT;
    this.nStepCycles -= 2;
    /*
     * If a Debugger is present and both the CPU and HALT message categories are enabled, then we
     * REALLY halt the CPU, on the theory that whoever's using the Debugger would like to see HLTs.
     */
    if (DEBUGGER && this.dbg && this.messageEnabled(Messages.CPU | Messages.HALT)) {
        this.resetIP();         // this is purely for the Debugger's benefit, to show the HLT
        this.dbg.stopCPU();
        return;
    }
    /*
     * We also REALLY halt the machine if interrupts have been disabled, since that means it's dead in
     * the water (yes, we support NMIs, but none of our devices are going to generate an NMI at this point).
     */
    if (!this.getIF()) {
        if (DEBUGGER && this.dbg) this.resetIP();
        this.stopCPU();
    }
};

/**
 * op=0xF5 (CMC)
 *
 * @this {CPUX86}
 */
X86.opCMC = function()
{
    if (this.getCF()) this.clearCF(); else this.setCF();
    this.nStepCycles -= 2;                          // CMC takes 2 cycles on all CPUs
};

/**
 * op=0xF6 (GRP3 byte)
 *
 * The MUL byte instruction is problematic in two cases:
 *
 *      0xF6 0xE0:  MUL AL
 *      0xF6 0xE4:  MUL AH
 *
 * because the OpModGrpByte decoder function will attempt to put the fnMULb() function's
 * return value back into AL or AH, undoing fnMULb's update of AX.  And since fnMULb doesn't
 * know what the target is (only the target's value), it cannot easily work around the problem.
 *
 * A simple, albeit kludgy, solution is for fnMULb to always save its result in a special
 * "register" (eg, regMDLo), which we will then put back into regEAX if it's been updated.
 * This also relieves us from having to decode any part of the ModRM byte, so maybe it's not
 * such a bad work-around after all.
 *
 * Similar issues with IMUL (and DIV and IDIV) are resolved using the same special variable(s).
 *
 * @this {CPUX86}
 */
X86.opGRP3b = function()
{
    this.fMDSet = false;
    this.decodeModGrpByte.call(this, X86.aOpGrp3b, X86.helpSRCNone);
    if (this.fMDSet) this.regEAX = (this.regEAX & ~this.maskData) | (this.regMDLo & this.maskData);
};

/**
 * op=0xF7 (GRP3 word)
 *
 * The MUL word instruction is problematic in two cases:
 *
 *      0xF7 0xE0:  MUL AX
 *      0xF7 0xE2:  MUL DX
 *
 * because the OpModGrpWord decoder function will attempt to put the fnMULw() function's
 * return value back into AX or DX, undoing fnMULw's update of DX:AX.  And since fnMULw doesn't
 * know what the target is (only the target's value), it cannot easily work around the problem.
 *
 * A simple, albeit kludgy, solution is for fnMULw to always save its result in a special
 * "register" (eg, regMDLo/regMDHi), which we will then put back into regEAX/regEDX if it's been
 * updated.  This also relieves us from having to decode any part of the ModRM byte, so maybe
 * it's not such a bad work-around after all.
 *
 * @this {CPUX86}
 */
X86.opGRP3w = function()
{
    this.fMDSet = false;
    this.decodeModGrpWord.call(this, X86.aOpGrp3w, X86.helpSRCNone);
    if (this.fMDSet) {
        this.regEAX = (this.regEAX & ~this.maskData) | (this.regMDLo & this.maskData);
        this.regEDX = (this.regEDX & ~this.maskData) | (this.regMDHi & this.maskData);
    }
};

/**
 * op=0xF8 (CLC)
 *
 * @this {CPUX86}
 */
X86.opCLC = function()
{
    this.clearCF();
    this.nStepCycles -= 2;                              // CLC takes 2 cycles on all CPUs
};

/**
 * op=0xF9 (STC)
 *
 * @this {CPUX86}
 */
X86.opSTC = function()
{
    this.setCF();
    this.nStepCycles -= 2;                              // STC takes 2 cycles on all CPUs
};

/**
 * op=0xFA (CLI)
 *
 * @this {CPUX86}
 */
X86.opCLI = function()
{
    /*
     * The following code should be sufficient for all modes, because in real-mode, CPL is always zero,
     * and in V86-mode, CPL is always 3.
     */
    if (this.nCPL > this.nIOPL) {
        if (DEBUG && (this.regPS & X86.PS.VM)) this.printMessage("CLI in v86-mode (IOPL < 3)", this.bitsMessage, true);
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    this.clearIF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesCLI;  // CLI takes LONGER on an 80286
};

/**
 * op=0xFB (STI)
 *
 * @this {CPUX86}
 */
X86.opSTI = function()
{
    /*
     * The following code should be sufficient for all modes, because in real-mode, CPL is always zero,
     * and in V86-mode, CPL is always 3.
     */
    if (this.nCPL > this.nIOPL) {
        if (DEBUG && (this.regPS & X86.PS.VM)) this.printMessage("STI in v86-mode (IOPL < 3)", this.bitsMessage, true);
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    this.setIF();
    this.opFlags |= X86.OPFLAG.NOINTR;
    this.nStepCycles -= 2;                              // STI takes 2 cycles on all CPUs
};

/**
 * op=0xFC (CLD)
 *
 * @this {CPUX86}
 */
X86.opCLD = function()
{
    this.clearDF();
    this.nStepCycles -= 2;                              // CLD takes 2 cycles on all CPUs
};

/**
 * op=0xFD (STD)
 *
 * @this {CPUX86}
 */
X86.opSTD = function()
{
    this.setDF();
    this.nStepCycles -= 2;                              // STD takes 2 cycles on all CPUs
};

/**
 * op=0xFE (GRP4 byte)
 *
 * @this {CPUX86}
 */
X86.opGRP4b = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp4b, X86.helpSRCNone);
};

/**
 * op=0xFF (GRP4 word)
 *
 * @this {CPUX86}
 */
X86.opGRP4w = function()
{
    this.decodeModGrpWord.call(this, X86.aOpGrp4w, X86.helpSRCNone);
};

/**
 * opInvalid()
 *
 * @this {CPUX86}
 */
X86.opInvalid = function()
{
    X86.helpFault.call(this, X86.EXCEPTION.UD_FAULT);
};

/**
 * opUndefined()
 *
 * @this {CPUX86}
 */
X86.opUndefined = function()
{
    this.setIP(this.opLIP - this.segCS.base);
    this.setError("Undefined opcode " + Str.toHexByte(this.getByte(this.regLIP)) + " at " + Str.toHexLong(this.regLIP));
    this.stopCPU();
};

/**
 * opTBD()
 *
 * @this {CPUX86}
 */
X86.opTBD = function()
{
    this.setIP(this.opLIP - this.segCS.base);
    this.printMessage("unimplemented 80386 opcode", true);
    this.stopCPU();
};

/*
 * This 256-entry array of opcode functions is at the heart of the CPU engine: stepCPU(n).
 *
 * It might be worth trying a switch() statement instead, to see how the performance compares,
 * but I suspect that would vary quite a bit across JavaScript engines; for now, I'm putting my
 * money on array lookup.
 */
X86.aOps = [
    X86.opADDmb,            X86.opADDmw,            X86.opADDrb,            X86.opADDrw,        // 0x00-0x03
    X86.opADDALb,           X86.opADDAX,            X86.opPUSHES,           X86.opPOPES,        // 0x04-0x07
    X86.opORmb,             X86.opORmw,             X86.opORrb,             X86.opORrw,         // 0x08-0x0B
    X86.opORALb,            X86.opORAX,             X86.opPUSHCS,           X86.opPOPCS,        // 0x0C-0x0F
    X86.opADCmb,            X86.opADCmw,            X86.opADCrb,            X86.opADCrw,        // 0x10-0x13
    X86.opADCALb,           X86.opADCAX,            X86.opPUSHSS,           X86.opPOPSS,        // 0x14-0x17
    X86.opSBBmb,            X86.opSBBmw,            X86.opSBBrb,            X86.opSBBrw,        // 0x18-0x1B
    X86.opSBBALb,           X86.opSBBAX,            X86.opPUSHDS,           X86.opPOPDS,        // 0x1C-0x1F
    X86.opANDmb,            X86.opANDmw,            X86.opANDrb,            X86.opANDrw,        // 0x20-0x23
    X86.opANDAL,            X86.opANDAX,            X86.opES,               X86.opDAA,          // 0x24-0x27
    X86.opSUBmb,            X86.opSUBmw,            X86.opSUBrb,            X86.opSUBrw,        // 0x28-0x2B
    X86.opSUBALb,           X86.opSUBAX,            X86.opCS,               X86.opDAS,          // 0x2C-0x2F
    X86.opXORmb,            X86.opXORmw,            X86.opXORrb,            X86.opXORrw,        // 0x30-0x33
    X86.opXORALb,           X86.opXORAX,            X86.opSS,               X86.opAAA,          // 0x34-0x37
    X86.opCMPmb,            X86.opCMPmw,            X86.opCMPrb,            X86.opCMPrw,        // 0x38-0x3B
    X86.opCMPALb,           X86.opCMPAX,            X86.opDS,               X86.opAAS,          // 0x3C-0x3F
    X86.opINCAX,            X86.opINCCX,            X86.opINCDX,            X86.opINCBX,        // 0x40-0x43
    X86.opINCSP,            X86.opINCBP,            X86.opINCSI,            X86.opINCDI,        // 0x44-0x47
    X86.opDECAX,            X86.opDECCX,            X86.opDECDX,            X86.opDECBX,        // 0x48-0x4B
    X86.opDECSP,            X86.opDECBP,            X86.opDECSI,            X86.opDECDI,        // 0x4C-0x4F
    X86.opPUSHAX,           X86.opPUSHCX,           X86.opPUSHDX,           X86.opPUSHBX,       // 0x50-0x53
    X86.opPUSHSP_8086,      X86.opPUSHBP,           X86.opPUSHSI,           X86.opPUSHDI,       // 0x54-0x57
    X86.opPOPAX,            X86.opPOPCX,            X86.opPOPDX,            X86.opPOPBX,        // 0x58-0x5B
    X86.opPOPSP,            X86.opPOPBP,            X86.opPOPSI,            X86.opPOPDI,        // 0x5C-0x5F
    /*
     * On an 8086/8088, opcodes 0x60-0x6F are aliases for the conditional jumps 0x70-0x7F.  Sometimes you'll see
     * references to these opcodes (like 0x60) being a "two-byte NOP" and using them differentiate an 8088 from newer
     * CPUs, but they're only a "two-byte NOP" if the second byte is zero, resulting in zero displacement.
     */
    X86.opJO,               X86.opJNO,              X86.opJC,               X86.opJNC,          // 0x60-0x63
    X86.opJZ,               X86.opJNZ,              X86.opJBE,              X86.opJNBE,         // 0x64-0x67
    X86.opJS,               X86.opJNS,              X86.opJP,               X86.opJNP,          // 0x68-0x6B
    X86.opJL,               X86.opJNL,              X86.opJLE,              X86.opJNLE,         // 0x6C-0x6F
    X86.opJO,               X86.opJNO,              X86.opJC,               X86.opJNC,          // 0x70-0x73
    X86.opJZ,               X86.opJNZ,              X86.opJBE,              X86.opJNBE,         // 0x74-0x77
    X86.opJS,               X86.opJNS,              X86.opJP,               X86.opJNP,          // 0x78-0x7B
    X86.opJL,               X86.opJNL,              X86.opJLE,              X86.opJNLE,         // 0x7C-0x7F
    /*
     * On all processors, opcode groups 0x80 and 0x82 perform identically (0x82 opcodes sign-extend their
     * immediate data, but since both 0x80 and 0x82 are byte operations, the sign extension has no effect).
     *
     * WARNING: Intel's "Pentium Processor User's Manual (Volume 3: Architecture and Programming Manual)" refers
     * to opcode 0x82 as a "reserved" instruction, but also cryptically refers to it as "MOVB AL,imm".  This is
     * assumed to be an error in the manual, because as far as I know, 0x82 has always mirrored 0x80.
     */
    X86.opGRP1b,            X86.opGRP1w,            X86.opGRP1b,            X86.opGRP1sw,       // 0x80-0x83
    X86.opTESTrb,           X86.opTESTrw,           X86.opXCHGrb,           X86.opXCHGrw,       // 0x84-0x87
    X86.opMOVmb,            X86.opMOVmw,            X86.opMOVrb,            X86.opMOVrw,        // 0x88-0x8B
    X86.opMOVwsr,           X86.opLEA,              X86.opMOVsrw,           X86.opPOPmw,        // 0x8C-0x8F
    X86.opNOP,              X86.opXCHGCX,           X86.opXCHGDX,           X86.opXCHGBX,       // 0x90-0x93
    X86.opXCHGSP,           X86.opXCHGBP,           X86.opXCHGSI,           X86.opXCHGDI,       // 0x94-0x97
    X86.opCBW,              X86.opCWD,              X86.opCALLF,            X86.opWAIT,         // 0x98-0x9B
    X86.opPUSHF,            X86.opPOPF,             X86.opSAHF,             X86.opLAHF,         // 0x9C-0x9F
    X86.opMOVALm,           X86.opMOVAXm,           X86.opMOVmAL,           X86.opMOVmAX,       // 0xA0-0xA3
    X86.opMOVSb,            X86.opMOVSw,            X86.opCMPSb,            X86.opCMPSw,        // 0xA4-0xA7
    X86.opTESTALb,          X86.opTESTAX,           X86.opSTOSb,            X86.opSTOSw,        // 0xA8-0xAB
    X86.opLODSb,            X86.opLODSw,            X86.opSCASb,            X86.opSCASw,        // 0xAC-0xAF
    X86.opMOVALb,           X86.opMOVCLb,           X86.opMOVDLb,           X86.opMOVBLb,       // 0xB0-0xB3
    X86.opMOVAHb,           X86.opMOVCHb,           X86.opMOVDHb,           X86.opMOVBHb,       // 0xB4-0xB7
    X86.opMOVAX,            X86.opMOVCX,            X86.opMOVDX,            X86.opMOVBX,        // 0xB8-0xBB
    X86.opMOVSP,            X86.opMOVBP,            X86.opMOVSI,            X86.opMOVDI,        // 0xBC-0xBF
    /*
     * On an 8086/8088, opcodes 0xC0 -> 0xC2, 0xC1 -> 0xC3, 0xC8 -> 0xCA and 0xC9 -> 0xCB.
     */
    X86.opRETn,             X86.opRET,              X86.opRETn,             X86.opRET,          // 0xC0-0xC3
    X86.opLES,              X86.opLDS,              X86.opMOVb,             X86.opMOVw,         // 0xC4-0xC7
    X86.opRETFn,            X86.opRETF,             X86.opRETFn,            X86.opRETF,         // 0xC8-0xCB
    X86.opINT3,             X86.opINTn,             X86.opINTO,             X86.opIRET,         // 0xCC-0xCF
    X86.opGRP2b1,           X86.opGRP2w1,           X86.opGRP2bCL,          X86.opGRP2wCL,      // 0xD0-0xD3
    /*
     * Even as of the Pentium, opcode 0xD6 is still marked as "reserved", but it's always been SALC (aka SETALC).
     */
    X86.opAAM,              X86.opAAD,              X86.opSALC,             X86.opXLAT,         // 0xD4-0xD7
    X86.opESC0,             X86.opESC1,             X86.opESC2,             X86.opESC3,         // 0xD8-0xDB
    X86.opESC4,             X86.opESC5,             X86.opESC6,             X86.opESC7,         // 0xDC-0xDF
    X86.opLOOPNZ,           X86.opLOOPZ,            X86.opLOOP,             X86.opJCXZ,         // 0xE0-0xE3
    X86.opINb,              X86.opINw,              X86.opOUTb,             X86.opOUTw,         // 0xE4-0xE7
    X86.opCALL,             X86.opJMP,              X86.opJMPF,             X86.opJMPs,         // 0xE8-0xEB
    X86.opINDXb,            X86.opINDXw,            X86.opOUTDXb,           X86.opOUTDXw,       // 0xEC-0xEF
    /*
     * On an 8086/8088, opcode 0xF1 is believed to be an alias for 0xF0; in any case, it definitely behaves like
     * a prefix on those processors, so we treat it as such.  On the 80186 and 80286, we treat it as opUndefined(),
     * and on the 80386, it becomes opINT1().
     *
     * As of the Pentium, opcode 0xF1 is still marked "reserved".
     */
    X86.opLOCK,             X86.opLOCK,             X86.opREPNZ,            X86.opREPZ,         // 0xF0-0xF3
    X86.opHLT,              X86.opCMC,              X86.opGRP3b,            X86.opGRP3w,        // 0xF4-0xF7
    X86.opCLC,              X86.opSTC,              X86.opCLI,              X86.opSTI,          // 0xF8-0xFB
    X86.opCLD,              X86.opSTD,              X86.opGRP4b,            X86.opGRP4w         // 0xFC-0xFF
];

/*
 * A word (or two) on instruction groups (eg, Grp1, Grp2), which are groups of instructions that
 * use a mod/reg/rm byte, where the reg field of that byte selects a function rather than a register.
 *
 * I start with the groupings used by Intel's "Pentium Processor User's Manual (Volume 3: Architecture
 * and Programming Manual)", but I deviate slightly, mostly by subdividing their groups with letter suffixes:
 *
 *      Opcodes     Intel       PCx86                                               PC Mag TechRef
 *      -------     -----       ----                                                --------------
 *      0x80-0x83   Grp1        Grp1b and Grp1w                                     Group A
 *      0xC0-0xC1   Grp2        Grp2b and Grp2w (opGRP2bn/wn)                       Group B
 *      0xD0-0xD3   Grp2        Grp2b and Grp2w (opGRP2b1/w1 and opGRP2bCL/wCL)     Group B
 *      0xF6-0xF7   Grp3        Grp3b and Grp3w                                     Group C
 *      0xFE        Grp4        Grp4b                                               Group D
 *      0xFF        Grp5        Grp4w                                               Group E
 *      0x0F,0x00   Grp6        Grp6 (SLDT, STR, LLDT, LTR, VERR, VERW)             Group F
 *      0x0F,0x01   Grp7        Grp7 (SGDT, SIDT, LGDT, LIDT, SMSW, LMSW, INVLPG)   Group G
 *      0x0F,0xBA   Grp8        Grp8 (BT, BTS, BTR, BTC)                            Group H
 *      0x0F,0xC7   Grp9        Grp9 (CMPXCH)                                       (N/A, 80486 and up)
 *
 * My only serious deviation is Grp5, which I refer to as Grp4w, because it contains word forms of
 * the INC and DEC instructions found in Grp4b.  Granted, Grp4w also contains versions of the CALL,
 * JMP and PUSH instructions, which are not in Grp4b, but there's nothing in Grp4b that conflicts with
 * Grp4w, so I think my nomenclature makes more sense.  To compensate, I don't use Grp5, so that the
 * remaining group numbers remain in sync with Intel's.
 *
 * To the above list, I've added a few "single-serving" groups: opcode 0x8F uses GrpPOPw, and opcodes 0xC6/0xC7
 * use GrpMOVn.  In both of these groups, the only valid (documented) instruction is where reg=0x0.
 *
 * TODO: Test what happens on real hardware when the reg field is non-zero for opcodes 0x8F and 0xC6/0xC7.
 */
X86.aOpGrp1b = [
    X86.fnADDb,             X86.fnORb,              X86.fnADCb,             X86.fnSBBb,             // 0x80/0x82(reg=0x0-0x3)
    X86.fnANDb,             X86.fnSUBb,             X86.fnXORb,             X86.fnCMPb              // 0x80/0x82(reg=0x4-0x7)
];

X86.aOpGrp1w = [
    X86.fnADDw,             X86.fnORw,              X86.fnADCw,             X86.fnSBBw,             // 0x81/0x83(reg=0x0-0x3)
    X86.fnANDw,             X86.fnSUBw,             X86.fnXORw,             X86.fnCMPw              // 0x81/0x83(reg=0x4-0x7)
];

X86.aOpGrpPOPw = [
    X86.fnPOPw,             X86.fnGRPFault,         X86.fnGRPFault,         X86.fnGRPFault,         // 0x8F(reg=0x0-0x3)
    X86.fnGRPFault,         X86.fnGRPFault,         X86.fnGRPFault,         X86.fnGRPFault          // 0x8F(reg=0x4-0x7)
];

X86.aOpGrpMOVn = [
    X86.fnMOVn,             X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     // 0xC6/0xC7(reg=0x0-0x3)
    X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined      // 0xC6/0xC7(reg=0x4-0x7)
];

X86.aOpGrp2b = [
    X86.fnROLb,             X86.fnRORb,             X86.fnRCLb,             X86.fnRCRb,             // 0xC0/0xD0/0xD2(reg=0x0-0x3)
    X86.fnSHLb,             X86.fnSHRb,             X86.fnGRPUndefined,     X86.fnSARb              // 0xC0/0xD0/0xD2(reg=0x4-0x7)
];

X86.aOpGrp2w = [
    X86.fnROLw,             X86.fnRORw,             X86.fnRCLw,             X86.fnRCRw,             // 0xC1/0xD1/0xD3(reg=0x0-0x3)
    X86.fnSHLw,             X86.fnSHRw,             X86.fnGRPUndefined,     X86.fnSARw              // 0xC1/0xD1/0xD3(reg=0x4-0x7)
];

X86.aOpGrp2d = [
    X86.fnROLd,             X86.fnRORd,             X86.fnRCLd,             X86.fnRCRd,             // 0xC1/0xD1/0xD3(reg=0x0-0x3)
    X86.fnSHLd,             X86.fnSHRd,             X86.fnGRPUndefined,     X86.fnSARd              // 0xC1/0xD1/0xD3(reg=0x4-0x7)
];

X86.aOpGrp3b = [
    X86.fnTESTib,           X86.fnGRPUndefined,     X86.fnNOTb,             X86.fnNEGb,             // 0xF6(reg=0x0-0x3)
    X86.fnMULb,             X86.fnIMULb,            X86.fnDIVb,             X86.fnIDIVb             // 0xF6(reg=0x4-0x7)
];

X86.aOpGrp3w = [
    X86.fnTESTiw,           X86.fnGRPUndefined,     X86.fnNOTw,             X86.fnNEGw,             // 0xF7(reg=0x0-0x3)
    X86.fnMULw,             X86.fnIMULw,            X86.fnDIVw,             X86.fnIDIVw             // 0xF7(reg=0x4-0x7)
];

X86.aOpGrp4b = [
    X86.fnINCb,             X86.fnDECb,             X86.fnGRPUndefined,     X86.fnGRPUndefined,     // 0xFE(reg=0x0-0x3)
    X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined      // 0xFE(reg=0x4-0x7)
];

X86.aOpGrp4w = [
    X86.fnINCw,             X86.fnDECw,             X86.fnCALLw,            X86.fnCALLFdw,          // 0xFF(reg=0x0-0x3)
    X86.fnJMPw,             X86.fnJMPFdw,           X86.fnPUSHw,            X86.fnGRPUndefined      // 0xFF(reg=0x4-0x7)
];

/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/x86op0f.js (C) Jeff Parsons 2012-2018
 */


/**
 * op=0x0F,0x00 (GRP6 mem/reg)
 *
 * @this {CPUX86}
 */
X86.opGRP6 = function()
{
    let bModRM = this.peekIPByte();
    if ((bModRM & 0x38) < 0x10) {   // possible reg values: 0x00, 0x08, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38
        this.opFlags |= X86.OPFLAG.NOREAD;
    }
    this.decodeModGrpWord.call(this, this.aOpGrp6, X86.helpSRCNone);
};

/**
 * op=0x0F,0x01 (GRP7 mem/reg)
 *
 * @this {CPUX86}
 */
X86.opGRP7 = function()
{
    let bModRM = this.peekIPByte();
    if (!(bModRM & 0x10)) {
        this.opFlags |= X86.OPFLAG.NOREAD;
    }
    this.decodeModGrpWord.call(this, X86.aOpGrp7, X86.helpSRCNone);
};

/**
 * opLAR()
 *
 * op=0x0F,0x02 (LAR reg,mem/reg)
 *
 * @this {CPUX86}
 */
X86.opLAR = function()
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to real-mode or V86-mode.
     */
    if (!(this.regCR0 & X86.CR0.MSW.PE) || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
        return;
    }
    this.decodeModRegWord.call(this, X86.fnLAR);
};

/**
 * opLSL()
 *
 * op=0x0F,0x03 (LSL reg,mem/reg)
 *
 * @this {CPUX86}
 */
X86.opLSL = function()
{
    /*
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to real-mode or V86-mode.
     */
    if (!(this.regCR0 & X86.CR0.MSW.PE) || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
        return;
    }
    this.decodeModRegWord.call(this, X86.fnLSL);
};

/**
 * opLOADALL286()
 *
 * op=0x0F,0x05 (LOADALL)
 *
 * From the "Undocumented iAPX 286 Test Instruction" document at http://www.pcjs.org/pubs/pc/reference/intel/80286/loadall/:
 *
 *  Physical Address (Hex)        Associated CPU Register
 *          800-805                        None
 *          806-807                        MSW
 *          808-815                        None
 *          816-817                        TR
 *          818-819                        Flag word
 *          81A-81B                        IP
 *          81C-81D                        LDT
 *          81E-81F                        DS
 *          820-821                        SS
 *          822-823                        CS
 *          824-825                        ES
 *          826-827                        DI
 *          828-829                        SI
 *          82A-82B                        BP
 *          82C-82D                        SP
 *          82E-82F                        BX
 *          830-831                        DX
 *          832-833                        CX
 *          834-835                        AX
 *          836-83B                        ES descriptor cache
 *          83C-841                        CS descriptor cache
 *          842-847                        SS descriptor cache
 *          848-84D                        DS descriptor cache
 *          84E-853                        GDTR
 *          854-859                        LDT descriptor cache
 *          85A-85F                        IDTR
 *          860-865                        TSS descriptor cache
 *
 * @this {CPUX86}
 */
X86.opLOADALL286 = function()
{
    if (this.nCPL) {
        /*
         * To use LOADALL, CPL must be zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0, 0, true);
        return;
    }
    this.setMSW(this.getShort(0x806));
    this.regEDI = this.getShort(0x826);
    this.regESI = this.getShort(0x828);
    this.regEBP = this.getShort(0x82A);
    this.regEBX = this.getShort(0x82E);
    this.regEDX = this.getShort(0x830);
    this.regECX = this.getShort(0x832);
    this.regEAX = this.getShort(0x834);
    this.segES.loadDesc6(0x836, this.getShort(0x824));
    this.segCS.loadDesc6(0x83C, this.getShort(0x822));
    this.segSS.loadDesc6(0x842, this.getShort(0x820));
    this.segDS.loadDesc6(0x848, this.getShort(0x81E));
    /*
     * Unlike LOADALL386, there's no requirement for calling setPS() before loading segment registers;
     * in fact, since we're not passing a CPL to setPS(), it may be preferable to have CS (and perhaps SS)
     * already loaded, so that setPS() can query the CPL.  TODO: Verify that CPL is set correctly.
     */
    this.setPS(this.getShort(0x818));
    /*
     * It's important to call setIP() and setSP() *after* the segCS and segSS loads, so that the CPU's
     * linear IP and SP registers (regLIP and regLSP) will be updated properly.  Ordinarily that would be
     * taken care of by simply using the CPU's setCS() and setSS() functions, but those functions call the
     * default descriptor load() functions, and obviously here we must use loadDesc6() instead.
     */
    this.setIP(this.getShort(0x81A));
    this.setSP(this.getShort(0x82C));
    /*
     * The bytes at 0x851 and 0x85D "should be zeroes", as per the "Undocumented iAPX 286 Test Instruction"
     * document, but the LOADALL issued by RAMDRIVE in PC-DOS 7.0 contains 0xFF in both of those bytes, resulting
     * in very large addrGDT and addrIDT values.  Obviously, we can't have that, so we load only the low byte
     * of the second word for both of those registers.
     */
    this.addrGDT = this.getShort(0x84E) | (this.getByte(0x850) << 16);
    this.addrGDTLimit = this.addrGDT + this.getShort(0x852);
    this.addrIDT = this.getShort(0x85A) | (this.getByte(0x85C) << 16);
    this.addrIDTLimit = this.addrIDT + this.getShort(0x85E);
    this.segLDT.loadDesc6(0x854, this.getShort(0x81C));
    this.segTSS.loadDesc6(0x860, this.getShort(0x816));

    /*
     * Oddly, the above Intel document gives two contradictory cycle counts for LOADALL: 190 and 195.
     * I'm going with 195, since both the PC Magazine Programmer's Technical Reference and Robert Collins
     * (http://www.rcollins.org/articles/loadall/tspec_a3_doc.html) agree.
     */
    this.nStepCycles -= 195;

    /*
     * TODO: LOADALL operation still needs to be verified in protected mode....
     */
    if (DEBUG && DEBUGGER && (this.regCR0 & X86.CR0.MSW.PE)) this.stopCPU();
};

/**
 * opCLTS()
 *
 * op=0x0F,0x06 (CLTS)
 *
 * @this {CPUX86}
 */
X86.opCLTS = function()
{
    /*
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    this.regCR0 &= ~X86.CR0.MSW.TS;
    this.nStepCycles -= 2;
};

/**
 * opLOADALL386()
 *
 * op=0x0F,0x07 (LOADALL ES:[EDI])
 *
 * Excerpt from Intel Internal Correspondence on "386 LOADALL Instruction" (undated), available as part of the
 * PCjs Project at http://www.pcjs.org/pubs/pc/reference/intel/80386/loadall/
 *
 *      1.5. 386 LOADALL Memory Format
 *
 *      The following tables define the LOADALL memory format. The LOADALL instruction uses a 512-byte block of
 *      memory, where the lowest addressed byte is given in ES:[(E)DI]. The area above offset CC hex is used for
 *      processor dependent registers (temporaries, invisible registers). These are loaded into the processor,
 *      but will not affect normal program execution. All values in the memory area are read from a four byte field,
 *      to keep the memory format DWORD aligned, but it is possible to locate memory area at a non-aligned address.
 *      In this case, the execution time of LOADALL will DOUBLE For this reason, the memory dump area should always
 *      be DWORD aligned.
 *
 *         Offset         Register
 *         ------         --------
 *          0x00            CR0
 *          0x04            EFLAGS
 *          0x08            EIP
 *          0x0C            EDI
 *          0x10            ESI
 *          0x14            EBP
 *          0x18            ESP
 *          0x1C            EBX
 *          0x20            EDX
 *          0x24            ECX
 *          0x28            EAX
 *          0x2C            DR6
 *          0x30            DR7
 *          0x34            TSSR(TSSSelector-Word)
 *          0x38            LDTR(LDTSelector-Word)
 *          0x3C            GS
 *          0x40            FS
 *          0x44            DS
 *          0x48            SS
 *          0x4C            CS
 *          0x50            ES
 *          0x54            TSS(AR)
 *          0x58            TSS(BASE)
 *          0x5C            TSS(LIMIT)
 *          0x60            IDT(AR)
 *          0x64            IDT(BASE)
 *          0x68            IDT(LIMIT)
 *          0x6C            GDT(AR)
 *          0x70            GDT(BASE)
 *          0x74            GDT(LIMIT)
 *          0x78            LDT(AR)
 *          0x7C            LDT(BASE)
 *          0x80            LDT(LIMIT)
 *          0x84            GS(AR)
 *          0x88            GS(BASE)
 *          0x8C            GS(LIMIT)
 *          0x90            FS(AR)
 *          0x94            FS(BASE)
 *          0x98            FS(LIMIT)
 *          0x9C            DS(AR)
 *          0xA0            DS(BASE)
 *          0xA4            DS(LIMIT)
 *          0xA8            SS(AR)
 *          0xAC            SS(BASE)
 *          0xB0            SS(LIMIT)
 *          0xB4            CS(AR)
 *          0xB8            CS(BASE)
 *          0xBC            CS(LIMIT)
 *          0xC0            ES(AR)
 *          0xC4            ES(BASE)
 *          0xC8            ES(LIMIT)
 *
 *      Each descriptor entry consists of 3 pieces:
 *
 *          AR
 *          BASE
 *          LIMIT
 *
 *      The AR part has the same format as the second dword of a segment descriptor except that only the AR byte
 *      (bits 8-15) and the G and B/D bits (bits 23 and 22) are used. All other bits in the AR field are ignored.
 *      The BASE and LIMIT parts contain full 32-bit values, fully expanded and unscrambled from the 386 descriptor.
 *      In particular, the LIMIT field loaded for a page granular segment gives a byte granular limit, so should
 *      contain the page limit*4096 plus 4095.
 *
 * @this {CPUX86}
 */
X86.opLOADALL386 = function()
{
    if (this.nCPL) {
        /*
         * To use LOADALL, CPL must be zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0, 0, true);
        return;
    }
    let addr = this.segES.checkRead(this.regEDI & this.maskAddr, 0xCC);
    if (addr !== X86.ADDR_INVALID) {
        X86.helpLoadCR0.call(this, this.getLong(addr));
        /*
         * We need to call setPS() before loading any segment registers, because if the Virtual 8086 Mode (VM)
         * bit is set in EFLAGS, the segment registers need to know that.
         */
        let accSS = this.getLong(addr + 0xA8);
        let cpl = (accSS & X86.DESC.ACC.DPL.MASK) >> X86.DESC.ACC.DPL.SHIFT;
        this.setPS(this.getLong(addr + 0x04), cpl);
        /*
         * TODO: We have no use for the GDT(AR) at offset 0x6C or the IDT(AR) at offset 0x60, because
         * we don't manage them as segment registers.  Should we?
         */
        this.addrGDT = this.getLong(addr + 0x70);
        this.addrGDTLimit = this.addrGDT + this.getLong(addr + 0x74);
        this.addrIDT = this.getLong(addr + 0x64);
        this.addrIDTLimit = this.addrIDT + this.getLong(addr + 0x68);
        this.segLDT.loadDesc(this.getLong(addr + 0x38), this.getLong(addr + 0x78), this.getLong(addr + 0x7C), this.getLong(addr + 0x80));
        this.segTSS.loadDesc(this.getLong(addr + 0x34), this.getLong(addr + 0x54), this.getLong(addr + 0x58), this.getLong(addr + 0x5C));
        this.regEDI = this.getLong(addr + 0x0C);
        this.regESI = this.getLong(addr + 0x10);
        this.regEBP = this.getLong(addr + 0x14);
        this.regEBX = this.getLong(addr + 0x1C);
        this.regEDX = this.getLong(addr + 0x20);
        this.regECX = this.getLong(addr + 0x24);
        this.regEAX = this.getLong(addr + 0x28);
        this.segGS.loadDesc(this.getLong(addr + 0x3C), this.getLong(addr + 0x84), this.getLong(addr + 0x88), this.getLong(addr + 0x8C));
        this.segFS.loadDesc(this.getLong(addr + 0x40), this.getLong(addr + 0x90), this.getLong(addr + 0x94), this.getLong(addr + 0x98));
        this.segDS.loadDesc(this.getLong(addr + 0x44), this.getLong(addr + 0x9C), this.getLong(addr + 0xA0), this.getLong(addr + 0xA4));
        this.segSS.loadDesc(this.getLong(addr + 0x48), accSS,                     this.getLong(addr + 0xAC), this.getLong(addr + 0xB0));
        this.segCS.loadDesc(this.getLong(addr + 0x4C), this.getLong(addr + 0xB4), this.getLong(addr + 0xB8), this.getLong(addr + 0xBC));
        this.segES.loadDesc(this.getLong(addr + 0x50), this.getLong(addr + 0xC0), this.getLong(addr + 0xC4), this.getLong(addr + 0xC8));
        /*
         * It's important to call setIP() and setSP() *after* the segCS and segSS loads, so that the CPU's
         * linear IP and SP registers (regLIP and regLSP) will be updated properly.  Ordinarily that would be
         * taken care of by simply using the CPU's setCS() and setSS() functions, but those functions call the
         * default descriptor load() functions, and obviously here we must use loadDesc() instead.
         */
        this.setIP(this.getLong(addr + 0x08));
        this.setSP(this.getLong(addr + 0x18));
        /*
         * TODO: We need to factor out the code that updates DR6 and DR7 from X86.opMOVdr(), so that we can
         * more easily update DR6 and DR7 (which we're simply ignoring for now).
         */
    }

    /*
     * According to Robert Collins (http://www.rcollins.org/articles/loadall/tspec_a3_doc.html), the 80386 LOADALL
     * takes 122 cycles.  Also, according the above-mentioned Intel document, if the memory buffer is not DWORD aligned,
     * execution time will DOUBLE.
     */
    this.nStepCycles -= (122 << ((addr & 0x3)? 1 : 0));
};

/**
 * opMOVrc()
 *
 * op=0x0F,0x20 (MOV reg,ctlreg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * From PCMag_Prog_TechRef, p.476: "The 80386 executes the MOV to/from control registers (CRn) regardless
 * of the setting of the MOD field.  The MOD field should be set to 11, but an early 80386 documentation
 * error indicated that the MOD field value was a don't care.  Early versions of the 80486 detect
 * a MOD != 11 as an illegal opcode.  This was changed in later versions to ignore the value of MOD.
 * Assemblers that generate MOD != 11 for these instructions will fail on some 80486s."
 *
 * And in fact, the COMPAQ DeskPro 386 ROM BIOS executes this instruction with MOD set to 00, so we have
 * to ignore it.
 *
 * @this {CPUX86}
 */
X86.opMOVrc = function()
{
    /*
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /*
         * You're not allowed to read control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let reg;
    let bModRM = this.getIPByte();
    switch((bModRM & 0x38) >> 3) {
    case 0x0:
        reg = this.regCR0;
        break;
    case 0x2:
        reg = this.regCR2;
        break;
    case 0x3:
        reg = this.regCR3;
        break;
    default:
        X86.opUndefined.call(this);
        return;
    }

    this.setReg(bModRM & 0x7, reg);

    this.nStepCycles -= 6;

    /*
     * TODO: Implement BACKTRACK for this instruction (although Control registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVrd()
 *
 * op=0x0F,0x21 (MOV reg,dbgreg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * @this {CPUX86}
 */
X86.opMOVrd = function()
{
    /*
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /*
         * You're not allowed to read control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let iSrc = (bModRM & 0x38) >> 3;

    if (iSrc == 4 || iSrc == 5) {
        X86.opUndefined.call(this);
        return;
    }

    this.setReg(bModRM & 0x7, this.regDR[iSrc]);

    this.nStepCycles -= 22;

    /*
     * TODO: Implement BACKTRACK for this instruction (although Debug registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVcr()
 *
 * op=0x0F,0x22 (MOV ctlreg,reg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * From PCMag_Prog_TechRef, p.476: "The 80386 executes the MOV to/from control registers (CRn) regardless
 * of the setting of the MOD field.  The MOD field should be set to 11, but an early 80386 documentation
 * error indicated that the MOD field value was a don't care.  Early versions of the 80486 detect
 * a MOD != 11 as an illegal opcode.  This was changed in later versions to ignore the value of MOD.
 * Assemblers that generate MOD != 11 for these instructions will fail on some 80486s."
 *
 * And in fact, the COMPAQ DeskPro 386 ROM BIOS executes this instruction with MOD set to 00, so we have
 * to ignore it.
 *
 * @this {CPUX86}
 */
X86.opMOVcr = function()
{
    /*
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /*
         * You're not allowed to write control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let reg = this.getReg(bModRM & 0x7);

    switch((bModRM & 0x38) >> 3) {
    case 0x0:
        X86.helpLoadCR0.call(this, reg);
        this.nStepCycles -= 10;
        break;
    case 0x2:
        this.regCR2 = reg;
        this.nStepCycles -= 4;
        break;
    case 0x3:
        X86.helpLoadCR3.call(this, reg);
        this.nStepCycles -= 5;
        break;
    default:
        X86.opUndefined.call(this);
        return;
    }

    /*
     * TODO: Implement BACKTRACK for this instruction (although Control registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVdr()
 *
 * op=0x0F,0x23 (MOV dbgreg,reg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * @this {CPUX86}
 */
X86.opMOVdr = function()
{
    /*
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /*
         * You're not allowed to write control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let iDst = (bModRM & 0x38) >> 3;

    if (iDst == 4 || iDst == 5) {
        X86.opUndefined.call(this);
        return;
    }

    let regDR = this.getReg(bModRM & 0x7);

    if (regDR != this.regDR[iDst]) {
        this.checkDebugRegisters(false);
        this.regDR[iDst] = regDR;
        this.checkDebugRegisters(true);
    }

    this.nStepCycles -= (iDst < 4? 22 : 14);

    /*
     * TODO: Implement BACKTRACK for this instruction (although Debug registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVrt()
 *
 * op=0x0F,0x24 (MOV reg,tstreg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * @this {CPUX86}
 */
X86.opMOVrt = function()
{
    /*
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /*
         * You're not allowed to read control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let iSrc = (bModRM & 0x38) >> 3;

    /*
     * Only TR6 and TR7 are defined, and only for the 80386 and 80486.  From the PC Magazine Prog. TechRef, p.64:
     *
     *  "The 80386 provides two 32-bit test registers, TR6 and TR7, as a mechanism for programmers to verify proper
     *   operation of the Translation Lookaside Buffer (TLB) when power is applied to the chip. The TLB is a cache used
     *   internally by the 80386 to translate linear addresses to physical addresses."
     */
    if (iSrc < 6) {
        X86.opUndefined.call(this);
        return;
    }

    this.setReg(bModRM & 0x7, this.regTR[iSrc]);
    this.nStepCycles -= 12;

    /*
     * TODO: Implement BACKTRACK for this instruction (although Test registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVtr()
 *
 * op=0x0F,0x26 (MOV tstreg,reg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * @this {CPUX86}
 */
X86.opMOVtr = function()
{
    /*
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /*
         * You're not allowed to write control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let iDst = (bModRM & 0x38) >> 3;

    /*
     * Only TR6 and TR7 are defined, and only for the 80386 and 80486.  From the PC Magazine Prog. TechRef, p.64:
     *
     *  "The 80386 provides two 32-bit test registers, TR6 and TR7, as a mechanism for programmers to verify proper
     *   operation of the Translation Lookaside Buffer (TLB) when power is applied to the chip. The TLB is a cache used
     *   internally by the 80386 to translate linear addresses to physical addresses."
     */
    if (iDst < 6) {
        X86.opUndefined.call(this);
        return;
    }

    /*
     * TODO: Do something useful with the Test registers.
     */
    this.regTR[iDst] = this.getReg(bModRM & 0x7);

    this.nStepCycles -= 12;

    /*
     * TODO: Implement BACKTRACK for this instruction (although Test registers are not likely to be a conduit for interesting data).
     */
};

/*
 * NOTE: The following 16 new conditional jumps actually rely on the OPERAND override setting
 * for determining whether a signed 16-bit or 32-bit displacement will be fetched, even though
 * the ADDRESS override might seem more intuitive.  Think of them as instructions that are loading
 * a new operand into IP/EIP.
 *
 * Also, in 16-bit code, even though a signed rel16 value would seem to imply a range of -32768
 * to +32767, any location within a 64Kb code segment outside that range can be reached by choosing
 * a displacement in the opposite direction, causing the 16-bit value in EIP to underflow or overflow;
 * any underflow or overflow doesn't matter, because only the low 16 bits of EIP are updated when a
 * 16-bit OPERAND size is in effect.
 *
 * In fact, for 16-bit jumps, it's simpler to always think of rel16 as an UNSIGNED value added to
 * the current EIP, where the result is then truncated to a 16-bit value.  This is why we don't have
 * to sign-extend rel16 before adding it to the current EIP.
 */

/**
 * opJOw()
 *
 * op=0x0F,0x80 (JO rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJOw = function()
{
    let disp = this.getIPWord();
    if (this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNOw()
 *
 * op=0x0F,0x81 (JNO rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJNOw = function()
{
    let disp = this.getIPWord();
    if (!this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJCw()
 *
 * op=0x0F,0x82 (JC rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJCw = function()
{
    let disp = this.getIPWord();
    if (this.getCF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNCw()
 *
 * op=0x0F,0x83 (JNC rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJNCw = function()
{
    let disp = this.getIPWord();
    if (!this.getCF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJZw()
 *
 * op=0x0F,0x84 (JZ rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJZw = function()
{
    let disp = this.getIPWord();
    if (this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNZw()
 *
 * op=0x0F,0x85 (JNZ rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJNZw = function()
{
    let disp = this.getIPWord();
    if (!this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJBEw()
 *
 * op=0x0F,0x86 (JBE rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJBEw = function()
{
    let disp = this.getIPWord();
    if (this.getCF() || this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNBEw()
 *
 * op=0x0F,0x87 (JNBE rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJNBEw = function()
{
    let disp = this.getIPWord();
    if (!this.getCF() && !this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJSw()
 *
 * op=0x0F,0x88 (JS rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJSw = function()
{
    let disp = this.getIPWord();
    if (this.getSF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNSw()
 *
 * op=0x0F,0x89 (JNS rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJNSw = function()
{
    let disp = this.getIPWord();
    if (!this.getSF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJPw()
 *
 * op=0x0F,0x8A (JP rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJPw = function()
{
    let disp = this.getIPWord();
    if (this.getPF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNPw()
 *
 * op=0x0F,0x8B (JNP rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJNPw = function()
{
    let disp = this.getIPWord();
    if (!this.getPF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJLw()
 *
 * op=0x0F,0x8C (JL rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJLw = function()
{
    let disp = this.getIPWord();
    if (!this.getSF() != !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNLw()
 *
 * op=0x0F,0x8D (JNL rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJNLw = function()
{
    let disp = this.getIPWord();
    if (!this.getSF() == !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJLEw()
 *
 * op=0x0F,0x8E (JLE rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJLEw = function()
{
    let disp = this.getIPWord();
    if (this.getZF() || !this.getSF() != !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNLEw()
 *
 * op=0x0F,0x8F (JNLE rel16/rel32)
 *
 * @this {CPUX86}
 */
X86.opJNLEw = function()
{
    let disp = this.getIPWord();
    if (!this.getZF() && !this.getSF() == !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opSETO()
 *
 * op=0x0F,0x90 (SETO b)
 *
 * @this {CPUX86}
 */
X86.opSETO = function()
{
    X86.helpSETcc.call(this, X86.fnSETO);
};

/**
 * opSETNO()
 *
 * op=0x0F,0x91 (SETNO b)
 *
 * @this {CPUX86}
 */
X86.opSETNO = function()
{
    X86.helpSETcc.call(this, X86.fnSETO);
};

/**
 * opSETC()
 *
 * op=0x0F,0x92 (SETC b)
 *
 * @this {CPUX86}
 */
X86.opSETC = function()
{
    X86.helpSETcc.call(this, X86.fnSETC);
};

/**
 * opSETNC()
 *
 * op=0x0F,0x93 (SETNC b)
 *
 * @this {CPUX86}
 */
X86.opSETNC = function()
{
    X86.helpSETcc.call(this, X86.fnSETNC);
};

/**
 * opSETZ()
 *
 * op=0x0F,0x94 (SETZ b)
 *
 * @this {CPUX86}
 */
X86.opSETZ = function()
{
    X86.helpSETcc.call(this, X86.fnSETZ);
};

/**
 * opSETNZ()
 *
 * op=0x0F,0x95 (SETNZ b)
 *
 * @this {CPUX86}
 */
X86.opSETNZ = function()
{
    X86.helpSETcc.call(this, X86.fnSETNZ);
};

/**
 * opSETBE()
 *
 * op=0x0F,0x96 (SETBE b)
 *
 * @this {CPUX86}
 */
X86.opSETBE = function()
{
    X86.helpSETcc.call(this, X86.fnSETBE);
};

/**
 * opSETNBE()
 *
 * op=0x0F,0x97 (SETNBE b)
 *
 * @this {CPUX86}
 */
X86.opSETNBE = function()
{
    X86.helpSETcc.call(this, X86.fnSETNBE);
};

/**
 * opSETS()
 *
 * op=0x0F,0x98 (SETS b)
 *
 * @this {CPUX86}
 */
X86.opSETS = function()
{
    X86.helpSETcc.call(this, X86.fnSETS);
};

/**
 * opSETNS()
 *
 * op=0x0F,0x99 (SETNS b)
 *
 * @this {CPUX86}
 */
X86.opSETNS = function()
{
    X86.helpSETcc.call(this, X86.fnSETNS);
};

/**
 * opSETP()
 *
 * op=0x0F,0x9A (SETP b)
 *
 * @this {CPUX86}
 */
X86.opSETP = function()
{
    X86.helpSETcc.call(this, X86.fnSETP);
};

/**
 * opSETNP()
 *
 * op=0x0F,0x9B (SETNP b)
 *
 * @this {CPUX86}
 */
X86.opSETNP = function()
{
    X86.helpSETcc.call(this, X86.fnSETNP);
};

/**
 * opSETL()
 *
 * op=0x0F,0x9C (SETL b)
 *
 * @this {CPUX86}
 */
X86.opSETL = function()
{
    X86.helpSETcc.call(this, X86.fnSETL);
};

/**
 * opSETNL()
 *
 * op=0x0F,0x9D (SETNL b)
 *
 * @this {CPUX86}
 */
X86.opSETNL = function()
{
    X86.helpSETcc.call(this, X86.fnSETNL);
};

/**
 * opSETLE()
 *
 * op=0x0F,0x9E (SETLE b)
 *
 * @this {CPUX86}
 */
X86.opSETLE = function()
{
    X86.helpSETcc.call(this, X86.fnSETLE);
};

/**
 * opSETNLE()
 *
 * op=0x0F,0x9F (SETNLE b)
 *
 * @this {CPUX86}
 */
X86.opSETNLE = function()
{
    X86.helpSETcc.call(this, X86.fnSETNLE);
};

/**
 * opPUSHFS()
 *
 * op=0x0F,0xA0 (PUSH FS)
 *
 * @this {CPUX86}
 */
X86.opPUSHFS = function()
{
    /*
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segFS.sel);
    } else {
        this.pushData(this.segFS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * opPOPFS()
 *
 * op=0x0F,0xA1 (POP FS)
 *
 * @this {CPUX86}
 */
X86.opPOPFS = function()
{
    /*
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setFS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * opBT()
 *
 * op=0x0F,0xA3 (BT mem/reg,reg)
 *
 * @this {CPUX86}
 */
X86.opBT = function()
{
    this.decodeModMemWord.call(this, X86.fnBTMem);
    if (this.regEA !== X86.ADDR_INVALID) this.nStepCycles -= 6;
};

/**
 * opSHLDn()
 *
 * op=0x0F,0xA4 (SHLD mem/reg,reg,imm8)
 *
 * @this {CPUX86}
 */
X86.opSHLDn = function()
{
    this.decodeModMemWord.call(this, this.sizeData == 2? X86.fnSHLDwi : X86.fnSHLDdi);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 7);
};

/**
 * opSHLDcl()
 *
 * op=0x0F,0xA5 (SHLD mem/reg,reg,CL)
 *
 * @this {CPUX86}
 */
X86.opSHLDcl = function()
{
    this.decodeModMemWord.call(this, this.sizeData == 2? X86.fnSHLDwCL : X86.fnSHLDdCL);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 7);
};

/**
 * opXBTS()
 *
 * op=0x0F,0xA6 (XBTS reg,mem/reg,[E]AX,CL)
 *
 * @this {CPUX86}
 */
X86.opXBTS = function()
{
    this.decodeModRegWord.call(this, X86.fnXBTS);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 6 : 13);
};

/**
 * opIBTS()
 *
 * op=0x0F,0xA7 (IBTS mem/reg,[E]AX,CL,reg)
 *
 * @this {CPUX86}
 */
X86.opIBTS = function()
{
    this.decodeModMemWord.call(this, X86.fnIBTS);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 12 : 19);
};

/**
 * opPUSHGS()
 *
 * op=0x0F,0xA8 (PUSH GS)
 *
 * @this {CPUX86}
 */
X86.opPUSHGS = function()
{
    /*
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segGS.sel);
    } else {
        this.pushData(this.segGS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * opPOPGS()
 *
 * op=0x0F,0xA9 (POP GS)
 *
 * @this {CPUX86}
 */
X86.opPOPGS = function()
{
    /*
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setGS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * opBTS()
 *
 * op=0x0F,0xAB (BTC mem/reg,reg)
 *
 * @this {CPUX86}
 */
X86.opBTS = function()
{
    this.decodeModMemWord.call(this, X86.fnBTSMem);
    if (this.regEA !== X86.ADDR_INVALID) this.nStepCycles -= 5;
};

/**
 * opSHRDn()
 *
 * op=0x0F,0xAC (SHRD mem/reg,reg,imm8)
 *
 * @this {CPUX86}
 */
X86.opSHRDn = function()
{
    this.decodeModMemWord.call(this, this.sizeData == 2? X86.fnSHRDwi : X86.fnSHRDdi);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 7);
};

/**
 * opSHRDcl()
 *
 * op=0x0F,0xAD (SHRD mem/reg,reg,CL)
 *
 * @this {CPUX86}
 */
X86.opSHRDcl = function()
{
    this.decodeModMemWord.call(this, this.sizeData == 2? X86.fnSHRDwCL : X86.fnSHRDdCL);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 7);
};

/**
 * opIMUL()
 *
 * op=0x0F,0xAF (IMUL reg,mem/reg) (80386 and up)
 *
 * @this {CPUX86}
 */
X86.opIMUL = function()
{
    this.decodeModRegWord.call(this, this.sizeData == 2? X86.fnIMULrw : X86.fnIMULrd);
};

/**
 * opLSS()
 *
 * op=0x0F,0xB2 (LSS reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads SS from the next word.
 *
 * @this {CPUX86}
 */
X86.opLSS = function()
{
    this.decodeModRegWord.call(this, X86.fnLSS);
};

/**
 * opBTR()
 *
 * op=0x0F,0xB3 (BTC mem/reg,reg) (80386 and up)
 *
 * @this {CPUX86}
 */
X86.opBTR = function()
{
    this.decodeModMemWord.call(this, X86.fnBTRMem);
    if (this.regEA !== X86.ADDR_INVALID) this.nStepCycles -= 5;
};

/**
 * opLFS()
 *
 * op=0x0F,0xB4 (LFS reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads FS from the next word.
 *
 * @this {CPUX86}
 */
X86.opLFS = function()
{
    this.decodeModRegWord.call(this, X86.fnLFS);
};

/**
 * opLGS()
 *
 * op=0x0F,0xB5 (LGS reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads GS from the next word.
 *
 * @this {CPUX86}
 */
X86.opLGS = function()
{
    this.decodeModRegWord.call(this, X86.fnLGS);
};

/**
 * opMOVZXb()
 *
 * op=0x0F,0xB6 (MOVZX reg,byte)
 *
 * @this {CPUX86}
 */
X86.opMOVZXb = function()
{
    this.decodeModRegByte.call(this, X86.fnMOVXb);
    let reg = (this.bModRM >> 3) & 0x7;
    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~this.maskData) | (this.regEAX & 0xff);
        break;
    case 0x1:
        this.regECX = (this.regECX & ~this.maskData) | (this.regECX & 0xff);
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~this.maskData) | (this.regEDX & 0xff);
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~this.maskData) | (this.regEBX & 0xff);
        break;
    case 0x4:
        this.regESP = (this.regESP & ~this.maskData) | ((this.regEAX >> 8) & 0xff);
        this.regEAX = this.regXX;
        break;
    case 0x5:
        this.regEBP = (this.regEBP & ~this.maskData) | ((this.regECX >> 8) & 0xff);
        this.regECX = this.regXX;
        break;
    case 0x6:
        this.regESI = (this.regESI & ~this.maskData) | ((this.regEDX >> 8) & 0xff);
        this.regEDX = this.regXX;
        break;
    case 0x7:
        this.regEDI = (this.regEDI & ~this.maskData) | ((this.regEBX >> 8) & 0xff);
        this.regEBX = this.regXX;
        break;
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
};

/**
 * opMOVZXw()
 *
 * op=0x0F,0xB7 (MOVZX reg,word)
 *
 * @this {CPUX86}
 */
X86.opMOVZXw = function()
{
    this.setDataSize(2);
    this.decodeModRegWord.call(this, X86.fnMOVXw);
    switch((this.bModRM >> 3) & 0x7) {
    case 0x0:
        this.regEAX = (this.regEAX & 0xffff);
        break;
    case 0x1:
        this.regECX = (this.regECX & 0xffff);
        break;
    case 0x2:
        this.regEDX = (this.regEDX & 0xffff);
        break;
    case 0x3:
        this.regEBX = (this.regEBX & 0xffff);
        break;
    case 0x4:
        this.regESP = (this.regESP & 0xffff);
        break;
    case 0x5:
        this.regEBP = (this.regEBP & 0xffff);
        break;
    case 0x6:
        this.regESI = (this.regESI & 0xffff);
        break;
    case 0x7:
        this.regEDI = (this.regEDI & 0xffff);
        break;
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
};

/**
 * op=0x0F,0xBA (GRP8 mem/reg) (80386 and up)
 *
 * @this {CPUX86}
 */
X86.opGRP8 = function()
{
    this.decodeModGrpWord.call(this, X86.aOpGrp8, this.getIPByte);
};

/**
 * opBTC()
 *
 * op=0x0F,0xBB (BTC mem/reg,reg)
 *
 * @this {CPUX86}
 */
X86.opBTC = function()
{
    this.decodeModMemWord.call(this, X86.fnBTCMem);
    if (this.regEA !== X86.ADDR_INVALID) this.nStepCycles -= 5;
};

/**
 * opBSF()
 *
 * op=0x0F,0xBC (BSF reg,mem/reg)
 *
 * @this {CPUX86}
 */
X86.opBSF = function()
{
    this.decodeModRegWord.call(this, X86.fnBSF);
};

/**
 * opBSR()
 *
 * op=0x0F,0xBD (BSR reg,mem/reg)
 *
 * @this {CPUX86}
 */
X86.opBSR = function()
{
    this.decodeModRegWord.call(this, X86.fnBSR);
};

/**
 * opMOVSXb()
 *
 * op=0x0F,0xBE (MOVSX reg,byte)
 *
 * @this {CPUX86}
 */
X86.opMOVSXb = function()
{
    this.decodeModRegByte.call(this, X86.fnMOVXb);
    let reg = (this.bModRM >> 3) & 0x7;
    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~this.maskData) | ((((this.regEAX & 0xff) << 24) >> 24) & this.maskData);
        break;
    case 0x1:
        this.regECX = (this.regECX & ~this.maskData) | ((((this.regECX & 0xff) << 24) >> 24) & this.maskData);
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~this.maskData) | ((((this.regEDX & 0xff) << 24) >> 24) & this.maskData);
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~this.maskData) | ((((this.regEBX & 0xff) << 24) >> 24) & this.maskData);
        break;
    case 0x4:
        this.regESP = (this.regESP & ~this.maskData) | (((this.regEAX << 16) >> 24) & this.maskData);
        this.regEAX = this.regXX;
        break;
    case 0x5:
        this.regEBP = (this.regEBP & ~this.maskData) | (((this.regECX << 16) >> 24) & this.maskData);
        this.regECX = this.regXX;
        break;
    case 0x6:
        this.regESI = (this.regESI & ~this.maskData) | (((this.regEDX << 16) >> 24) & this.maskData);
        this.regEDX = this.regXX;
        break;
    case 0x7:
        this.regEDI = (this.regEDI & ~this.maskData) | (((this.regEBX << 16) >> 24) & this.maskData);
        this.regEBX = this.regXX;
        break;
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
};

/**
 * opMOVSXw()
 *
 * op=0x0F,0xBF (MOVSX reg,word)
 *
 * @this {CPUX86}
 */
X86.opMOVSXw = function()
{
    this.setDataSize(2);
    this.decodeModRegWord.call(this, X86.fnMOVXw);
    switch((this.bModRM >> 3) & 0x7) {
    case 0x0:
        this.regEAX = ((this.regEAX << 16) >> 16);
        break;
    case 0x1:
        this.regECX = ((this.regECX << 16) >> 16);
        break;
    case 0x2:
        this.regEDX = ((this.regEDX << 16) >> 16);
        break;
    case 0x3:
        this.regEBX = ((this.regEBX << 16) >> 16);
        break;
    case 0x4:
        this.regESP = ((this.regESP << 16) >> 16);
        break;
    case 0x5:
        this.regEBP = ((this.regEBP << 16) >> 16);
        break;
    case 0x6:
        this.regESI = ((this.regESI << 16) >> 16);
        break;
    case 0x7:
        this.regEDI = ((this.regEDI << 16) >> 16);
        break;
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
};

X86.aOps0F = new Array(256);

X86.aOps0F[0x00] = X86.opGRP6;
X86.aOps0F[0x01] = X86.opGRP7;
X86.aOps0F[0x02] = X86.opLAR;
X86.aOps0F[0x03] = X86.opLSL;
X86.aOps0F[0x05] = X86.opLOADALL286;
X86.aOps0F[0x06] = X86.opCLTS;

/*
 * On all processors (except the 8086/8088, of course), X86.OPCODE.UD2 (0x0F,0x0B), aka "UD2", is an
 * instruction guaranteed to raise a #UD (Invalid Opcode) exception (INT 0x06) on all post-8086 processors.
 */
X86.aOps0F[0x0B] = X86.opInvalid;

/*
 * The following 0x0F opcodes are of no consequence to us, since they were all introduced post-80386;
 * 0x0F,0xA6 and 0x0F,0xA7 were introduced on some 80486 processors (and then deprecated), while 0x0F,0xB0
 * and 0x0F,0xB1 were introduced on 80586 (aka Pentium) processors.
 *
 *      CMPXCHG r/m8,reg8           ; 0F B0 /r          [PENT]
 *      CMPXCHG r/m16,reg16         ; o16 0F B1 /r      [PENT]
 *      CMPXCHG r/m32,reg32         ; o32 0F B1 /r      [PENT]
 *      CMPXCHG486 r/m8,reg8        ; 0F A6 /r          [486,UNDOC]
 *      CMPXCHG486 r/m16,reg16      ; o16 0F A7 /r      [486,UNDOC]
 *      CMPXCHG486 r/m32,reg32      ; o32 0F A7 /r      [486,UNDOC]
 *
 * So why are we even mentioning them here? Only because some software (eg, Windows 3.00) attempts to execute
 * 0x0F,0xA6, so we need to explicitly mark it as invalid.  TODO: Purely out of curiosity, I would like to
 * eventually learn *why* Windows 3.00 does this; is it hoping to use the CMPXCHG486 opcode, or is it performing
 * a CPU/stepping check to detect/work-around some errata, or....?
 */
X86.aOps0F[0xA6] = X86.opInvalid;

/*
 * When Windows 95 Setup initializes in protected-mode, it sets a DPMI exception handler for UD_FAULT and
 * then attempts to generate that exception with undefined opcode 0x0F,0xFF.  Apparently, whoever wrote that code
 * didn't get the Intel memo regarding the preferred invalid opcode (0x0F,0x0B, aka UD2), or perhaps Intel hadn't
 * written that memo yet -- although if that's the case, then Intel should have followed Microsoft's lead and
 * selected 0x0F,0xFF instead of 0x0F,0x0B.
 *
 * In any case, this means we need to explicitly set the handler for that opcode to opInvalid(), too.
 */
X86.aOps0F[0xFF] = X86.opInvalid;

/*
 * NOTE: Any other opcode slots NOT explicitly initialized above with either a dedicated function OR opInvalid()
 * will be set to opUndefined() when initProcessor() finalizes the opcode tables.  If the processor is an 80386,
 * initProcessor() will also incorporate all the handlers listed below in aOps0F386.
 *
 * A call to opUndefined() implies something serious has occurred that merits our attention (eg, perhaps someone
 * is using an undocumented opcode that we haven't implemented yet), whereas a call to opInvalid() may or may not.
 */

if (I386) {
    X86.aOps0F386 = [];
    X86.aOps0F386[0x05] = X86.opInvalid;        // the 80286 LOADALL opcode (LOADALL286) is invalid on the 80386
    X86.aOps0F386[0x07] = X86.opLOADALL386;
    X86.aOps0F386[0x10] = X86.opMOVmb;          // see the undocumented [UMOV](/docs/x86/ops/UMOV/) instruction
    X86.aOps0F386[0x11] = X86.opMOVmw;          // see the undocumented [UMOV](/docs/x86/ops/UMOV/) instruction
    X86.aOps0F386[0x12] = X86.opMOVrb;          // see the undocumented [UMOV](/docs/x86/ops/UMOV/) instruction
    X86.aOps0F386[0x13] = X86.opMOVrw;          // see the undocumented [UMOV](/docs/x86/ops/UMOV/) instruction
    X86.aOps0F386[0x20] = X86.opMOVrc;
    X86.aOps0F386[0x21] = X86.opMOVrd;
    X86.aOps0F386[0x22] = X86.opMOVcr;
    X86.aOps0F386[0x23] = X86.opMOVdr;
    X86.aOps0F386[0x24] = X86.opMOVrt;
    X86.aOps0F386[0x26] = X86.opMOVtr;
    X86.aOps0F386[0x80] = X86.opJOw;
    X86.aOps0F386[0x81] = X86.opJNOw;
    X86.aOps0F386[0x82] = X86.opJCw;
    X86.aOps0F386[0x83] = X86.opJNCw;
    X86.aOps0F386[0x84] = X86.opJZw;
    X86.aOps0F386[0x85] = X86.opJNZw;
    X86.aOps0F386[0x86] = X86.opJBEw;
    X86.aOps0F386[0x87] = X86.opJNBEw;
    X86.aOps0F386[0x88] = X86.opJSw;
    X86.aOps0F386[0x89] = X86.opJNSw;
    X86.aOps0F386[0x8A] = X86.opJPw;
    X86.aOps0F386[0x8B] = X86.opJNPw;
    X86.aOps0F386[0x8C] = X86.opJLw;
    X86.aOps0F386[0x8D] = X86.opJNLw;
    X86.aOps0F386[0x8E] = X86.opJLEw;
    X86.aOps0F386[0x8F] = X86.opJNLEw;
    X86.aOps0F386[0x90] = X86.opSETO;
    X86.aOps0F386[0x91] = X86.opSETNO;
    X86.aOps0F386[0x92] = X86.opSETC;
    X86.aOps0F386[0x93] = X86.opSETNC;
    X86.aOps0F386[0x94] = X86.opSETZ;
    X86.aOps0F386[0x95] = X86.opSETNZ;
    X86.aOps0F386[0x96] = X86.opSETBE;
    X86.aOps0F386[0x97] = X86.opSETNBE;
    X86.aOps0F386[0x98] = X86.opSETS;
    X86.aOps0F386[0x99] = X86.opSETNS;
    X86.aOps0F386[0x9A] = X86.opSETP;
    X86.aOps0F386[0x9B] = X86.opSETNP;
    X86.aOps0F386[0x9C] = X86.opSETL;
    X86.aOps0F386[0x9D] = X86.opSETNL;
    X86.aOps0F386[0x9E] = X86.opSETLE;
    X86.aOps0F386[0x9F] = X86.opSETNLE;
    X86.aOps0F386[0xA0] = X86.opPUSHFS;
    X86.aOps0F386[0xA1] = X86.opPOPFS;
    X86.aOps0F386[0xA3] = X86.opBT;
    X86.aOps0F386[0xA4] = X86.opSHLDn;
    X86.aOps0F386[0xA5] = X86.opSHLDcl;
    X86.aOps0F386[0xA8] = X86.opPUSHGS;
    X86.aOps0F386[0xA9] = X86.opPOPGS;
    X86.aOps0F386[0xAB] = X86.opBTS;
    X86.aOps0F386[0xAC] = X86.opSHRDn;
    X86.aOps0F386[0xAD] = X86.opSHRDcl;
    X86.aOps0F386[0xAF] = X86.opIMUL;
    X86.aOps0F386[0xB2] = X86.opLSS;
    X86.aOps0F386[0xB3] = X86.opBTR;
    X86.aOps0F386[0xB4] = X86.opLFS;
    X86.aOps0F386[0xB5] = X86.opLGS;
    X86.aOps0F386[0xB6] = X86.opMOVZXb;
    X86.aOps0F386[0xB7] = X86.opMOVZXw;
    X86.aOps0F386[0xBA] = X86.opGRP8;
    X86.aOps0F386[0xBB] = X86.opBTC;
    X86.aOps0F386[0xBC] = X86.opBSF;
    X86.aOps0F386[0xBD] = X86.opBSR;
    X86.aOps0F386[0xBE] = X86.opMOVSXb;
    X86.aOps0F386[0xBF] = X86.opMOVSXw;
}

/*
 * These instruction groups are not as orthogonal as the original 8086/8088 groups (Grp1 through Grp4); some of
 * the instructions in Grp6 and Grp7 only read their dst operand (eg, LLDT), which means the ModRM helper function
 * must insure that setEAWord() is disabled, while others only write their dst operand (eg, SLDT), which means that
 * getEAWord() should be disabled *prior* to calling the ModRM helper function.  This latter case requires that
 * we decode the reg field of the ModRM byte before dispatching.
 */
X86.aOpGrp6Prot = [
    X86.fnSLDT,             X86.fnSTR,              X86.fnLLDT,             X86.fnLTR,              // 0x0F,0x00(reg=0x0-0x3)
    X86.fnVERR,             X86.fnVERW,             X86.fnGRPUndefined,     X86.fnGRPUndefined      // 0x0F,0x00(reg=0x4-0x7)
];

X86.aOpGrp6Real = [
    X86.fnGRPInvalid,       X86.fnGRPInvalid,       X86.fnGRPInvalid,       X86.fnGRPInvalid,       // 0x0F,0x00(reg=0x0-0x3)
    X86.fnGRPInvalid,       X86.fnGRPInvalid,       X86.fnGRPUndefined,     X86.fnGRPUndefined      // 0x0F,0x00(reg=0x4-0x7)
];

/*
 * Unlike Grp6, Grp7 and Grp8 do not require separate real-mode and protected-mode dispatch tables, because
 * all Grp7 and Grp8 instructions are valid in both modes.
 */
X86.aOpGrp7 = [
    X86.fnSGDT,             X86.fnSIDT,             X86.fnLGDT,             X86.fnLIDT,             // 0x0F,0x01(reg=0x0-0x3)
    X86.fnSMSW,             X86.fnGRPUndefined,     X86.fnLMSW,             X86.fnGRPUndefined      // 0x0F,0x01(reg=0x4-0x7)
];

X86.aOpGrp8 = [
    X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     // 0x0F,0xBA(reg=0x0-0x3)
    X86.fnBT,               X86.fnBTS,              X86.fnBTR,              X86.fnBTC               // 0x0F,0xBA(reg=0x4-0x7)
];

/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/chipset.js (C) Jeff Parsons 2012-2018
 */


/**
 * class ChipSet
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class ChipSet extends Component {
    /**
     * ChipSet(parmsChipSet)
     *
     * The ChipSet component has the following component-specific (parmsChipSet) properties:
     *
     *      model:          eg, "5150", "5160", "5170", "deskpro386" (should be a member of ChipSet.MODELS)
     *      sw1:            8-character binary string representing the SW1 DIP switches (SW1[1-8]); see Switches Overview
     *      sw2:            8-character binary string representing the SW2 DIP switches (SW2[1-8]) (MODEL_5150 only)
     *      sound:          true (or non-zero) to enable sounds (default), false (or 0) to disable; number used as initial volume
     *      scaleTimers:    true to divide timer cycle counts by the CPU's cycle multiplier (default is false)
     *      floppies:       array of floppy drive sizes in Kb (default is "[360, 360]" if no sw1 value provided)
     *      monitor:        none|tv|color|mono|ega|vga (if no sw1 value provided, default is "ega" for 5170, "mono" otherwise)
     *      dateRTC:        optional RTC date/time (in GMT) to use on reset; use the ISO 8601 format; eg: "2014-10-01T08:00:00"
     *
     * TODO: As support for IBM-compatible machines grows, we should refrain from adding new model strings (eg, "att6300")
     * and corresponding model checks, and instead add more ChipSet configuration properties, such as:
     *
     *      portPIT1:       0x48 to enable PIT1 at base port 0x48 (as used by COMPAQ_DESKPRO386); default to undefined
     *      chipKBD:        8041 to select 8041 emulation (eg, for ATT_6300); default to 8255 for MODEL_5150/MODEL_5160, 8042 for MODEL_5170
     *
     * @this {ChipSet}
     * @param {Object} parmsChipSet
     */
    constructor(parmsChipSet)
    {
        super("ChipSet", parmsChipSet, Messages.CHIPSET);

        let model = parmsChipSet['model'];

        /*
         * this.model is a numeric version of the 'model' string; when comparing this.model to standard IBM
         * model numbers, you should generally compare (this.model|0) to the target value, which truncates it.
         */
        if (model && !ChipSet.MODELS[model]) {
            Component.notice("Unrecognized ChipSet model: " + model);
        }

        this.model = ChipSet.MODELS[model] || ChipSet.MODEL_5150_OTHER;

        let bSwitches;
        this.aDIPSwitches = [];

        /*
         * SW1 describes the number of floppy drives, the amount of base memory, the primary monitor type,
         * and (on the MODEL_5160) whether or not a coprocessor is installed.  If no SW1 settings are provided,
         * we look for individual 'floppies' and 'monitor' settings and build a default SW1 value.
         *
         * The defaults below select max memory, monochrome monitor (EGA monitor for MODEL_5170), and two floppies.
         * Don't get too excited about "max memory" either: on a MODEL_5150, the max was 64Kb, and on a MODEL_5160,
         * the max was 256Kb.  However, the RAM component is free to install as much base memory as it likes,
         * overriding the SW1 memory setting.
         *
         * Given that the ROM BIOS is hard-coded to load boot sectors @0000:7C00, the minimum amount of system RAM
         * required to boot is therefore 32Kb.  Whether that's actually enough to run any or all versions of PC-DOS is
         * a separate question.  FYI, with only 16Kb, the ROM BIOS will still try to boot, and fail miserably.
         */
        bSwitches = this.parseDIPSwitches(parmsChipSet[ChipSet.CONTROLS.SW1]);
        this.aDIPSwitches[0] = [bSwitches, bSwitches];

        if (bSwitches == null) {
            this.aFloppyDrives = [360, 360];
            let aFloppyDrives = parmsChipSet['floppies'];
            if (aFloppyDrives && aFloppyDrives.length) this.aFloppyDrives = aFloppyDrives;
            this.setDIPSwitches(ChipSet.SWITCH_TYPE.FLOPNUM, this.aFloppyDrives.length);

            let sMonitor = parmsChipSet['monitor'] || (this.model < ChipSet.MODEL_5170? "mono" : "ega");
            this.setDIPSwitches(ChipSet.SWITCH_TYPE.MONITOR, sMonitor);
        }

        /*
         * SW2 describes the number of 32Kb blocks of I/O expansion RAM that's present in the system. The MODEL_5150
         * ROM BIOS only checked/supported the first four switches, so the maximum amount of additional RAM specifiable
         * was 15 * 32Kb, or 480Kb.  So with a 16Kb-64Kb motherboard, the MODEL_5150 ROM BIOS could support a grand
         * total of 544Kb.  With the 64Kb-256Kb motherboard revision, a 5150 could use the first FIVE SW2 switches,
         * allowing for a grand total as high as 640Kb.
         *
         * For MODEL_5160 (PC XT) and up, memory expansion cards had their own switches, and the motherboard
         * SW2 switches for I/O expansion RAM were eliminated.  Instead, the ROM BIOS scans the entire address space
         * (up to 0xA0000) looking for additional memory.  As a result, the only mechanism we provide for adding RAM
         * (above the maximum of 256Kb supported on the motherboard) is the "size" parameter of the RAM component.
         *
         * NOTE: If you use the "size" parameter, you will not be able to dynamically alter the memory configuration;
         * the RAM component will ignore any changes to SW1.
         */
        bSwitches = this.parseDIPSwitches(parmsChipSet[ChipSet.CONTROLS.SW2]);
        this.aDIPSwitches[1] = [bSwitches, bSwitches];

        this.sCellClass = PCX86.CSSCLASS + "-bitCell";

        this.cDMACs = this.cPICs = 1;
        if (this.model >= ChipSet.MODEL_5170) {
            this.cDMACs = this.cPICs = 2;
        }

        this.fScaleTimers = parmsChipSet['scaleTimers'] || false;
        this.sDateRTC = parmsChipSet['dateRTC'];

        /*
         * Here, I'm finally getting around to trying the Web Audio API.  Fortunately, based on what little
         * I know about sound generation, using the API to make the same noises as the IBM PC speaker seems
         * straightforward.
         *
         * To start, we create an audio context, unless the 'sound' parameter has been explicitly set to false
         * or 0; the boolean value true (along with any illegal number) now defaults to 0.5 instead of 1.0.
         */
        this.volumeInit = 0;
        let sound = parmsChipSet['sound'];
        if (sound) {
            this.volumeInit = (typeof sound != "number" || sound < 0 || sound > 1)? 0.5 : sound;
            this.classAudio = this.contextAudio = null;
            if (window) {
                this.classAudio = window['AudioContext'] || window['webkitAudioContext'];
            }
            if (this.classAudio) {
                this.contextAudio = new this.classAudio();
            } else {
                if (DEBUG) this.log("AudioContext not available");
            }
        }
        /*
         * fSpeakerEnabled indicates whether the speaker is *logically* on, whereas fSpeakerOn indicates
         * whether we have ACTUALLY turned the speaker on.  And finally, fUserSound is set to true only after
         * we have have created the audio oscillator in the context of a user event (a requirement for most
         * browsers before they'll actually emit any sound).
         */
        this.fSpeakerEnabled = this.fSpeakerOn = this.fUserSound = false;

        /*
         * I used to defer ChipSet's reset() to powerUp(), which then gave us the option of doing either
         * reset() OR restore(), instead of both.  However, on MODEL_5170 machines, the initial CMOS data
         * needs to be created earlier, so that when other components are initializing their state (eg, when
         * HDC calls setCMOSDriveType() or RAM calls addCMOSMemory()), the CMOS will be ready to take their calls.
         */
        this.reset(true);
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {ChipSet}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.cmp = cmp;

        this.fpu = cmp.getMachineComponent("FPU");
        this.setDIPSwitches(ChipSet.SWITCH_TYPE.FPU, this.fpu? 1 : 0, true);

        this.kbd = cmp.getMachineComponent("Keyboard");

        let sound = cmp.getMachineParm('sound');
        if (sound != null) {
            let volume = +sound || 0;
            this.volumeInit = (sound == "true" || volume < 0 || volume > 1? 0.5 : volume);
        }
        if (!this.volumeInit) this.println("note: speaker disabled");

        /*
         * This divisor is invariant, so we calculate it as soon as we're able to query the CPU's base speed.
         */
        this.nTicksDivisor = (cpu.getBaseCyclesPerSecond() / ChipSet.TIMER_TICKS_PER_SEC);

        bus.addPortInputTable(this, ChipSet.aPortInput);
        bus.addPortOutputTable(this, ChipSet.aPortOutput);
        if (this.model == ChipSet.MODEL_4860) {
            bus.addPortInputTable(this, ChipSet.aPortInput4860);
            bus.addPortOutputTable(this, ChipSet.aPortOutput4860);
        }
        else {
            bus.addPortInputTable(this, ChipSet.aPortInput5xxx);
            bus.addPortOutputTable(this, ChipSet.aPortOutput5xxx);
            if (this.model < ChipSet.MODEL_5170) {
                if (this.model == ChipSet.MODEL_ATT_6300) {
                    bus.addPortInputTable(this, ChipSet.aPortInput6300);
                    bus.addPortOutputTable(this, ChipSet.aPortOutput6300);
                } else {
                    bus.addPortInputTable(this, ChipSet.aPortInput5150);
                    bus.addPortOutputTable(this, ChipSet.aPortOutput5150);
                }
            } else {
                bus.addPortInputTable(this, ChipSet.aPortInput5170);
                bus.addPortOutputTable(this, ChipSet.aPortOutput5170);
                if (DESKPRO386 && (this.model|0) == ChipSet.MODEL_COMPAQ_DESKPRO386) {
                    bus.addPortInputTable(this, ChipSet.aPortInputDeskPro386);
                    bus.addPortOutputTable(this, ChipSet.aPortOutputDeskPro386);
                }
            }
        }
        if (DEBUGGER) {
            if (dbg) {
                let chipset = this;
                /*
                 * TODO: Add more "dumpers" (eg, for DMA, RTC, 8042, etc)
                 */
                dbg.messageDump(Messages.PIC, function onDumpPIC() {
                    chipset.dumpPIC();
                });
                dbg.messageDump(Messages.TIMER, function onDumpTimer(asArgs) {
                    chipset.dumpTimer(asArgs);
                });
                if (this.model >= ChipSet.MODEL_5170) {
                    dbg.messageDump(Messages.CMOS, function onDumpCMOS() {
                        chipset.dumpCMOS();
                    });
                }
            }
            cpu.addIntNotify(Interrupts.TIMER, this.intBIOSTimer.bind(this));
        }
        this.setReady();
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {ChipSet}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "sw1")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        switch (sBinding) {

        case ChipSet.CONTROLS.SW1:
            this.bindings[sBinding] = control;
            this.addDIPSwitches(0, sBinding);
            return true;

        case ChipSet.CONTROLS.SW2:
            if ((this.model|0) == ChipSet.MODEL_5150 || this.model == ChipSet.MODEL_ATT_6300) {
                this.bindings[sBinding] = control;
                this.addDIPSwitches(1, sBinding);
                return true;
            }
            break;

        case ChipSet.CONTROLS.SWDESC:
            this.bindings[sBinding] = control;
            return true;

        default:
            break;
        }
        return false;
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {ChipSet}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {ChipSet}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset(fHard)
     *
     * @this {ChipSet}
     * @param {boolean} [fHard] true on the initial reset (not a normal "soft" reset)
     */
    reset(fHard)
    {
        /*
         * We propagate the initial DIP switch values to the current DIP switch values on reset;
         * the user is only allowed to tweak the initial values, which require a reset to take effect.
         */
        let i;
        this.updateDIPSwitches();

        /*
         * DMA (Direct Memory Access) Controller initialization
         */
        this.aDMACs = new Array(this.cDMACs);
        for (i = 0; i < this.cDMACs; i++) {
            this.initDMAController(i);
        }

        /*
         * PIC (Programmable Interupt Controller) initialization
         */
        this.aPICs = new Array(this.cPICs);
        this.initPIC(ChipSet.PIC0.INDEX, ChipSet.PIC0.PORT_LO);
        if (this.cPICs > 1) {
            this.initPIC(ChipSet.PIC1.INDEX, ChipSet.PIC1.PORT_LO);
        }

        /*
         * PIT (Programmable Interval Timer) initialization
         *
         * Although the DeskPro 386 refers to the timers in the first PIT as "Timer 1, Counter 0",
         * "Timer 1, Counter 1" and "Timer 1, Counter 2", we're sticking with IBM's nomenclature:
         * TIMER0, TIMER1 and TIMER2.  Which means that we refer to the "counters" in the second PIT
         * as TIMER3, TIMER4 and TIMER5; that numbering also matches their indexes in the aTimers array.
         */
        this.bPIT0Ctrl = null;          // tracks writes to port 0x43
        this.bPIT1Ctrl = null;          // tracks writes to port 0x4B (MODEL_COMPAQ_DESKPRO386 only)
        this.aTimers = new Array((this.model|0) == ChipSet.MODEL_COMPAQ_DESKPRO386? 6 : 3);
        for (i = 0; i < this.aTimers.length; i++) {
            this.initTimer(i);
        }

        /*
         * PPI and other misc ports
         */
        this.bPPIA = null;              // tracks writes to port 0x60, in case PPI_CTRL.A_IN is not set
        this.bPPIB = null;              // tracks writes to port 0x61, in case PPI_CTRL.B_IN is not set
        this.bPPIC = null;              // tracks writes to port 0x62, in case PPI_CTRL.C_IN_LO or PPI_CTRL.C_IN_HI is not set
        this.bPPICtrl = null;           // tracks writes to port 0x63 (eg, 0x99); read-only
        this.bNMI = ChipSet.NMI.RESET;  // tracks writes to the NMI Mask Register
        this.bKbdData = 0;              // records last byte received via receiveKbdData(); for machines without an 8042 (eg, PC/PC XT/PCjr)

        if (this.model == ChipSet.MODEL_ATT_6300) {
            this.b8041Status = 0;       // similar to b8042Status (but apparently only bits 0 and 1 are used)
        }

        /*
         * ChipSet state introduced by the MODEL_5170
         */
        if (this.model >= ChipSet.MODEL_5170) {
            /*
             * The 8042 input buffer is treated as a "command byte" when written via port 0x64 and as a "data byte"
             * when written via port 0x60.  So, whenever the C8042.CMD.WRITE_CMD "command byte" is written to the input
             * buffer, the subsequent command data byte is saved in b8042CmdData.  Similarly, for C8042.CMD.WRITE_OUTPORT,
             * the subsequent data byte is saved in b8042OutPort.
             *
             * TODO: Consider a UI for the Keyboard INHIBIT switch.  By default, our keyboard is never inhibited
             * (ie, locked).  Also, note that the hardware changes this bit only when new data is sent to b8042OutBuff.
             */
            this.b8042Status = ChipSet.C8042.STATUS.NO_INHIBIT;
            this.b8042InBuff = 0;
            this.b8042CmdData = ChipSet.C8042.DATA.CMD.NO_CLOCK;
            this.b8042OutBuff = 0;

            /*
             * TODO: Provide more control over these 8042 "Input Port" bits (eg, the keyboard lock)
             */
            this.b8042InPort = ChipSet.C8042.INPORT.MFG_OFF | ChipSet.C8042.INPORT.KBD_UNLOCKED;

            if (this.getDIPMemorySize() >= 512) {
                this.b8042InPort |= ChipSet.C8042.INPORT.ENABLE_256KB;
            }

            if (this.getDIPVideoMonitor() == ChipSet.MONITOR.MONO) {
                this.b8042InPort |= ChipSet.C8042.INPORT.MONO;
            }

            if (DESKPRO386 && (this.model|0) == ChipSet.MODEL_COMPAQ_DESKPRO386) {
                this.b8042InPort |= ChipSet.C8042.INPORT.COMPAQ_NO80387 | ChipSet.C8042.INPORT.COMPAQ_NOWEITEK;
            }

            this.b8042OutPort = ChipSet.C8042.OUTPORT.NO_RESET | ChipSet.C8042.OUTPORT.A20_ON;

            this.abDMAPageSpare = new Array(8);

            this.bCMOSAddr = 0;         // NMI is enabled, since the ChipSet.CMOS.ADDR.NMI_DISABLE bit is not set in bCMOSAddr

            /*
             * Now that we call reset() from the ChipSet constructor, enabling other components to update
             * their own CMOS information as needed, we must distinguish between the initial ("hard") reset
             * and any later ("soft") resets (eg, from powerUp() calls), and make sure the latter preserves
             * existing CMOS information.
             */
            if (fHard) {
                this.abCMOSData = new Array(ChipSet.CMOS.ADDR.TOTAL);
            }

            this.initRTCTime(this.sDateRTC);

            /*
             * initCMOSData() will initialize a variety of "legacy" CMOS bytes, but it will NOT overwrite any memory
             * size or hard drive type information that might have been set, via addCMOSMemory() or setCMOSDriveType().
             */
            this.initCMOSData();
        }

        if (DEBUGGER && MAXDEBUG) {
            /*
             * Arrays for interrupt counts (one count per IRQ) and timer data
             */
            this.acInterrupts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            this.acTimersFired = [0, 0, 0];
            this.acTimer0Counts = [];
        }
    }

    /**
     * initRTCTime(sDate)
     *
     * Initialize the RTC portion of the CMOS registers to match the specified date/time (or if none is specified,
     * the current date/time).  The date/time should be expressed in the ISO 8601 format; eg: "2011-10-10T14:48:00".
     *
     * NOTE: There are two approaches we could take here: always store the RTC bytes in binary, and convert them
     * to/from BCD on-demand (ie, as the simulation reads/writes the CMOS RTC registers); or init/update them in the
     * format specified by CMOS.STATUSB.BINARY (1 for binary, 0 for BCD).  Both approaches require BCD conversion
     * functions, but the former seems more efficient, in part because the periodic calls to updateRTCTime() won't
     * require any conversions.
     *
     * We take the same approach with the CMOS.STATUSB.HOUR24 setting: internally, we always operate in 24-hour mode,
     * but externally, we convert the RTC hour values to the 12-hour format as needed.
     *
     * Thus, all I/O to the RTC bytes must be routed through the getRTCByte() and setRTCByte() functions, to ensure
     * that all the necessary on-demand conversions occur.
     *
     * @this {ChipSet}
     * @param {string} [sDate]
     */
    initRTCTime(sDate)
    {
        /*
         * NOTE: I've already been burned once by a JavaScript library function that did NOT treat an undefined
         * parameter (ie, a parameter === undefined) the same as an omitted parameter (eg, the async parameter in
         * xmlHTTP.open() in IE), so I'm taking no chances here: if sDate is undefined, then explicitly call Date()
         * with no parameters.
         */
        let date = sDate? new Date(sDate) : new Date();

        /*
         * Example of a valid Date string:
         *
         *      2014-10-01T08:00:00 (interpreted as GMT, resulting in "Wed Oct 01 2014 01:00:00 GMT-0700 (PDT)")
         *
         * Examples of INVALID Date strings:
         *
         *      2014-10-01T08:00:00PST
         *      2014-10-01T08:00:00-0700 (actually, this DOES work in Chrome, but NOT in Safari)
         *
         * In the case of INVALID Date strings, the Date object is invalid, but there's no obvious test for an "invalid"
         * object, so I've adapted the following test from StackOverflow.
         *
         * See http://stackoverflow.com/questions/1353684/detecting-an-invalid-date-date-instance-in-javascript
         */
        if (Object.prototype.toString.call(date) !== "[object Date]" || isNaN(date.getTime())) {
            date = new Date();
            this.println("CMOS date invalid (" + sDate + "), using " + date);
        } else if (sDate) {
            this.println("CMOS date: " + date);
        }

        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC] = date.getSeconds();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC_ALRM] = 0;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN] = date.getMinutes();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN_ALRM] = 0;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR] = date.getHours();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR_ALRM] = 0;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_WEEK_DAY] = date.getDay() + 1;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH_DAY] = date.getDate();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH] = date.getMonth() + 1;
        let nYear = date.getFullYear();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_YEAR] = nYear % 100;
        let nCentury = (nYear / 100);
        this.abCMOSData[ChipSet.CMOS.ADDR.CENTURY_DATE] = (nCentury % 10) | ((nCentury / 10) << 4);

        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSA] = 0x26;                          // hard-coded default; refer to ChipSet.CMOS.STATUSA.DV and ChipSet.CMOS.STATUSA.RS
        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] = ChipSet.CMOS.STATUSB.HOUR24;   // default to BCD mode (ChipSet.CMOS.STATUSB.BINARY not set)
        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] = 0x00;
        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSD] = ChipSet.CMOS.STATUSD.VRB;

        this.nRTCCyclesLastUpdate = this.nRTCCyclesNextUpdate = 0;
        this.nRTCPeriodsPerSecond = this.nRTCCyclesPerPeriod = null;
    }

    /**
     * getRTCByte(iRTC)
     *
     * @param {number} iRTC
     * @return {number} b
     */
    getRTCByte(iRTC)
    {


        let b = this.abCMOSData[iRTC];

        if (iRTC < ChipSet.CMOS.ADDR.STATUSA) {
            let f12HourValue = false;
            if (iRTC == ChipSet.CMOS.ADDR.RTC_HOUR || iRTC == ChipSet.CMOS.ADDR.RTC_HOUR_ALRM) {
                if (!(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.HOUR24)) {
                    if (b < 12) {
                        b = (!b? 12 : b);
                    } else {
                        b -= 12;
                        b = (!b? 0x8c : b + 0x80);
                    }
                    f12HourValue = true;
                }
            }
            if (!(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.BINARY)) {
                /*
                 * We're in BCD mode, so we must convert b from BINARY to BCD.  But first:
                 *
                 *      If b is a 12-hour value (ie, we're in 12-hour mode) AND the hour is a PM value
                 *      (ie, in the range 0x81-0x8C), then it must be adjusted to yield 81-92 in BCD.
                 *
                 *      AM hour values (0x01-0x0C) need no adjustment; they naturally convert to 01-12 in BCD.
                 */
                if (f12HourValue && b > 0x80) {
                    b -= (0x81 - 81);
                }
                b = (b % 10) | ((b / 10) << 4);
            }
        } else {
            if (iRTC == ChipSet.CMOS.ADDR.STATUSA) {
                /*
                 * Make sure that the "Update-In-Progress" bit we set in updateRTCTime() doesn't stay set for
                 * more than one read.
                 */
                this.abCMOSData[iRTC] &= ~ChipSet.CMOS.STATUSA.UIP;
            }
        }
        return b;
    }

    /**
     * setRTCByte(iRTC, b)
     *
     * @param {number} iRTC
     * @param {number} b proposed byte to write
     * @return {number} actual byte to write
     */
    setRTCByte(iRTC, b)
    {


        if (iRTC < ChipSet.CMOS.ADDR.STATUSA) {
            let fBCD = false;
            if (!(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.BINARY)) {
                /*
                 * We're in BCD mode, so we must convert b from BCD to BINARY (we assume it's valid
                 * BCD; ie, that both nibbles contain only 0-9, not A-F).
                 */
                b = (b >> 4) * 10 + (b & 0xf);
                fBCD = true;
            }
            if (iRTC == ChipSet.CMOS.ADDR.RTC_HOUR || iRTC == ChipSet.CMOS.ADDR.RTC_HOUR_ALRM) {
                if (fBCD) {
                    /*
                     * If the original BCD hour was 0x81-0x92, then the previous BINARY-to-BCD conversion
                     * transformed it to 0x51-0x5C, so we must add 0x30.
                     */
                    if (b > 23) {

                        b += 0x30;
                    }
                }
                if (!(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.HOUR24)) {
                    if (b <= 12) {
                        b = (b == 12? 0 : b);
                    } else {
                        b -= (0x80 - 12);
                        b = (b == 24? 12 : b);
                    }
                }
            }
        }
        return b;
    }

    /**
     * calcRTCCyclePeriod()
     *
     * This should be called whenever the timings in STATUSA may have changed.
     *
     * TODO: 1024 is a hard-coded number of periods per second based on the default interrupt rate of 976.562us
     * (ie, 1000000 / 976.562).  Calculate the actual number based on the values programmed in the STATUSA register.
     *
     * @this {ChipSet}
     */
    calcRTCCyclePeriod()
    {
        this.nRTCCyclesLastUpdate = this.cpu.getCycles(this.fScaleTimers);
        this.nRTCPeriodsPerSecond = 1024;
        this.nRTCCyclesPerPeriod = Math.floor(this.cpu.getBaseCyclesPerSecond() / this.nRTCPeriodsPerSecond);
        this.setRTCCycleLimit();
    }

    /**
     * getRTCCycleLimit(nCycles)
     *
     * This is called by the CPU to determine the maximum number of cycles it can process for the current burst.
     *
     * @this {ChipSet}
     * @param {number} nCycles desired
     * @return {number} maximum number of cycles (<= nCycles)
     */
    getRTCCycleLimit(nCycles)
    {
        if (this.abCMOSData && this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.PIE) {
            let nCyclesUpdate = this.nRTCCyclesNextUpdate - this.cpu.getCycles(this.fScaleTimers);
            if (nCyclesUpdate > 0) {
                if (nCycles > nCyclesUpdate) {
                    if (DEBUG && this.messageEnabled(Messages.RTC)) {
                        this.printMessage("getRTCCycleLimit(" + nCycles + "): reduced to " + nCyclesUpdate + " cycles", true);
                    }
                    nCycles = nCyclesUpdate;
                } else {
                    if (DEBUG && this.messageEnabled(Messages.RTC)) {
                        this.printMessage("getRTCCycleLimit(" + nCycles + "): already less than " + nCyclesUpdate + " cycles", true);
                    }
                }
            } else {
                if (DEBUG && this.messageEnabled(Messages.RTC)) {
                    this.printMessage("RTC next update has passed by " + nCyclesUpdate + " cycles", true);
                }
            }
        }
        return nCycles;
    }

    /**
     * setRTCCycleLimit()
     *
     * This should be called when PIE becomes set in STATUSB (and whenever PF is cleared in STATUSC while PIE is still set).
     *
     * @this {ChipSet}
     */
    setRTCCycleLimit()
    {
        let nCycles = this.nRTCCyclesPerPeriod;
        this.nRTCCyclesNextUpdate = this.cpu.getCycles(this.fScaleTimers) + nCycles;
        if (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.PIE) {
            this.cpu.setBurstCycles(nCycles);
        }
    }

    /**
     * updateRTCTime()
     *
     * @this {ChipSet}
     */
    updateRTCTime()
    {
        let nCyclesPerSecond = this.cpu.getBaseCyclesPerSecond();
        let nCyclesUpdate = this.cpu.getCycles(this.fScaleTimers);

        /*
         * We must arrange for the very first calcRTCCyclePeriod() call to occur here, on the very first
         * updateRTCTime() call, because this is the first point we can be guaranteed that CPU cycle counts
         * are initialized (the CPU is the last component to be powered up/restored).
         *
         * TODO: A side-effect of this is that it undermines the save/restore code's preservation of last
         * and next RTC cycle counts, which may affect when the next RTC event is delivered.
         */
        if (this.nRTCCyclesPerPeriod == null) this.calcRTCCyclePeriod();

        /*
         * Step 1: Deal with Periodic Interrupts
         */
        if (nCyclesUpdate >= this.nRTCCyclesNextUpdate) {
            let bPrev = this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC];
            this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.PF;
            if (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.PIE) {
                /*
                 * When PIE is set, setBurstCycles() should be getting called as needed to ensure
                 * that updateRTCTime() is called more frequently, so let's assert that we don't have
                 * an excess of cycles and thus possibly some missed Periodic Interrupts.
                 */
                if (DEBUG) {
                    if (nCyclesUpdate - this.nRTCCyclesNextUpdate > this.nRTCCyclesPerPeriod) {
                        if (bPrev & ChipSet.CMOS.STATUSC.PF) {
                            this.printMessage("RTC interrupt handler failed to clear STATUSC", Messages.RTC);
                        } else {
                            this.printMessage("CPU took too long trigger new RTC periodic interrupt", Messages.RTC);
                        }
                    }
                }
                this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.IRQF;
                this.setIRR(ChipSet.IRQ.RTC);
                /*
                 * We could also call setRTCCycleLimit() at this point, but I don't think there's any
                 * benefit until the interrupt had been acknowledged and STATUSC has been read, thereby
                 * clearing the way for another Periodic Interrupt; it seems to me that when STATUSC
                 * is read, that's the more appropriate time to call setRTCCycleLimit().
                 */
            }
            this.nRTCCyclesNextUpdate = nCyclesUpdate + this.nRTCCyclesPerPeriod;
        }

        /*
         * Step 2: Deal with Alarm Interrupts
         */
        if (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC] == this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC_ALRM]) {
            if (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN] == this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN_ALRM]) {
                if (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR] == this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR_ALRM]) {
                    this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.AF;
                    if (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.AIE) {
                        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.IRQF;
                        this.setIRR(ChipSet.IRQ.RTC);
                    }
                }
            }
        }

        /*
         * Step 3: Update the RTC date/time and deal with Update Interrupts
         */
        let nCyclesDelta = nCyclesUpdate - this.nRTCCyclesLastUpdate;
        // DEBUG:
        let nSecondsDelta = Math.floor(nCyclesDelta / nCyclesPerSecond);

        /*
         * We trust that updateRTCTime() is being called as part of updateAllTimers(), and is therefore
         * being called often enough to ensure that nSecondsDelta will never be greater than one.  In fact,
         * it would always be LESS than one if it weren't also for the fact that we plow any "unused" cycles
         * (nCyclesDelta % nCyclesPerSecond) back into nRTCCyclesLastUpdate, so that we will eventually
         * see a one-second delta.
         */
        // DEBUG:

        /*
         * Make sure that CMOS.STATUSB.SET isn't set; if it is, then the once-per-second RTC updates must be
         * disabled so that software can write new RTC date/time values without interference.
         */
        if (nSecondsDelta && !(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.SET)) {
            while (nSecondsDelta--) {
                if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC] >= 60) {
                    this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC] = 0;
                    if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN] >= 60) {
                        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN] = 0;
                        if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR] >= 24) {
                            this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR] = 0;
                            this.abCMOSData[ChipSet.CMOS.ADDR.RTC_WEEK_DAY] = (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_WEEK_DAY] % 7) + 1;
                            let nDayMax = Usr.getMonthDays(this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH], this.abCMOSData[ChipSet.CMOS.ADDR.RTC_YEAR]);
                            if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH_DAY] > nDayMax) {
                                this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH_DAY] = 1;
                                if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH] > 12) {
                                    this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH] = 1;
                                    this.abCMOSData[ChipSet.CMOS.ADDR.RTC_YEAR] = (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_YEAR] + 1) % 100;
                                }
                            }
                        }
                    }
                }
            }

            /*
             * Obviously, setting the "Update-In-Progress" bit now might seem rather pointless, since we just
             * updated the RTC "atomically" as far as the machine is concerned; however, the bit must be set at
             * at some point, in order to make the MODEL_5170 BIOS ("POST2_RTCUP") happy.
             */
            this.abCMOSData[ChipSet.CMOS.ADDR.STATUSA] |= ChipSet.CMOS.STATUSA.UIP;

            this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.UF;
            if (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.UIE) {
                this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.IRQF;
                this.setIRR(ChipSet.IRQ.RTC);
            }
        }

        this.nRTCCyclesLastUpdate = nCyclesUpdate - (nCyclesDelta % nCyclesPerSecond);
    }

    /**
     * initCMOSData()
     *
     * Initialize all the CMOS configuration bytes in the range 0x0E-0x2F (TODO: Decide what to do about 0x30-0x3F)
     *
     * Note that the MODEL_5170 "SETUP" utility is normally what sets all these bytes, including the checksum, and then
     * the BIOS verifies it, but since we want our machines to pass BIOS verification "out of the box", we go the extra
     * mile here, even though it's not really our responsibility.
     *
     * @this {ChipSet}
     */
    initCMOSData()
    {
        /*
         * On all reset() calls, the RAM component(s) will (re)add their totals, so we have to make sure that
         * the addition always starts with 0.  That also means that ChipSet must always be initialized before RAM.
         */
        let iCMOS;
        for (iCMOS = ChipSet.CMOS.ADDR.BASEMEM_LO; iCMOS <= ChipSet.CMOS.ADDR.EXTMEM_HI; iCMOS++) {
            this.abCMOSData[iCMOS] = 0;
        }

        /*
         * Make sure all the "checksummed" CMOS bytes are initialized (not just the handful we set below) to ensure
         * that the checksum will be valid.
         */
        for (iCMOS = ChipSet.CMOS.ADDR.DIAG; iCMOS < ChipSet.CMOS.ADDR.CHKSUM_HI; iCMOS++) {
            if (this.abCMOSData[iCMOS] === undefined) this.abCMOSData[iCMOS] = 0;
        }

        /*
         * We propagate all compatible "legacy" SW1 bits to the CMOS.EQUIP byte using the old SW masks, but any further
         * access to CMOS.ADDR.EQUIP should use the new CMOS_EQUIP flags (eg, CMOS.EQUIP.FPU, CMOS.EQUIP.MONITOR.CGA80, etc).
         */
        this.abCMOSData[ChipSet.CMOS.ADDR.EQUIP] = this.getDIPLegacyBits(0);
        this.abCMOSData[ChipSet.CMOS.ADDR.FDRIVE] = (this.getDIPFloppyDriveType(0) << 4) | this.getDIPFloppyDriveType(1);

        /*
         * The final step is calculating the CMOS checksum, which we then store into the CMOS as a courtesy, so that the
         * user doesn't get unnecessary CMOS errors.
         */
        this.updateCMOSChecksum();
    }

    /**
     * setCMOSByte(iCMOS, b)
     *
     * This is ONLY for use by components that need to update CMOS configuration bytes to match their internal configuration.
     *
     * @this {ChipSet}
     * @param {number} iCMOS
     * @param {number} b
     * @return {boolean} true if successful, false if not (eg, CMOS not initialized yet, or no CMOS on this machine)
     */
    setCMOSByte(iCMOS, b)
    {
        if (this.abCMOSData) {

            this.abCMOSData[iCMOS] = b;
            this.updateCMOSChecksum();
            return true;
        }
        return false;
    }

    /**
     * addCMOSMemory(addr, size)
     *
     * For use by the RAM component, to dynamically update the CMOS memory configuration.
     *
     * @this {ChipSet}
     * @param {number} addr (if 0, BASEMEM_LO/BASEMEM_HI is updated; if >= 0x100000, then EXTMEM_LO/EXTMEM_HI is updated)
     * @param {number} size (in bytes; we convert to Kb)
     * @return {boolean} true if successful, false if not (eg, CMOS not initialized yet, or no CMOS on this machine)
     */
    addCMOSMemory(addr, size)
    {
        if (this.abCMOSData) {
            let iCMOS = (addr < 0x100000? ChipSet.CMOS.ADDR.BASEMEM_LO : ChipSet.CMOS.ADDR.EXTMEM_LO);
            let wKb = this.abCMOSData[iCMOS] | (this.abCMOSData[iCMOS+1] << 8);
            wKb += (size >> 10);
            this.abCMOSData[iCMOS] = wKb & 0xff;
            this.abCMOSData[iCMOS+1] = wKb >> 8;
            this.updateCMOSChecksum();
            return true;
        }
        return false;
    }

    /**
     * setCMOSDriveType(iDrive, bType)
     *
     * For use by the HDC component, to update the CMOS drive configuration to match HDC's internal configuration.
     *
     * TODO: Consider extending this to support FDC drive updates, so that the FDC can specify diskette drive types
     * (ie, FD360 or FD1200) in the same way that HDC does.  However, historically, the ChipSet has been responsible for
     * floppy drive configuration, at least in terms of *number* of drives, through the use of SW1 settings, and we've
     * continued that tradition with the addition of the ChipSet 'floppies' parameter, which allows both the number *and*
     * capacity of drives to be specified with a simple array (eg, [360, 360] for two 360Kb drives).
     *
     * @this {ChipSet}
     * @param {number} iDrive (0 or 1)
     * @param {number} bType (0 for none, 1-14 for original drive type, 16-255 for extended drive type; 15 reserved)
     * @return {boolean} true if successful, false if not (eg, CMOS not initialized yet, or no CMOS on this machine)
     */
    setCMOSDriveType(iDrive, bType)
    {
        if (this.abCMOSData) {
            let bExt = null, iExt;
            let bOrig = this.abCMOSData[ChipSet.CMOS.ADDR.HDRIVE];
            if (bType > 15) {
                bExt = bType;  bType = 15;
            }
            if (iDrive) {
                bOrig = (bOrig & ChipSet.CMOS.HDRIVE.D0_MASK) | bType;
                iExt = ChipSet.CMOS.ADDR.EXTHDRIVE1;
            } else {
                bOrig = (bOrig & ChipSet.CMOS.HDRIVE.D1_MASK) | (bType << 4);
                iExt = ChipSet.CMOS.ADDR.EXTHDRIVE0;
            }
            this.setCMOSByte(ChipSet.CMOS.ADDR.HDRIVE, bOrig);
            if (bExt != null) this.setCMOSByte(iExt, bExt);
            return true;
        }
        return false;
    }

    /**
     * updateCMOSChecksum()
     *
     * This sums all the CMOS bytes from 0x10-0x2D, creating a 16-bit checksum.  That's a total of 30 (unsigned) 8-bit
     * values which could sum to at most 30*255 or 7650 (0x1DE2).  Since there's no way that can overflow 16 bits, we don't
     * worry about masking it with 0xffff.
     *
     * WARNING: The IBM PC AT TechRef, p.1-53 (p.75) claims that the checksum is on bytes 0x10-0x20, but that's simply wrong.
     *
     * @this {ChipSet}
     */
    updateCMOSChecksum()
    {
        let wChecksum = 0;
        for (let iCMOS = ChipSet.CMOS.ADDR.FDRIVE; iCMOS < ChipSet.CMOS.ADDR.CHKSUM_HI; iCMOS++) {
            wChecksum += this.abCMOSData[iCMOS];
        }
        this.abCMOSData[ChipSet.CMOS.ADDR.CHKSUM_LO] = wChecksum & 0xff;
        this.abCMOSData[ChipSet.CMOS.ADDR.CHKSUM_HI] = wChecksum >> 8;
    }

    /**
     * save()
     *
     * This implements save support for the ChipSet component.
     *
     * @this {ChipSet}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, [this.aDIPSwitches]);
        state.set(1, [this.saveDMAControllers()]);
        state.set(2, [this.savePICs()]);
        state.set(3, [this.bPIT0Ctrl, this.saveTimers(), this.bPIT1Ctrl]);
        state.set(4, [this.bPPIA, this.bPPIB, this.bPPIC, this.bPPICtrl, this.bNMI]);
        if (this.model >= ChipSet.MODEL_5170) {
            state.set(5, [this.b8042Status, this.b8042InBuff, this.b8042CmdData,
                          this.b8042OutBuff, this.b8042InPort, this.b8042OutPort]);
            state.set(6, [this.abDMAPageSpare[7], this.abDMAPageSpare, this.bCMOSAddr, this.abCMOSData, this.nRTCCyclesLastUpdate, this.nRTCCyclesNextUpdate]);
        }
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the ChipSet component.
     *
     * @this {ChipSet}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        let a, i;
        a = data[0];

        if (Array.isArray(a[0])) {
            this.aDIPSwitches = a[0];
        } else {
            this.aDIPSwitches[0][0] = a[0];
            this.aDIPSwitches[1][0] = a[1] & 0x0F;  // we do honor SW2[5] now, but it was erroneously set on some machines
            this.aDIPSwitches[0][1] = a[2];
            this.aDIPSwitches[1][1] = a[3] & 0x0F;  // we do honor SW2[5] now, but it was erroneously set on some machines
        }
        this.updateDIPSwitches();

        a = data[1];
        for (i = 0; i < this.cDMACs; i++) {
            this.initDMAController(i, a.length == 1? a[0][i] : a);
        }

        a = data[2];
        for (i = 0; i < this.cPICs; i++) {
            this.initPIC(i, i === 0? ChipSet.PIC0.PORT_LO : ChipSet.PIC1.PORT_LO, a[0][i]);
        }

        a = data[3];
        this.bPIT0Ctrl = a[0];
        this.bPIT1Ctrl = a[2];
        for (i = 0; i < this.aTimers.length; i++) {
            this.initTimer(i, a[1][i]);
        }

        a = data[4];
        this.bPPIA = a[0];
        this.bPPIB = a[1];
        this.bPPIC = a[2];
        this.bPPICtrl = a[3];
        this.bNMI  = a[4];

        a = data[5];
        if (a) {

            this.b8042Status = a[0];
            this.b8042InBuff = a[1];
            this.b8042CmdData = a[2];
            this.b8042OutBuff = a[3];
            this.b8042InPort = a[4];
            this.b8042OutPort = a[5];
        }

        a = data[6];
        if (a) {

            this.abDMAPageSpare = a[1];
            this.abDMAPageSpare[7] = a[0];  // formerly bMFGData
            this.bCMOSAddr = a[2];
            this.abCMOSData = a[3];
            this.nRTCCyclesLastUpdate = a[4];
            this.nRTCCyclesNextUpdate = a[5];
            /*
             * TODO: Decide whether restore() should faithfully preserve the RTC date/time that save() saved,
             * or always reinitialize the date/time, or give the user (or the machine configuration) the option.
             *
             * For now, we're always reinitializing the RTC date.  Alternatively, we could selectively update
             * the CMOS bytes above, instead of overwriting them all, in which case this extra call to initRTCTime()
             * could be avoided.
             */
            this.initRTCTime();
        }
        return true;
    }

    /**
     * start()
     *
     * Notification from the Computer that it's starting.
     *
     * @this {ChipSet}
     */
    start()
    {
        /*
         * Currently, all we do with this notification is allow the speaker to make noise.
         */
        this.setSpeaker();
    }

    /**
     * stop()
     *
     * Notification from the Computer that it's stopping.
     *
     * @this {ChipSet}
     */
    stop()
    {
        /*
         * Currently, all we do with this notification is prevent the speaker from making noise.
         */
        this.setSpeaker();
    }

    /**
     * initDMAController(iDMAC, aState)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {Array} [aState]
     */
    initDMAController(iDMAC, aState)
    {
        let controller = this.aDMACs[iDMAC];
        if (!controller) {

            controller = {
                aChannels: new Array(4)
            };
        }
        let a = aState && aState.length >= 5? aState : ChipSet.aDMAControllerInit;
        controller.bStatus = a[0];
        controller.bCmd = a[1];
        controller.bReq = a[2];
        controller.bIndex = a[3];
        controller.nChannelBase = iDMAC << 2;
        for (let iChannel = 0; iChannel < controller.aChannels.length; iChannel++) {
            this.initDMAChannel(controller, iChannel, a[4][iChannel]);
        }
        controller.bTemp = a[5] || 0;       // not present in older states
        this.aDMACs[iDMAC] = controller;
    }

    /**
     * initDMAChannel(controller, iChannel, aState)
     *
     * @this {ChipSet}
     * @param {Object} controller
     * @param {number} iChannel
     * @param {Array} [aState]
     */
    initDMAChannel(controller, iChannel, aState)
    {
        let channel = controller.aChannels[iChannel];
        if (!channel) {

            channel = {
                addrInit: [0,0],
                countInit: [0,0],
                addrCurrent: [0,0],
                countCurrent: [0,0]
            };
        }
        let a = aState && aState.length == 8? aState : ChipSet.aDMAChannelInit;
        channel.masked = a[0];
        channel.addrInit[0] = a[1][0]; channel.addrInit[1] = a[1][1];
        channel.countInit[0] = a[2][0];  channel.countInit[1] = a[2][1];
        channel.addrCurrent[0] = a[3][0]; channel.addrCurrent[1] = a[3][1];
        channel.countCurrent[0] = a[4][0]; channel.countCurrent[1] = a[4][1];
        channel.mode = a[5];
        channel.bPage = a[6];
        // a[7] is deprecated
        channel.controller = controller;
        channel.iChannel = iChannel;
        this.initDMAFunction(channel, a[8], a[9]);
        controller.aChannels[iChannel] = channel;
    }

    /**
     * initDMAFunction(channel)
     *
     * @param {Object} channel
     * @param {Component|string} [component]
     * @param {string} [sFunction]
     * @param {Object} [obj]
     * @return {*}
     */
    initDMAFunction(channel, component, sFunction, obj)
    {
        if (typeof component == "string") {
            component = Component.getComponentByID(component);
        }
        if (component) {
            channel.done = null;
            channel.sDevice = component.id;
            channel.sFunction = sFunction;
            channel.component = component;
            channel.fnTransfer = component[sFunction];
            channel.obj = obj;
        }
        return channel.fnTransfer;
    }

    /**
     * saveDMAControllers()
     *
     * @this {ChipSet}
     * @return {Array}
     */
    saveDMAControllers()
    {
        let data = [];
        for (let iDMAC = 0; iDMAC < this.aDMACs; iDMAC++) {
            let controller = this.aDMACs[iDMAC];
            data[iDMAC] = [
                controller.bStatus,
                controller.bCmd,
                controller.bReq,
                controller.bIndex,
                this.saveDMAChannels(controller),
                controller.bTemp
            ];
        }
        return data;
    }

    /**
     * saveDMAChannels(controller)
     *
     * @this {ChipSet}
     * @param {Object} controller
     * @return {Array}
     */
    saveDMAChannels(controller)
    {
        let data = [];
        for (let iChannel = 0; iChannel < controller.aChannels.length; iChannel++) {
            let channel = controller.aChannels[iChannel];
            data[iChannel] = [
                channel.masked,
                channel.addrInit,
                channel.countInit,
                channel.addrCurrent,
                channel.countCurrent,
                channel.mode,
                channel.bPage,
                channel.sDevice,
                channel.sFunction
            ];
        }
        return data;
    }

    /**
     * initPIC(iPIC, port, aState)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} port
     * @param {Array} [aState]
     */
    initPIC(iPIC, port, aState)
    {
        let pic = this.aPICs[iPIC];
        if (!pic) {
            pic = {
                aICW:   [null,null,null,null]
            };
        }
        let a = aState && aState.length == 8? aState : ChipSet.aPICInit;
        pic.port = port;
        pic.nIRQBase = iPIC << 3;
        pic.nDelay = a[0];
        pic.aICW[0] = a[1][0]; pic.aICW[1] = a[1][1]; pic.aICW[2] = a[1][2]; pic.aICW[3] = a[1][3];
        pic.nICW = a[2];
        pic.bIMR = a[3];
        pic.bIRR = a[4];
        pic.bISR = a[5];
        pic.bIRLow = a[6];
        pic.bOCW3 = a[7];
        this.aPICs[iPIC] = pic;
    }

    /**
     * savePICs()
     *
     * @this {ChipSet}
     * @return {Array}
     */
    savePICs()
    {
        let data = [];
        for (let iPIC = 0; iPIC < this.aPICs.length; iPIC++) {
            let pic = this.aPICs[iPIC];
            data[iPIC] = [
                pic.nDelay,
                pic.aICW,
                pic.nICW,
                pic.bIMR,
                pic.bIRR,
                pic.bISR,
                pic.bIRLow,
                pic.bOCW3
            ];
        }
        return data;
    }

    /**
     * initTimer(iTimer, aState)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @param {Array} [aState]
     */
    initTimer(iTimer, aState)
    {
        let timer = this.aTimers[iTimer];
        if (!timer) {
            timer = {
                countInit: [0,0],
                countStart: [0,0],
                countCurrent: [0,0],
                countLatched: [0,0]
            };
        }
        let a = aState && aState.length >= 13? aState : ChipSet.aTimerInit;
        timer.countInit[0] = a[0][0]; timer.countInit[1] = a[0][1];
        timer.countStart[0] = a[1][0]; timer.countStart[1] = a[1][1];
        timer.countCurrent[0] = a[2][0]; timer.countCurrent[1] = a[2][1];
        timer.countLatched[0] = a[3][0]; timer.countLatched[1] = a[3][1];
        timer.bcd = a[4];
        timer.mode = a[5];
        timer.rw = a[6];
        timer.countIndex = a[7];
        timer.countBytes = a[8];
        timer.fOUT = a[9];
        timer.fCountLatched = a[10];
        timer.fCounting = a[11];
        timer.nCyclesStart = a[12];
        timer.bStatus = a[13] || 0;
        timer.fStatusLatched = a[14] || false;
        this.aTimers[iTimer] = timer;
    }

    /**
     * saveTimers()
     *
     * @this {ChipSet}
     * @return {Array}
     */
    saveTimers()
    {
        let data = [];
        for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
            let timer = this.aTimers[iTimer];
            data[iTimer] = [
                timer.countInit,
                timer.countStart,
                timer.countCurrent,
                timer.countLatched,
                timer.bcd,
                timer.mode,
                timer.rw,
                timer.countIndex,
                timer.countBytes,
                timer.fOUT,
                timer.fCountLatched,
                timer.fCounting,
                timer.nCyclesStart,
                timer.bStatus,
                timer.fStatusLatched
            ];
        }
        return data;
    }

    /**
     * addDIPSwitches(iDIP, sBinding)
     *
     * @this {ChipSet}
     * @param {number} iDIP (0 or 1)
     * @param {string} sBinding is the name of the control
     */
    addDIPSwitches(iDIP, sBinding)
    {
        let sHTML = "";
        let control = this.bindings[sBinding];
        for (let i = 1; i <= 8; i++) {
            let sCellClasses = this.sCellClass;
            if (!i) sCellClasses += " " + this.sCellClass + "Left";
            let sCellID = sBinding + "-" + i;
            sHTML += "<div id=\"" + sCellID + "\" class=\"" + sCellClasses + "\" data-value=\"0\">" + i + "</div>\n";
        }
        control.innerHTML = sHTML;
        this.updateDIPSwitchControls(iDIP, sBinding, true);
    }

    /**
     * findDIPSwitch(iDIP, iSwitch)
     *
     * @this {ChipSet}
     * @param {number} iDIP
     * @param {number} iSwitch
     * @return {Object|null} DIPSW switchGroup containing the DIP switch's MASK, VALUES, and LABEL, or null if none
     */
    findDIPSwitch(iDIP, iSwitch)
    {
        let switchDIPs = ChipSet.DIPSW[this.model|0];
        let switchTypes = switchDIPs && switchDIPs[iDIP];
        if (switchTypes) {
            for (let iType in switchTypes) {
                let switchGroup = switchTypes[iType];
                if (switchGroup.MASK & (1 << iSwitch)) {
                    return switchGroup;
                }
            }
        }
        return null;
    }

    /**
     * getDIPLegacyBits(iDIP)
     *
     * @this {ChipSet}
     * @param {number} iDIP
     * @return {number|undefined}
     */
    getDIPLegacyBits(iDIP)
    {
        let b;
        if (!iDIP) {
            b = 0;
            b |= (this.getDIPVideoMonitor() << ChipSet.PPI_SW.MONITOR.SHIFT) & ChipSet.PPI_SW.MONITOR.MASK;
            b |= (this.getDIPCoprocessor()? ChipSet.PPI_SW.FPU : 0);
            let nDrives = this.getDIPFloppyDrives();
            b |= (nDrives? ((((nDrives - 1) << ChipSet.PPI_SW.FDRIVE.SHIFT) & ChipSet.PPI_SW.FDRIVE.MASK) | ChipSet.PPI_SW.FDRIVE.IPL) : 0);
        }
        return b;
    }

    /**
     * getDIPSwitches(iType, fInit)
     *
     * @this {ChipSet}
     * @param {number} iType
     * @param {boolean} [fInit] is true for initial switch value, current value otherwise
     * @return {*|null}
     */
    getDIPSwitches(iType, fInit)
    {
        let value = null;
        let switchDIPs = ChipSet.DIPSW[this.model] || ChipSet.DIPSW[this.model|0] || ChipSet.DIPSW[ChipSet.MODEL_5150];
        for (let iDIP = 0; iDIP < switchDIPs.length; iDIP++) {
            let switchTypes = switchDIPs[iDIP];
            if (switchTypes) {
                let switchGroup = switchTypes[iType];
                if (switchGroup) {
                    let bits = this.aDIPSwitches[iDIP][fInit?0:1] & switchGroup.MASK;
                    for (let v in switchGroup.VALUES) {
                        if (switchGroup.VALUES[v] == bits) {
                            value = v;
                            /*
                             * We prefer numeric properties, and all switch definitions must provide them
                             * if their helper functions (eg, getDIPVideoMonitor()) expect numeric properties.
                             */
                            if (typeof +value == 'number') break;
                        }
                    }
                    break;
                }
            }
        }
        return value;
    }

    /**
     * getDIPCoprocessor(fInit)
     *
     * @this {ChipSet}
     * @param {boolean} [fInit] is true for init switch value(s) only, current value(s) otherwise
     * @return {number} 1 if installed, 0 if not
     */
    getDIPCoprocessor(fInit)
    {
        let n = /** @type {number} */ (this.getDIPSwitches(ChipSet.SWITCH_TYPE.FPU, fInit));
        return +n;
    }

    /**
     * getDIPFloppyDrives(fInit)
     *
     * @this {ChipSet}
     * @param {boolean} [fInit] is true for init switch value(s) only, current value(s) otherwise
     * @return {number} number of floppy drives specified by SW1 (range is 0 to 4)
     */
    getDIPFloppyDrives(fInit)
    {
        let n = /** @type {number} */ (this.getDIPSwitches(ChipSet.SWITCH_TYPE.FLOPNUM, fInit));
        return +n;
    }

    /**
     * getDIPFloppyDriveType(iDrive)
     *
     * @this {ChipSet}
     * @param {number} iDrive (0-based)
     * @return {number} one of the ChipSet.CMOS.FDRIVE.FD* values (FD360, FD1200, etc)
     */
    getDIPFloppyDriveType(iDrive)
    {
        if (iDrive < this.getDIPFloppyDrives()) {
            if (!this.aFloppyDrives) {
                return ChipSet.CMOS.FDRIVE.FD360;
            }
            if (iDrive < this.aFloppyDrives.length) {
                switch(this.aFloppyDrives[iDrive]) {
                case 160:
                case 180:
                case 320:
                case 360:
                    return ChipSet.CMOS.FDRIVE.FD360;
                case 720:
                    return ChipSet.CMOS.FDRIVE.FD720;
                case 1200:
                    return ChipSet.CMOS.FDRIVE.FD1200;
                case 1440:
                    return ChipSet.CMOS.FDRIVE.FD1440;
                }
            }

        }
        return ChipSet.CMOS.FDRIVE.NONE;
    }

    /**
     * getDIPFloppyDriveSize(iDrive)
     *
     * @this {ChipSet}
     * @param {number} iDrive (0-based)
     * @return {number} capacity of drive in Kb (eg, 360, 1200, 1440, etc), or 0 if none
     */
    getDIPFloppyDriveSize(iDrive)
    {
        if (iDrive < this.getDIPFloppyDrives()) {
            if (!this.aFloppyDrives) {
                return 360;
            }
            if (iDrive < this.aFloppyDrives.length) {
                return this.aFloppyDrives[iDrive];
            }

        }
        return 0;
    }

    /**
     * getDIPMemorySize(fInit)
     *
     * @this {ChipSet}
     * @param {boolean} [fInit] is true for init switch value(s) only, current value(s) otherwise
     * @return {number} number of Kb of specified memory (NOT necessarily the same as installed memory; see RAM component)
     */
    getDIPMemorySize(fInit)
    {
        let nKBLowMem = /** @type {number} */ (this.getDIPSwitches(ChipSet.SWITCH_TYPE.LOWMEM, fInit));
        let nKBExpMem = /** @type {number} */ (this.getDIPSwitches(ChipSet.SWITCH_TYPE.EXPMEM, fInit));
        return +nKBLowMem + +nKBExpMem;
    }

    /**
     * getDIPVideoMonitor(fInit)
     *
     * @this {ChipSet}
     * @param {boolean} [fInit] is true for init switch value(s) only, current value(s) otherwise
     * @return {number} one of ChipSet.MONITOR.*
     */
    getDIPVideoMonitor(fInit)
    {
        let n = /** @type {number} */ (this.getDIPSwitches(ChipSet.SWITCH_TYPE.MONITOR, fInit));
        return +n;
    }

    /**
     * parseDIPSwitches(sBits, bDefault)
     *
     * @this {ChipSet}
     * @param {string} sBits describing switch settings
     * @param {number} [bDefault]
     * @return {number|undefined}
     */
    parseDIPSwitches(sBits, bDefault)
    {
        let b = bDefault;
        if (sBits) {
            /*
             * NOTE: We can't use parseInt() with a base of 2, because both bit order and bit sense are reversed.
             */
            b = 0;
            let bit = 0x1;
            for (let i = 0; i < sBits.length; i++) {
                if (sBits.charAt(i) == "0") b |= bit;
                bit <<= 1;
            }
        }
        return b;
    }

    /**
     * setDIPSwitches(iType, value, fInit)
     *
     * @this {ChipSet}
     * @param {number} iType
     * @param {*} value
     * @param {boolean} [fInit]
     * @return {boolean} true if successful, false if unrecognized type and/or value
     */
    setDIPSwitches(iType, value, fInit)
    {
        let switchDIPs = ChipSet.DIPSW[this.model] || ChipSet.DIPSW[this.model|0] || ChipSet.DIPSW[ChipSet.MODEL_5150];
        for (let iDIP = 0; iDIP < switchDIPs.length; iDIP++) {
            let switchTypes = switchDIPs[iDIP];
            if (switchTypes) {
                let switchGroup = switchTypes[iType];
                if (switchGroup) {
                    for (let v in switchGroup.VALUES) {
                        if (v == value) {
                            this.aDIPSwitches[iDIP][fInit?0:1] &= ~switchGroup.MASK;
                            this.aDIPSwitches[iDIP][fInit?0:1] |= switchGroup.VALUES[v];
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * getDIPSwitchControl(control)
     *
     * @this {ChipSet}
     * @param {HTMLElement} control is an HTML control DOM object
     * @return {boolean} true if the switch represented by e is "on", false if "off"
     */
    getDIPSwitchControl(control)
    {
        return control.getAttribute("data-value") == "1";
    }

    /**
     * setDIPSwitchControl(control, f)
     *
     * @this {ChipSet}
     * @param {HTMLElement} control is an HTML control DOM object
     * @param {boolean} f is true if the switch represented by control should be "on", false if "off"
     */
    setDIPSwitchControl(control, f)
    {
        control.setAttribute("data-value", f? "1" : "0");
        control.style.color = (f? "#ffffff" : "#000000");
        control.style.backgroundColor = (f? "#000000" : "#ffffff");
    }

    /**
     * toggleDIPSwitchControl(control)
     *
     * @this {ChipSet}
     * @param {HTMLElement} control is an HTML control DOM object
     */
    toggleDIPSwitchControl(control)
    {
        let f = !this.getDIPSwitchControl(control);
        this.setDIPSwitchControl(control, f);
        let sID = control.getAttribute("id");
        let asParts = sID.split("-");
        let b = (0x1 << (+asParts[1] - 1));
        switch (asParts[0]) {
        case ChipSet.CONTROLS.SW1:
            this.aDIPSwitches[0][0] = (this.aDIPSwitches[0][0] & ~b) | (f? 0 : b);
            break;
        case ChipSet.CONTROLS.SW2:
            this.aDIPSwitches[1][0] = (this.aDIPSwitches[1][0] & ~b) | (f? 0 : b);
            break;
        default:
            break;
        }
        this.updateDIPSwitchDescriptions();
    }

    /**
     * updateDIPSwitches()
     *
     * @this {ChipSet}
     */
    updateDIPSwitches()
    {
        this.updateDIPSwitchControls(0, ChipSet.CONTROLS.SW1);
        this.updateDIPSwitchControls(1, ChipSet.CONTROLS.SW2);
        this.updateDIPSwitchDescriptions();
    }

    /**
     * updateDIPSwitchControls(iDIP, sBinding, fInit)
     *
     * @this {ChipSet}
     * @param {number} iDIP (0 or 1)
     * @param {string} sBinding is the name of the control
     * @param {boolean} [fInit]
     */
    updateDIPSwitchControls(iDIP, sBinding, fInit)
    {
        let control = this.bindings[sBinding];
        if (control) {
            let v;
            if (fInit) {
                v = this.aDIPSwitches[iDIP][0];
            } else {
                v = this.aDIPSwitches[iDIP][1] = this.aDIPSwitches[iDIP][0];
            }
            let aeCells = Component.getElementsByClass(control, this.sCellClass);
            for (let i = 0; i < aeCells.length; i++) {
                let switchGroup = this.findDIPSwitch(iDIP, i);
                let sLabel = switchGroup && switchGroup.LABEL || "Reserved";
                aeCells[i].setAttribute("title", sLabel);
                this.setDIPSwitchControl(aeCells[i], !(v & (0x1 << i)));
                aeCells[i].onclick = function(chipset, eSwitch) {
                    /*
                     * If we define the onclick handler below as "function(e)" instead of simply "function()", then we will
                     * also receive an Event object; however, IE reportedly requires that we examine a global (window.event)
                     * instead.  If that's true, and if we ever care to get more details about the click event, then define
                     * a local var; eg:
                     *
                     *      let event = window.event || e;
                     */
                    return function onClickSwitch() {
                        chipset.toggleDIPSwitchControl(eSwitch);
                    };
                }(this, aeCells[i]);
            }
        }
    }

    /**
     * updateDIPSwitchDescriptions()
     *
     * @this {ChipSet}
     */
    updateDIPSwitchDescriptions()
    {
        let controlDesc = this.bindings[ChipSet.CONTROLS.SWDESC];
        if (controlDesc != null) {
            let sText = "";
            /*
             * TODO: Monitor type 0 used to be "None" (ie, "No Monitor"), which was correct in a pre-EGA world,
             * but in the post-EGA world, it depends.  We should ask the Video component for a definitive answer.
             */
            let asMonitorTypes = {
                0: "Enhanced Color",
                1: "TV",
                2: "Color",
                3: "Monochrome"
            };
            sText += this.getDIPMemorySize(true) + "Kb";
            sText += ", " + (+this.getDIPCoprocessor(true)? "" : "No ") + "FPU";
            sText += ", " + asMonitorTypes[this.getDIPVideoMonitor(true)] + " Monitor";
            sText += ", " + this.getDIPFloppyDrives(true) + " Floppy Drives";
            if (this.aDIPSwitches[0][1] != null && this.aDIPSwitches[0][1] != this.aDIPSwitches[0][0] ||
                this.aDIPSwitches[1][1] != null && this.aDIPSwitches[1][1] != this.aDIPSwitches[1][0]) {
                sText += " (Reset required)";
            }
            controlDesc.textContent = sText;
        }
    }

    /**
     * dumpPIC()
     *
     * @this {ChipSet}
     */
    dumpPIC()
    {
        if (DEBUGGER) {
            for (let iPIC = 0; iPIC < this.aPICs.length; iPIC++) {
                let pic = this.aPICs[iPIC];
                let sDump = "PIC" + iPIC + ":";
                for (let i = 0; i < pic.aICW.length; i++) {
                    let b = pic.aICW[i];
                    sDump += " IC" + (i + 1) + '=' + Str.toHexByte(b);
                }
                sDump += " IMR=" + Str.toHexByte(pic.bIMR) + " IRR=" + Str.toHexByte(pic.bIRR) + " ISR=" + Str.toHexByte(pic.bISR) + " DELAY=" + pic.nDelay;
                this.dbg.println(sDump);
            }
        }
    }

    /**
     * dumpTimer(asArgs)
     *
     * Use "d timer" to dump all timers, or "d timer n" to dump only timer n.
     *
     * @this {ChipSet}
     * @param {Array.<string>} asArgs
     */
    dumpTimer(asArgs)
    {
        if (DEBUGGER) {
            let sParm = asArgs[0];
            let nTimer = (sParm? +sParm : null);
            for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
                if (nTimer != null && iTimer != nTimer) continue;
                this.updateTimer(iTimer);
                let timer = this.aTimers[iTimer];
                let sDump = "TIMER" + iTimer + ":";
                let count = 0;
                if (timer.countBytes != null) {
                    for (let i = 0; i <= timer.countBytes; i++) {
                        count |= (timer.countCurrent[i] << (i * 8));
                    }
                }
                sDump += " mode=" + (timer.mode >> 1) + " bytes=" + timer.countBytes + " count=" + Str.toHexWord(count);
                this.dbg.println(sDump);
            }
        }
    }

    /**
     * dumpCMOS()
     *
     * @this {ChipSet}
     */
    dumpCMOS()
    {
        if (DEBUGGER) {
            let sDump = "";
            for (let iCMOS = 0; iCMOS < ChipSet.CMOS.ADDR.TOTAL; iCMOS++) {
                let b = (iCMOS <= ChipSet.CMOS.ADDR.STATUSD? this.getRTCByte(iCMOS) : this.abCMOSData[iCMOS]);
                if (sDump) sDump += '\n';
                sDump += "CMOS[" + Str.toHexByte(iCMOS) + "]: " + Str.toHexByte(b);
            }
            this.dbg.println(sDump);
        }
    }

    /**
     * inDMAChannelAddr(iDMAC, iChannel, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port (0x00, 0x02, 0x04, 0x06 for DMAC 0, 0xC0, 0xC4, 0xC8, 0xCC for DMAC 1)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inDMAChannelAddr(iDMAC, iChannel, port, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        let channel = controller.aChannels[iChannel];
        let b = channel.addrCurrent[controller.bIndex];
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, undefined, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".ADDR[" + controller.bIndex + "]", b, true);
        }
        controller.bIndex ^= 0x1;
        /*
         * Technically, aTimers[1].fOut is what drives DMA requests for DMA channel 0 (ChipSet.DMA_REFRESH),
         * every 15us, once the BIOS has initialized the channel's "mode" with MODE_SINGLE, INCREMENT, AUTOINIT,
         * and TYPE_READ (0x58) and initialized TIMER1 appropriately.
         *
         * However, we don't need to be that particular.  Simply simulate an ever-increasing address after every
         * read of the full DMA channel 0 address.
         */
        if (!iDMAC && iChannel == ChipSet.DMA_REFRESH && !controller.bIndex) {
            channel.addrCurrent[0]++;
            if (channel.addrCurrent[0] > 0xff) {
                channel.addrCurrent[0] = 0;
                channel.addrCurrent[1]++;
                if (channel.addrCurrent[1] > 0xff) {
                    channel.addrCurrent[1] = 0;
                }
            }
        }
        return b;
    }

    /**
     * outDMAChannelAddr(iDMAC, iChannel, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port (0x00, 0x02, 0x04, 0x06 for DMAC 0, 0xC0, 0xC4, 0xC8, 0xCC for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAChannelAddr(iDMAC, iChannel, port, bOut, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".ADDR[" + controller.bIndex + "]", undefined, true);
        }
        let channel = controller.aChannels[iChannel];
        channel.addrCurrent[controller.bIndex] = channel.addrInit[controller.bIndex] = bOut;
        controller.bIndex ^= 0x1;
    }

    /**
     * inDMAChannelCount(iDMAC, iChannel, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port (0x01, 0x03, 0x05, 0x07 for DMAC 0, 0xC2, 0xC6, 0xCA, 0xCE for DMAC 1)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inDMAChannelCount(iDMAC, iChannel, port, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        let channel = controller.aChannels[iChannel];
        let b = channel.countCurrent[controller.bIndex];
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, undefined, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".COUNT[" + controller.bIndex + "]", b, true);
        }
        controller.bIndex ^= 0x1;
        /*
         * Technically, aTimers[1].fOut is what drives DMA requests for DMA channel 0 (ChipSet.DMA_REFRESH),
         * every 15us, once the BIOS has initialized the channel's "mode" with MODE_SINGLE, INCREMENT, AUTOINIT,
         * and TYPE_READ (0x58) and initialized TIMER1 appropriately.
         *
         * However, we don't need to be that particular.  Simply simulate an ever-decreasing count after every
         * read of the full DMA channel 0 count.
         */
        if (!iDMAC && iChannel == ChipSet.DMA_REFRESH && !controller.bIndex) {
            channel.countCurrent[0]--;
            if (channel.countCurrent[0] < 0) {
                channel.countCurrent[0] = 0xff;
                channel.countCurrent[1]--;
                if (channel.countCurrent[1] < 0) {
                    channel.countCurrent[1] = 0xff;
                    /*
                     * This is the logical point to indicate Terminal Count (TC), but again, there's no need to be
                     * so particular; inDMAStatus() has its own logic for periodically signalling TC.
                     */
                }
            }
        }
        return b;
    }

    /**
     * outDMAChannelCount(iDMAC, iChannel, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel (ports 0x01, 0x03, 0x05, 0x07)
     * @param {number} port (0x01, 0x03, 0x05, 0x07 for DMAC 0, 0xC2, 0xC6, 0xCA, 0xCE for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAChannelCount(iDMAC, iChannel, port, bOut, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".COUNT[" + controller.bIndex + "]", undefined, true);
        }
        let channel = controller.aChannels[iChannel];
        channel.countCurrent[controller.bIndex] = channel.countInit[controller.bIndex] = bOut;
        controller.bIndex ^= 0x1;
    }

    /**
     * inDMAStatus(iDMAC, port, addrFrom)
     *
     * From the 8237A spec:
     *
     * "The Status register is available to be read out of the 8237A by the microprocessor.
     * It contains information about the status of the devices at this point. This information includes
     * which channels have reached Terminal Count (TC) and which channels have pending DMA requests.
     *
     * Bits 0â3 are set every time a TC is reached by that channel or an external EOP is applied.
     * These bits are cleared upon Reset and on each Status Read.
     *
     * Bits 4â7 are set whenever their corresponding channel is requesting service."
     *
     * TRIVIA: This hook wasn't installed when I was testing with the MODEL_5150 ROM BIOS, and it
     * didn't matter, but the MODEL_5160 ROM BIOS checks it several times, including @F000:E156, where
     * it verifies that TIMER1 didn't request service on channel 0.
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x08 for DMAC 0, 0xD0 for DMAC 1)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inDMAStatus(iDMAC, port, addrFrom)
    {
        /*
         * HACK: Unlike the MODEL_5150, the MODEL_5160 ROM BIOS checks DMA channel 0 for TC (@F000:E4DF)
         * after running a number of unrelated tests, since enough time would have passed for channel 0 to
         * have reached TC at least once.  So I simply OR in a hard-coded TC bit for channel 0 every time
         * status is read.
         */
        let controller = this.aDMACs[iDMAC];
        let b = controller.bStatus | ChipSet.DMA_STATUS.CH0_TC;
        controller.bStatus &= ~ChipSet.DMA_STATUS.ALL_TC;
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, undefined, addrFrom, "DMA" + iDMAC + ".STATUS", b, true);
        }
        return b;
    }

    /**
     * outDMACmd(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x08 for DMAC 0, 0xD0 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMACmd(iDMAC, port, bOut, addrFrom)
    {
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".CMD", undefined, true);
        }
        this.aDMACs[iDMAC].bCmd = bOut;
    }

    /**
     * outDMAReq(iDMAC, port, bOut, addrFrom)
     *
     * From the 8237A spec:
     *
     * "The 8237A can respond to requests for DMA service which are initiated by software as well as by a DREQ.
     * Each channel has a request bit associated with it in the 4-bit Request register. These are non-maskable and subject
     * to prioritization by the Priority Encoder network. Each register bit is set or reset separately under software
     * control or is cleared upon generation of a TC or external EOP. The entire register is cleared by a Reset.
     *
     * To set or reset a bit the software loads the proper form of the data word.... In order to make a software request,
     * the channel must be in Block Mode."
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x09 for DMAC 0, 0xD2 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAReq(iDMAC, port, bOut, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".REQ", undefined, true);
        }
        /*
         * Bits 0-1 contain the channel number
         */
        let iChannel = (bOut & 0x3);
        /*
         * Bit 2 is the request bit (0 to reset, 1 to set), which must be propagated to the corresponding bit (4-7) in the status register
         */
        let iChannelBit = ((bOut & 0x4) << (iChannel + 2));
        controller.bStatus = (controller.bStatus & ~(0x10 << iChannel)) | iChannelBit;
        controller.bReq = bOut;
    }

    /**
     * outDMAMask(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0A for DMAC 0, 0xD4 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAMask(iDMAC, port, bOut, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".MASK", undefined, true);
        }
        let iChannel = bOut & ChipSet.DMA_MASK.CHANNEL;
        let channel = controller.aChannels[iChannel];
        channel.masked = !!(bOut & ChipSet.DMA_MASK.CHANNEL_SET);
        if (!channel.masked) this.requestDMA(controller.nChannelBase + iChannel);
    }

    /**
     * outDMAMode(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0B for DMAC 0, 0xD6 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAMode(iDMAC, port, bOut, addrFrom)
    {
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".MODE", undefined, true);
        }
        let iChannel = bOut & ChipSet.DMA_MODE.CHANNEL;
        this.aDMACs[iDMAC].aChannels[iChannel].mode = bOut;
    }

    /**
     * outDMAResetFF(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0C for DMAC 0, 0xD8 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     *
     * Any write to this port simply resets the controller's "first/last flip-flop", which determines whether
     * the even or odd byte of a DMA address or count register will be accessed next.
     */
    outDMAResetFF(iDMAC, port, bOut, addrFrom)
    {
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".RESET_FF", undefined, true);
        }
        this.aDMACs[iDMAC].bIndex = 0;
    }

    /**
     * inDMATemp(iDMAC, port, addrFrom)
     *
     * From the 8237A spec:
     *
     * "The Temporary register is used to hold data during memory-to-memory transfers  Following the
     * completion of the transfers, the last word moved can be read by the microprocessor in the Program Condition.
     * The Temporary register always contains the last byte transferred in the previous memory-to-memory operation,
     * unless cleared by a Reset."
     *
     * TRIVIA: This hook wasn't installed when I was testing with ANY of the IBM ROMs, but it's required
     * by the AT&T 6300 (aka Olivetti M24) ROM.
     *
     * TODO: When support is added for memory-to-memory transfers, bTemp needs to be updated according to spec.
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0D for DMAC 0, 0xDA for DMAC 1)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inDMATemp(iDMAC, port, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        let b = controller.bTemp;
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, undefined, addrFrom, "DMA" + iDMAC + ".TEMP", b, true);
        }
        return b;
    }

    /**
     * outDMAMasterClear(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0D for DMAC 0, 0xDA for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAMasterClear(iDMAC, port, bOut, addrFrom)
    {
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".MASTER_CLEAR", undefined, true);
        }
        /*
         * The value written to this port doesn't matter; any write triggers a "master clear" operation
         *
         * TODO: Can't we just call initDMAController(), which would also take care of clearing controller.bStatus?
         */
        let controller = this.aDMACs[iDMAC];
        for (let i = 0; i < controller.aChannels.length; i++) {
            this.initDMAChannel(controller, i);
        }
    }

    /**
     * inDMAPageReg(iDMAC, iChannel, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inDMAPageReg(iDMAC, iChannel, port, addrFrom)
    {
        let bIn = this.aDMACs[iDMAC].aChannels[iChannel].bPage;
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, undefined, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".PAGE", bIn, true);
        }
        return bIn;
    }

    /**
     * outDMAPageReg(iDMAC, iChannel, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAPageReg(iDMAC, iChannel, port, bOut, addrFrom)
    {
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".PAGE", undefined, true);
        }
        this.aDMACs[iDMAC].aChannels[iChannel].bPage = bOut;
    }

    /**
     * inDMAPageSpare(iSpare, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iSpare
     * @param {number} port
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inDMAPageSpare(iSpare, port, addrFrom)
    {
        let bIn = this.abDMAPageSpare[iSpare];
        if (this.messageEnabled(Messages.DMA | Messages.PORT)) {
            this.printMessageIO(port, undefined, addrFrom, "DMA.SPARE" + iSpare + ".PAGE", bIn, true);
        }
        return bIn;
    }

    /**
     * outDMAPageSpare(iSpare, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iSpare
     * @param {number} port
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAPageSpare(iSpare, port, bOut, addrFrom)
    {
        /*
         * TODO: Remove this DEBUG-only DESKPRO386 code once we're done debugging DeskPro 386 ROMs;
         * it enables logging of all DeskPro 386 ROM checkpoint I/O to port 0x84.
         */
        if (this.messageEnabled(Messages.DMA | Messages.PORT) || DEBUG && (this.model|0) == ChipSet.MODEL_COMPAQ_DESKPRO386) {
            this.printMessageIO(port, bOut, addrFrom, "DMA.SPARE" + iSpare + ".PAGE", undefined, true);
        }
        this.abDMAPageSpare[iSpare] = bOut;
    }

    /**
     * connectDMA(iDMAChannel, component, sFunction, obj)
     *
     * @param {number} iDMAChannel
     * @param {Component|string} component
     * @param {string} sFunction
     * @param {Object} obj (eg, when the HDC connects, it passes a drive object)
     */
    connectDMA(iDMAChannel, component, sFunction, obj)
    {
        let iDMAC = iDMAChannel >> 2;
        let controller = this.aDMACs[iDMAC];

        let iChannel = iDMAChannel & 0x3;
        let channel = controller.aChannels[iChannel];

        this.initDMAFunction(channel, component, sFunction, obj);
    }

    /**
     * requestDMA(iDMAChannel, done)
     *
     * @this {ChipSet}
     * @param {number} iDMAChannel
     * @param {function(boolean)} [done]
     *
     * For DMA_MODE.TYPE_WRITE transfers, fnTransfer(-1) must return bytes as long as we request them (although it may
     * return -1 if it runs out of bytes prematurely).
     *
     * Similarly, for DMA_MODE.TYPE_READ transfers, fnTransfer(b) must accept bytes as long as we deliver them (although
     * it is certainly free to ignore bytes it no longer wants).
     */
    requestDMA(iDMAChannel, done)
    {
        let iDMAC = iDMAChannel >> 2;
        let controller = this.aDMACs[iDMAC];

        let iChannel = iDMAChannel & 0x3;
        let channel = controller.aChannels[iChannel];

        if (!channel.component || !channel.fnTransfer || !channel.obj) {
            if (DEBUG && this.messageEnabled(Messages.DMA | Messages.DATA)) {
                this.printMessage("requestDMA(" + iDMAChannel + "): not connected to a component", true);
            }
            if (done) done(true);
            return;
        }

        /*
         * We can't simply slam done into channel.done; that would be fine if requestDMA() was called only by functions
         * like HDC.doRead() and HDC.doWrite(), but we're also called whenever a DMA channel is unmasked, and in those cases,
         * we need to preserve whatever handler may have been previously set.
         *
         * However, in an effort to ensure we don't end up with stale done handlers, connectDMA() will reset channel.done.
         */
        if (done) channel.done = done;

        if (channel.masked) {
            if (DEBUG && this.messageEnabled(Messages.DMA | Messages.DATA)) {
                this.printMessage("requestDMA(" + iDMAChannel + "): channel masked, request queued", true);
            }
            return;
        }

        /*
         * Let's try to do async DMA without asking the CPU for help...
         *
         *      this.cpu.setDMA(true);
         */
        this.advanceDMA(channel, true);
    }

    /**
     * advanceDMA(channel, fInit)
     *
     * @this {ChipSet}
     * @param {Object} channel
     * @param {boolean} [fInit]
     */
    advanceDMA(channel, fInit)
    {
        if (fInit) {
            channel.count = (channel.countCurrent[1] << 8) | channel.countCurrent[0];
            channel.type = (channel.mode & ChipSet.DMA_MODE.TYPE);
            channel.fWarning = channel.fError = false;
            if (DEBUG && DEBUGGER) {
                channel.cbDebug = channel.count + 1;
                channel.sAddrDebug = (DEBUG && DEBUGGER? null : undefined);
            }
        }
        /*
         * To support async DMA without requiring help from the CPU (ie, without relying upon cpu.setDMA()), we require that
         * the data transfer functions provide an fAsync parameter to their callbacks; fAsync must be true if the callback was
         * truly asynchronous (ie, it had to wait for a remote I/O request to finish), or false if the data was already available
         * and the callback was performed synchronously.
         *
         * Whenever a callback is issued asynchronously, we will immediately daisy-chain another pair of updateDMA()/advanceDMA()
         * calls, which will either finish the DMA operation if no more remote I/O requests are required, or will queue up another
         * I/O request, which will in turn trigger another async callback.  Thus, the DMA request keeps itself going without
         * requiring any special assistance from the CPU via setDMA().
         */
        let bto = null;
        let chipset = this;
        let fAsyncRequest = false;
        let controller = channel.controller;
        let iDMAChannel = controller.nChannelBase + channel.iChannel;

        while (true) {
            if (channel.count >= 0) {
                let b;
                let addr = (channel.bPage << 16) | (channel.addrCurrent[1] << 8) | channel.addrCurrent[0];
                if (DEBUG && DEBUGGER && channel.sAddrDebug === null) {
                    channel.sAddrDebug = Str.toHex(addr >> 4, 4) + ":" + Str.toHex(addr & 0xf, 4);
                    if (this.messageEnabled(this.messageBitsDMA(iDMAChannel)) && channel.type != ChipSet.DMA_MODE.TYPE_WRITE) {
                        this.printMessage("advanceDMA(" + iDMAChannel + ") transferring " + channel.cbDebug + " bytes from " + channel.sAddrDebug, true);
                        this.dbg.doDump(["db", channel.sAddrDebug, 'l', channel.cbDebug]);
                    }
                }
                if (channel.type == ChipSet.DMA_MODE.TYPE_WRITE) {
                    fAsyncRequest = true;
                    (function advanceDMAWrite(addrCur) {
                        channel.fnTransfer.call(channel.component, channel.obj, -1, function onTransferDMA(b, fAsync, obj, off) {
                            if (b < 0) {
                                if (!channel.fWarning) {
                                    if (DEBUG && chipset.messageEnabled(Messages.DMA)) {
                                        chipset.printMessage("advanceDMA(" + iDMAChannel + ") ran out of data, assuming 0xff", true);
                                    }
                                    channel.fWarning = true;
                                }
                                /*
                                 * TODO: Determine whether to abort, as we do for DMA_MODE.TYPE_READ.
                                 */
                                b = 0xff;
                            }
                            if (!channel.masked) {
                                chipset.bus.setByte(addrCur, b);
                                /*
                                 * WARNING: Do NOT assume that obj is valid; if the sector data was not found, there will be no obj.
                                 */
                                if (BACKTRACK && obj) {
                                    if (!off && obj.file) {
                                        if (chipset.messageEnabled(Messages.DISK)) {
                                            chipset.printMessage("loading " + obj.file.sPath + '[' + obj.offFile + "] at %" + Str.toHex(addrCur), true);
                                        }
                                        /*
                                        if (obj.file.sPath == "\\SYSBAS.EXE" && obj.offFile == 512) {
                                            chipset.cpu.stopCPU();
                                        }
                                        */
                                    }
                                    bto = chipset.bus.addBackTrackObject(obj, bto, off);
                                    chipset.bus.writeBackTrackObject(addrCur, bto, off);
                                }
                            }
                            fAsyncRequest = fAsync;
                            if (fAsync) {
                                setTimeout(function() {
                                    if (!chipset.updateDMA(channel)) chipset.advanceDMA(channel);
                                }, 0);
                            }
                        });
                    }(addr));
                }
                else if (channel.type == ChipSet.DMA_MODE.TYPE_READ) {
                    /*
                     * TODO: Determine whether we should support async dmaWrite() functions (currently not required)
                     */
                    b = chipset.bus.getByte(addr);
                    if (channel.fnTransfer.call(channel.component, channel.obj, b) < 0) {
                        /*
                         * In this case, I think I have no choice but to terminate the DMA operation in response to a failure,
                         * because the ROM BIOS FDC.REG_DATA.CMD.FORMAT_TRACK command specifies a count that is MUCH too large
                         * (a side-effect of the ROM BIOS using the same "DMA_SETUP" code for reads, writes AND formats).
                         */
                        channel.fError = true;
                    }
                }
                else if (channel.type == ChipSet.DMA_MODE.TYPE_VERIFY) {
                    /*
                     * Nothing to read or write; just call updateDMA()
                     */
                }
                else {
                    if (DEBUG && this.messageEnabled(Messages.DMA | Messages.WARN)) {
                        this.printMessage("advanceDMA(" + iDMAChannel + ") unsupported transfer type: " + Str.toHexWord(channel.type), true);
                    }
                    channel.fError = true;
                }
            }
            if (fAsyncRequest || this.updateDMA(channel)) break;
        }
    }

    /**
     * updateDMA(channel)
     *
     * @this {ChipSet}
     * @param {Object} channel
     * @return {boolean} true if DMA operation complete, false if not
     */
    updateDMA(channel)
    {
        if (!channel.fError && --channel.count >= 0) {
            if (channel.mode & ChipSet.DMA_MODE.DECREMENT) {
                channel.addrCurrent[0]--;
                if (channel.addrCurrent[0] < 0) {
                    channel.addrCurrent[0] = 0xff;
                    channel.addrCurrent[1]--;
                    if (channel.addrCurrent[1] < 0) channel.addrCurrent[1] = 0xff;
                }
            } else {
                channel.addrCurrent[0]++;
                if (channel.addrCurrent[0] > 0xff) {
                    channel.addrCurrent[0] = 0x00;
                    channel.addrCurrent[1]++;
                    if (channel.addrCurrent[1] > 0xff) channel.addrCurrent[1] = 0x00;
                }
            }
            /*
             * In situations where an HDC DMA operation took too long, the Fixed Disk BIOS would give up, but the DMA operation would continue.
             *
             * TODO: Verify that the Fixed Disk BIOS shuts down (ie, re-masks) a DMA channel for failed requests, and that this handles those failures.
             */
            if (!channel.masked) return false;
        }

        let controller = channel.controller;
        let iDMAChannel = controller.nChannelBase + channel.iChannel;
        controller.bStatus = (controller.bStatus & ~(0x10 << channel.iChannel)) | (0x1 << channel.iChannel);

        /*
         * EOP is supposed to automatically (re)mask the channel, unless it's set for auto-initialize.
         */
        if (!(channel.mode & ChipSet.DMA_MODE.AUTOINIT)) {
            channel.masked = true;
            channel.component = channel.obj = null;
        }

        if (DEBUG && this.messageEnabled(this.messageBitsDMA(iDMAChannel)) && channel.type == ChipSet.DMA_MODE.TYPE_WRITE && channel.sAddrDebug) {
            this.printMessage("updateDMA(" + iDMAChannel + ") transferred " + channel.cbDebug + " bytes to " + channel.sAddrDebug, true);
            this.dbg.doDump(["db", channel.sAddrDebug, 'l', channel.cbDebug]);
        }

        if (channel.done) {
            channel.done(!channel.fError);
            channel.done = null;
        }

        /*
         * While it might make sense to call cpu.setDMA() here, it's simpler to let the CPU issue one more call
         * to chipset.checkDMA() and let the CPU update INTR.DMA on its own, based on the return value from checkDMA().
         */
        return true;
    }

    /**
     * inPICLo(iPIC, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inPICLo(iPIC, addrFrom)
    {
        let b = 0;
        let pic = this.aPICs[iPIC];
        if (pic.bOCW3 != null) {
            let bReadReg = pic.bOCW3 & ChipSet.PIC_LO.OCW3_READ_CMD;
            switch (bReadReg) {
                case ChipSet.PIC_LO.OCW3_READ_IRR:
                    b = pic.bIRR;
                    break;
                case ChipSet.PIC_LO.OCW3_READ_ISR:
                    b = pic.bISR;
                    break;
                default:
                    break;
            }
        }
        if (this.messageEnabled(Messages.PIC | Messages.PORT)) {
            this.printMessageIO(pic.port, undefined, addrFrom, "PIC" + iPIC, b, true);
        }
        return b;
    }

    /**
     * outPICLo(iPIC, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPICLo(iPIC, bOut, addrFrom)
    {
        let pic = this.aPICs[iPIC];
        if (this.messageEnabled(Messages.PIC | Messages.PORT)) {
            this.printMessageIO(pic.port, bOut, addrFrom, "PIC" + iPIC, undefined, true);
        }
        if (bOut & ChipSet.PIC_LO.ICW1) {
            /*
             * This must be an ICW1...
             */
            pic.nICW = 0;
            pic.aICW[pic.nICW++] = bOut;
            /*
             * I used to do the rest of this initialization in outPICHi(), once all the ICW commands had been received,
             * but a closer reading of the 8259A spec indicates that that should happen now, on receipt on ICW1.
             *
             * Also, on p.10 of that spec, it says "The Interrupt Mask Register is cleared".  I originally took that to
             * mean that all interrupts were masked, but based on what MS-DOS 4.0M expects to happen after this code runs:
             *
             *      0070:44C6 B013          MOV      AL,13
             *      0070:44C8 E620          OUT      20,AL
             *      0070:44CA B050          MOV      AL,50
             *      0070:44CC E621          OUT      21,AL
             *      0070:44CE B009          MOV      AL,09
             *      0070:44D0 E621          OUT      21,AL
             *
             * (ie, it expects its next call to INT 0x13 will still generate an interrupt), I've decided the spec
             * must be read literally, meaning that all IMR bits must be zeroed.  Unmasking all possible interrupts by
             * default seems unwise to me, but who am I to judge....
             */
            pic.bIMR = 0x00;
            pic.bIRLow = 7;
            /*
             * TODO: I'm also zeroing both IRR and ISR, even though that's not actually mentioned as part of the ICW
             * sequence, because they need to be (re)initialized at some point.  However, if some component is currently
             * requesting an interrupt, what should I do about that?  Originally, I had decided to clear them ONLY if they
             * were still undefined, but that change appeared to break the ROM BIOS handling of CTRL-ALT-DEL, so I'm back
             * to unconditionally zeroing them.
             */
            pic.bIRR = pic.bISR = 0;
            /*
             * The spec also says that "Special Mask Mode is cleared and Status Read is set to IRR".  I attempt to insure
             * the latter, but as for special mask mode... well, that mode isn't supported yet.
             */
            pic.bOCW3 = ChipSet.PIC_LO.OCW3 | ChipSet.PIC_LO.OCW3_READ_IRR;
        }
        else if (!(bOut & ChipSet.PIC_LO.OCW3)) {
            /*
             * This must be an OCW2...
             */
            let bOCW2 = bOut & ChipSet.PIC_LO.OCW2_OP_MASK;
            if (bOCW2 & ChipSet.PIC_LO.OCW2_EOI) {
                /*
                 * This OCW2 must be an EOI command...
                 */
                let nIRL, bIREnd = 0;
                if ((bOCW2 & ChipSet.PIC_LO.OCW2_EOI_SPEC) == ChipSet.PIC_LO.OCW2_EOI_SPEC) {
                    /*
                     * More "specifically", a specific EOI command...
                     */
                    nIRL = bOut & ChipSet.PIC_LO.OCW2_IR_LVL;
                    bIREnd = 1 << nIRL;
                } else {
                    /*
                     * Less "specifically", a non-specific EOI command.  The search for the highest priority in-service
                     * interrupt must start with whichever interrupt is opposite the lowest priority interrupt (normally 7,
                     * but technically whatever bIRLow is currently set to).  For example:
                     *
                     *      If bIRLow is 7, then the priority order is: 0, 1, 2, 3, 4, 5, 6, 7.
                     *      If bIRLow is 6, then the priority order is: 7, 0, 1, 2, 3, 4, 5, 6.
                     *      If bIRLow is 5, then the priority order is: 6, 7, 0, 1, 2, 3, 4, 5.
                     *      etc.
                     */
                    nIRL = pic.bIRLow + 1;
                    while (true) {
                        nIRL &= 0x7;
                        let bIR = 1 << nIRL;
                        if (pic.bISR & bIR) {
                            bIREnd = bIR;
                            break;
                        }
                        if (nIRL++ == pic.bIRLow) break;
                    }
                    if (DEBUG && !bIREnd) nIRL = null;      // for unexpected non-specific EOI commands, there's no IRQ to report
                }
                let nIRQ = (nIRL == null? undefined : pic.nIRQBase + nIRL);
                if (pic.bISR & bIREnd) {
                    if (DEBUG && this.messageEnabled(this.messageBitsIRQ(nIRQ))) {
                        this.printMessage("outPIC" + iPIC + '(' + Str.toHexByte(pic.port) + "): IRQ " + nIRQ + " ending @" + this.dbg.toHexOffset(this.cpu.getIP(), this.cpu.getCS()) + " stack=" + this.dbg.toHexOffset(this.cpu.getSP(), this.cpu.getSS()), true);
                    }
                    pic.bISR &= ~bIREnd;
                    this.checkIRR();
                } else {
                    if (DEBUG && this.messageEnabled(Messages.PIC | Messages.WARN)) {
                        this.printMessage("outPIC" + iPIC + '(' + Str.toHexByte(pic.port) + "): unexpected EOI for IRQ " + nIRQ, true, true);
                        if (MAXDEBUG) this.dbg.stopCPU();
                    }
                }
                /*
                 * TODO: Support EOI commands with automatic rotation (eg, ChipSet.PIC_LO.OCW2_EOI_ROT and ChipSet.PIC_LO.OCW2_EOI_ROTSPEC)
                 */
                if (bOCW2 & ChipSet.PIC_LO.OCW2_SET_ROTAUTO) {
                    if (this.messageEnabled(Messages.PIC | Messages.WARN)) {
                        this.printMessage("PIC" + iPIC + '(' + Str.toHexByte(pic.port) + "): unsupported OCW2 rotate " + Str.toHexByte(bOut), true, true);
                    }
                }
            }
            else  if (bOCW2 == ChipSet.PIC_LO.OCW2_SET_PRI) {
                /*
                 * This OCW2 changes the lowest priority interrupt to the specified level (the default is 7)
                 */
                pic.bIRLow = bOut & ChipSet.PIC_LO.OCW2_IR_LVL;
            }
            else {
                /*
                 * TODO: Remaining commands to support: ChipSet.PIC_LO.OCW2_SET_ROTAUTO and ChipSet.PIC_LO.OCW2_CLR_ROTAUTO
                 */
                if (this.messageEnabled(Messages.PIC | Messages.WARN)) {
                    this.printMessage("PIC" + iPIC + '(' + Str.toHexByte(pic.port) + "): unsupported OCW2 automatic EOI " + Str.toHexByte(bOut), true, true);
                }
            }
        } else {
            /*
             * This must be an OCW3 request. If it's a "Read Register" command (PIC_LO.OCW3_READ_CMD), inPICLo() will take care it.
             *
             * TODO: If OCW3 specified a "Poll" command (PIC_LO.OCW3_POLL_CMD) or a "Special Mask Mode" command (PIC_LO.OCW3_SMM_CMD),
             * that's unfortunate, because I don't support them yet.
             */
            if (bOut & (ChipSet.PIC_LO.OCW3_POLL_CMD | ChipSet.PIC_LO.OCW3_SMM_CMD)) {
                if (this.messageEnabled(Messages.PIC | Messages.WARN)) {
                    this.printMessage("PIC" + iPIC + '(' + Str.toHexByte(pic.port) + "): unsupported OCW3 " + Str.toHexByte(bOut), true, true);
                }
            }
            pic.bOCW3 = bOut;
        }
    }

    /**
     * inPICHi(iPIC, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inPICHi(iPIC, addrFrom)
    {
        let pic = this.aPICs[iPIC];
        let b = pic.bIMR;
        if (this.messageEnabled(Messages.PIC | Messages.PORT)) {
            this.printMessageIO(pic.port+1, undefined, addrFrom, "PIC" + iPIC, b, true);
        }
        return b;
    }

    /**
     * outPICHi(iPIC, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPICHi(iPIC, bOut, addrFrom)
    {
        let pic = this.aPICs[iPIC];
        if (this.messageEnabled(Messages.PIC | Messages.PORT)) {
            this.printMessageIO(pic.port+1, bOut, addrFrom, "PIC" + iPIC, undefined, true);
        }
        if (pic.nICW < pic.aICW.length) {
            pic.aICW[pic.nICW++] = bOut;
            if (pic.nICW == 2 && (pic.aICW[0] & ChipSet.PIC_LO.ICW1_SNGL))
                pic.nICW++;
            if (pic.nICW == 3 && !(pic.aICW[0] & ChipSet.PIC_LO.ICW1_ICW4))
                pic.nICW++;
        }
        else {
            /*
             * We have all our ICW "words" (ie, bytes), so this must be an OCW1 write (which is simply an IMR write)
             */
            pic.bIMR = bOut;
            /*
             * See the CPU's delayINTR() function for an explanation of why this explicit delay is necessary.
             */
            this.cpu.delayINTR();
            /*
             * Alas, we need a longer delay for the MODEL_5170's "KBD_RESET" function (F000:17D2), which must drop
             * into a loop and decrement CX at least once after unmasking the KBD IRQ.  The "KBD_RESET" function on
             * previous models could be handled with a 4-instruction delay provided by the Keyboard.resetDevice() call
             * to setIRR(), but the MODEL_5170 needs a roughly 6-instruction delay after it unmasks the KBD IRQ.
             */
            this.checkIRR(!iPIC && bOut == 0xFD? 6 : 0);
        }
    }

    /**
     * checkIMR(nIRQ)
     *
     * @this {ChipSet}
     * @param {number} nIRQ
     * @return {boolean} true if the specified IRQ is masked, false if not
     */
    checkIMR(nIRQ)
    {
        let iPIC = nIRQ >> 3;
        let nIRL = nIRQ & 0x7;
        let pic = this.aPICs[iPIC];
        return !!(pic.bIMR & (0x1 << nIRL));
    }

    /**
     * setIRR(nIRQ, nDelay)
     *
     * @this {ChipSet}
     * @param {number} nIRQ (IRQ 0-7 implies iPIC 0, and IRQ 8-15 implies iPIC 1)
     * @param {number} [nDelay] is an optional number of instructions to delay acknowledgment of the IRQ (see getIRRVector)
     */
    setIRR(nIRQ, nDelay)
    {
        let iPIC = nIRQ >> 3;
        let nIRL = nIRQ & 0x7;
        let pic = this.aPICs[iPIC];
        let bIRR = (1 << nIRL);
        if (!(pic.bIRR & bIRR)) {
            pic.bIRR |= bIRR;
            if (this.messageEnabled(this.messageBitsIRQ(nIRQ))) this.printMessage("set IRQ " + nIRQ, true);
            pic.nDelay = nDelay || 0;
            this.checkIRR();
        }
    }

    /**
     * clearIRR(nIRQ)
     *
     * @this {ChipSet}
     * @param {number} nIRQ (IRQ 0-7 implies iPIC 0, and IRQ 8-15 implies iPIC 1)
     */
    clearIRR(nIRQ)
    {
        let iPIC = nIRQ >> 3;
        let nIRL = nIRQ & 0x7;
        let pic = this.aPICs[iPIC];
        let bIRR = (1 << nIRL);
        if (pic.bIRR & bIRR) {
            pic.bIRR &= ~bIRR;
            if (this.messageEnabled(this.messageBitsIRQ(nIRQ))) this.printMessage("clear IRQ " + nIRQ, true);
            this.checkIRR();
        }
    }

    /**
     * checkIRR(nDelay)
     *
     * @this {ChipSet}
     * @param {number} [nDelay] is an optional number of instructions to delay acknowledgment of a pending interrupt
     */
    checkIRR(nDelay)
    {
        /*
         * Look for any IRR bits that aren't masked and aren't already in service; in theory, all we'd have to
         * check is the master PIC (which is the *only* PIC on pre-5170 models), because when any IRQs are set or
         * cleared on the slave, that would automatically be reflected in IRQ.SLAVE on the master; that's what
         * setIRR() and clearIRR() used to do.
         *
         * Unfortunately, despite setIRR() and clearIRR()'s efforts, whenever a slave interrupt is acknowledged,
         * getIRRVector() ends up clearing the IRR bits for BOTH the slave's IRQ and the master's IRQ.SLAVE.
         * So if another lower-priority slave IRQ is waiting to be dispatched, that fact is no longer reflected
         * in IRQ.SLAVE.
         *
         * Since checkIRR() is called on every EOI, we can resolve that problem here, by first checking the slave
         * PIC for any unmasked, unserviced interrupts and updating the master's IRQ.SLAVE.
         *
         * And since this is ALSO called by both setIRR() and clearIRR(), those functions no longer need to perform
         * their own IRQ.SLAVE updates.  This function consolidates the propagation of slave interrupts to the master.
         */
        let pic;
        let bIR = -1;

        if (this.cPICs > 1) {
            pic = this.aPICs[1];
            bIR = ~(pic.bISR | pic.bIMR) & pic.bIRR;
        }

        pic = this.aPICs[0];

        if (bIR >= 0) {
            if (bIR) {
                pic.bIRR |= (1 << ChipSet.IRQ.SLAVE);
            } else {
                pic.bIRR &= ~(1 << ChipSet.IRQ.SLAVE);
            }
        }

        bIR = ~(pic.bISR | pic.bIMR) & pic.bIRR;

        this.cpu.updateINTR(!!bIR);

        if (bIR && nDelay) pic.nDelay = nDelay;
    }

    /**
     * getIRRVector()
     *
     * getIRRVector() is called by the CPU whenever PS_IF is set and OP_NOINTR is clear.  Ordinarily, an immediate
     * response would seem perfectly reasonable, but unfortunately, there are places in the original ROM BIOS like
     * "KBD_RESET" (F000:E688) that enable interrupts but still expect nothing to happen for several more instructions.
     *
     * So, in addition to the two normal responses (an IDT vector #, or -1 indicating no pending interrupts), we must
     * support a third response (-2) that basically means: don't change the CPU interrupt state, just keep calling until
     * we return one of the first two responses.  The number of times we delay our normal response is determined by the
     * component that originally called setIRR with an optional delay parameter.
     *
     * @this {ChipSet}
     * @param {number} [iPIC]
     * @return {number} IDT vector # of the next highest-priority interrupt, -1 if none, or -2 for "please try your call again later"
     */
    getIRRVector(iPIC)
    {
        if (iPIC === undefined) iPIC = 0;

        /*
         * Look for any IRR bits that aren't masked and aren't already in service...
         */
        let nIDT = -1;
        let pic = this.aPICs[iPIC];
        if (!pic.nDelay) {
            let bIR = pic.bIRR & ((pic.bISR | pic.bIMR) ^ 0xff);
            /*
             * The search for the next highest priority requested interrupt (that's also not in-service and not masked)
             * must start with whichever interrupt is opposite the lowest priority interrupt (normally 7, but technically
             * whatever bIRLow is currently set to).  For example:
             *
             *      If bIRLow is 7, then the priority order is: 0, 1, 2, 3, 4, 5, 6, 7.
             *      If bIRLow is 6, then the priority order is: 7, 0, 1, 2, 3, 4, 5, 6.
             *      If bIRLow is 5, then the priority order is: 6, 7, 0, 1, 2, 3, 4, 5.
             *      etc.
             *
             * This process is similar to the search performed by non-specific EOIs, except those apply only to a single
             * PIC (which is why a slave interrupt must be EOI'ed twice: once for the slave PIC and again for the master),
             * whereas here we must search across all PICs.
             */
            let nIRL = pic.bIRLow + 1;
            while (true) {

                nIRL &= 0x7;
                let bIRNext = 1 << nIRL;

                /*
                 * If we encounter an interrupt that's still in-service BEFORE we encounter a requested interrupt,
                 * then we're done; we must allow a higher priority in-service interrupt to finish before acknowledging
                 * any lower priority interrupts.
                 */
                if (pic.bISR & bIRNext) break;

                if (bIR & bIRNext) {

                    if (!iPIC && nIRL == ChipSet.IRQ.SLAVE && this.aPICs.length > 1) {
                        /*
                         * Slave interrupts are tied to the master PIC on IRQ2; query the slave PIC for the vector #
                         */
                        nIDT = this.getIRRVector(1);
                    } else {
                        /*
                         * Get the starting IDT vector # from ICW2 and add the IR level to obtain the target IDT vector #
                         */
                        nIDT = pic.aICW[1] + nIRL;
                    }

                    if (nIDT >= 0) {
                        pic.bISR |= bIRNext;

                        /*
                         * Setting the ISR implies clearing the IRR, but clearIRR() has side-effects we don't want
                         * (eg, clearing the slave IRQ, notifying the CPU, etc), so we clear the IRR ourselves.
                         */
                        pic.bIRR &= ~bIRNext;

                        let nIRQ = pic.nIRQBase + nIRL;
                        if (DEBUG && this.messageEnabled(this.messageBitsIRQ(nIRQ))) {
                            this.printMessage("getIRRVector(): IRQ " + nIRQ + " interrupting stack " + this.dbg.toHexOffset(this.cpu.getSP(), this.cpu.getSS()), true, true);
                        }
                        if (MAXDEBUG && DEBUGGER) {
                            this.acInterrupts[nIRQ]++;
                        }
                    }
                    break;
                }

                if (nIRL++ == pic.bIRLow) break;
            }
        } else {
            nIDT = -2;
            pic.nDelay--;
        }
        return nIDT;
    }

    /**
     * setFPUInterrupt()
     *
     * @this {ChipSet}
     */
    setFPUInterrupt()
    {
        if (this.model >= ChipSet.MODEL_5170) {
            this.setIRR(ChipSet.IRQ.FPU);
        } else {
            /*
             * TODO: Determine whether we need to maintain an "Active NMI" state; ie, if NMI.DISABLE is cleared
             * later, and the FPU coprocessor is still indicating an error condition, should we then generate an NMI?
             */
            if (this.bNMI & ChipSet.NMI.ENABLE) {
                X86.helpInterrupt.call(this.cpu, X86.EXCEPTION.NMI);
            }
        }
    }

    /**
     * clearFPUInterrupt(fSet)
     *
     * @this {ChipSet}
     */
    clearFPUInterrupt()
    {
        if (this.model >= ChipSet.MODEL_5170) {
            this.clearIRR(ChipSet.IRQ.FPU);
        } else {
            /*
             * TODO: If we maintain an "Active NMI" state, then we will need code here to clear that state, as well
             * as code in outNMI() to clear that state and generate an NMI as needed.
             */
        }
    }

    /**
     * inTimer(iPIT, iPITTimer, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIT (0 or 1)
     * @param {number} iPITTimer (0, 1, or 2)
     * @param {number} port (0x40, 0x41, 0x42, etc)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inTimer(iPIT, iPITTimer, port, addrFrom)
    {
        let b;
        let iBaseTimer = (iPIT? 3 : 0);
        let timer = this.aTimers[iBaseTimer + iPITTimer];

        if (timer.fStatusLatched) {
            b = timer.bStatus;
            timer.fStatusLatched = false;
        }
        else {
            if (timer.countIndex == timer.countBytes) {
                this.resetTimerIndex(iBaseTimer + iPITTimer);
            }
            if (timer.fCountLatched) {
                b = timer.countLatched[timer.countIndex++];
                if (timer.countIndex == timer.countBytes) {
                    timer.fCountLatched = false
                }
            }
            else {
                this.updateTimer(iBaseTimer + iPITTimer);
                b = timer.countCurrent[timer.countIndex++];
            }
        }
        if (this.messageEnabled(Messages.TIMER | Messages.PORT)) {
            this.printMessageIO(port, undefined, addrFrom, "PIT" + iPIT + ".TIMER" + iPITTimer, b, true);
        }
        return b;
    }

    /**
     * outTimer(iPIT, iPITTimer, port, bOut, addrFrom)
     *
     * We now rely EXCLUSIVELY on setBurstCycles() to address situations where quick timer interrupt turn-around
     * is expected; eg, by the ROM BIOS POST when it sets TIMER0 to a low test count (0x16); since we typically
     * don't update any of the timers until after we've finished a burst of CPU cycles, we must reduce the current
     * burst cycle count, so that the current instruction burst will end at the same time a timer interrupt is expected.
     *
     * Note that in some cases, if the number of cycles remaining in the current burst is less than the target,
     * this may have the effect of *lengthening* the current burst instead of shortening it, but stepCPU() should be
     * OK with that.
     *
     * @this {ChipSet}
     * @param {number} iPIT (0 or 1)
     * @param {number} iPITTimer (0, 1, or 2)
     * @param {number} port (0x40, 0x41, 0x42, etc)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outTimer(iPIT, iPITTimer, port, bOut, addrFrom)
    {
        if (this.messageEnabled(Messages.TIMER | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "PIT" + iPIT + ".TIMER" + iPITTimer, undefined, true);
        }

        let iBaseTimer = (iPIT? 3 : 0);
        let timer = this.aTimers[iBaseTimer + iPITTimer];

        if (timer.countIndex == timer.countBytes) {
            this.resetTimerIndex(iBaseTimer + iPITTimer);
        }

        timer.countInit[timer.countIndex++] = bOut;

        if (timer.countIndex == timer.countBytes) {
            /*
             * In general, writing a new count to a timer that's already counting isn't supposed to affect the current
             * count, with the notable exceptions of MODE0 and MODE4.
             */
            if (!timer.fCounting || timer.mode == ChipSet.PIT_CTRL.MODE0 || timer.mode == ChipSet.PIT_CTRL.MODE4) {
                timer.fCountLatched = false;
                timer.countCurrent[0] = timer.countStart[0] = timer.countInit[0];
                timer.countCurrent[1] = timer.countStart[1] = timer.countInit[1];
                timer.nCyclesStart = this.cpu.getCycles(this.fScaleTimers);
                timer.fCounting = true;

                /*
                 * I believe MODE0 is the only mode where OUT (fOUT) starts out low (false); for the rest of the modes,
                 * OUT (fOUT) starts high (true).  It's also my understanding that the way edge-triggered interrupts work
                 * on the original PC is that an interrupt is requested only when the corresponding OUT transitions from
                 * low to high.
                 */
                timer.fOUT = (timer.mode != ChipSet.PIT_CTRL.MODE0);

                if (iPIT == ChipSet.PIT0.INDEX && iPITTimer == ChipSet.PIT0.TIMER0) {
                    /*
                     * TODO: Determine if there are situations/modes where I should NOT automatically clear IRQ0 on behalf of TIMER0.
                     */
                    this.clearIRR(ChipSet.IRQ.TIMER0);
                    let countInit = this.getTimerInit(ChipSet.PIT0.TIMER0);
                    let nCyclesRemain = (countInit * this.nTicksDivisor) | 0;
                    if (timer.mode == ChipSet.PIT_CTRL.MODE3) nCyclesRemain >>= 1;
                    this.cpu.setBurstCycles(nCyclesRemain);
                }
            }

            if (iPIT == ChipSet.PIT0.INDEX && iPITTimer == ChipSet.PIT0.TIMER2) this.setSpeaker();
        }
    }

    /**
     * inTimerCtrl(iPIT, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIT (0 or 1)
     * @param {number} port (0x43 or 0x4B)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number|null} simulated port value
     */
    inTimerCtrl(iPIT, port, addrFrom)
    {
        this.printMessageIO(port, undefined, addrFrom, "PIT" + iPIT + ".CTRL", undefined, Messages.TIMER);
        /*
         * NOTE: Even though reads to port 0x43 are undefined (I think), I'm going to "define" it
         * as returning the last value written, purely for the Debugger's benefit.
         */
        return iPIT? this.bPIT1Ctrl : this.bPIT0Ctrl;
    }

    /**
     * outTimerCtrl(iPIT, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIT (0 or 1)
     * @param {number} port (0x43)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outTimerCtrl(iPIT, port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "PIT" + iPIT + ".CTRL", undefined, Messages.TIMER);

        /*
         * Extract the SC (Select Counter) bits.
         */
        let iBaseTimer = 0;
        let iPITTimer = (bOut & ChipSet.PIT_CTRL.SC);
        if (!iPIT) {
            this.bPIT0Ctrl = bOut;
        } else {
            iBaseTimer = 3;
            this.bPIT1Ctrl = bOut;
        }

        /*
         * Check for the Read-Back command and process as needed.
         */
        if (iPITTimer == ChipSet.PIT_CTRL.SC_BACK) {
            if (!(bOut & ChipSet.PIT_CTRL.RB_STATUS)) {
                for (iPITTimer = 0; iPITTimer <= 2; iPITTimer++) {
                    if (bOut & (ChipSet.PIT_CTRL.RB_CTR0 << iPITTimer)) {
                        this.latchTimerStatus(iBaseTimer + iPITTimer);
                    }
                }
            }
            if (!(bOut & ChipSet.PIT_CTRL.RB_COUNTS)) {
                for (iPITTimer = 0; iPITTimer <= 2; iPITTimer++) {
                    if (bOut & (ChipSet.PIT_CTRL.RB_CTR0 << iPITTimer)) {
                        this.latchTimerCount(iBaseTimer + iPITTimer);
                    }
                }
            }
            return;
        }

        /*
         * Convert the SC (Select Counter) bits into an iPITTimer index (0-2).
         */
        iPITTimer >>= ChipSet.PIT_CTRL.SC_SHIFT;

        /*
         * Extract BCD (bit 0), MODE (bits 1-3), and RW (bits 4-5), which we simply store as-is (see setTimerMode).
         */
        let bcd = (bOut & ChipSet.PIT_CTRL.BCD);
        let mode = (bOut & ChipSet.PIT_CTRL.MODE);
        let rw = (bOut & ChipSet.PIT_CTRL.RW);

        if (rw == ChipSet.PIT_CTRL.RW_LATCH) {
            /*
             * Of all the RW bit combinations, this is the only one that "countermands" normal control register
             * processing (the BCD and MODE bits are "don't care").
             */
            this.latchTimerCount(iBaseTimer + iPITTimer);
        }
        else {
            this.setTimerMode(iBaseTimer + iPITTimer, bcd, mode, rw);

            /*
             * The 5150 ROM BIOS code @F000:E285 ("TEST.7") would fail after a warm boot (eg, after a CTRL-ALT-DEL) because
             * it assumed that no TIMER0 interrupt would occur between the point it unmasked the TIMER0 interrupt and the
             * point it started reprogramming TIMER0.
             *
             * Similarly, the 5160 ROM BIOS @F000:E35D ("8253 TIMER CHECKOUT") would fail after initializing the EGA BIOS,
             * because the EGA BIOS uses TIMER0 during its diagnostics; as in the previous example, by the time the 8253
             * test code runs later, there's now a pending TIMER0 interrupt, which triggers an interrupt as soon as IRQ0 is
             * unmasked @F000:E364.
             *
             * After looking at this problem at bit more closely the second time around (while debugging the EGA BIOS),
             * it turns out I missed an important 8253 feature: whenever a new MODE0 control word OR a new MODE0 count
             * is written, fOUT (which is what drives IRQ0) goes low.  So, by simply adding an appropriate clearIRR() call
             * both here and in outTimer(), this annoying problem seems to be gone.
             *
             * TODO: Determine if there are situations/modes where I should NOT automatically clear IRQ0 on behalf of TIMER0.
             */
            if (iPIT == ChipSet.PIT0.INDEX && iPITTimer == ChipSet.PIT0.TIMER0) this.clearIRR(ChipSet.IRQ.TIMER0);

            /*
             * Another TIMER0 HACK: The "CASSETTE DATA WRAP TEST" @F000:E51E occasionally reports an error when the second of
             * two TIMER0 counts it latches is greater than the first.  You would think the ROM BIOS would expect this, since
             * TIMER0 can reload its count at any time.  Is the ROM BIOS assuming that TIMER0 was initialized sufficiently
             * recently that this should never happen?  I'm not sure, but for now, let's try resetting TIMER0's count immediately
             * after TIMER2 has been reprogrammed for the test in question (ie, when interrupts are masked and PPIB is set as
             * shown below).
             *
             * FWIW, I believe the cassette hardware was discontinued after MODEL_5150, and even if the test fails, it's non-fatal;
             * the ROM BIOS displays an error (131) and moves on.
             */
            if (iPIT == ChipSet.PIT0.INDEX && iPITTimer == ChipSet.PIT0.TIMER2) {
                let pic = this.aPICs[0];
                if (pic.bIMR == 0xff && this.bPPIB == (ChipSet.PPI_B.CLK_TIMER2 | ChipSet.PPI_B.ENABLE_SW2 | ChipSet.PPI_B.CASS_MOTOR_OFF | ChipSet.PPI_B.CLK_KBD)) {
                    let timer = this.aTimers[0];
                    timer.countStart[0] = timer.countInit[0];
                    timer.countStart[1] = timer.countInit[1];
                    timer.nCyclesStart = this.cpu.getCycles(this.fScaleTimers);
                    if (DEBUG && this.messageEnabled(Messages.TIMER)) {
                        this.printMessage("PIT0.TIMER0 count reset @" + timer.nCyclesStart + " cycles", true);
                    }
                }
            }
        }
    }

    /**
     * getTimerInit(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @return {number} initial timer count
     */
    getTimerInit(iTimer)
    {
        let timer = this.aTimers[iTimer];
        let countInit = (timer.countInit[1] << 8) | timer.countInit[0];
        if (!countInit) countInit = (timer.countBytes == 1? 0x100 : 0x10000);
        return countInit;
    }

    /**
     * getTimerStart(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @return {number} starting timer count (from the initial timer count for the current countdown)
     */
    getTimerStart(iTimer)
    {
        let timer = this.aTimers[iTimer];
        let countStart = (timer.countStart[1] << 8) | timer.countStart[0];
        if (!countStart) countStart = (timer.countBytes == 1? 0x100 : 0x10000);
        return countStart;
    }

    /**
     * getTimerCycleLimit(iTimer, nCycles)
     *
     * This is called by the CPU to determine the maximum number of cycles it can process for the current burst.
     * It's presumed that no instructions have been executed since the last updateTimer(iTimer) call.
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @param {number} nCycles desired
     * @return {number} maximum number of cycles remaining for the specified timer (<= nCycles)
     */
    getTimerCycleLimit(iTimer, nCycles)
    {
        let timer = this.aTimers[iTimer];
        if (timer.fCounting) {
            let nCyclesUpdate = this.cpu.getCycles(this.fScaleTimers);
            let ticksElapsed = ((nCyclesUpdate - timer.nCyclesStart) / this.nTicksDivisor) | 0;
            // DEBUG:
            let countStart = this.getTimerStart(iTimer);
            let count = countStart - ticksElapsed;
            if (timer.mode == ChipSet.PIT_CTRL.MODE3) count -= ticksElapsed;
            // DEBUG:
            let nCyclesRemain = (count * this.nTicksDivisor) | 0;
            if (timer.mode == ChipSet.PIT_CTRL.MODE3) nCyclesRemain >>= 1;
            if (nCycles > nCyclesRemain) nCycles = nCyclesRemain;
        }
        return nCycles;
    }

    /**
     * latchTimerCount(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     */
    latchTimerCount(iTimer)
    {
        /*
         * Update the timer's current count.
         */
        this.updateTimer(iTimer);

        /*
         * Now we can latch it.
         */
        let timer = this.aTimers[iTimer];
        timer.countLatched[0] = timer.countCurrent[0];
        timer.countLatched[1] = timer.countCurrent[1];
        timer.fCountLatched = true;

        /*
         * VERIFY: That a latch request resets the timer index.
         */
        this.resetTimerIndex(iTimer);
    }

    /**
     * latchTimerStatus(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     */
    latchTimerStatus(iTimer)
    {
        let timer = this.aTimers[iTimer];
        if (!timer.fStatusLatched) {
            this.updateTimer(iTimer);
            timer.bStatus = timer.bcd | timer.mode | timer.rw | (timer.countIndex < timer.countBytes? ChipSet.PIT_CTRL.RB_NULL : 0) | (timer.fOUT? ChipSet.PIT_CTRL.RB_OUT : 0);
            timer.fStatusLatched = true;
        }
    }

    /**
     * setTimerMode(iTimer, bcd, mode, rw)
     *
     * FYI: After setting a timer's mode, the CPU must set the timer's count before it becomes operational;
     * ie, before fCounting becomes true.
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @param {number} bcd
     * @param {number} mode
     * @param {number} rw
     */
    setTimerMode(iTimer, bcd, mode, rw)
    {
        let timer = this.aTimers[iTimer];
        timer.rw = rw;
        timer.mode = mode;
        timer.bcd = bcd;
        timer.countInit = [0, 0];
        timer.countCurrent = [0, 0];
        timer.countLatched = [0, 0];
        timer.fOUT = false;
        timer.fCountLatched = false;
        timer.fCounting = false;
        timer.fStatusLatched = false;
        this.resetTimerIndex(iTimer);
    }

    /**
     * resetTimerIndex(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     */
    resetTimerIndex(iTimer)
    {
        let timer = this.aTimers[iTimer];
        timer.countIndex = (timer.rw == ChipSet.PIT_CTRL.RW_MSB? 1 : 0);
        timer.countBytes = (timer.rw == ChipSet.PIT_CTRL.RW_BOTH? 2 : 1);
    }

    /**
     * updateTimer(iTimer, fCycleReset)
     *
     * updateTimer() calculates and updates a timer's current count purely on an "on-demand" basis; we don't
     * actually adjust timer counters every 4 CPU cycles on a 4.77Mhz PC, since updating timers that frequently
     * would be prohibitively slow.  If you're single-stepping the CPU, then yes, updateTimer() will be called
     * after every stepCPU(), via updateAllTimers(), but if we're doing our job correctly here, the frequency
     * of calls to updateTimer() should not affect timer counts across otherwise identical runs.
     *
     * TODO: Implement support for all TIMER modes, and verify that all the modes currently implemented are
     * "up to spec"; they're close enough to make the ROM BIOS happy, but beyond that, I've done very little.
     *
     * @this {ChipSet}
     * @param {number} iTimer
     *      0: Time-of-Day interrupt (~18.2 interrupts/second)
     *      1: DMA refresh
     *      2: Sound/Cassette
     * @param {boolean} [fCycleReset] is true if a cycle-count reset is about to occur
     * @return {Object} timer
     */
    updateTimer(iTimer, fCycleReset)
    {
        let timer = this.aTimers[iTimer];

        /*
         * Every timer's counting state is gated by its own fCounting flag; TIMER2 is further gated by PPI_B's
         * CLK_TIMER2 bit.
         */
        if (timer.fCounting && (iTimer != ChipSet.PIT0.TIMER2 || (this.bPPIB & ChipSet.PPI_B.CLK_TIMER2))) {
            /*
             * We determine the current timer count based on how many instruction cycles have elapsed since we started
             * the timer.  Timers are supposed to be "ticking" at a rate of 1193181.8181 times per second, which is
             * the system clock of 14.31818Mhz, divided by 12.
             *
             * Similarly, for an 8088, there are supposed to be 4.77Mhz instruction cycles per second, which comes from
             * the system clock of 14.31818Mhz, divided by 3.
             *
             * If we divide 4,772,727 CPU cycles per second by 1,193,181 ticks per second, we get 4 cycles per tick,
             * which agrees with the ratio of the clock divisors: 12 / 3 == 4.
             *
             * However, if getCycles() is being called with fScaleTimers == true AND the CPU is running faster than its
             * base cycles-per-second setting, then getCycles() will divide the cycle count by the CPU's cycle multiplier,
             * so that the timers fire with the same real-world frequency that the user expects.  However, that will
             * break any code (eg, the ROM BIOS diagnostics) that assumes that the timers are ticking once every 4 cycles
             * (or more like every 5 cycles on a 6Mhz 80286).
             *
             * So, when using a machine with the ChipSet "scaleTimers" property set, make sure you reset the machine's
             * speed prior to rebooting, otherwise you're likely to see ROM BIOS errors.  Ditto for any application code
             * that makes similar assumptions about the relationship between CPU and timer speeds.
             *
             * In general, you're probably better off NOT using the "scaleTimers" property, and simply allowing the timers
             * to tick faster as you increase CPU speed (which is why fScaleTimers defaults to false).
             */
            let nCycles = this.cpu.getCycles(this.fScaleTimers);

            /*
             * Instead of maintaining partial tick counts, we calculate a fresh countCurrent from countStart every
             * time we're called, using the cycle count recorded when the timer was initialized.  countStart is set
             * to countInit when fCounting is first set, and then it is refreshed from countInit at the expiration of
             * every count, so that if someone loaded a new countInit in the meantime (eg, BASICA), we'll pick it up.
             *
             * For the original MODEL_5170, the number of cycles per tick is approximately 6,000,000 / 1,193,181,
             * or 5.028575, so we can no longer always divide cycles by 4 with a simple right-shift by 2.  The proper
             * divisor (eg, 4 for MODEL_5150 and MODEL_5160, 5 for MODEL_5170, etc) is nTicksDivisor, which initBus()
             * calculates using the base CPU speed returned by cpu.getBaseCyclesPerSecond().
             */
            let ticksElapsed = ((nCycles - timer.nCyclesStart) / this.nTicksDivisor) | 0;

            if (ticksElapsed < 0) {
                if (DEBUG && this.messageEnabled(Messages.TIMER)) {
                    this.printMessage("updateTimer(" + iTimer + "): negative tick count (" + ticksElapsed + ")", true);
                }
                timer.nCyclesStart = nCycles;
                ticksElapsed = 0;
            }

            let countInit = this.getTimerInit(iTimer);
            let countStart = this.getTimerStart(iTimer);

            let fFired = false;
            let count = countStart - ticksElapsed;

            /*
             * NOTE: This mode is used by ROM BIOS test code that wants to verify timer interrupts are arriving
             * neither too slowly nor too quickly.  As a result, I've had to add some corresponding trickery
             * in outTimer() to force interrupt simulation immediately after a low initial count (0x16) has been set.
             */
            if (timer.mode == ChipSet.PIT_CTRL.MODE0) {
                if (count <= 0) count = 0;
                if (DEBUG && this.messageEnabled(Messages.TIMER)) {
                    this.printMessage("updateTimer(" + iTimer + "): MODE0 timer count=" + count, true);
                }
                if (!count) {
                    timer.fOUT = true;
                    timer.fCounting = false;
                    if (!iTimer) {
                        fFired = true;
                        this.setIRR(ChipSet.IRQ.TIMER0);
                        if (MAXDEBUG && DEBUGGER) this.acTimersFired[iTimer]++;
                    }
                }
            }
            /*
             * Early implementation of this mode was minimal because when using this mode, the ROM BIOS simply wanted
             * to see the count changing; it wasn't looking for interrupts.  See ROM BIOS "TEST.03" code @F000:E0DE,
             * where TIMER1 is programmed for MODE2, LSB (the same settings, incidentally, used immediately afterward
             * for TIMER1 in conjunction with DMA channel 0 memory refreshes).
             *
             * Now this mode generates interrupts.  Note that OUT goes low when the count reaches 1, then high
             * one tick later, at which point the count is reloaded and counting continues.
             *
             * Chances are, we will often miss the exact point at which the count becomes 1 (or more importantly,
             * one tick later, when the count *would* become 0, since that's when OUT transitions from low to high),
             * but as with MODE3, hopefully no one will mind.
             *
             * FYI, technically, it appears that the count is never supposed to reach 0, and that an initial count of 1
             * is "illegal", whatever that means.
             */
            else if (timer.mode == ChipSet.PIT_CTRL.MODE2) {
                timer.fOUT = (count != 1);          // yes, this line does seem rather pointless....
                if (count <= 0) {
                    count = countInit + count;
                    if (count <= 0) {
                        /*
                         * TODO: Consider whether we ever care about TIMER1 or TIMER2 underflow
                         */
                        if (DEBUG && this.messageEnabled(Messages.TIMER) && !iTimer) {
                            this.printMessage("updateTimer(" + iTimer + "): mode=2, underflow=" + count, true);
                        }
                        count = countInit;
                    }
                    timer.countStart[0] = count & 0xff;
                    timer.countStart[1] = (count >> 8) & 0xff;
                    timer.nCyclesStart = nCycles;
                    if (!iTimer && timer.fOUT) {
                        fFired = true;
                        this.setIRR(ChipSet.IRQ.TIMER0);
                        if (MAXDEBUG && DEBUGGER) this.acTimersFired[iTimer]++;
                    }
                }
            }
            /*
             * NOTE: This is the normal mode for TIMER0, which the ROM BIOS uses to generate h/w interrupts roughly
             * 18.2 times per second.  In this mode, the count must be decremented twice as fast (hence the extra ticks
             * subtraction below, in addition to the subtraction above), but IRQ_TIMER0 is raised only on alternate
             * iterations; ie, only when fOUT transitions to true ("high").  The equal alternating fOUT states is why
             * this mode is referred to as "square wave" mode.
             *
             * TODO: Implement the correct behavior for this mode when the count is ODD.  In that case, fOUT is supposed
             * to be "high" for (N + 1) / 2 ticks and "low" for (N - 1) / 2 ticks.
             */
            else if (timer.mode == ChipSet.PIT_CTRL.MODE3) {
                count -= ticksElapsed;
                if (count <= 0) {
                    timer.fOUT = !timer.fOUT;
                    count = countInit + count;
                    if (count <= 0) {
                        /*
                         * TODO: Consider whether we ever care about TIMER1 or TIMER2 underflow
                         */
                        if (DEBUG && this.messageEnabled(Messages.TIMER) && !iTimer) {
                            this.printMessage("updateTimer(" + iTimer + "): mode=3, underflow=" + count, true);
                        }
                        count = countInit;
                    }
                    if (MAXDEBUG && DEBUGGER && !iTimer) {
                        let nCycleDelta = 0;
                        if (this.acTimer0Counts.length > 0) nCycleDelta = nCycles - this.acTimer0Counts[0][1];
                        this.acTimer0Counts.push([count, nCycles, nCycleDelta]);
                    }
                    timer.countStart[0] = count & 0xff;
                    timer.countStart[1] = (count >> 8) & 0xff;
                    timer.nCyclesStart = nCycles;
                    if (!iTimer && timer.fOUT) {
                        fFired = true;
                        this.setIRR(ChipSet.IRQ.TIMER0);
                        if (MAXDEBUG && DEBUGGER) this.acTimersFired[iTimer]++;
                    }
                }
            }

            if (MAXDEBUG && this.messageEnabled(Messages.TIMER | Messages.WARN)) {
                this.log("TIMER" + iTimer + " count: " + count + ", ticks: " + ticksElapsed + ", fired: " + (fFired? "true" : "false"));
            }

            timer.countCurrent[0] = count & 0xff;
            timer.countCurrent[1] = (count >> 8) & 0xff;
            if (fCycleReset) this.nCyclesStart = 0;
        }
        return timer;
    }

    /**
     * updateAllTimers(fCycleReset)
     *
     * @this {ChipSet}
     * @param {boolean} [fCycleReset] is true if a cycle-count reset is about to occur
     */
    updateAllTimers(fCycleReset)
    {
        for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
            this.updateTimer(iTimer, fCycleReset);
        }
        if (this.model >= ChipSet.MODEL_5170) this.updateRTCTime();
    }

    /**
     * outMFGTest(port, bOut, addrFrom)
     *
     * This is test port on the PCjr (MODEL_4860) only.
     *
     * @this {ChipSet}
     * @param {number} port (0x10)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outMFGTest(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "MFG_TEST");
    }

    /**
     * inPPIA(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inPPIA(port, addrFrom)
    {
        let b = this.bPPIA;
        if (this.bPPICtrl & ChipSet.PPI_CTRL.A_IN) {
            if (this.bPPIB & ChipSet.PPI_B.CLEAR_KBD) {
                b = this.aDIPSwitches[0][1];
            } else {
                b = this.bKbdData;
                this.printMessageIO(port, undefined, addrFrom, "PPI_A", b, Messages.KBD);
                return b;
            }
        }
        this.printMessageIO(port, undefined, addrFrom, "PPI_A", b);
        return b;
    }

    /**
     * outPPIA(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPPIA(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "PPI_A");
        this.bPPIA = bOut;
    }

    /**
     * inPPIB(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inPPIB(port, addrFrom)
    {
        let b = this.bPPIB;
        this.printMessageIO(port, undefined, addrFrom, "PPI_B", b);
        return b;
    }

    /**
     * outPPIB(port, bOut, addrFrom)
     *
     * This is the original (MODEL_5150 and MODEL_5160) handler for port 0x61.  Functionality common
     * to all models must be placed in updatePPIB().
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPPIB(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "PPI_B");
        this.updatePPIB(bOut);
    }

    /**
     * updatePPIB(bOut)
     *
     * On MODEL_5170 and up, this updates the "simulated" PPI_B.  The only common (and well-documented) PPI_B bits
     * across all models are PPI_B.CLK_TIMER2 and PPI_B.SPK_TIMER2, so its possible that this function may need to
     * limit its updates to just those bits, and move any model-specific requirements back into the appropriate I/O
     * handlers (PPIB or 8042RWReg).  We'll see.
     *
     * UPDATE: The WOLF3D keyboard interrupt handler toggles the CLEAR_KBD bit of port 0x61 (ie, it sets and then
     * clears the bit) after reading the scan code from port 0x60; assuming that they use the same interrupt handler
     * for all machine models (which I haven't verified), the clear implication is that updatePPIB() also needs to
     * support CLEAR_KBD and CLK_KBD, so I've moved that code from outPPIB() to updatePPIB().
     *
     * @this {ChipSet}
     * @param {number} bOut
     */
    updatePPIB(bOut)
    {
        let fNewSpeaker = !!(bOut & ChipSet.PPI_B.SPK_TIMER2);
        let fOldSpeaker = !!(this.bPPIB & ChipSet.PPI_B.SPK_TIMER2);
        this.bPPIB = bOut;
        if (this.kbd) this.kbd.setEnabled(!(bOut & ChipSet.PPI_B.CLEAR_KBD), !!(bOut & ChipSet.PPI_B.CLK_KBD));
        if (fNewSpeaker != fOldSpeaker) {
            /*
             * Originally, this code didn't catch the "ERROR_BEEP" case @F000:EC34, which first turns both PPI_B.CLK_TIMER2 (0x01)
             * and PPI_B.SPK_TIMER2 (0x02) off, then turns on only PPI_B.SPK_TIMER2 (0x02), then restores the original port value.
             *
             * So, when the ROM BIOS keyboard buffer got full, we didn't issue a BEEP alert.  I've fixed that by limiting the test
             * to PPI_B.SPK_TIMER2 and ignoring PPI_B.CLK_TIMER2.
             */
            this.setSpeaker(fNewSpeaker);
        }
    }

    /**
     * inPPIC(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x62)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inPPIC(port, addrFrom)
    {
        let b = 0;

        /*
         * If you ever wanted to simulate I/O channel errors or R/W memory parity errors, you could
         * add either PPI_C.IO_CHANNEL_CHK (0x40) or PPI_C.RW_PARITY_CHK (0x80) to the return value (b).
         */
        if ((this.model|0) == ChipSet.MODEL_4860) {
            b |= this.bNMI & ChipSet.NMI.KBD_LATCH;
            /*
             * We're going to hard-code the rest of the PCjr settings for now, including NOT setting the NO_KBD_CABLE
             * bit, on the theory that if we don't have to deal with IR hardware emulation, so much the better.
             */
            b |= ChipSet.PPI_C.NO_MODEM | ChipSet.PPI_C.NO_DISKETTE | ChipSet.PPI_C.NO_MEMEXP;
            /*
             * I'm just guessing at how keyboard data is "clocked" into the the KBD_DATA bit; this will be revisited.
             */
            b |= (this.bKbdData & 0x1)? ChipSet.PPI_C.KBD_DATA : 0;
            this.bKbdData >>>= 1;
        }
        else if ((this.model|0) == ChipSet.MODEL_5150) {
            if (this.bPPIB & ChipSet.PPI_B.ENABLE_SW2) {
                b |= this.aDIPSwitches[1][1] & ChipSet.PPI_C.SW;
            } else {
                b |= (this.aDIPSwitches[1][1] >> 4) & 0x1;
            }
        } else {
            if (this.bPPIB & ChipSet.PPI_B.ENABLE_SW_HI) {
                b |= this.aDIPSwitches[0][1] >> 4;
            } else {
                b |= this.aDIPSwitches[0][1] & 0xf;
            }
        }

        if (this.bPPIB & ChipSet.PPI_B.CLK_TIMER2) {
            let timer = this.updateTimer(ChipSet.PIT0.TIMER2);
            if (timer.fOUT) {
                if (this.bPPIB & ChipSet.PPI_B.SPK_TIMER2)
                    b |= ChipSet.PPI_C.TIMER2_OUT;
                else
                    b |= ChipSet.PPI_C.CASS_DATA_IN;
            }
        }

        /*
         * The ROM BIOS polls this port incessantly during its memory tests, checking for memory parity errors
         * (which of course we never report), so you must use both Messages.PORT and Messages.CHIPSET.
         */
        this.printMessageIO(port, undefined, addrFrom, "PPI_C", b, Messages.CHIPSET);
        return b;
    }

    /**
     * outPPIC(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x62)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPPIC(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "PPI_C");
        this.bPPIC = bOut;
    }

    /**
     * inPPICtrl(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x63)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inPPICtrl(port, addrFrom)
    {
        let b = this.bPPICtrl;
        this.printMessageIO(port, undefined, addrFrom, "PPI_CTRL", b);
        return b;
    }

    /**
     * outPPICtrl(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x63)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outPPICtrl(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "PPI_CTRL");
        this.bPPICtrl = bOut;
    }

    /**
     * in8041Kbd(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    in8041Kbd(port, addrFrom)
    {
        let b = this.bKbdData;
        this.printMessageIO(port, undefined, addrFrom, "8041_KBD", b, Messages.KBD);
        this.b8041Status &= ~ChipSet.C8042.STATUS.OUTBUFF_FULL;
        return b;
    }

    /**
     * out8041Kbd(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    out8041Kbd(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "8041_KBD");
        // if (this.kbd) this.kbd.receiveCmd(bOut);
    }

    /**
     * in8041Ctrl(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    in8041Ctrl(port, addrFrom)
    {
        let b = this.bPPIB;
        this.printMessageIO(port, undefined, addrFrom, "8041_CTRL", b);
        return b;
    }

    /**
     * out8041Ctrl(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    out8041Ctrl(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "8041_CTRL");
        this.updatePPIB(bOut);
    }

    /**
     * in8041Status(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x64)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    in8041Status(port, addrFrom)
    {
        let b = this.b8041Status;
        this.printMessageIO(port, undefined, addrFrom, "8041_STATUS", b);
        return b;
    }

    /**
     * in8042OutBuff(port, addrFrom)
     *
     * Return the contents of the OUTBUFF register and clear the OUTBUFF_FULL status bit.
     *
     * Moreover, we also call kbd.checkBuffer() to let the Keyboard know that we just pulled
     * data, so that it can reset its internal timer controlling the delivery of additional data.
     *
     * Note that there are applications like BASICA that install a keyboard interrupt handler
     * that reads OUTBUFF, does some scan code preprocessing, and then passes control on to the
     * ROM's interrupt handler.  As a result, OUTBUFF is read multiple times during a single
     * interrupt, so we need to avoid filling it with new data after every read; otherwise,
     * scan codes will get dropped.
     *
     * The safest thing to do is to wait until kbd.setEnabled() is called, and let that call supply
     * more data to receiveKbdData().  That will happen as soon as the ROM re-enables the controller,
     * and is why C8042.CMD.ENABLE_KBD processing ends with a call to kbd.checkBuffer().  However,
     * not all software (eg, Xenix 286, and the Windows 95 VMM) does that, so we have to rely on
     * the Keyboard's internal timer.
     *
     * Also note that, the foregoing notwithstanding, I still clear the OUTBUFF_FULL bit here
     * (as I believe I should); fortunately, none of the interrupt handlers I've seen rely on
     * OUTBUFF_FULL as a prerequisite for reading OUTBUFF (certainly not BASICA or the ROM).
     * The assumption seems to be that if an interrupt occurred, OUTBUFF must contain data,
     * regardless of the state of OUTBUFF_FULL.
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    in8042OutBuff(port, addrFrom)
    {
        let b = this.b8042OutBuff;
        this.printMessageIO(port, undefined, addrFrom, "8042_OUTBUFF", b, Messages.C8042);
        this.b8042Status &= ~(ChipSet.C8042.STATUS.OUTBUFF_FULL | ChipSet.C8042.STATUS.OUTBUFF_DELAY);
        if (this.kbd) this.kbd.checkBuffer(b);
        return b;
    }

    /**
     * out8042InBuffData(port, bOut, addrFrom)
     *
     * This writes to the 8042's input buffer; using this port (ie, 0x60 instead of 0x64) designates the
     * the byte as a C8042.DATA.CMD "data byte".  Before clearing C8042.STATUS.CMD_FLAG, however, we see if it's set,
     * and then based on the previous C8042.CMD "command byte", we do whatever needs to be done with this "data byte".
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    out8042InBuffData(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "8042_INBUF.DATA", undefined, Messages.C8042);

        if (this.b8042Status & ChipSet.C8042.STATUS.CMD_FLAG) {

            switch (this.b8042InBuff) {

            case ChipSet.C8042.CMD.WRITE_CMD:
                this.set8042CmdData(bOut);
                break;

            case ChipSet.C8042.CMD.WRITE_OUTPORT:
                this.set8042OutPort(bOut);
                break;

            /*
             * This case is reserved for command bytes that the 8042 is not expecting, which should therefore be passed
             * on to the Keyboard itself.
             *
             * Here's some relevant MODEL_5170 ROM BIOS code, "XMIT_8042" (missing from the original MODEL_5170 ROM BIOS
             * listing), which sends a command code in AL to the Keyboard and waits for a response, returning it in AL.
             * Note that the only "success" exit path from this function involves LOOPing 64K times before finally reading
             * the Keyboard's response; either the hardware and/or this code seems a bit brain-damaged if that's REALLY
             * what you had to do to ensure a valid response....
             *
             *      F000:1B25 86E0          XCHG     AH,AL
             *      F000:1B27 2BC9          SUB      CX,CX
             *      F000:1B29 E464          IN       AL,64
             *      F000:1B2B A802          TEST     AL,02      ; WAIT FOR INBUFF_FULL TO BE CLEAR
             *      F000:1B2D E0FA          LOOPNZ   1B29
             *      F000:1B2F E334          JCXZ     1B65       ; EXIT WITH ERROR (CX == 0)
             *      F000:1B31 86E0          XCHG     AH,AL
             *      F000:1B33 E660          OUT      60,AL      ; SAFE TO WRITE KEYBOARD CMD TO INBUFF NOW
             *      F000:1B35 2BC9          SUB      CX,CX
             *      F000:1B37 E464          IN       AL,64
             *      F000:1B39 8AE0          MOV      AH,AL
             *      F000:1B3B A801          TEST     AL,01
             *      F000:1B3D 7402          JZ       1B41
             *      F000:1B3F E460          IN       AL,60      ; READ PORT 0x60 IF OUTBUFF_FULL SET ("FLUSH"?)
             *      F000:1B41 F6C402        TEST     AH,02
             *      F000:1B44 E0F1          LOOPNZ   1B37
             *      F000:1B46 751D          JNZ      1B65       ; EXIT WITH ERROR (CX == 0)
             *      F000:1B48 B306          MOV      BL,06
             *      F000:1B4A 2BC9          SUB      CX,CX
             *      F000:1B4C E464          IN       AL,64
             *      F000:1B4E A801          TEST     AL,01
             *      F000:1B50 E1FA          LOOPZ    1B4C
             *      F000:1B52 7508          JNZ      1B5C       ; PROCEED TO EXIT NOW THAT OUTBUFF_FULL IS SET
             *      F000:1B54 FECB          DEC      BL
             *      F000:1B56 75F4          JNZ      1B4C
             *      F000:1B58 FEC3          INC      BL
             *      F000:1B5A EB09          JMP      1B65       ; EXIT WITH ERROR (CX == 0)
             *      F000:1B5C 2BC9          SUB      CX,CX
             *      F000:1B5E E2FE          LOOP     1B5E       ; LOOOOOOPING....
             *      F000:1B60 E460          IN       AL,60
             *      F000:1B62 83E901        SUB      CX,0001    ; EXIT WITH SUCCESS (CX != 0)
             *      F000:1B65 C3            RET
             *
             * But WAIT, the FUN doesn't end there.  After this function returns, "KBD_RESET" waits for a Keyboard
             * interrupt to occur, hoping for scan code 0xAA as the Keyboard's final response.  "KBD_RESET" also returns
             * CX to the caller, and the caller ("TEST.21") assumes there was no interrupt if CX is zero.
             *
             *              MOV     AL,0FDH
             *              OUT     INTA01,AL
             *              MOV     INTR_FLAG,0
             *              STI
             *              MOV     BL,10
             *              SUB     CX,CX
             *      G11:    TEST    [1NTR_FLAG],02H
             *              JNZ     G12
             *              LOOP    G11
             *              DEC     BL
             *              JNZ     G11
             *              ...
             *
             * However, if [INTR_FLAG] is set immediately, the above code will exit immediately, without ever decrementing
             * CX.  CX can be zero not only if the loop exhausted it, but also if no looping was required; the latter is not
             * an error, but "TEST.21" assumes that it is.
             */
            default:
                this.set8042CmdData(this.b8042CmdData & ~ChipSet.C8042.DATA.CMD.NO_CLOCK);
                if (this.kbd) this.set8042OutBuff(this.kbd.receiveCmd(bOut));
                break;
            }
        }
        this.b8042InBuff = bOut;
        this.b8042Status &= ~ChipSet.C8042.STATUS.CMD_FLAG;
    }

    /**
     * in8042RWReg(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    in8042RWReg(port, addrFrom)
    {
        /*
         * Normally, we return whatever was last written to this port, but we do need to mask the
         * two upper-most bits (C8042.RWREG.NMI_ERROR), as those are output-only bits used to signal
         * parity errors.
         *
         * Also, "TEST.09" of the MODEL_5170 BIOS expects the REFRESH_BIT to alternate, so we used to
         * do this:
         *
         *      this.bPPIB ^= ChipSet.C8042.RWREG.REFRESH_BIT;
         *
         * However, the MODEL_5170_REV3 BIOS not only checks REFRESH_BIT in "TEST.09", but includes
         * an additional test right before "TEST.11A", which requires the bit change "a bit less"
         * frequently.  This new test sets CX to zero, and at the end of the test (@F000:05B8), CX
         * must be in the narrow range of 0xF600 through 0xF9FD.
         *
         * In fact, the new "WAITF" function @F000:1A3A tells us exactly how frequently REFRESH_BIT
         * is expected to change now.  That function performs a "FIXED TIME WAIT", where CX is a
         * "COUNT OF 15.085737us INTERVALS TO WAIT".
         *
         * So we now tie the state of the REFRESH_BIT to bit 6 of the current CPU cycle count,
         * effectively toggling the bit after every 64 cycles.  On an 8Mhz CPU that can do 8 cycles
         * in 1us, 64 cycles represents 8us, so that might be a bit fast for "WAITF", but bit 6
         * is the only choice that also satisfies the pre-"TEST.11A" test as well.
         */
        let b = this.bPPIB & ~(ChipSet.C8042.RWREG.NMI_ERROR | ChipSet.C8042.RWREG.REFRESH_BIT) | ((this.cpu.getCycles() & 0x40)? ChipSet.C8042.RWREG.REFRESH_BIT : 0);
        /*
         * Thanks to the WAITF function, this has become a very "busy" port, so if this generates too
         * many messages, try adding Messages.WARN to the criteria.
         */
        this.printMessageIO(port, undefined, addrFrom, "8042_RWREG", b, Messages.C8042 | Messages.WARN);
        return b;
    }

    /**
     * out8042RWReg(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    out8042RWReg(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "8042_RWREG", undefined, Messages.C8042);
        this.updatePPIB(bOut);
    }

    /**
     * in8042Status(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x64)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    in8042Status(port, addrFrom)
    {
        this.printMessageIO(port, undefined, addrFrom, "8042_STATUS", this.b8042Status, Messages.C8042);
        let b = this.b8042Status & 0xff;
        /*
         * There's code in the 5170 BIOS (F000:03BF) that writes an 8042 command (0xAA), waits for
         * C8042.STATUS.INBUFF_FULL to go clear (which it always is, because we always accept commands
         * immediately), then checks C8042.STATUS.OUTBUFF_FULL and performs a "flush" on port 0x60 if
         * it's set, then waits for C8042.STATUS.OUTBUFF_FULL *again*.  Unfortunately, the "flush" throws
         * away our response if we respond immediately.
         *
         * So now when out8042InBuffCmd() has a response, it sets C8042.STATUS.OUTBUFF_DELAY instead
         * (which is outside the 0xff range of bits we return); when we see C8042.STATUS.OUTBUFF_DELAY,
         * we clear it and set C8042.STATUS.OUTBUFF_FULL, which will be returned on the next read.
         *
         * This provides a single poll delay, so that the aforementioned "flush" won't toss our response.
         * If longer delays are needed down the road, we may need to set a delay count in the upper (unused)
         * bits of b8042Status, instead of using a single delay bit.
         */
        if (this.b8042Status & ChipSet.C8042.STATUS.OUTBUFF_DELAY) {
            this.b8042Status |= ChipSet.C8042.STATUS.OUTBUFF_FULL;
            this.b8042Status &= ~ChipSet.C8042.STATUS.OUTBUFF_DELAY;
        }
        /*
         * I added this for Windows 95's VMM keyboard driver for DOS sessions, which differs from the keyboard
         * driver for protected-mode applications (see the keyboard's setEnabled() function for more details).
         *
         * The Windows 95 VMM driver doesn't do what EITHER the ROM or the protected-mode driver typically does
         * after receiving a scan code (ie, toggle the keyboard's enable state).  Instead, the VMM simply checks
         * this status port one more time, perhaps to confirm that the OUTBUFF_FULL bit is clear.  It then
         * expects another keyboard interrupt to arrive when the next scan code is available.  Very minimalistic.
         */
        if (!(this.b8042Status & ChipSet.C8042.STATUS.OUTBUFF_FULL) && this.kbd) {
            this.kbd.checkBuffer();
        }
        return b;
    }

    /**
     * out8042InBuffCmd(port, bOut, addrFrom)
     *
     * This writes to the 8042's input buffer; using this port (ie, 0x64 instead of 0x60) designates the
     * the byte as a "command byte".  We immediately set C8042.STATUS.CMD_FLAG, and then see if we can act upon
     * the command immediately (some commands requires us to wait for a "data byte").
     *
     * @this {ChipSet}
     * @param {number} port (0x64)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    out8042InBuffCmd(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "8042_INBUFF.CMD", undefined, Messages.C8042);

        this.b8042InBuff = bOut;

        this.b8042Status |= ChipSet.C8042.STATUS.CMD_FLAG;

        let bPulseBits = 0;
        if (this.b8042InBuff >= ChipSet.C8042.CMD.PULSE_OUTPORT) {
            bPulseBits = (this.b8042InBuff ^ 0xf);
            /*
             * Now that we have isolated the bit(s) to pulse, map all pulse commands to C8042.CMD.PULSE_OUTPORT
             */
            this.b8042InBuff = ChipSet.C8042.CMD.PULSE_OUTPORT;
        }

        switch (this.b8042InBuff) {
        case ChipSet.C8042.CMD.READ_CMD:        // 0x20
            this.set8042OutBuff(this.b8042CmdData);
            break;

        case ChipSet.C8042.CMD.WRITE_CMD:       // 0x60
            /*
             * No further action required for this command; more data is expected via out8042InBuffData()
             */
            break;

        case ChipSet.C8042.CMD.DISABLE_KBD:     // 0xAD
            this.set8042CmdData(this.b8042CmdData | ChipSet.C8042.DATA.CMD.NO_CLOCK);
            if (!COMPILED) this.printMessage("keyboard disabled", Messages.KBD | Messages.PORT);
            /*
             * NOTE: The MODEL_5170 BIOS calls "KBD_RESET" (F000:17D2) while the keyboard interface is disabled,
             * yet we must still deliver the Keyboard's CMDRES.BAT_OK response code?  Seems like an odd thing for
             * a "disabled interface" to do.
             */
            break;

        case ChipSet.C8042.CMD.ENABLE_KBD:      // 0xAE
            this.set8042CmdData(this.b8042CmdData & ~ChipSet.C8042.DATA.CMD.NO_CLOCK);
            if (!COMPILED) this.printMessage("keyboard re-enabled", Messages.KBD | Messages.PORT);
            if (this.kbd) this.kbd.checkBuffer();
            break;

        case ChipSet.C8042.CMD.SELF_TEST:       // 0xAA
            if (this.kbd) this.kbd.flushBuffer();
            this.set8042CmdData(this.b8042CmdData | ChipSet.C8042.DATA.CMD.NO_CLOCK);
            if (!COMPILED) this.printMessage("keyboard disabled on reset", Messages.KBD | Messages.PORT);
            this.set8042OutBuff(ChipSet.C8042.DATA.SELF_TEST.OK);
            this.set8042OutPort(ChipSet.C8042.OUTPORT.NO_RESET | ChipSet.C8042.OUTPORT.A20_ON);
            break;

        case ChipSet.C8042.CMD.INTF_TEST:       // 0xAB
            /*
             * TODO: Determine all the side-effects of the Interface Test, if any.
             */
            this.set8042OutBuff(ChipSet.C8042.DATA.INTF_TEST.OK);
            break;

        case ChipSet.C8042.CMD.READ_INPORT:     // 0xC0
            this.set8042OutBuff(this.b8042InPort);
            break;

        case ChipSet.C8042.CMD.READ_OUTPORT:    // 0xD0
            this.set8042OutBuff(this.b8042OutPort);
            break;

        case ChipSet.C8042.CMD.WRITE_OUTPORT:   // 0xD1
            /*
             * No further action required for this command; more data is expected via out8042InBuffData()
             */
            break;

        case ChipSet.C8042.CMD.READ_TEST:       // 0xE0
            this.set8042OutBuff((this.b8042CmdData & ChipSet.C8042.DATA.CMD.NO_CLOCK)? 0 : ChipSet.C8042.TESTPORT.KBD_CLOCK);
            break;

        case ChipSet.C8042.CMD.PULSE_OUTPORT:   // 0xF0-0xFF
            if (bPulseBits & 0x1) {
                /*
                 * Bit 0 of the 8042's output port is connected to RESET.  If it's pulsed, the processor resets.
                 * We don't want to clear *all* CPU state (eg, cycle counts), so we call cpu.resetRegs() instead
                 * of cpu.reset().
                 */
                this.cpu.resetRegs();
            }
            break;

        default:
            if (!COMPILED && this.messageEnabled(Messages.C8042)) {
                this.printMessage("unrecognized 8042 command: " + Str.toHexByte(this.b8042InBuff), true);
                this.dbg.stopCPU();
            }
            break;
        }
    }

    /**
     * set8042CmdData(b)
     *
     * @this {ChipSet}
     * @param {number} b
     */
    set8042CmdData(b)
    {
        this.b8042CmdData = b;

        this.b8042Status = (this.b8042Status & ~ChipSet.C8042.STATUS.SYS_FLAG) | (b & ChipSet.C8042.DATA.CMD.SYS_FLAG);
        if (this.kbd) {
            /*
             * This seems to be what the doctor ordered for the MODEL_5170_REV3 BIOS @F000:0A6D, where it
             * sends ChipSet.C8042.CMD.WRITE_CMD to port 0x64, followed by 0x4D to port 0x60, which clears NO_CLOCK
             * and enables the keyboard.  The BIOS then waits for OUTBUFF_FULL to be set, at which point it seems
             * to be anticipating an 0xAA response in the output buffer.
             *
             * And indeed, if we call the original MODEL_5150/MODEL_5160 setEnabled() Keyboard interface here,
             * and both the data and clock lines have transitioned high (ie, both parameters are true), then it
             * will call resetDevice(), generating a Keyboard.CMDRES.BAT_OK response.
             *
             * This agrees with my understanding of what happens when the 8042 toggles the clock line high
             * (ie, clears NO_CLOCK): the TechRef's "Basic Assurance Test" section says that when the Keyboard is
             * powered on, it performs the BAT, and then when the clock and data lines go high, the keyboard sends
             * a completion code (eg, 0xAA for success, or 0xFC or something else for failure).
             */
            this.kbd.setEnabled(!!(b & ChipSet.C8042.DATA.CMD.NO_INHIBIT), !(b & ChipSet.C8042.DATA.CMD.NO_CLOCK));
        }
    }

    /**
     * set8042OutBuff(b, fNoDelay)
     *
     * The 5170 ROM BIOS assumed there would be a slight delay after certain 8042 commands, like SELF_TEST
     * (0xAA), before there was an OUTBUFF response; in fact, there is BIOS code that will fail without such
     * a delay.  This is discussed in greater detail in in8042Status().
     *
     * So we default to a "single poll" delay, setting OUTBUFF_DELAY instead of OUTBUFF_FULL, unless the caller
     * explicitly asks for no delay.  The fNoDelay parameter was added later, so that receiveKbdData() could
     * request immediate delivery of keyboard scan codes, because some operating systems (eg, Microport's 1986
     * version of Unix for PC AT machines) poll the status port only once, immediately giving up if no data is
     * available.
     *
     * TODO: Determine if we should invert the fNoDelay default (from false to true) and delay only in specific
     * cases; ie, perhaps only the SELF_TEST command required a delay.
     *
     * @this {ChipSet}
     * @param {number} b
     * @param {boolean} [fNoDelay]
     */
    set8042OutBuff(b, fNoDelay)
    {
        if (b >= 0) {
            this.b8042OutBuff = b;
            if (fNoDelay) {
                this.b8042Status |= ChipSet.C8042.STATUS.OUTBUFF_FULL;
            } else {
                this.b8042Status &= ~ChipSet.C8042.STATUS.OUTBUFF_FULL;
                this.b8042Status |= ChipSet.C8042.STATUS.OUTBUFF_DELAY;
            }
            if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.PORT)) {
                this.printMessage("chipset.set8042OutBuff(" + Str.toHexByte(b) + ',' + (fNoDelay? "no" : "") + "delay)", true);
            }
        }
    }

    /**
     * set8042OutPort(b)
     *
     * When ChipSet.C8042.CMD.WRITE_OUTPORT (0xD1) is written to port 0x64, the next byte written to port 0x60 comes here,
     * to the KBC's OUTPORT.  One of the most important bits in the OUTPORT is the A20_ON bit (0x02): set it to turn A20 on,
     * clear it to turn A20 off.
     *
     * @this {ChipSet}
     * @param {number} b
     */
    set8042OutPort(b)
    {
        this.b8042OutPort = b;

        this.bus.setA20(!!(b & ChipSet.C8042.OUTPORT.A20_ON));

        if (!(b & ChipSet.C8042.OUTPORT.NO_RESET)) {
            /*
             * Bit 0 of the 8042's output port is connected to RESET.  Normally, it's "pulsed" with the
             * C8042.CMD.PULSE_OUTPORT command, so if a RESET is detected via this command, we should try to
             * determine if that's what the caller intended.
             */
            if (!COMPILED && this.messageEnabled(Messages.C8042)) {
                this.printMessage("unexpected 8042 output port reset: " + Str.toHexByte(b), true);
                this.dbg.stopCPU();
            }
            this.cpu.resetRegs();
        }
    }

    /**
     * receiveKbdData(b)
     *
     * In the old days of PCx86, the Keyboard component would simply call setIRR() when it had some data for the
     * keyboard controller.  However, the Keyboard's sole responsibility is to emulate an actual keyboard and call
     * receiveKbdData() whenever it has some data; it's not allowed to mess with IRQ lines.
     *
     * If there's an 8042, we check (this.b8042CmdData & ChipSet.C8042.DATA.CMD.NO_CLOCK); if NO_CLOCK is clear,
     * we can raise the IRQ immediately.  Well, not quite immediately....
     *
     * Notes regarding the MODEL_5170 (eg, /devices/pc/machine/5170/ega/1152kb/rev3/machine.xml):
     *
     * The "Rev3" BIOS, dated 11-Nov-1985, contains the following code in the keyboard interrupt handler at K26A:
     *
     *      F000:3704 FA            CLI
     *      F000:3705 B020          MOV      AL,20
     *      F000:3707 E620          OUT      20,AL
     *      F000:3709 B0AE          MOV      AL,AE
     *      F000:370B E88D02        CALL     SHIP_IT
     *      F000:370E FA            CLI                     <-- window of opportunity
     *      F000:370F 07            POP      ES
     *      F000:3710 1F            POP      DS
     *      F000:3711 5F            POP      DI
     *      F000:3712 5E            POP      SI
     *      F000:3713 5A            POP      DX
     *      F000:3714 59            POP      CX
     *      F000:3715 5B            POP      BX
     *      F000:3716 58            POP      AX
     *      F000:3717 5D            POP      BP
     *      F000:3718 CF            IRET
     *
     * and SHIP_IT looks like this:
     *
     *      F000:399B 50            PUSH     AX
     *      F000:399C FA            CLI
     *      F000:399D 2BC9          SUB      CX,CX
     *      F000:399F E464          IN       AL,64
     *      F000:39A1 A802          TEST     AL,02
     *      F000:39A3 E0FA          LOOPNZ   399F
     *      F000:39A5 58            POP      AX
     *      F000:39A6 E664          OUT      64,AL
     *      F000:39A8 FB            STI
     *      F000:39A9 C3            RET
     *
     * This code *appears* to be trying to ensure that another keyboard interrupt won't occur until after the IRET,
     * but sadly, it looks to me like the CLI following the call to SHIP_IT is too late.  SHIP_IT should have been
     * written with PUSHF/CLI and POPF intro/outro sequences, thereby honoring the first CLI at the top of K26A and
     * eliminating the need for the second CLI (@F000:370E).
     *
     * Of course, in "real life", this was probably never a problem, because the 8042 probably wasn't fast enough to
     * generate another interrupt so soon after receiving the ChipSet.C8042.CMD.ENABLE_KBD command.  In my case, I ran
     * into this problem by 1) turning on "kbd" Debugger messages and 2) rapidly typing lots of keys.  The Debugger
     * messages bogged the machine down enough for me to hit the "window of opportunity", generating this message in
     * PC-DOS 3.20:
     *
     *      "FATAL: Internal Stack Failure, System Halted."
     *
     * and halting the system @0070:0923 (JMP 0923).
     *
     * That wasn't the only spot in the BIOS where I hit this problem; here's another "window of opportunity":
     *
     *      F000:3975 FA            CLI
     *      F000:3976 B020          MOV      AL,20
     *      F000:3978 E620          OUT      20,AL
     *      F000:397A B0AE          MOV      AL,AE
     *      F000:397C E81C00        CALL     SHIP_IT
     *      F000:397F B80291        MOV      AX,9102        <-- window of opportunity
     *      F000:3982 CD15          INT      15
     *      F000:3984 80269600FC    AND      [0096],FC
     *      F000:3989 E982FD        JMP      370E
     *
     * In this second, lengthier, example, I counted about 60 instructions being executed from the EOI @F000:3978 to
     * the final IRET @F000:3718, most of them in the INT 0x15 handler.  So, I'm going to double that count to 120
     * instructions, just to be safe, and pass that along to every setIRR() call we make here.
     *
     * @this {ChipSet}
     * @param {number} b
     * @return {boolean} (true if data accepted, false if declined)
     */
    receiveKbdData(b)
    {
        if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.PORT)) {
            this.printMessage("chipset.receiveKbdData(" + Str.toHexByte(b) + ')', true);
        }
        if (this.model == ChipSet.MODEL_4860) {
            if (!(this.bNMI & ChipSet.NMI.KBD_LATCH)) {
                this.bNMI |= ChipSet.NMI.KBD_LATCH;
                this.bKbdData = b;
                if (b && (this.bNMI & ChipSet.NMI.ENABLE)) {
                    X86.helpInterrupt.call(this.cpu, X86.EXCEPTION.NMI);
                }
                return true;
            }
            return false;
        }
        if (this.model < ChipSet.MODEL_5170) {
            if (this.bPPIB & ChipSet.PPI_B.CLK_KBD) {
                this.bKbdData = b;
                if (b) {
                    this.setIRR(ChipSet.IRQ.KBD, 120);
                    this.b8041Status |= ChipSet.C8042.STATUS.OUTBUFF_FULL;
                }
                return true;
            }
            return false;
        }
        if (b) {
            if (!(this.b8042CmdData & ChipSet.C8042.DATA.CMD.NO_CLOCK)) {
                /*
                 * The next in8042OutBuff() will clear both of these bits and call kbd.checkBuffer(),
                 * which will call receiveKbdData() again if there's still keyboard data to process.
                 */
                if (!(this.b8042Status & (ChipSet.C8042.STATUS.OUTBUFF_FULL | ChipSet.C8042.STATUS.OUTBUFF_DELAY))) {
                    this.set8042OutBuff(b, true);
                    /*
                     * A delay of 4 instructions was originally requested as part of the the Keyboard's resetDevice()
                     * response, but a larger delay (120) is now needed for MODEL_5170 machines, per the discussion above.
                     */
                    this.setIRR(ChipSet.IRQ.KBD, 120);
                    return true;
                }
                if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.PORT)) {
                    this.printMessage("chipset.receiveKbdData(" + Str.toHexByte(b) + "): output buffer full", true);
                }
                return false;
            }
            if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.PORT)) {
                this.printMessage("chipset.receiveKbdData(" + Str.toHexByte(b) + "): disabled", true);
            }
        }
        return false;
    }

    /**
     * in6300DIPSwitches(iDIP, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDIP (0 or 1)
     * @param {number} port (0x66 or 0x67)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    in6300DIPSwitches(iDIP, port, addrFrom)
    {
        let b = this.aDIPSwitches[iDIP][1];
        this.printMessageIO(port, undefined, addrFrom, "DIPSW-" + iDIP, b, Messages.CHIPSET);
        return b;
    }

    /**
     * inCMOSAddr(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x70)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inCMOSAddr(port, addrFrom)
    {
        this.printMessageIO(port, undefined, addrFrom, "CMOS.ADDR", this.bCMOSAddr, Messages.CMOS);
        return this.bCMOSAddr;
    }

    /**
     * outCMOSAddr(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x70)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outCMOSAddr(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "CMOS.ADDR", undefined, Messages.CMOS);
        this.bCMOSAddr = bOut;
        this.bNMI = (this.bNMI & ~ChipSet.NMI.ENABLE) | ((bOut & ChipSet.CMOS.ADDR.NMI_DISABLE)? 0 : ChipSet.NMI.ENABLE);
    }

    /**
     * inCMOSData(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x71)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inCMOSData(port, addrFrom)
    {
        let bAddr = this.bCMOSAddr & ChipSet.CMOS.ADDR.MASK;
        let bIn = (bAddr <= ChipSet.CMOS.ADDR.STATUSD? this.getRTCByte(bAddr) : this.abCMOSData[bAddr]);
        if (this.messageEnabled(Messages.CMOS | Messages.PORT)) {
            this.printMessageIO(port, undefined, addrFrom, "CMOS.DATA[" + Str.toHexByte(bAddr) + "]", bIn, true);
        }
        if (addrFrom != null) {
            if (bAddr == ChipSet.CMOS.ADDR.STATUSC) {
                /*
                 * When software reads the STATUSC port, all interrupt bits (PF, AF, and UF) are automatically
                 * cleared, which in turn clears the IRQF bit, which in turn clears the IRQ.
                 */
                this.abCMOSData[bAddr] &= ChipSet.CMOS.STATUSC.RESERVED;
                if (bIn & ChipSet.CMOS.STATUSC.IRQF) this.clearIRR(ChipSet.IRQ.RTC);
                /*
                 * If we just cleared PF, and PIE is still set, then we need to make sure the next Periodic Interrupt
                 * occurs in a timely manner, too.
                 */
                if ((bIn & ChipSet.CMOS.STATUSC.PF) && (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.PIE)) {
                    if (!COMPILED) this.printMessage("RTC periodic interrupt cleared", Messages.RTC);
                    this.setRTCCycleLimit();
                }
            }
        }
        return bIn;
    }

    /**
     * outCMOSData(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x71)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outCMOSData(port, bOut, addrFrom)
    {
        let bAddr = this.bCMOSAddr & ChipSet.CMOS.ADDR.MASK;
        if (this.messageEnabled(Messages.CMOS | Messages.PORT)) {
            this.printMessageIO(port, bOut, addrFrom, "CMOS.DATA[" + Str.toHexByte(bAddr) + "]", undefined, true);
        }
        let bDelta = bOut ^ this.abCMOSData[bAddr];
        this.abCMOSData[bAddr] = (bAddr <= ChipSet.CMOS.ADDR.STATUSD? this.setRTCByte(bAddr, bOut) : bOut);
        if (bAddr == ChipSet.CMOS.ADDR.STATUSB && (bDelta & ChipSet.CMOS.STATUSB.PIE)) {
            if (bOut & ChipSet.CMOS.STATUSB.PIE) {
                if (!COMPILED) this.printMessage("RTC periodic interrupts enabled", Messages.RTC);
                this.setRTCCycleLimit();
            } else {
                if (!COMPILED) this.printMessage("RTC periodic interrupts disabled", Messages.RTC);
            }
        }
    }

    /**
     * inNMI(port, addrFrom)
     *
     * This handler is installed only for models before MODEL_5170; technically, this port is not readable,
     * except on the MODEL_4860, and even there, all a read is required to do is clear KBD_LATCH, but we go ahead
     * and return all the bits.
     *
     * @this {ChipSet}
     * @param {number} port (0xA0)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @return {number} simulated port value
     */
    inNMI(port, addrFrom)
    {
        let bIn = this.bNMI;
        this.printMessageIO(port, undefined, addrFrom, "NMI", bIn);
        this.bNMI &= ~ChipSet.NMI.KBD_LATCH;
        return bIn;
    }

    /**
     * outNMI(port, bOut, addrFrom)
     *
     * This handler is installed only for models before MODEL_5170.
     *
     * @this {ChipSet}
     * @param {number} port (0xA0)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outNMI(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "NMI");
        this.bNMI = bOut;
    }

    /**
     * outFPUClear(port, bOut, addrFrom)
     *
     * This handler is installed only for MODEL_5170.
     *
     * @this {ChipSet}
     * @param {number} port (0xF0)
     * @param {number} bOut (0x00 is the only expected output)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outFPUClear(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "FPU.CLEAR");

        if (this.fpu) this.fpu.clearBusy();
    }

    /**
     * outFPUReset(port, bOut, addrFrom)
     *
     * This handler is installed only for MODEL_5170.
     *
     * @this {ChipSet}
     * @param {number} port (0xF1)
     * @param {number} bOut (0x00 is the only expected output)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outFPUReset(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "FPU.RESET");

        if (this.fpu) this.fpu.resetFPU();
    }

    /**
     * intBIOSTimer(addr)
     *
     * INT 0x1A Quick Reference:
     *
     *      AH
     *      ----
     *      0x00    Get current clock count in CX:DX
     *      0x01    Set current clock count from CX:DX
     *      0x02    Get real-time clock using BCD (CH=hours, CL=minutes, DH=seconds)
     *      0x03    Set real-time clock using BCD (CH=hours, CL=minutes, DH=seconds, DL=1 if Daylight Savings Time option)
     *      0x04    Get real-time date using BCD (CH=century, CL=year, DH=month, DL=day)
     *      0x05    Set real-time date using BCD (CH=century, CL=year, DH=month, DL=day)
     *      0x06    Set alarm using BCD (CH=hours, CL=minutes, DH=seconds)
     *      0x07    Reset alarm
     *
     * @this {ChipSet}
     * @param {number} addr
     * @return {boolean} true to proceed with the INT 0x1A software interrupt, false to skip
     */
    intBIOSTimer(addr)
    {
        if (DEBUGGER) {
            if (this.messageEnabled(Messages.INT) && this.dbg.messageInt(Interrupts.TIMER, addr)) {
                /*
                 * By computing AH now, we get the incoming AH value; if we computed it below, along with
                 * the rest of the register values, we'd get the outgoing AH value, which is not what we want.
                 */
                let chipset = this;
                let AH = this.cpu.regEAX >> 8;
                let nCycles = this.cpu.getCycles();
                this.cpu.addIntReturn(addr, function onBIOSRTCReturn(nLevel) {
                    let sResult;
                    let CL = chipset.cpu.regEDX & 0xff;
                    let CH = chipset.cpu.regEDX >> 8;
                    let DL = chipset.cpu.regEDX & 0xff;
                    let DH = chipset.cpu.regEDX >> 8;
                    if (AH == 0x02 || AH == 0x03) {
                        sResult = " CH(hour)=" + Str.toHexWord(CH) + " CL(min)=" + Str.toHexByte(CL) + " DH(sec)=" + Str.toHexByte(DH);
                    } else if (AH == 0x04 || AH == 0x05) {
                        sResult = " CX(year)=" + Str.toHexWord(chipset.cpu.regECX) + " DH(month)=" + Str.toHexByte(DH) + " DL(day)=" + Str.toHexByte(DL);
                    }
                    let nCyclesDelta = -nCycles + (nCycles = chipset.cpu.getCycles());
                    chipset.dbg.messageIntReturn(Interrupts.TIMER, nLevel, nCyclesDelta, sResult);
                });
            }
        }
        return true;
    }

    /**
     * setSpeaker(fEnable)
     *
     * @this {ChipSet}
     * @param {boolean} [fEnable] true to enable speaker, false to disable it, otherwise update it as appropriate
     */
    setSpeaker(fEnable)
    {
        let fOn;
        if (fEnable !== undefined) {
            fOn = fEnable;
            if (fOn != this.fSpeakerEnabled) {
                //
                // Yielding doesn't seem to help the simulation of sound via rapid speaker toggling.
                //
                // if (this.cpu) {
                //     this.cpu.yieldCPU();
                // }
                this.fSpeakerEnabled = fOn;
            }
        } else {
            fOn = !!(this.fSpeakerEnabled && this.cpu && this.cpu.isRunning());
        }
        let freq = Math.round(ChipSet.TIMER_TICKS_PER_SEC / this.getTimerInit(ChipSet.PIT0.TIMER2));
        if (freq < 20 || freq > 20000) {
            /*
             * Treat frequencies outside the normal hearing range (below 20hz or above 20Khz) as a clever
             * attempt to turn sound off.
             */
            fOn = false;
        }
        if (this.contextAudio) {
            if (fOn && this.startAudio()) {
                /*
                 * Instead of setting the frequency's 'value' property directly, as we used to do, we use the
                 * setValueAtTime() method, with a time of zero, as a work-around to avoid the "easing" (aka
                 * "de-zippering") of the frequency that browsers like to do.  Supposedly de-zippering is an
                 * attempt to avoid "pops" if the frequency is altered while the wave is still rising or falling.
                 *
                 * Ditto for the gain's 'value'.
                 */
                // this.oscillatorAudio['frequency']['value'] = freq;
                this.oscillatorAudio['frequency']['setValueAtTime'](freq, 0);
                // this.volumeAudio['gain']['value'] = this.volumeInit;
                this.volumeAudio['gain']['setValueAtTime'](this.volumeInit, 0);
                if (this.messageEnabled(Messages.SPEAKER)) this.printMessage("speaker on at  " + freq + "hz", true);
            } else if (this.volumeAudio) {
                this.volumeAudio['gain']['setValueAtTime'](0, 0);
                if (this.messageEnabled(Messages.SPEAKER)) this.printMessage("speaker off at " + freq + "hz", true);
            }
        } else if (fOn && this.fSpeakerOn != fOn) {
            this.printMessage("BEEP", Messages.SPEAKER);
        }
        this.fSpeakerOn = fOn;
    }

    /**
     * startAudio(event)
     *
     * NOTE: We currently use named properties rather than "dot" properties to access all the AudioContext
     * properties and methods, because we don't have any built-in declarations or externs for them, so neither
     * WebStorm nor the Closure Compiler recognize them.  We could live with the WebStorm inspection warnings,
     * but we definitely can't have the Closure Compiler renaming any of the properties -- and since it
     * automatically converts them all to "dot" properties, there's no incentive for us to do anything more.
     *
     * @this {ChipSet}
     * @param {Event} [event] object from a 'touch' event, if any
     * @return {boolean}
     */
    startAudio(event)
    {
        if (this.contextAudio) {
            /*
             * NOTE: If the machine happened to enable its speaker *before* the user generated an event
             * (eg, touchstart) that resulted in a call here, then we're too late -- at least as far as iOS
             * devices are concerned, because those devices require the oscillator's start() method to be
             * called in the context of a user-initiated event.
             *
             * So, for the benefit of iOS devices, when we finally receive a user-generated call, we will
             * simply recreate the oscillator.  This is a one-time work-around for the life of the machine.
             *
             * TODO: Consider adding a "Sound On/Off" button to all machines (probably in the top right corner,
             * where "Full Screen" and "Lock Pointer" buttons typically appear), at least on iOS devices.
             */
            if (event) {
                if (this.fUserSound) return true;
                this.oscillatorAudio = null;
                this.fUserSound = true;
            }
            if (this.oscillatorAudio) return true;
            try {
                this.oscillatorAudio = this.contextAudio['createOscillator']();
                if ('start' in this.oscillatorAudio) {  // early versions of Web Audio used noteOn() instead of start()
                    this.volumeAudio = this.contextAudio['createGain']();
                    this.oscillatorAudio['connect'](this.volumeAudio);
                    this.volumeAudio['connect'](this.contextAudio['destination']);
                    this.volumeAudio['gain']['setValueAtTime'](0, 0);
                    this.oscillatorAudio['type'] = "square";
                    this.oscillatorAudio['start'](0);
                    return true;
                }
            } catch(e) {
                this.notice("AudioContext exception: " + e.message);
                this.contextAudio = null;
            }
        }
        return false;
    }

    /**
     * messageBitsDMA(iChannel)
     *
     * @this {ChipSet}
     * @param {number} [iChannel] if the message is associated with a particular IRQ #
     * @return {number}
     */
    messageBitsDMA(iChannel)
    {
        let bitsMessage = 0;
        if (DEBUG) {
            bitsMessage = Messages.DATA;
            if (iChannel == ChipSet.DMA_FDC) {
                bitsMessage |= Messages.FDC;
            } else if (iChannel == ChipSet.DMA_HDC) {
                bitsMessage |= Messages.HDC;
            }
        }
        return bitsMessage;
    }

    /**
     * messageBitsIRQ(nIRQ)
     *
     * @this {ChipSet}
     * @param {number|undefined} [nIRQ] if the message is associated with a particular IRQ #
     * @return {number}
     */
    messageBitsIRQ(nIRQ)
    {
        let bitsMessage = Messages.IRQ;
        if (nIRQ == ChipSet.IRQ.TIMER0) {       // IRQ 0
            bitsMessage |= Messages.TIMER;
        } else if (nIRQ == ChipSet.IRQ.KBD) {   // IRQ 1
            bitsMessage |= Messages.KBD;
        } else if (nIRQ == ChipSet.IRQ.SLAVE) { // IRQ 2
            bitsMessage =  Messages.NONE;       // (we're not really interested in IRQ 2 itself, just the slaves)
        } else if (nIRQ == ChipSet.IRQ.COM1 || nIRQ == ChipSet.IRQ.COM2) {
            bitsMessage |= Messages.SERIAL;
        } else if (nIRQ == ChipSet.IRQ.XTC) {   // IRQ 5 (MODEL_5160)
            bitsMessage |= Messages.HDC;
        } else if (nIRQ == ChipSet.IRQ.FDC) {   // IRQ 6
            bitsMessage |= Messages.FDC;
        } else if (nIRQ == ChipSet.IRQ.RTC) {   // IRQ 8 (MODEL_5170 and up)
            bitsMessage |= Messages.RTC;
        } else if (nIRQ == ChipSet.IRQ.ATC) {   // IRQ 14 (MODEL_5170 and up)
            bitsMessage |= Messages.HDC;
        }
        return bitsMessage;
    }

    /**
     * checkDMA()
     *
     * Called by the CPU whenever INTR.DMA is set.
     *
     * @return {boolean} true if one or more async DMA channels are still active (unmasked), false to reset INTR.DMA
     *
     checkDMA()
     {
         let fActive = false;
         for (let iDMAC = 0; iDMAC < this.aDMACs; iDMAC++) {
             let controller = this.aDMACs[iDMAC];
             for (let iChannel = 0; iChannel < controller.aChannels.length; iChannel++) {
                 let channel = controller.aChannels[iChannel];
                 if (!channel.masked) {
                     this.advanceDMA(channel);
                     if (!channel.masked) fActive = true;
                 }
             }
         }
         return fActive;
     }
     */

    /**
     * ChipSet.init()
     *
     * This function operates on every HTML element of class "chipset", extracting the
     * JSON-encoded parameters for the ChipSet constructor from the element's "data-value"
     * attribute, invoking the constructor to create a ChipSet component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeChipSet = Component.getElementsByClass(document, PCX86.APPCLASS, "chipset");
        for (let iChip = 0; iChip < aeChipSet.length; iChip++) {
            let eChipSet = aeChipSet[iChip];
            let parmsChipSet = Component.getComponentParms(eChipSet);
            let chipset = new ChipSet(parmsChipSet);
            Component.bindComponentControls(chipset, eChipSet, PCX86.APPCLASS);
            chipset.updateDIPSwitchDescriptions();
        }
    }
}

/*
 * Ports Overview
 * --------------
 *
 * This module provides support for many of the following components (except where a separate component is noted).
 * This list is taken from p.1-8 ("System Unit") of the IBM 5160 (PC XT) Technical Reference Manual (as revised
 * April 1983), only because I didn't see a similar listing in the original 5150 Technical Reference.
 *
 *      Port(s)         Description
 *      -------         -----------
 *      000-00F         DMA Chip 8237A-5                                [see below]
 *      020-021         Interrupt 8259A                                 [see below]
 *      040-043         Timer 8253-5                                    [see below]
 *      060-063         PPI 8255A-5                                     [see below]
 *      080-083         DMA Page Registers                              [see below]
 *          0Ax [1]     NMI Mask Register                               [see below]
 *          0Cx         Reserved
 *          0Ex         Reserved
 *      200-20F         Game Control
 *      210-217         Expansion Unit
 *      220-24F         Reserved
 *      278-27F         Reserved
 *      2F0-2F7         Reserved
 *      2F8-2FF         Asynchronous Communications (Secondary)         [see the SerialPort component]
 *      300-31F         Prototype Card
 *      320-32F         Hard Drive Controller (XTC)                     [see the HDC component]
 *      378-37F         Printer
 *      380-38C [2]     SDLC Communications
 *      380-389 [2]     Binary Synchronous Communications (Secondary)
 *      3A0-3A9         Binary Synchronous Communications (Primary)
 *      3B0-3BF         IBM Monochrome Display/Printer                  [see the Video component]
 *      3C0-3CF         Reserved
 *      3D0-3DF         Color/Graphics (Motorola 6845)                  [see the Video component]
 *      3EO-3E7         Reserved
 *      3FO-3F7         Floppy Drive Controller                         [see the FDC component]
 *      3F8-3FF         Asynchronous Communications (Primary)           [see the SerialPort component]
 *
 * [1] At power-on time, NMI is masked off, perhaps because models 5150 and 5160 also tie coprocessor
 * (FPU) interrupts to NMI.  Suppressing NMI by default seems odd, because that would also suppress memory
 * parity errors.  TODO: Determine whether "power-on time" refers to the initial power-on state of the
 * NMI Mask Register or the state that the BIOS "POST" (Power-On Self-Test) sets.
 *
 * [2] These devices cannot be used together since their port addresses overlap.
 *
 *      MODEL_5170      Description
 *      ----------      -----------
 *          070 [3]     CMOS Address                                    ChipSet.CMOS.ADDR.PORT
 *          071         CMOS Data                                       ChipSet.CMOS.DATA.PORT
 *          0F0         FPU Coprocessor Clear Busy (output 0x00)
 *          0F1         FPU Coprocessor Reset (output 0x00)
 *      1F0-1F7         Hard Drive Controller (ATC)                     [see the HDC component]
 *
 * [3] Port 0x70 doubles as the NMI Mask Register: output a CMOS address with bit 7 clear to enable NMI
 * or with bit 7 set to disable NMI (apparently the inverse of the older NMI Mask Register at port 0xA0).
 * Also, apparently unlike previous models, the MODEL_5170 POST leaves NMI enabled.  And fortunately, the
 * FPU coprocessor interrupt line is no longer tied to NMI (it uses IRQ 13).
 */

/*
 * Supported model numbers
 *
 * In general, when comparing this.model to "base" model numbers (ie, non-REV numbers), you should use
 * (this.model|0), which truncates the current model number.
 *
 * Note that there were two 5150 motherboard revisions: the "REV A" 16Kb-64Kb motherboard and the
 * "REV B" 64Kb-256Kb motherboard.  There may have been a manufacturing correlation between motherboard
 * revisions ("REV A" and "REV B") and the ROM BIOS revisions shown below, but in general, we can't assume
 * any correlation, because newer ROMs could be installed with either motherboard.
 *
 * I do know that, for "REV A" motherboards, the Apr 1984 5150 TechRef says that "To expand the memory
 * of your system beyond 544K requires your IBM Personal Computer System Unit to have a BIOS ROM module
 * dated 10/27/82 or later."  Which suggests that SW2[5] was not used until the REV3 5150 ROM BIOS.
 *
 * For now, we treat all our MODEL_5150 systems as 16Kb-64Kb motherboards; if you want a 64Kb-256Kb motherboard,
 * then step up to a MODEL_5160 system.  We use a multiplier of 16 for 5150 LOWMEM values, and a multiplier
 * of 64 for 5160 LOWMEM values.
 */
ChipSet.MODEL_4860              = 4860;     // PCjr

ChipSet.MODEL_5150              = 5150;     // used in reference to the 1st 5150 ROM BIOS, dated Apr 24, 1981
ChipSet.MODEL_5150_REV2         = 5150.2;   // used in reference to the 2nd 5150 ROM BIOS, dated Oct 19, 1981
ChipSet.MODEL_5150_REV3         = 5150.3;   // used in reference to the 3rd 5150 ROM BIOS, dated Oct 27, 1982
ChipSet.MODEL_5150_OTHER        = 5150.9;

ChipSet.MODEL_5160              = 5160;     // used in reference to the 1st 5160 ROM BIOS, dated Nov 08, 1982
ChipSet.MODEL_5160_REV2         = 5160.2;   // used in reference to the 1st 5160 ROM BIOS, dated Jan 10, 1986
ChipSet.MODEL_5160_REV3         = 5160.3;   // used in reference to the 1st 5160 ROM BIOS, dated May 09, 1986
ChipSet.MODEL_5160_OTHER        = 5160.9;

ChipSet.MODEL_5170              = 5170;     // used in reference to the 1st 5170 ROM BIOS, dated Jan 10, 1984
ChipSet.MODEL_5170_REV2         = 5170.2;   // used in reference to the 2nd 5170 ROM BIOS, dated Jun 10, 1985
ChipSet.MODEL_5170_REV3         = 5170.3;   // used in reference to the 3rd 5170 ROM BIOS, dated Nov 15, 1985
ChipSet.MODEL_5170_OTHER        = 5170.9;

/*
 * Assorted non-IBM models (we don't put "IBM" in the IBM models, but non-IBM models should include the company name).
 */
ChipSet.MODEL_CDP_MPC1600       = 5150.101; // Columbia Data Products MPC 1600 ("Copyright Columbia Data Products 1983, ROM/BIOS Ver 4.34")
ChipSet.MODEL_COMPAQ_PORTABLE   = 5150.102; // COMPAQ Portable (COMPAQ's first PC)

ChipSet.MODEL_ATT_6300          = 5160.101; // AT&T Personal Computer 6300/Olivetti M24 ("COPYRIGHT (C) OLIVETTI 1984","04/03/86",v1.43)
ChipSet.MODEL_ZENITH_Z150       = 5160.150; // Zenith Data Systems Z-150 ("08/11/88 (C)ZDS CORP")

ChipSet.MODEL_COMPAQ_DESKPRO386 = 5180;     // COMPAQ DeskPro 386 (COMPAQ's first 80386-based PC); should be > MODEL_5170

/*
 * Last but not least, a complete list of supported model strings, and corresponding internal model numbers.
 */
ChipSet.MODELS = {
    "4860":         ChipSet.MODEL_4860,     // IBM PCjr
    "5150":         ChipSet.MODEL_5150,     // IBM PC
    "5160":         ChipSet.MODEL_5160,     // IBM PC XT
    "5170":         ChipSet.MODEL_5170,     // IBM PC AT
    "att6300":      ChipSet.MODEL_ATT_6300,
    "mpc1600":      ChipSet.MODEL_CDP_MPC1600,
    "z150":         ChipSet.MODEL_ZENITH_Z150,
    "compaq":       ChipSet.MODEL_COMPAQ_PORTABLE,
    "other":        ChipSet.MODEL_5150_OTHER
};

if (DESKPRO386) {
    ChipSet.MODELS["deskpro386"] = ChipSet.MODEL_COMPAQ_DESKPRO386;
}

ChipSet.CONTROLS = {
    SW1:    "sw1",
    SW2:    "sw2",
    SWDESC: "swdesc"
};

/*
 * Values returned by ChipSet.getDIPVideoMonitor()
 */
ChipSet.MONITOR = {
    NONE:               0,
    TV:                 1,  // Composite monitor (lower resolution; no support)
    COLOR:              2,  // Color Display (5153)
    MONO:               3,  // Monochrome Display (5151)
    EGACOLOR:           4,  // Enhanced Color Display (5154) in High-Res Mode
    EGAEMULATION:       6,  // Enhanced Color Display (5154) in Emulation Mode
    VGACOLOR:           7   // VGA Color Display
};

/*
 *  8237A DMA Controller (DMAC) I/O ports
 *
 *  MODEL_5150 and up uses DMA channel 0 for memory refresh cycles and channel 2 for the FDC.
 *
 *  MODEL_5160 and up uses DMA channel 3 for HDC transfers (XTC only).
 *
 *  DMA0 refers to the original DMA controller found on all models, and DMA1 refers to the additional
 *  controller found on MODEL_5170 and up; channel 4 on DMA1 is used to "cascade" channels 0-3 from DMA0,
 *  so only channels 5-7 are available on DMA1.
 *
 *  For FDC DMA notes, refer to http://wiki.osdev.org/ISA_DMA
 *  For general DMA notes, refer to http://www.freebsd.org/doc/en/books/developers-handbook/dma.html
 *
 *  TODO: Determine why the MODEL_5150 ROM BIOS sets the DMA channel 1 page register (port 0x83) to zero.
 */
ChipSet.DMA0 = {
    INDEX:              0,
    PORT: {
        CH0_ADDR:       0x00,   // OUT: starting address        IN: current address
        CH0_COUNT:      0x01,   // OUT: starting word count     IN: remaining word count
        CH1_ADDR:       0x02,   // OUT: starting address        IN: current address
        CH1_COUNT:      0x03,   // OUT: starting word count     IN: remaining word count
        CH2_ADDR:       0x04,   // OUT: starting address        IN: current address
        CH2_COUNT:      0x05,   // OUT: starting word count     IN: remaining word count
        CH3_ADDR:       0x06,   // OUT: starting address        IN: current address
        CH3_COUNT:      0x07,   // OUT: starting word count     IN: remaining word count
        CMD_STATUS:     0x08,   // OUT: command register        IN: status register
        REQUEST:        0x09,
        MASK:           0x0A,
        MODE:           0x0B,
        RESET_FF:       0x0C,   // reset flip-flop
        MASTER_CLEAR:   0x0D,   // OUT: master clear            IN: temporary register
        MASK_CLEAR:     0x0E,   // TODO: Provide handlers
        MASK_ALL:       0x0F,   // TODO: Provide handlers
        CH2_PAGE:       0x81,   // OUT: DMA channel 2 page register
        CH3_PAGE:       0x82,   // OUT: DMA channel 3 page register
        CH1_PAGE:       0x83,   // OUT: DMA channel 1 page register
        CH0_PAGE:       0x87    // OUT: DMA channel 0 page register (unusable; See "The Inside Out" book, p.246)
    }
};
ChipSet.DMA1 = {
    INDEX:              1,
    PORT: {
        CH6_PAGE:       0x89,   // OUT: DMA channel 6 page register (MODEL_5170)
        CH7_PAGE:       0x8A,   // OUT: DMA channel 7 page register (MODEL_5170)
        CH5_PAGE:       0x8B,   // OUT: DMA channel 5 page register (MODEL_5170)
        CH4_PAGE:       0x8F,   // OUT: DMA channel 4 page register (MODEL_5170; unusable; aka "Refresh" page register?)
        CH4_ADDR:       0xC0,   // OUT: starting address        IN: current address
        CH4_COUNT:      0xC2,   // OUT: starting word count     IN: remaining word count
        CH5_ADDR:       0xC4,   // OUT: starting address        IN: current address
        CH5_COUNT:      0xC6,   // OUT: starting word count     IN: remaining word count
        CH6_ADDR:       0xC8,   // OUT: starting address        IN: current address
        CH6_COUNT:      0xCA,   // OUT: starting word count     IN: remaining word count
        CH7_ADDR:       0xCC,   // OUT: starting address        IN: current address
        CH7_COUNT:      0xCE,   // OUT: starting word count     IN: remaining word count
        CMD_STATUS:     0xD0,   // OUT: command register        IN: status register
        REQUEST:        0xD2,
        MASK:           0xD4,
        MODE:           0xD6,
        RESET_FF:       0xD8,   // reset flip-flop
        MASTER_CLEAR:   0xDA,   // master clear
        MASK_CLEAR:     0xDC,   // TODO: Provide handlers
        MASK_ALL:       0xDE    // TODO: Provide handlers
    }
};

ChipSet.DMA_CMD = {
    M2M_ENABLE:         0x01,
    CH0HOLD_ENABLE:     0x02,
    CTRL_DISABLE:       0x04,
    COMP_TIMING:        0x08,
    ROT_PRIORITY:       0x10,
    EXT_WRITE_SEL:      0x20,
    DREQ_ACTIVE_LO:     0x40,
    DACK_ACTIVE_HI:     0x80
};

ChipSet.DMA_STATUS = {
    CH0_TC:             0x01,   // Channel 0 has reached Terminal Count (TC)
    CH1_TC:             0x02,   // Channel 1 has reached Terminal Count (TC)
    CH2_TC:             0x04,   // Channel 2 has reached Terminal Count (TC)
    CH3_TC:             0x08,   // Channel 3 has reached Terminal Count (TC)
    ALL_TC:             0x0f,   // all TC bits are cleared whenever DMA_STATUS is read
    CH0_REQ:            0x10,   // Channel 0 DMA requested
    CH1_REQ:            0x20,   // Channel 1 DMA requested
    CH2_REQ:            0x40,   // Channel 2 DMA requested
    CH3_REQ:            0x80    // Channel 3 DMA requested
};

ChipSet.DMA_MASK = {
    CHANNEL:            0x03,
    CHANNEL_SET:        0x04
};

ChipSet.DMA_MODE = {
    CHANNEL:            0x03,   // bits 0-1 select 1 of 4 possible channels
    TYPE:               0x0C,   // bits 2-3 select 1 of 3 valid (4 possible) transfer types
    TYPE_VERIFY:        0x00,   // pseudo transfer (generates addresses, responds to EOP, but nothing is moved)
    TYPE_WRITE:         0x04,   // write to memory (move data FROM an I/O device; eg, reading a sector from a disk)
    TYPE_READ:          0x08,   // read from memory (move data TO an I/O device; eg, writing a sector to a disk)
    AUTOINIT:           0x10,
    DECREMENT:          0x20,   // clear for INCREMENT
    MODE:               0xC0,   // bits 6-7 select 1 of 4 possible transfer modes
    MODE_DEMAND:        0x00,
    MODE_SINGLE:        0x40,
    MODE_BLOCK:         0x80,
    MODE_CASCADE:       0xC0
};

ChipSet.DMA_REFRESH   = 0x00;   // DMA channel assigned to memory refresh
ChipSet.DMA_FDC       = 0x02;   // DMA channel assigned to the Floppy Drive Controller (FDC)
ChipSet.DMA_HDC       = 0x03;   // DMA channel assigned to the Hard Drive Controller (HDC; XTC only)

/*
 * 8259A Programmable Interrupt Controller (PIC) I/O ports
 *
 * Internal registers:
 *
 *      ICW1    Initialization Command Word 1 (sent to port ChipSet.PIC_LO)
 *      ICW2    Initialization Command Word 2 (sent to port ChipSet.PIC_HI)
 *      ICW3    Initialization Command Word 3 (sent to port ChipSet.PIC_HI)
 *      ICW4    Initialization Command Word 4 (sent to port ChipSet.PIC_HI)
 *      IMR     Interrupt Mask Register
 *      IRR     Interrupt Request Register
 *      ISR     Interrupt Service Register
 *      IRLow   (IR having lowest priority; IR+1 will have highest priority; default is 7)
 *
 * Note that ICW2 effectively contains the starting IDT vector number (ie, for IRQ 0),
 * which must be multiplied by 4 to calculate the vector offset, since every vector is 4 bytes long.
 *
 * Also, since the low 3 bits of ICW2 are ignored in 8086/8088 mode (ie, they are effectively
 * treated as zeros), this means that the starting IDT vector can only be a multiple of 8.
 *
 * So, if ICW2 is set to 0x08, the starting vector number (ie, for IRQ 0) will be 0x08, and the
 * 4-byte address for the corresponding ISR will be located at offset 0x20 in the real-mode IDT.
 *
 * ICW4 is typically set to 0x09, indicating 8086 mode, non-automatic EOI, buffered/slave mode.
 *
 * TODO: Determine why the original ROM BIOS chose buffered/slave over buffered/master.
 * Did it simply not matter in pre-AT systems with only one PIC, or am I misreading something?
 *
 * TODO: Consider support for level-triggered PIC interrupts, even though the original IBM PCs
 * (up through MODEL_5170) used only edge-triggered interrupts.
 */
ChipSet.PIC0 = {                // all models: the "master" PIC
    INDEX:              0,
    PORT_LO:            0x20,
    PORT_HI:            0x21
};

ChipSet.PIC1 = {                // MODEL_5170 and up: the "slave" PIC
    INDEX:              1,
    PORT_LO:            0xA0,
    PORT_HI:            0xA1
};

ChipSet.PIC_LO = {              // ChipSet.PIC1.PORT_LO or ChipSet.PIC2.PORT_LO
    ICW1:               0x10,   // set means ICW1
    ICW1_ICW4:          0x01,   // ICW4 needed (otherwise ICW4 must be sent)
    ICW1_SNGL:          0x02,   // single PIC (and therefore no ICW3; otherwise there is another "cascaded" PIC)
    ICW1_ADI:           0x04,   // call address interval is 4 (otherwise 8; presumably ignored in 8086/8088 mode)
    ICW1_LTIM:          0x08,   // level-triggered interrupt mode (otherwise edge-triggered mode, which is what PCs use)
    OCW2:               0x00,   // bit 3 (PIC_LO.OCW3) and bit 4 (ChipSet.PIC_LO.ICW1) are clear in an OCW2 command byte
    OCW2_IR_LVL:        0x07,
    OCW2_OP_MASK:       0xE0,   // of the following valid OCW2 operations, the first 4 are EOI commands (all have ChipSet.PIC_LO.OCW2_EOI set)
    OCW2_EOI:           0x20,   // non-specific EOI (end-of-interrupt)
    OCW2_EOI_SPEC:      0x60,   // specific EOI
    OCW2_EOI_ROT:       0xA0,   // rotate on non-specific EOI
    OCW2_EOI_ROTSPEC:   0xE0,   // rotate on specific EOI
    OCW2_SET_ROTAUTO:   0x80,   // set rotate in automatic EOI mode
    OCW2_CLR_ROTAUTO:   0x00,   // clear rotate in automatic EOI mode
    OCW2_SET_PRI:       0xC0,   // bits 0-2 specify the lowest priority interrupt
    OCW3:               0x08,   // bit 3 (PIC_LO.OCW3) is set and bit 4 (PIC_LO.ICW1) clear in an OCW3 command byte (bit 7 should be clear, too)
    OCW3_READ_IRR:      0x02,   // read IRR register
    OCW3_READ_ISR:      0x03,   // read ISR register
    OCW3_READ_CMD:      0x03,
    OCW3_POLL_CMD:      0x04,   // poll
    OCW3_SMM_RESET:     0x40,   // special mask mode: reset
    OCW3_SMM_SET:       0x60,   // special mask mode: set
    OCW3_SMM_CMD:       0x60
};

ChipSet.PIC_HI = {              // ChipSet.PIC1.PORT_HI or ChipSet.PIC2.PORT_HI
    ICW2_VECTOR:        0xF8,   // starting vector number (bits 0-2 are effectively treated as zeros in 8086/8088 mode)
    ICW4_8086:          0x01,
    ICW4_AUTO_EOI:      0x02,
    ICW4_MASTER:        0x04,
    ICW4_BUFFERED:      0x08,
    ICW4_FULLY_NESTED:  0x10,
    OCW1_IMR:           0xFF
};

/*
 * The priorities of IRQs 0-7 are normally high to low, unless the master PIC has been reprogrammed.
 * Also, if a slave PIC is present, the priorities of IRQs 8-15 fall between the priorities of IRQs 1 and 3.
 *
 * As the MODEL_5170 TechRef states:
 *
 *      "Interrupt requests are prioritized, with IRQ9 through IRQ12 and IRQ14 through IRQ15 having the
 *      highest priority (IRQ9 is the highest) and IRQ3 through IRQ7 having the lowest priority (IRQ7 is
 *      the lowest).
 *
 *      Interrupt 13 (IRQ.FPU) is used on the system board and is not available on the I/O channel.
 *      Interrupt 8 (IRQ.RTC) is used for the real-time clock."
 *
 * This priority scheme is a byproduct of IRQ8 through IRQ15 (slave PIC interrupts) being tied to IRQ2 of
 * the master PIC.  As a result, the two other system board interrupts, IRQ0 and IRQ1, continue to have the
 * highest priority, by default.
 */
ChipSet.IRQ = {
    TIMER0:             0x00,
    KBD:                0x01,
    VID:                0x02,   // EGA vertical retrace (arrives via IRQ 9 on MODEL_5170)
    SLAVE:              0x02,   // MODEL_5170
    COM2:               0x03,
    COM1:               0x04,
    XTC:                0x05,   // MODEL_5160 uses IRQ 5 for HDC (XTC version)
    LPT2:               0x05,   // MODEL_5170 uses IRQ 5 for LPT2
    FDC:                0x06,
    LPT1:               0x07,
    RTC:                0x08,   // MODEL_5170
    IRQ2:               0x09,   // MODEL_5170
    FPU:                0x0D,   // MODEL_5170
    ATC:                0x0E    // MODEL_5170 uses IRQ 14 for HDC (ATC version)
};

/*
 * 8253 Programmable Interval Timer (PIT) I/O ports
 *
 * Although technically, a PIT provides 3 "counters" rather than 3 "timers", we have
 * adopted IBM's TechRef nomenclature, which refers to the PIT's counters as TIMER0,
 * TIMER1, and TIMER2.  For machines with a second PIT (eg, the DeskPro 386), we refer
 * to those additional counters as TIMER3, TIMER4, and TIMER5.
 *
 * In addition, if there's a need to refer to a specific PIT, use PIT0 for the first PIT
 * and PIT1 for the second.  This mirrors how we refer to multiple DMA controllers
 * (eg, DMA0 and DMA1) and multiple PICs (eg, PIC0 and PIC1).
 *
 * This differs from COMPAQ's nomenclature, which used "Timer 1" to refer to the first
 * PIT, and "Timer 2" for the second PIT, and then referred to "Counter 0", "Counter 1",
 * and "Counter 2" within each PIT.
 */
ChipSet.PIT0 = {
    PORT:               0x40,
    INDEX:              0,
    TIMER0:             0,      // used for time-of-day (prior to MODEL_5170)
    TIMER1:             1,      // used for memory refresh
    TIMER2:             2       // used for speaker tone generation
};

ChipSet.PIT1 = {
    PORT:               0x48,   // MODEL_COMPAQ_DESKPRO386 only
    INDEX:              1,
    TIMER3:             0,      // used for fail-safe clock
    TIMER4:             1,      // N/A
    TIMER5:             2       // used for refresher request extend/speed control
};

ChipSet.PIT_CTRL = {
    PORT1:              0x43,   // write-only control register (use the Read-Back command to get status)
    PORT2:              0x4B,   // write-only control register (use the Read-Back command to get status)
    BCD:                0x01,
    MODE:               0x0E,
    MODE0:              0x00,   // interrupt on Terminal Count (TC)
    MODE1:              0x02,   // programmable one-shot
    MODE2:              0x04,   // rate generator
    MODE3:              0x06,   // square wave generator
    MODE4:              0x08,   // software-triggered strobe
    MODE5:              0x0A,   // hardware-triggered strobe
    RW:                 0x30,
    RW_LATCH:           0x00,
    RW_LSB:             0x10,
    RW_MSB:             0x20,
    RW_BOTH:            0x30,
    SC:                 0xC0,
    SC_CTR0:            0x00,
    SC_CTR1:            0x40,
    SC_CTR2:            0x80,
    SC_BACK:            0xC0,
    SC_SHIFT:           6,
    RB_CTR0:            0x02,
    RB_CTR1:            0x04,
    RB_CTR2:            0x08,
    RB_STATUS:          0x10,   // if this bit is CLEAR, then latch the current status of the selected counter(s)
    RB_COUNTS:          0x20,   // if this bit is CLEAR, then latch the current count(s) of the selected counter(s)
    RB_NULL:            0x40,   // bit set in Read-Back status byte if the counter has not been "fully loaded" yet
    RB_OUT:             0x80    // bit set in Read-Back status byte if fOUT is true
};

ChipSet.TIMER_TICKS_PER_SEC = 1193181;

/*
 * 8255A Programmable Peripheral Interface (PPI) I/O ports, for Cassette/Speaker/Keyboard/SW1/etc
 *
 * Normally, 0x99 is written to PPI_CTRL.PORT, indicating that PPI_A.PORT and PPI_C.PORT are INPUT ports
 * and PPI_B.PORT is an OUTPUT port.
 *
 * However, the MODEL_5160 ROM BIOS initially writes 0x89 instead, making PPI_A.PORT an OUTPUT port.
 * I'm guessing that's just part of some "diagnostic mode", because all it writes to PPI_A.PORT are a series
 * of "checkpoint" values (ie, 0x01, 0x02, and 0x03) before updating PPI_CTRL.PORT with the usual 0x99.
 */
ChipSet.PPI_A = {               // this.bPPIA (port 0x60)
    PORT:               0x60    // INPUT: keyboard scan code (PPI_B.CLEAR_KBD must be clear)
};

ChipSet.PPI_B = {               // this.bPPIB (port 0x61)
    PORT:               0x61,   // OUTPUT (although it has to be treated as INPUT, too; the keyboard interrupt handler reads it, OR's PPI_B.CLEAR_KBD, writes it, and then rewrites the original read value)
    CLK_TIMER2:         0x01,   // ALL: set to enable clock to TIMER2
    SPK_TIMER2:         0x02,   // ALL: set to connect output of TIMER2 to speaker (MODEL_5150: clear for cassette)
    ENABLE_SW2:         0x04,   // MODEL_5150: set to enable SW2[1-4] through PPI_C.PORT, clear to enable SW2[5]; MODEL_5160: unused (there is no SW2 switch block on the MODEL_5160 motherboard)
    CASS_MOTOR_OFF:     0x08,   // MODEL_5150: cassette motor off
    ENABLE_SW_HI:       0x08,   // MODEL_5160: clear to read SW1[1-4], set to read SW1[5-8]
    DISABLE_RW_MEM:     0x10,   // ALL: clear to enable RAM parity check, set to disable
    DISABLE_IO_CHK:     0x20,   // ALL: clear to enable I/O channel check, set to disable
    CLK_KBD:            0x40,   // ALL: clear to force keyboard clock low
    CLEAR_KBD:          0x80    // ALL: clear to enable keyboard scan codes (MODEL_5150: set to enable SW1 through PPI_A.PORT)
};

ChipSet.PPI_C = {               // this.bPPIC (port 0x62)
    PORT:               0x62,   // INPUT (see below)
    KBD_LATCH:          0x01,   // MODEL_4860 only (set if keyboard data latched)
    NO_MODEM:           0x02,   // MODEL_4860 only (set if no Internal Model Card installed)
    NO_DISKETTE:        0x04,   // MODEL_4860 only (set if no Diskette Drive Adapter installed)
    NO_MEMEXP:          0x08,   // MODEL_4860 only (set if no 64Kb Memory Expansion installed)
    SW:                 0x0F,   // MODEL_5150: SW2[1-4] or SW2[5], depending on whether PPI_B.ENABLE_SW2 is set or clear; MODEL_5160: SW1[1-4] or SW1[5-8], depending on whether PPI_B.ENABLE_SW_HI is clear or set
    CASS_DATA_IN:       0x10,   // MODEL_4860 and MODEL_5150
    TIMER2_OUT:         0x20,   // MODEL_4860 and up (timer 2 output)
    KBD_DATA:           0x40,   // MODEL_4860 only: data from either the keyboard cable or the IR receiver
    NO_KBD_CABLE:       0x80,   // MODEL_4860 only: (set if keyboard cable not connected)
    IO_CHANNEL_CHK:     0x40,   // used by NMI handler to detect I/O channel errors
    RW_PARITY_CHK:      0x80    // used by NMI handler to detect R/W memory parity errors
};

ChipSet.PPI_CTRL = {            // this.bPPICtrl (port 0x63)
    PORT:               0x63,   // OUTPUT: initialized to 0x99, defining PPI_A and PPI_C as INPUT and PPI_B as OUTPUT
    A_IN:               0x10,
    B_IN:               0x02,
    C_IN_LO:            0x01,
    C_IN_HI:            0x08,
    B_MODE:             0x04,
    A_MODE:             0x60
};

/*
 * Switches Overview
 * -----------------
 *
 * The conventions used for the sw1 and sw2 strings are that the left-most character represents DIP switch [1],
 * the right-most character represents DIP switch [8], and "1" means the DIP switch is ON and "0" means it is OFF.
 *
 * Internally, we convert the above strings into binary values that the 8255A PPI returns, where DIP switch [1]
 * is bit 0 and DIP switch [8] is bit 7, and 0 indicates the switch is ON and 1 indicates it is OFF.
 *
 * For reference, here's how the SW1 and SW2 switches correspond to the internal 8255A PPI bit values:
 *
 *      SW1[1]    (bit 0)     "0xxxxxxx" (1):  IPL,  "1xxxxxxx" (0):  No IPL
 *      SW1[2]    (bit 1)     reserved on the 5150; OFF (1) if FPU installed in a 5160
 *      SW1[3,4]  (bits 3-2)  "xx11xxxx" (00): 16Kb, "xx01xxxx" (10): 32Kb,  "xx10xxxx" (01): 48Kb,  "xx00xxxx" (11): 64Kb
 *      SW1[5,6]  (bits 5-4)  "xxxx11xx" (00): none, "xxxx01xx" (10): tv,    "xxxx10xx" (01): color, "xxxx00xx" (11): mono
 *      SW1[7,8]  (bits 7-6)  "xxxxxx11" (00): 1 FD, "xxxxxx01" (10): 2 FD,  "xxxxxx10" (01): 3 FD,  "xxxxxx00" (11): 4 FD
 *
 * Note: FD refers to floppy drive, and IPL refers to an "Initial Program Load" floppy drive.
 *
 *      SW2[1-5]    (bits 4-0)  "NNNxxxxx": number of 32Kb blocks of I/O expansion RAM present
 *
 * For example, sw1="01110011" indicates that all SW1 DIP switches are ON, except for SW1[1], SW1[5] and SW1[6],
 * which are OFF.  Internally, the order of these bits must reversed (to 11001110) and then inverted (to 00110001)
 * to yield the value that the 8255A PPI returns.  Reading the final value right-to-left, 00110001 indicates an
 * IPL floppy drive, 1X of RAM (where X is 16Kb on a MODEL_5150 and 64Kb on a MODEL_5160), MDA, and 1 floppy drive.
 *
 * WARNING: It is possible to set SW1 to indicate more memory than the RAM component has been configured to provide.
 * This is a configuration error which will cause the machine to crash after reporting a "201" error code (memory
 * test failure), which is presumably what a real machine would do if it was similarly misconfigured.  Surprisingly,
 * the BIOS forges ahead, setting SP to the top of the memory range indicated by SW1 (via INT 0x12), but the lack of
 * a valid stack causes the system to crash after the next IRET.  The BIOS should have either halted or modified
 * the actual memory size to match the results of the memory test.
 *
 * MODEL 5150 Switches
 * -------------------
 *
 * PPI_SW bits are exposed via port PPI_A.
 *
 * MODEL 5160 Switches
 * ------------------------
 *
 * PPI_SW bits 0-3 are exposed via PPI_C.SW if PPI_B.ENABLE_SW_HI is clear; bits 4-7 if PPI_B.ENABLE_SW_HI is set.
 *
 * AT&T 6300 Switches
 * ------------------
 *
 * Based on ATT_PC_6300_Service_Manual.pdf, there are two 8-switch blocks, DIPSW-0 and DIPSW-1, where:
 *
 *      DIPSW-0[1-4] Total RAM
 *      DIPSW-0[5] - ON if 8087 not installed, OFF if installed
 *      DIPSW-0[6] - ON if 8250 ACE serial interface present, OFF if Z-8530 SCC interface present
 *      DIPSW-0[7] - Not used
 *      DIPSW-0[8] - Type of EPROM chip for ROM 1.21 or lower, or presence of RAM in bank 1 for ROM 1.43 or higher
 *
 * and:
 *
 *      DIPSW-1[1] - Floppy Type (ON for 48TPI, OFF for 96TPI)
 *      DIPSW-1[2] - Floppy Speed (ON for slow startup, OFF for fast startup)
 *      DIPSW-1[3] - HDU ROM (ON for indigenous, OFF for external)
 *      DIPSW-1[4] - Not used (ROM 1.21 or lower) or Scroll Speed (ROM 1.43 or higher: ON for fast, OFF for slow)
 *      DIPSW-1[5-6] - Display Type (11=EGA or none, 01=color 40x25, 10=color 80x25, 00=monochrome 80x25)
 *      DIPSW-1[7-8] - Number of Floppy Drives (11=one, 01=two, 10=three, 00=four)
 *
 * For AT&T 6300 ROM 1.43 and up, DIPSW-0 supports the following RAM combinations:
 *
 *      0111xxx1: 128Kb on motherboard
 *      1011xxx0: 256Kb on motherboard
 *      1101xxx0: 256Kb on motherboard, 256Kb on expansion board (512Kb total)
 *      1110xxx1: 512Kb on motherboard
 *      0101xxx0: 256Kb on motherboard, 384Kb on expansion board (640Kb total)
 *      0100xxx0: 640Kb on motherboard (128Kb bank 0, 512Kb bank 1)
 *      0110xxx0: 640Kb on motherboard (512Kb bank 0, 128Kb bank 1)
 *
 * Inspection of the AT&T 6300 Plus ROM BIOS reveals that DIPSW-0[1-8] are obtained from bits 0-7
 * of port 0x66 ("sys_conf_a") and DIPSW-1[1-8] are obtained from bits 0-7 of port 0x67 ("sys_conf_b").
 */

ChipSet.PPI_SW = {
    FDRIVE: {
        IPL:            0x01,   // MODEL_5150: IPL ("Initial Program Load") floppy drive attached; MODEL_5160: "Loop on POST"
        ONE:            0x00,   // 1 floppy drive attached (or 0 drives if PPI_SW.FDRIVE_IPL is not set -- MODEL_5150 only)
        TWO:            0x40,   // 2 floppy drives attached
        THREE:          0x80,   // 3 floppy drives attached
        FOUR:           0xC0,   // 4 floppy drives attached
        MASK:           0xC0,
        SHIFT:          6
    },
    FPU:                0x02,   // MODEL_5150: reserved; MODEL_5160: FPU coprocessor installed
    MEMORY: {                   // MODEL_5150: "X" is 16Kb; MODEL_5160: "X" is 64Kb
        X1:             0x00,   // 16Kb or 64Kb
        X2:             0x04,   // 32Kb or 128Kb
        X3:             0x08,   // 48Kb or 192Kb
        X4:             0x0C,   // 64Kb or 256Kb
        MASK:           0x0C,
        SHIFT:          2
    },
    MONITOR: {
        TV:             0x10,
        COLOR:          0x20,
        MONO:           0x30,
        MASK:           0x30,
        SHIFT:          4
    }
};

/*
 * Some models have completely different DIP switch implementations from the MODEL_5150, which, being
 * the first IBM PC, was the model that we, um, modeled our DIP switch support on.  So, to support other
 * implementations, we now get and set DIP switch values according to SWITCH_TYPE, and rely on the
 * tables that follow to define which DIP switch(es) correspond to each SWITCH_TYPE.
 *
 * Not every model needs its own tables.  The getDIPSwitches() and setDIPSwitches() functions look first
 * for an *exact* model match, then a "truncated" model match, and failing that, they fall back to the
 * MODEL_5150 switch definitions.
 */
ChipSet.SWITCH_TYPE = {
    FLOPNUM:    1,
    FLOPTYPE:   2,
    FPU:        3,
    MONITOR:    4,
    LOWMEM:     5,
    EXPMEM:     6
};

ChipSet.DIPSW = {};
ChipSet.DIPSW[ChipSet.MODEL_5150] = [{},{}];
ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.FLOPNUM] = {
    MASK:       0xC0,
    VALUES: {
        1:      0x00,
        2:      0x40,
        3:      0x80,
        4:      0xC0
    },
    LABEL: "Number of Floppy Drives"
};
/*
 * NOTE: Both the Aug 1981 and the Apr 1984 IBM 5150 Technical Reference Manuals list SW1[2] as "RESERVED",
 * but the Aug 1981 edition (p. 2-28) also says SW1[2] "MUST BE ON (RESERVED FOR CO-PROCESSOR)".  Contemporary
 * articles discussing 8087 support in early PCs all indicate that switch SW1[2] must OFF if a coprocessor
 * is installed, and the 1984 5150 Guide to Operations (p. 5-34) confirms it.
 *
 * The Aug 1981 5150 TechRef makes no further mention of coprocessor support, whereas the Apr 1984 5150 TechRef
 * discusses it in a fair bit of detail, including the fact that 8087 exceptions generate an NMI, despite Intel's
 * warning in their iAPX 86,88 User's Manual, p. S-27, that "[t]he 8087 should not be tied to the CPU's NMI
 * (non-maskable interrupt) line.")
 */
ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.FPU] = {
    MASK:       0x02,
    VALUES: {
        0:      0x00,   // 0 means an FPU is NOT installed
        1:      0x02    // 1 means an FPU is installed
    },
    LABEL: "FPU"
};
ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.MONITOR] = {
    MASK:       0x30,
    VALUES: {
        0:      0x00,
        1:      0x10,
        2:      0x20,
        3:      0x30,
        "none": 0x00,
        "tv":   0x10,   // aka composite
        "color":0x20,
        "cga":  0x20,   // alias for color
        "mda":  0x30,   // alias for mono
        "mono": 0x30,
        "ega":  0x00,
        "vga":  0x00
    },
    LABEL: "Monitor Type"
};
ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.LOWMEM] = {
    MASK:       0x0C,
    VALUES: {
        16:     0x00,
        32:     0x04,
        48:     0x08,
        64:     0x0C
    },
    LABEL: "Base Memory (16Kb Increments)"
};
ChipSet.DIPSW[ChipSet.MODEL_5150][1][ChipSet.SWITCH_TYPE.EXPMEM] = {
    MASK:       0x1F,   // technically, this mask should be 0x0F for ROM revisions prior to 5150_REV3, and 0x1F on 5150_REV3
    VALUES: {
        0:      0x00,
        32:     0x01,
        64:     0x02,
        96:     0x03,
        128:    0x04,
        160:    0x05,
        192:    0x06,
        224:    0x07,
        256:    0x08,
        288:    0x09,
        320:    0x0A,
        352:    0x0B,
        384:    0x0C,
        416:    0x0D,
        448:    0x0E,
        480:    0x0F,
        512:    0x10,
        544:    0x11,
        576:    0x12
        /*
         * Obviously, more bit combinations are possible here (up to 0x1F), but assuming a minimum of 64Kb already on
         * the motherboard, any amount of expansion memory above 576Kb would break the 640Kb barrier.  Yes, if you used
         * only MDA or CGA video cards, you could go as high as 704Kb in a real system.  But in our happy little world,
         * this is where we stop.
         *
         * TODO: A value larger than 0x12 usually comes from a misconfigured machine (ie, it forgot to leave SW2[5] ON).
         * To compensate, when getDIPMemorySize() gets null back from its EXPMEM request, perhaps it should try truncating
         * the DIP switch value.  However, that would introduce a machine-specific hack into a function that's supposed
         * be machine-independent now.
         */
    },
    LABEL: "Expansion Memory (32Kb Increments)"
};

ChipSet.DIPSW[ChipSet.MODEL_5160] = [{},{}];
ChipSet.DIPSW[ChipSet.MODEL_5160][0][ChipSet.SWITCH_TYPE.FLOPNUM] = ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.FLOPNUM];
ChipSet.DIPSW[ChipSet.MODEL_5160][0][ChipSet.SWITCH_TYPE.FPU]     = ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.FPU];
ChipSet.DIPSW[ChipSet.MODEL_5160][0][ChipSet.SWITCH_TYPE.MONITOR] = ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.MONITOR];
ChipSet.DIPSW[ChipSet.MODEL_5160][0][ChipSet.SWITCH_TYPE.LOWMEM]  = {
    MASK:       0x0C,
    VALUES: {
        64:     0x00,
        128:    0x04,
        192:    0x08,
        256:    0x0C
    },
    LABEL: "Base Memory (64Kb Increments)"
};
ChipSet.DIPSW[ChipSet.MODEL_5160][1][ChipSet.SWITCH_TYPE.EXPMEM]  = ChipSet.DIPSW[ChipSet.MODEL_5150][1][ChipSet.SWITCH_TYPE.EXPMEM];

ChipSet.DIPSW[ChipSet.MODEL_ATT_6300] = [{},{}];
ChipSet.DIPSW[ChipSet.MODEL_ATT_6300][0][ChipSet.SWITCH_TYPE.LOWMEM] = {
    MASK:       0x8F,
    VALUES: {
        128:    0x01,   // "0111xxx1"
        256:    0x82,   // "1011xxx0"
        512:    0x08,   // "1110xxx1"
        640:    0x8D    // "0100xxx0"
    },
    LABEL: "Base Memory (128Kb Increments)"
};
ChipSet.DIPSW[ChipSet.MODEL_ATT_6300][0][ChipSet.SWITCH_TYPE.FPU] = {
    MASK:       0x10,
    VALUES: {
        0:      0x00,
        1:      0x10
    },
    LABEL: "FPU"
};
ChipSet.DIPSW[ChipSet.MODEL_ATT_6300][1][ChipSet.SWITCH_TYPE.FLOPTYPE] = {
    MASK:       0x01,
    VALUES: {
        0:      0x00,
        1:      0x01
    },
    LABEL: "Floppy Type"
};
ChipSet.DIPSW[ChipSet.MODEL_ATT_6300][1][ChipSet.SWITCH_TYPE.FLOPNUM] = ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.FLOPNUM];
ChipSet.DIPSW[ChipSet.MODEL_ATT_6300][1][ChipSet.SWITCH_TYPE.MONITOR] = ChipSet.DIPSW[ChipSet.MODEL_5150][0][ChipSet.SWITCH_TYPE.MONITOR];

/*
 * 8041 Keyboard Controller I/O ports (MODEL_ATT_6300)
 *
 * The AT&T 6300 uses an 8041 for its Keyboard Controller, which has the following ports:
 *
 *      Port    Description
 *      ----    -----------
 *      0x60    Keyboard Scan Code (input)
 *      0x61    Keyboard Control Port (output)
 *      0x64    Keyboard Status Port (input)
 *
 * And the Keyboard Control Port (0x61) has the following bit definitions:
 *
 *      0x01    Speaker gate to 8253 (counter 2)
 *      0x02    Speaker data
 *      0x0C    Not used
 *      0x10    RAM Parity (NMI) Enable
 *      0x20    I/O Channel (NMI) Enable
 *      0x40    Keyboard Clock Reset
 *      0x80    Reset Interrupt Pending
 */

/*
 * 8042 Keyboard Controller I/O ports (MODEL_5170)
 *
 * On the MODEL_5170, port 0x60 is designated C8042.DATA rather than PPI_A, although the BIOS also refers to it
 * as "PORT_A: 8042 KEYBOARD SCAN/DIAG OUTPUTS").  This is the 8042's output buffer and should be read only when
 * C8042.STATUS.OUTBUFF_FULL is set.
 *
 * Similarly, port 0x61 is designated C8042.RWREG rather than PPI_B; the BIOS also refers to it as "PORT_B: 8042
 * READ WRITE REGISTER", but it is not otherwise discussed in the MODEL_5170 TechRef's 8042 documentation.
 *
 * There are brief references to bits 0 and 1 (C8042.RWREG.CLK_TIMER2 and C8042.RWREG.SPK_TIMER2), and the BIOS sets
 * bits 2-7 to "DISABLE PARITY CHECKERS" (principally C8042.RWREG.DISABLE_NMI, which are bits 2 and 3); why the BIOS
 * also sets bits 4-7 (or if those bits are even settable) is unclear, since it uses 11111100b rather than defined
 * constants.
 *
 * The bottom line: on a MODEL_5170, port 0x61 is still used for speaker control and parity checking, so we use
 * the same register (bPPIB) but install different I/O handlers.  It's also bi-directional: at one point, the BIOS
 * reads C8042.RWREG.REFRESH_BIT (bit 4) to verify that it's alternating.
 *
 * PPI_C and PPI_CTRL don't seem to be documented or used by the MODEL_5170 BIOS, so I'm assuming they're obsolete.
 *
 * NOTE: For more information on the 8042 Controller, including information on undocumented commands, refer to the
 * documents in /devices/pc/keyboard, as well as the following websites:
 *
 *      http://halicery.com/8042/8042_INTERN_TXT.htm
 *      http://www.os2museum.com/wp/ibm-pcat-8042-keyboard-controller-commands/
 */
ChipSet.C8042 = {
    DATA: {                     // this.b8042OutBuff (PPI_A on previous models, still referred to as "PORT A" by the MODEL_5170 BIOS)
        PORT:           0x60,
        CMD: {                  // this.b8042CmdData (C8042.DATA.CMD "data bytes" written to port 0x60, after writing a C8042.CMD byte to port 0x64)
            INT_ENABLE: 0x01,   // generate an interrupt when the controller places data in the output buffer
            SYS_FLAG:   0x04,   // this value is propagated to ChipSet.C8042.STATUS.SYS_FLAG
            NO_INHIBIT: 0x08,   // disable inhibit function
            NO_CLOCK:   0x10,   // disable keyboard by driving "clock" line low
            PC_MODE:    0x20,
            PC_COMPAT:  0x40    // generate IBM PC-compatible scan codes
        },
        SELF_TEST: {            // result of ChipSet.C8042.CMD.SELF_TEST command (0xAA)
            OK:         0x55
        },
        INTF_TEST: {            // result of ChipSet.C8042.CMD.INTF_TEST command (0xAB)
            OK:         0x00,   // no error
            CLOCK_LO:   0x01,   // keyboard clock line stuck low
            CLOCK_HI:   0x02,   // keyboard clock line stuck high
            DATA_LO:    0x03,   // keyboard data line stuck low
            DATA_HI:    0x04    // keyboard data line stuck high
        }
    },
    INPORT: {                   // this.b8042InPort
        COMPAQ_50MHZ:   0x01,   // 50Mhz system clock enabled (0=48Mhz); see COMPAQ 386/25 TechRef p2-106
        UNDEFINED:      0x02,   // undefined
        COMPAQ_NO80387: 0x04,   // 80387 coprocessor NOT installed; see COMPAQ 386/25 TechRef p2-106
        COMPAQ_NOWEITEK:0x08,   // Weitek coprocessor NOT installed; see COMPAQ 386/25 TechRef p2-106
        ENABLE_256KB:   0x10,   // enable 2nd 256Kb of system board RAM
        COMPAQ_HISPEED: 0x10,   // high-speed enabled (0=AUTO, 1=HIGH); see COMPAQ 386/25 TechRef p2-106
        MFG_OFF:        0x20,   // manufacturing jumper not installed
        COMPAQ_DIP5OFF: 0x20,   // system board DIP switch #5 OFF (0=ON); see COMPAQ 386/25 TechRef p2-106
        MONO:           0x40,   // monochrome monitor is primary display
        COMPAQ_NONDUAL: 0x40,   // COMPAQ Dual-Mode monitor NOT installed; see COMPAQ 386/25 TechRef p2-106
        KBD_UNLOCKED:   0x80    // keyboard not inhibited (in COMPAQ parlance: security lock is unlocked)
    },
    OUTPORT: {                  // this.b8042OutPort
        NO_RESET:       0x01,   // set by default
        A20_ON:         0x02,   // set by default
        COMPAQ_SLOWD:   0x08,   // SL0WD* NOT asserted (refer to timer 2, counter 2); see COMPAQ 386/25 TechRef p2-105
        OUTBUFF_FULL:   0x10,   // output buffer full
        INBUFF_EMPTY:   0x20,   // input buffer empty
        KBD_CLOCK:      0x40,   // keyboard clock (output)
        KBD_DATA:       0x80    // keyboard data (output)
    },
    TESTPORT: {                 // generated "on the fly"
        KBD_CLOCK:      0x01,   // keyboard clock (input)
        KBD_DATA:       0x02    // keyboard data (input)
    },
    RWREG: {                    // this.bPPIB (since CLK_TIMER2 and SPK_TIMER2 are in both PPI_B and RWREG)
        PORT:           0x61,
        CLK_TIMER2:     0x01,   // set to enable clock to TIMER2 (R/W)
        SPK_TIMER2:     0x02,   // set to connect output of TIMER2 to speaker (R/W)
        COMPAQ_FSNMI:   0x04,   // set to disable RAM/FS NMI (R/W, DESKPRO386)
        COMPAQ_IONMI:   0x08,   // set to disable IOCHK NMI (R/W, DESKPRO386)
        DISABLE_NMI:    0x0C,   // set to disable IOCHK and RAM/FS NMI, clear to enable (R/W)
        REFRESH_BIT:    0x10,   // 0 if RAM refresh occurring, 1 if RAM not in refresh cycle (R/O)
        OUT_TIMER2:     0x20,   // state of TIMER2 output signal (R/O, DESKPRO386)
        IOCHK_NMI:      0x40,   // IOCHK NMI (R/O); to reset, pulse bit 3 (0x08)
        RAMFS_NMI:      0x80,   // RAM/FS (parity or fail-safe) NMI (R/O); to reset, pulse bit 2 (0x04)
        NMI_ERROR:      0xC0
    },
    CMD: {                      // this.b8042InBuff (on write to port 0x64, interpret this as a CMD)
        PORT:           0x64,
        READ_CMD:       0x20,   // sends the current CMD byte (this.b8042CmdData) to C8042.DATA.PORT
        WRITE_CMD:      0x60,   // followed by a command byte written to C8042.DATA.PORT (see C8042.DATA.CMD)
        COMPAQ_SLOWD:   0xA3,   // enable system slow down; see COMPAQ 386/25 TechRef p2-111
        COMPAQ_TOGGLE:  0xA4,   // toggle speed-control bit; see COMPAQ 386/25 TechRef p2-111
        COMPAQ_SREAD2:  0xA5,   // special read of "port 2"; see COMPAQ 386/25 TechRef p2-111
        SELF_TEST:      0xAA,   // self-test (C8042.DATA.SELF_TEST.OK is placed in the output buffer if no errors)
        INTF_TEST:      0xAB,   // interface test
        DIAG_DUMP:      0xAC,   // diagnostic dump
        DISABLE_KBD:    0xAD,   // disable keyboard
        ENABLE_KBD:     0xAE,   // enable keyboard
        READ_INPORT:    0xC0,   // read input port and place data in output buffer (use only if output buffer empty)
        READ_OUTPORT:   0xD0,   // read output port and place data in output buffer (use only if output buffer empty)
        WRITE_OUTPORT:  0xD1,   // next byte written to C8042.DATA.PORT (port 0x60) is placed in the output port (see C8042.OUTPORT)
        READ_TEST:      0xE0,
        PULSE_OUTPORT:  0xF0    // this is the 1st of 16 commands (0xF0-0xFF) that pulse bits 0-3 of the output port
    },
    STATUS: {                   // this.b8042Status (on read from port 0x64)
        PORT:           0x64,
        OUTBUFF_FULL:   0x01,
        INBUFF_FULL:    0x02,   // set if the controller has received but not yet read data from the input buffer (not normally set)
        SYS_FLAG:       0x04,
        CMD_FLAG:       0x08,   // set on write to C8042.CMD (port 0x64), clear on write to C8042.DATA (port 0x60)
        NO_INHIBIT:     0x10,   // (in COMPAQ parlance: security lock not engaged)
        XMT_TIMEOUT:    0x20,
        RCV_TIMEOUT:    0x40,
        PARITY_ERR:     0x80,   // last byte of data received had EVEN parity (ODD parity is normally expected)
        OUTBUFF_DELAY:  0x100
    }
};

/*
 * MC146818A RTC/CMOS Ports (MODEL_5170)
 *
 * Write a CMOS address to ChipSet.CMOS.ADDR.PORT, then read/write data from/to ChipSet.CMOS.DATA.PORT.
 *
 * The ADDR port also controls NMI: write an address with bit 7 clear to enable NMI or set to disable NMI.
 */
ChipSet.CMOS = {
    ADDR: {                     // this.bCMOSAddr
        PORT:           0x70,
        RTC_SEC:        0x00,
        RTC_SEC_ALRM:   0x01,
        RTC_MIN:        0x02,
        RTC_MIN_ALRM:   0x03,
        RTC_HOUR:       0x04,
        RTC_HOUR_ALRM:  0x05,
        RTC_WEEK_DAY:   0x06,
        RTC_MONTH_DAY:  0x07,
        RTC_MONTH:      0x08,
        RTC_YEAR:       0x09,   // 2-digit year (eg, 0x82 for 1982 if BCD mode)
        STATUSA:        0x0A,
        STATUSB:        0x0B,
        STATUSC:        0x0C,
        STATUSD:        0x0D,
        DIAG:           0x0E,
        SHUTDOWN:       0x0F,
        FDRIVE:         0x10,
        HDRIVE:         0x12,   // bits 4-7 contain type of drive 0, bits 0-3 contain type of drive 1 (type 0 means none)
        EQUIP:          0x14,
        BASEMEM_LO:     0x15,
        BASEMEM_HI:     0x16,   // the BASEMEM values indicate the total Kb of base memory, up to 0x280 (640Kb)
        EXTMEM_LO:      0x17,
        EXTMEM_HI:      0x18,   // the EXTMEM values indicate the total Kb of extended memory, up to 0x3C00 (15Mb)
        EXTHDRIVE0:     0x19,   // if bits 4-7 of HDRIVE contains 15, then the type of drive 0 is stored here (16-255)
        EXTHDRIVE1:     0x1A,   // if bits 0-3 of HDRIVE contains 15, then the type of drive 1 is stored here (16-255)
        CHKSUM_HI:      0x2E,
        CHKSUM_LO:      0x2F,   // CMOS bytes included in the checksum calculation: 0x10-0x2D
        EXTMEM2_LO:     0x30,
        EXTMEM2_HI:     0x31,
        CENTURY_DATE:   0x32,   // 2-digit century value in BCD (eg, 0x19 for 20th century, 0x20 for 21st century)
        BOOT_INFO:      0x33,   // 0x80 if 128Kb expansion memory installed, 0x40 if Setup Utility wants an initial setup message
        MASK:           0x3F,
        TOTAL:          0x40,
        NMI_DISABLE:    0x80
    },
    DATA: {                     // this.abCMOSData
        PORT:           0x71
    },
    STATUSA: {                  // abCMOSData[ChipSet.CMOS.ADDR.STATUSA]
        UIP:            0x80,   // bit 7: 1 indicates Update-In-Progress, 0 indicates date/time ready to read
        DV:             0x70,   // bits 6-4 (DV2-DV0) are programmed to 010 to select a 32.768Khz time base
        RS:             0x0F    // bits 3-0 (RS3-RS0) are programmed to 0110 to select a 976.562us interrupt rate
    },
    STATUSB: {                  // abCMOSData[ChipSet.CMOS.ADDR.STATUSB]
        SET:            0x80,   // bit 7: 1 to set any/all of the 14 time-bytes
        PIE:            0x40,   // bit 6: 1 for Periodic Interrupt Enable
        AIE:            0x20,   // bit 5: 1 for Alarm Interrupt Enable
        UIE:            0x10,   // bit 4: 1 for Update Interrupt Enable
        SQWE:           0x08,   // bit 3: 1 for Square Wave Enabled (as set by the STATUSA rate selection bits)
        BINARY:         0x04,   // bit 2: 1 for binary Date Mode, 0 for BCD Date Mode
        HOUR24:         0x02,   // bit 1: 1 for 24-hour mode, 0 for 12-hour mode
        DST:            0x01    // bit 0: 1 for Daylight Savings Time enabled
    },
    STATUSC: {                  // abCMOSData[ChipSet.CMOS.ADDR.STATUSC]
        IRQF:           0x80,   // bit 7: 1 indicates one or more of the following bits (PF, AF, UF) are set
        PF:             0x40,   // bit 6: 1 indicates Periodic Interrupt
        AF:             0x20,   // bit 5: 1 indicates Alarm Interrupt
        UF:             0x10,   // bit 4: 1 indicates Update Interrupt
        RESERVED:       0x0F
    },
    STATUSD: {                  // abCMOSData[ChipSet.CMOS.ADDR.STATUSD]
        VRB:            0x80,   // bit 7: 1 indicates Valid RAM Bit (0 implies power was and/or is lost)
        RESERVED:       0x7F
    },
    DIAG: {                     // abCMOSData[ChipSet.CMOS.ADDR.DIAG]
        RTCFAIL:        0x80,   // bit 7: 1 indicates RTC lost power
        CHKSUMFAIL:     0x40,   // bit 6: 1 indicates bad CMOS checksum
        CONFIGFAIL:     0x20,   // bit 5: 1 indicates bad CMOS configuration info
        MEMSIZEFAIL:    0x10,   // bit 4: 1 indicates memory size miscompare
        HDRIVEFAIL:     0x08,   // bit 3: 1 indicates hard drive controller or drive init failure
        TIMEFAIL:       0x04,   // bit 2: 1 indicates time failure
        RESERVED:       0x03
    },
    FDRIVE: {                   // abCMOSData[ChipSet.CMOS.ADDR.FDRIVE]
        D0_MASK:        0xF0,   // Drive 0 type in high nibble
        D1_MASK:        0x0F,   // Drive 1 type in lower nibble
        NONE:           0,      // no drive
        /*
         * There's at least one floppy drive type that IBM didn't bother defining a CMOS drive type for:
         * single-sided drives that were only capable of storing 160Kb (or 180Kb when using 9 sectors/track).
         * So, as you can see in getDIPFloppyDriveType(), we lump all standard diskette capacities <= 360Kb
         * into the FD360 bucket.
         */
        FD360:          1,      // 5.25-inch double-sided double-density (DSDD 48TPI) drive: 40 tracks, 9 sectors/track, 360Kb max
        FD1200:         2,      // 5.25-inch double-sided high-density (DSHD 96TPI) drive: 80 tracks, 15 sectors/track, 1200Kb max
        FD720:          3,      // 3.5-inch drive capable of storing 80 tracks and up to 9 sectors/track, 720Kb max
        FD1440:         4       // 3.5-inch drive capable of storing 80 tracks and up to 18 sectors/track, 1440Kb max
    },
    /*
     * HDRIVE types are defined by table in the HDC component, which uses setCMOSDriveType() to update the CMOS
     */
    HDRIVE: {                   // abCMOSData[ChipSet.CMOS.ADDR.HDRIVE]
        D0_MASK:        0xF0,   // Drive 0 type in high nibble
        D1_MASK:        0x0F    // Drive 1 type in lower nibble
    },
    /*
     * The CMOS equipment flags use the same format as the older PPI equipment flags
     */
    EQUIP: {                    // abCMOSData[ChipSet.CMOS.ADDR.EQUIP]
        MONITOR:        ChipSet.PPI_SW.MONITOR,         // PPI_SW.MONITOR.MASK == 0x30
        FPU:            ChipSet.PPI_SW.FPU,             // PPI_SW.FPU == 0x02
        FDRIVE:         ChipSet.PPI_SW.FDRIVE           // PPI_SW.FDRIVE.IPL == 0x01 and PPI_SW.FDRIVE.MASK = 0xC0
    }
};

/*
 * DMA Page Registers
 *
 * The MODEL_5170 TechRef lists 0x80-0x9F as the range for DMA page registers, but that may be a bit
 * overbroad.  There are a total of 8 (7 usable) DMA channels on the MODEL_5170, each of which has the
 * following assigned DMA page registers:
 *
 *      Channel #   Page Reg
 *      ---------   --------
 *          0         0x87
 *          1         0x83
 *          2         0x81
 *          3         0x82
 *          4         0x8F (not usable; the 5170 TechRef refers to this as the "Refresh" page register)
 *          5         0x8B
 *          6         0x89
 *          7         0x8A
 *
 * That leaves 0x80, 0x84, 0x85, 0x86, 0x88, 0x8C, 0x8D and 0x8E unaccounted for in the range 0x80-0x8F.
 * (I'm saving the question of what, if anything, is available in the range 0x90-0x9F for another day.)
 *
 * As for port 0x80, the TechRef says:
 *
 *      "I/O address hex 080 is used as a diagnostic-checkpoint port or register.
 *      This port corresponds to a read/write register in the DMA page register (74LS612)."
 *
 * so I used to have dedicated handlers and storage (bMFGData) for the register at port 0x80, but I've since
 * appended it to abDMAPageSpare, an 8-element array that captures all I/O to the 8 unassigned (aka "spare")
 * DMA page registers.  The 5170 BIOS uses 0x80 as a "checkpoint" register, and the DESKPRO386 uses 0x84 in a
 * similar fashion.  The 5170 also contains "MFG_TST" code that uses other unassigned DMA page registers as
 * scratch registers, which come in handy when RAM hasn't been tested/initialized yet.
 *
 * Here's our mapping of entries in the abDMAPageSpare array to the unassigned ("spare") DMA page registers:
 *
 *      Index #     Page Reg
 *      --------    --------
 *          0         0x84
 *          1         0x85
 *          2         0x86
 *          3         0x88
 *          4         0x8C
 *          5         0x8D
 *          6         0x8E
 *          7         0x80
 *
 * The only reason port 0x80 is out of sequence (ie, at the end of the array, at index 7 instead of index 0) is
 * because it was added the array later, and the entire array gets written to our save/restore data structures, so
 * reordering the elements would be a bad idea.
 */

/*
 * NMI Mask Register (port 0xA0)
 *
 * On the MODEL_5150 and MODEL_5160, this is a write-only register, and the only valid bit is ENABLE.
 *
 * On the MODEL_4860, this is a read-write register; the following bit definitions apply to writes, whereas
 * reads are defined as merely clearing the PCjr's keyboard NMI latch (which we maintain here in bit 0).
 */
ChipSet.NMI = {                 // this.bNMI
    PORT:               0xA0,   //
    ENABLE:             0x80,   // enables NMI
    IRTEST:             0x40,   // enables 8253 timer 2 output into an IR diode on the IR receiver board
    SELCLK1:            0x20,   // selects timer 0 output to be used as CLK input to timer 1
    DISHRQ:             0x10,   // not implemented on the system board; for use with external bus-master devices
    KBD_LATCH:          0x01,   // keyboard latch (we maintain it here for convenience; it gets propagated to PPI_C bit 0)
    RESET:              0x00    // default value on reset (TODO: Is NMI really disabled by default on reset?)
};

/*
 * FPU Coprocessor Control Registers (MODEL_5170)
 */
ChipSet.FPU = {                 // TODO: Define a variable for this?
    PORT_CLEAR:         0xF0,   // clear the FPU's "busy" state
    PORT_RESET:         0xF1    // reset the FPU
};

ChipSet.aDMAControllerInit = [0, null, null, 0, new Array(4), 0];

ChipSet.aDMAChannelInit = [true, [0,0], [0,0], [0,0], [0,0]];

ChipSet.aPICInit = [0, new Array(4)];

ChipSet.aTimerInit = [[0,0], [0,0], [0,0], [0,0]];

/*
 * Port input notification tables, starting with the one that's common to all models (aPortInput)
 */
ChipSet.aPortInput = {
    0x20: /** @this {ChipSet} */ function(port, addrFrom) { return this.inPICLo(ChipSet.PIC0.INDEX, addrFrom); },
    0x21: /** @this {ChipSet} */ function(port, addrFrom) { return this.inPICHi(ChipSet.PIC0.INDEX, addrFrom); },
    0x40: /** @this {ChipSet} */ function(port, addrFrom) { return this.inTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER0, port, addrFrom); },
    0x41: /** @this {ChipSet} */ function(port, addrFrom) { return this.inTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER1, port, addrFrom); },
    0x42: /** @this {ChipSet} */ function(port, addrFrom) { return this.inTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER2, port, addrFrom); },
    0x43: /** @this {ChipSet} */ function(port, addrFrom) { return this.inTimerCtrl(ChipSet.PIT0.INDEX, port, addrFrom); },
};

ChipSet.aPortInput4860 = {
    0x60: ChipSet.prototype.inPPIA,
    0x61: ChipSet.prototype.inPPIB,
    0x62: ChipSet.prototype.inPPIC,
    0x63: ChipSet.prototype.inPPICtrl,  // technically, not actually readable, but I want the Debugger to be able to read it
    0xA0: ChipSet.prototype.inNMI
};

ChipSet.aPortInput5150 = {
    0x60: ChipSet.prototype.inPPIA,
    0x61: ChipSet.prototype.inPPIB,
    0x62: ChipSet.prototype.inPPIC,
    0x63: ChipSet.prototype.inPPICtrl,  // technically, not actually readable, but I want the Debugger to be able to read it
};

ChipSet.aPortInput5xxx = {
    0x00: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA0.INDEX, 0, port, addrFrom); },
    0x01: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA0.INDEX, 0, port, addrFrom); },
    0x02: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA0.INDEX, 1, port, addrFrom); },
    0x03: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA0.INDEX, 1, port, addrFrom); },
    0x04: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA0.INDEX, 2, port, addrFrom); },
    0x05: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA0.INDEX, 2, port, addrFrom); },
    0x06: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA0.INDEX, 3, port, addrFrom); },
    0x07: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA0.INDEX, 3, port, addrFrom); },
    0x08: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAStatus(ChipSet.DMA0.INDEX, port, addrFrom); },
    0x0D: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMATemp(ChipSet.DMA0.INDEX, port, addrFrom); },
    0x81: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA0.INDEX, 2, port, addrFrom); },
    0x82: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA0.INDEX, 3, port, addrFrom); },
    0x83: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA0.INDEX, 1, port, addrFrom); },
    0x87: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA0.INDEX, 0, port, addrFrom); }
};

ChipSet.aPortInput5170 = {
    0x60: ChipSet.prototype.in8042OutBuff,
    0x61: ChipSet.prototype.in8042RWReg,
    0x64: ChipSet.prototype.in8042Status,
    0x70: ChipSet.prototype.inCMOSAddr,
    0x71: ChipSet.prototype.inCMOSData,
    0x80: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageSpare(7, port, addrFrom); },
    0x84: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageSpare(0, port, addrFrom); },
    0x85: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageSpare(1, port, addrFrom); },
    0x86: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageSpare(2, port, addrFrom); },
    0x88: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageSpare(3, port, addrFrom); },
    0x89: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA1.INDEX, 2, port, addrFrom); },
    0x8A: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA1.INDEX, 3, port, addrFrom); },
    0x8B: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA1.INDEX, 1, port, addrFrom); },
    0x8C: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageSpare(4, port, addrFrom); },
    0x8D: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageSpare(5, port, addrFrom); },
    0x8E: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageSpare(6, port, addrFrom); },
    0x8F: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA1.INDEX, 0, port, addrFrom); },
    0xA0: /** @this {ChipSet} */ function(port, addrFrom) { return this.inPICLo(ChipSet.PIC1.INDEX, addrFrom); },
    0xA1: /** @this {ChipSet} */ function(port, addrFrom) { return this.inPICHi(ChipSet.PIC1.INDEX, addrFrom); },
    0xC0: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA1.INDEX, 0, port, addrFrom); },
    0xC2: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA1.INDEX, 0, port, addrFrom); },
    0xC4: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA1.INDEX, 1, port, addrFrom); },
    0xC6: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA1.INDEX, 1, port, addrFrom); },
    0xC8: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA1.INDEX, 2, port, addrFrom); },
    0xCA: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA1.INDEX, 2, port, addrFrom); },
    0xCC: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA1.INDEX, 3, port, addrFrom); },
    0xCE: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA1.INDEX, 3, port, addrFrom); },
    0xD0: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMAStatus(ChipSet.DMA1.INDEX, port, addrFrom); },
    0xDA: /** @this {ChipSet} */ function(port, addrFrom) { return this.inDMATemp(ChipSet.DMA1.INDEX, port, addrFrom); }
};

ChipSet.aPortInput6300 = {
    0x60: ChipSet.prototype.in8041Kbd,
    0x61: ChipSet.prototype.in8041Ctrl,
    0x64: ChipSet.prototype.in8041Status,
    0x66: /** @this {ChipSet} */ function(port, addrFrom) { return this.in6300DIPSwitches(0, port, addrFrom); },
    0x67: /** @this {ChipSet} */ function(port, addrFrom) { return this.in6300DIPSwitches(1, port, addrFrom); }
};

if (DESKPRO386) {
    ChipSet.aPortInputDeskPro386 = {
        0x48: /** @this {ChipSet} */ function(port, addrFrom) { return this.inTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER3, port, addrFrom); },
        0x49: /** @this {ChipSet} */ function(port, addrFrom) { return this.inTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER4, port, addrFrom); },
        0x4A: /** @this {ChipSet} */ function(port, addrFrom) { return this.inTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER5, port, addrFrom); },
        0x4B: /** @this {ChipSet} */ function(port, addrFrom) { return this.inTimerCtrl(ChipSet.PIT1.INDEX, port, addrFrom); }
    };
}

/*
 * Port output notification tables, starting with the one that's common to all models (aPortOutput)
 */
ChipSet.aPortOutput = {
    0x20: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outPICLo(ChipSet.PIC0.INDEX, bOut, addrFrom); },
    0x21: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outPICHi(ChipSet.PIC0.INDEX, bOut, addrFrom); },
    0x40: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER0, port, bOut, addrFrom); },
    0x41: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER1, port, bOut, addrFrom); },
    0x42: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER2, port, bOut, addrFrom); },
    0x43: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outTimerCtrl(ChipSet.PIT0.INDEX, port, bOut, addrFrom); },
};

ChipSet.aPortOutput4860 = {
    0x10: ChipSet.prototype.outMFGTest,     // a manufacturing test port that we don't really care about
    0x60: ChipSet.prototype.outPPIA,
    0x61: ChipSet.prototype.outPPIB,
    0x62: ChipSet.prototype.outPPIC,
    0x63: ChipSet.prototype.outPPICtrl,
    0xA0: ChipSet.prototype.outNMI
};

ChipSet.aPortOutput5150 = {
    0x60: ChipSet.prototype.outPPIA,
    0x61: ChipSet.prototype.outPPIB,
    0x62: ChipSet.prototype.outPPIC,
    0x63: ChipSet.prototype.outPPICtrl,
    0xA0: ChipSet.prototype.outNMI
};

ChipSet.aPortOutput5xxx = {
    0x00: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA0.INDEX, 0, port, bOut, addrFrom); },
    0x01: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA0.INDEX, 0, port, bOut, addrFrom); },
    0x02: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA0.INDEX, 1, port, bOut, addrFrom); },
    0x03: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA0.INDEX, 1, port, bOut, addrFrom); },
    0x04: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA0.INDEX, 2, port, bOut, addrFrom); },
    0x05: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA0.INDEX, 2, port, bOut, addrFrom); },
    0x06: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA0.INDEX, 3, port, bOut, addrFrom); },
    0x07: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA0.INDEX, 3, port, bOut, addrFrom); },
    0x08: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMACmd(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
    0x09: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAReq(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
    0x0A: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAMask(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
    0x0B: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAMode(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
    0x0C: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAResetFF(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
    0x0D: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAMasterClear(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
    0x81: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA0.INDEX, 2, port, bOut, addrFrom); },
    0x82: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA0.INDEX, 3, port, bOut, addrFrom); },
    0x83: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA0.INDEX, 1, port, bOut, addrFrom); },
    0x87: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA0.INDEX, 0, port, bOut, addrFrom); }
};

ChipSet.aPortOutput5170 = {
    0x60: ChipSet.prototype.out8042InBuffData,
    0x61: ChipSet.prototype.out8042RWReg,
    0x64: ChipSet.prototype.out8042InBuffCmd,
    0x70: ChipSet.prototype.outCMOSAddr,
    0x71: ChipSet.prototype.outCMOSData,
    0x80: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageSpare(7, port, bOut, addrFrom); },
    0x84: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageSpare(0, port, bOut, addrFrom); },
    0x85: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageSpare(1, port, bOut, addrFrom); },
    0x86: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageSpare(2, port, bOut, addrFrom); },
    0x88: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageSpare(3, port, bOut, addrFrom); },
    0x89: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA1.INDEX, 2, port, bOut, addrFrom); },
    0x8A: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA1.INDEX, 3, port, bOut, addrFrom); },
    0x8B: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA1.INDEX, 1, port, bOut, addrFrom); },
    0x8C: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageSpare(4, port, bOut, addrFrom); },
    0x8D: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageSpare(5, port, bOut, addrFrom); },
    0x8E: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageSpare(6, port, bOut, addrFrom); },
    0x8F: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA1.INDEX, 0, port, bOut, addrFrom); },
    0xA0: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outPICLo(ChipSet.PIC1.INDEX, bOut, addrFrom); },
    0xA1: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outPICHi(ChipSet.PIC1.INDEX, bOut, addrFrom); },
    0xC0: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA1.INDEX, 0, port, bOut, addrFrom); },
    0xC2: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA1.INDEX, 0, port, bOut, addrFrom); },
    0xC4: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA1.INDEX, 1, port, bOut, addrFrom); },
    0xC6: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA1.INDEX, 1, port, bOut, addrFrom); },
    0xC8: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA1.INDEX, 2, port, bOut, addrFrom); },
    0xCA: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA1.INDEX, 2, port, bOut, addrFrom); },
    0xCC: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA1.INDEX, 3, port, bOut, addrFrom); },
    0xCE: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA1.INDEX, 3, port, bOut, addrFrom); },
    0xD0: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMACmd(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
    0xD2: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAReq(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
    0xD4: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAMask(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
    0xD6: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAMode(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
    0xD8: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAResetFF(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
    0xDA: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outDMAMasterClear(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
    0xF0: ChipSet.prototype.outFPUClear,
    0xF1: ChipSet.prototype.outFPUReset
};

ChipSet.aPortOutput6300 = {
    0x60: ChipSet.prototype.out8041Kbd,
    0x61: ChipSet.prototype.out8041Ctrl,
    0xA0: ChipSet.prototype.outNMI
};

if (DESKPRO386) {
    ChipSet.aPortOutputDeskPro386 = {
        0x48: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER3, port, bOut, addrFrom); },
        0x49: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER4, port, bOut, addrFrom); },
        0x4A: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER5, port, bOut, addrFrom); },
        0x4B: /** @this {ChipSet} */ function(port, bOut, addrFrom) { this.outTimerCtrl(ChipSet.PIT1.INDEX, port, bOut, addrFrom); }
    };
}

/*
 * Initialize every ChipSet module on the page.
 */
Web.onInit(ChipSet.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/rom.js (C) Jeff Parsons 2012-2018
 */


/**
 * class ROMX86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class ROMX86 extends Component {
    /**
     * ROMX86(parmsROM)
     *
     * The ROMX86 component expects the following (parmsROM) properties:
     *
     *      addr: physical address of ROM
     *      size: amount of ROM, in bytes
     *      alias: physical alias address (null if none)
     *      file: name of ROM data file
     *      notify: ID of a component to notify once the ROM is in place (optional)
     *
     * NOTE: The ROM data will not be copied into place until the Bus is ready (see initBus()) AND the
     * ROM data file has finished loading (see doneLoad()).
     *
     * Also, while the size parameter may seem redundant, I consider it useful to confirm that the ROM you received
     * is the ROM you expected.
     *
     * @this {ROMX86}
     * @param {Object} parmsROM
     */
    constructor(parmsROM)
    {
        super("ROMX86", parmsROM);

        this.abROM = null;
        this.addrROM = parmsROM['addr'];
        this.sizeROM = parmsROM['size'];

        /*
         * The new 'alias' property can now be EITHER a single physical address (like 'addr') OR an array of
         * physical addresses; eg:
         *
         *      [0xf0000,0xffff0000,0xffff8000]
         *
         * We could have overloaded 'addr' to accomplish the same thing, but I think it's better to have any
         * aliased locations listed under a separate property.
         *
         * Most ROMs are not aliased, in which case the 'alias' property should have the default value of null.
         */
        this.addrAlias = parmsROM['alias'];

        /*
         * The 'notify' property can now (as of v1.18.2) contain an array of parameters that the notified
         * component (typically Video) may use as it sees fit.  For example, the Video component is generally
         * interested in knowing the offsets of specific font tables within the ROM, which used to be hard-coded
         * when all we supported were a few specific IBM video cards, but that's no longer feasible as we move
         * beyond the original handful of IBM cards.
         *
         * It's up to the notified component to decide how to interpret the parameters it receives, if any.
         */
        this.idNotify = parmsROM['notify'];
        this.aNotifyParms = null;
        if (this.idNotify) {
            let i = this.idNotify.indexOf('[');
            if (i > 0) {
                try {
                    this.aNotifyParms = eval(this.idNotify.substr(i));
                } catch (e) {}
                this.idNotify = this.idNotify.substr(0, i);
            }
        }

        this.sFileURL = this.sFilePath = parmsROM['file'];

        if (this.sFileURL) {
            let sFileName = Str.getBaseName(this.sFileURL);
            if (DEBUG) this.log('load("' + this.sFileURL + '")');
            /*
             * If the selected ROM file has a ".json" extension, then we assume it's pre-converted
             * JSON-encoded ROM data, so we load it as-is; ditto for ROM files with a ".hex" extension.
             * Otherwise, we ask our server-side ROM converter to return the file in a JSON-compatible format.
             */
            let sFileExt = Str.getExtension(sFileName);
            if (sFileExt != DumpAPI.FORMAT.JSON && sFileExt != DumpAPI.FORMAT.HEX) {
                this.sFileURL = Web.getHostOrigin() + DumpAPI.ENDPOINT + '?' + DumpAPI.QUERY.FILE + '=' + this.sFilePath + '&' + DumpAPI.QUERY.FORMAT + '=' + DumpAPI.FORMAT.BYTES + '&' + DumpAPI.QUERY.DECIMAL + '=true';
            }
        }
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {ROMX86}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;

        if (this.sFileURL) {
            let rom = this;
            let sProgress = "Loading " + this.sFileURL + "...";
            Web.getResource(this.sFileURL, null, true, function doneROMLoad(sURL, sResponse, nErrorCode) {
                rom.doneLoad(sURL, sResponse, nErrorCode);
            }, function(nState) {
                rom.println(sProgress, Component.PRINT.PROGRESS);
            });
        }
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {ROMX86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (this.aSymbols) {
            if (this.dbg) {
                this.dbg.addSymbols(this.id, 0, this.addrROM >>> 4, 0, this.addrROM, this.sizeROM, this.aSymbols);
            }
            /*
             * Our only role in the handling of symbols is to hand them off to the Debugger at our
             * first opportunity. Now that we've done that, our copy of the symbols, if any, are toast.
             */
            delete this.aSymbols;
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * Since we have nothing to do on powerDown(), and no state to return, we could simply omit
     * this function.  But it doesn't hurt anything, and maybe we'll use our state to save something
     * useful down the road, like user-defined symbols (ie, symbols that the Debugger may have
     * created, above and beyond those symbols we automatically loaded, if any, along with the ROM).
     *
     * @this {ROMX86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return true;
    }

    /**
     * doneLoad(sURL, sROMData, nErrorCode)
     *
     * @this {ROMX86}
     * @param {string} sURL
     * @param {string} sROMData
     * @param {number} nErrorCode (response from server if anything other than 200)
     */
    doneLoad(sURL, sROMData, nErrorCode)
    {
        if (nErrorCode) {
            this.notice("Unable to load system ROM (error " + nErrorCode + ": " + sURL + ")", nErrorCode < 0);
            return;
        }

        Component.addMachineResource(this.idMachine, sURL, sROMData);

        if (sROMData.charAt(0) == "[" || sROMData.charAt(0) == "{") {
            try {
                /*
                 * The most likely source of any exception will be here: parsing the JSON-encoded ROM data.
                 */
                let rom = eval("(" + sROMData + ")");
                let ab = rom['bytes'];
                /*
                 * Resource 'longs' should always be 32-bit DWORD values, whereas 'data' bit lengths
                 * will vary according to the machine architecture for which the resource was designed.
                 */
                let adw = rom['longs'] || rom['data'];

                if (ab) {
                    this.abROM = ab;
                }
                else if (adw) {
                    /*
                     * Convert all the DWORDs into BYTEs, so that subsequent code only has to deal with abROM.
                     */
                    this.abROM = new Array(adw.length * 4);
                    for (let idw = 0, ib = 0; idw < adw.length; idw++) {
                        this.abROM[ib++] = adw[idw] & 0xff;
                        this.abROM[ib++] = (adw[idw] >> 8) & 0xff;
                        this.abROM[ib++] = (adw[idw] >> 16) & 0xff;
                        this.abROM[ib++] = (adw[idw] >> 24) & 0xff;
                    }
                }
                else {
                    this.abROM = rom;
                }

                this.aSymbols = rom['symbols'];

                if (!this.abROM.length) {
                    Component.error("Empty ROM: " + sURL);
                    return;
                }
                else if (this.abROM.length == 1) {
                    Component.error(this.abROM[0]);
                    return;
                }
            } catch (e) {
                this.notice("ROM data error: " + e.message);
                return;
            }
        }
        else {
            /*
             * Parse the ROM data manually; we assume it's in "simplified" hex form (a series of hex byte-values
             * separated by whitespace).
             */
            let sHexData = sROMData.replace(/\n/gm, " ").replace(/ +$/, "");
            let asHexData = sHexData.split(" ");
            this.abROM = new Array(asHexData.length);
            for (let i = 0; i < asHexData.length; i++) {
                this.abROM[i] = Str.parseInt(asHexData[i], 16);
            }
        }
        this.copyROM();
    }

    /**
     * copyROM()
     *
     * This function is called by both initBus() and doneLoad(), but it cannot copy the the ROM data into place
     * until after initBus() has received the Bus component AND doneLoad() has received the abROM data.  When both
     * those criteria are satisfied, the component becomes "ready".
     *
     * @this {ROMX86}
     */
    copyROM()
    {
        if (!this.isReady()) {
            if (!this.sFilePath) {
                this.setReady();
            }
            else if (this.abROM && this.bus) {
                /*
                 * If no explicit size was specified, then use whatever the actual size is.
                 */
                if (!this.sizeROM) {
                    this.sizeROM = this.abROM.length;
                }
                if (this.abROM.length != this.sizeROM) {
                    /*
                     * Note that setError() sets the component's fError flag, which in turn prevents setReady() from
                     * marking the component ready.  TODO: Revisit this decision.  On the one hand, it sounds like a
                     * good idea to stop the machine in its tracks whenever a setError() occurs, but there may also be
                     * times when we'd like to forge ahead anyway.
                     */
                    this.setError("ROM size (" + Str.toHexLong(this.abROM.length) + ") does not match specified size (" + Str.toHexLong(this.sizeROM) + ")");
                }
                else if (this.addROM(this.addrROM)) {

                    let aliases = [];
                    if (typeof this.addrAlias == "number") {
                        aliases.push(this.addrAlias);
                    } else if (this.addrAlias != null && this.addrAlias.length) {
                        aliases = this.addrAlias;
                    }
                    for (let i = 0; i < aliases.length; i++) {
                        this.cloneROM(aliases[i]);
                    }
                    /*
                     * If there's a component we should notify, notify it now, and give it the internal byte array, so that
                     * it doesn't have to ask the CPU for the data.  Currently, the only component that uses this notification
                     * option is the Video component, and only when the associated ROM contains font data that it needs.
                     */
                    if (this.idNotify) {
                        let component = Component.getComponentByID(this.idNotify, this.id);
                        if (component) {
                            component.onROMLoad(this.abROM, this.aNotifyParms);
                        } else {
                            this.notice("Unable to find component: " + this.idNotify);
                        }
                    }
                    /*
                     * We used to hang onto the original ROM data so that we could restore any bytes the CPU overwrote,
                     * using memory write-notification handlers, but with the introduction of read-only memory blocks, that's
                     * no longer necessary.
                     *
                     * TODO: Consider an option to retain the ROM data, and give the user some way of restoring ROMs.
                     * That may be useful for "resumable" machines that save/restore all dirty block of memory, regardless
                     * whether they're ROM or RAM.  However, the only way to modify a machine's ROM is with the Debugger,
                     * and Debugger users should know better.
                     */
                    delete this.abROM;
                }
                this.setReady();
            }
        }
    }

    /**
     * addROM(addr)
     *
     * @this {ROMX86}
     * @param {number} addr
     * @return {boolean}
     */
    addROM(addr)
    {
        if (this.bus.addMemory(addr, this.sizeROM, Memory.TYPE.ROM)) {
            if (DEBUG) this.log("addROM(): copying ROM to " + Str.toHexLong(addr) + " (" + Str.toHexLong(this.abROM.length) + " bytes)");
            let bto = null;
            for (let off = 0; off < this.abROM.length; off++) {
                this.bus.setByteDirect(addr + off, this.abROM[off]);
                if (BACKTRACK) {
                    bto = this.bus.addBackTrackObject(this, bto, off);
                    this.bus.writeBackTrackObject(addr + off, bto, off);
                }
            }
            return true;
        }
        /*
         * We don't need to report an error here, because addMemory() already takes care of that.
         */
        return false;
    }

    /**
     * cloneROM(addr)
     *
     * For ROMs with one or more alias addresses, we used to call addROM() for each address.  However,
     * that obviously wasted memory, since each alias was an independent copy, and if you used the
     * Debugger to edit the ROM in one location, the changes would not appear in the other location(s).
     *
     * Now that the Bus component provides low-level getMemoryBlocks() and setMemoryBlocks() methods
     * to manually get and set the blocks of any memory range, it is now possible to create true aliases.
     *
     * @this {ROMX86}
     * @param {number} addr
     */
    cloneROM(addr)
    {
        let aBlocks = this.bus.getMemoryBlocks(this.addrROM, this.sizeROM);
        this.bus.setMemoryBlocks(addr, this.sizeROM, aBlocks);
    }

    /**
     * ROMX86.init()
     *
     * This function operates on every HTML element of class "rom", extracting the
     * JSON-encoded parameters for the ROM constructor from the element's "data-value"
     * attribute, invoking the constructor to create a ROM component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeROM = Component.getElementsByClass(document, PCX86.APPCLASS, "rom");
        for (let iROM = 0; iROM < aeROM.length; iROM++) {
            let eROM = aeROM[iROM];
            let parmsROM = Component.getComponentParms(eROM);
            let rom = new ROMX86(parmsROM);
            Component.bindComponentControls(rom, eROM, PCX86.APPCLASS);
        }
    }
}

/*
 * ROM BIOS Data Area (RBDA) definitions, in physical address form, using the same CAPITALIZED names
 * found in the original IBM PC ROM BIOS listing.
 */
ROMX86.BIOS = {
    RS232_BASE:     0x400,              // ADDRESSES OF RS232 ADAPTERS (4 words)
    PRINTER_BASE:   0x408,              // ADDRESSES OF PRINTERS (4 words)
    EQUIP_FLAG: {                       // INSTALLED HARDWARE (word)
        ADDR:       0x410,
        NUM_PRINT:      0xC000,         // NUMBER OF PRINTERS ATTACHED
        GAME_CTRL:      0x1000,         // GAME I/O ATTACHED
        NUM_RS232:      0x0E00,         // NUMBER OF RS232 CARDS ATTACHED
        NUM_DRIVES:     0x00C0,         // NUMBER OF DISKETTE DRIVES (00=1, 01=2, 10=3, 11=4) ONLY IF IPL_DRIVE SET
        VIDEO_MODE:     0x0030,         // INITIAL VIDEO MODE (00=UNUSED, 01=40X25 COLOR, 10=80X25 COLOR, 11=80X25 MONO)
        RAM_SIZE:       0x000C,         // PLANAR RAM SIZE (00=16K,01=32K,10=48K,11=64K)
        IPL_DRIVE:      0x0001          // IPL (Initial Program Load) FROM DISKETTE (ie, diskette drives exist)
    },
    MFG_TEST:       0x412,              // INITIALIZATION FLAG (byte)
    MEMORY_SIZE:    0x413,              // MEMORY SIZE IN K BYTES (word)
    IO_RAM_SIZE:    0x415,              // PC: MEMORY IN I/O CHANNEL (word)
    MFG_ERR_FLAG:   0x415,              // PC AT: SCRATCHPAD FOR MANUFACTURING ERROR CODES (2 bytes)
    COMPAQ_PREV_SC: 0x415,              // COMPAQ DESKPRO 386: PREVIOUS SCAN CODE (byte)
    COMPAQ_KEYCLICK:0x416,              // COMPAQ DESKPRO 386: KEYCLICK LOUDNESS (byte)
    /*
     * KEYBOARD DATA AREAS
     */
    KB_FLAG: {                          // FIRST BYTE OF KEYBOARD STATUS (byte)
        ADDR:       0x417,              //
        INS_STATE:      0x80,           // INSERT STATE IS ACTIVE
        CAPS_STATE:     0x40,           // CAPS LOCK STATE HAS BEEN TOGGLED
        NUM_STATE:      0x20,           // NUM LOCK STATE HAS BEEN TOGGLED
        SCROLL_STATE:   0x10,           // SCROLL LOCK STATE HAS BEEN TOGGLED
        ALT_SHIFT:      0x08,           // ALTERNATE SHIFT KEY DEPRESSED
        CTL_SHIFT:      0x04,           // CONTROL SHIFT KEY DEPRESSED
        LEFT_SHIFT:     0x02,           // LEFT SHIFT KEY DEPRESSED
        RIGHT_SHIFT:    0x01            // RIGHT SHIFT KEY DEPRESSED
    },
    KB_FLAG_1: {                        // SECOND BYTE OF KEYBOARD STATUS (byte)
        ADDR:       0x418,              //
        INS_SHIFT:      0x80,           // INSERT KEY IS DEPRESSED
        CAPS_SHIFT:     0x40,           // CAPS LOCK KEY IS DEPRESSED
        NUM_SHIFT:      0x20,           // NUM LOCK KEY IS DEPRESSED
        SCROLL_SHIFT:   0x10,           // SCROLL LOCK KEY IS DEPRESSED
        HOLD_STATE:     0x08            // SUSPEND KEY HAS BEEN TOGGLED
    },
    ALT_INPUT:      0x419,              // STORAGE FOR ALTERNATE KEYPAD ENTRY (byte)
    BUFFER_HEAD:    0x41A,              // POINTER TO HEAD OF KEYBOARD BUFFER (word)
    BUFFER_TAIL:    0x41C,              // POINTER TO TAIL OF KEYBOARD BUFFER (word)
    KB_BUFFER:      0x41E,              // ROOM FOR 15 ENTRIES (16 words)
    KB_BUFFER_END:  0x43E,              // HEAD = TAIL INDICATES THAT THE BUFFER IS EMPTY
    /*
     * DISKETTE DATA AREAS
     */
    SEEK_STATUS: {                      // DRIVE RECALIBRATION STATUS (byte)
        ADDR:       0x43E,              //
                                        //      BIT 3-0 = DRIVE 3-0 NEEDS RECAL BEFORE
                                        //      NEXT SEEK IF BIT IS = 0
        INT_FLAG:       0x80,           // INTERRUPT OCCURRENCE FLAG
    },
    MOTOR_STATUS:   0x43F,              // MOTOR STATUS (byte)
                                        //      BIT 3-0 = DRIVE 3-0 IS CURRENTLY RUNNING
                                        //      BIT 7 = CURRENT OPERATION IS A WRITE, REQUIRES DELAY
    MOTOR_COUNT:    0x440,              // TIME OUT COUNTER FOR DRIVE TURN OFF
                                        //      37 == TWO SECONDS OF COUNTS FOR MOTOR TURN OFF
    DISKETTE_STATUS: {                  // SINGLE BYTE OF RETURN CODE INFO FOR STATUS
        ADDR:       0x441,
        TIME_OUT:       0x80,           // ATTACHMENT FAILED TO RESPOND
        BAD_SEEK:       0x40,           // SEEK OPERATION FAILED
        BAD_NEC:        0x20,           // NEC CONTROLLER HAS FAILED
        BAD_CRC:        0x10,           // BAD CRC ON DISKETTE READ
        DMA_BOUNDARY:   0x09,           // ATTEMPT TO DMA ACROSS 64K BOUNDARY
        BAD_DMA:        0x08,           // DMA OVERRUN ON OPERATION
        RECORD_NOT_FND: 0x04,           // REQUESTED SECTOR NOT FOUND
        WRITE_PROTECT:  0x03,           // WRITE ATTEMPTED ON WRITE PROT DISK
        BAD_ADDR_MARK:  0x02,           // ADDRESS MARK NOT FOUND
        BAD_CMD:        0x01            // BAD COMMAND PASSED TO DISKETTE I/O
    },
    NEC_STATUS:     0x442,              // STATUS BYTES FROM NEC (7 bytes)
    /*
     * VIDEO DISPLAY DATA AREA
     */
    CRT_MODE:       0x449,              // CURRENT CRT MODE (byte)
    CRT_COLS:       0x44A,              // NUMBER OF COLUMNS ON SCREEN (word)
    CRT_LEN:        0x44C,              // LENGTH OF REGEN IN BYTES (word)
    CRT_START:      0x44E,              // STARTING ADDRESS IN REGEN BUFFER (word)
    CURSOR_POSN:    0x450,              // CURSOR FOR EACH OF UP TO 8 PAGES (8 words)
    CURSOR_MODE:    0x460,              // CURRENT CURSOR MODE SETTING (word)
    ACTIVE_PAGE:    0x462,              // CURRENT PAGE BEING DISPLAYED (byte)
    ADDR_6845:      0x463,              // BASE ADDRESS FOR ACTIVE DISPLAY CARD (word)
    CRT_MODE_SET:   0x465,              // CURRENT SETTING OF THE 3X8 REGISTER (byte)
    CRT_PALLETTE:   0x466,              // CURRENT PALLETTE SETTING COLOR CARD (byte)
    /*
     * CASSETTE DATA AREA
     */
    EDGE_CNT:       0x467,              // PC: TIME COUNT AT DATA EDGE (word)
    CRC_REG:        0x469,              // PC: CRC REGISTER (word)
    LAST_VAL:       0x46B,              // PC: LAST INPUT VALUE (byte)
    IO_ROM_INIT:    0x467,              // PC AT: POINTER TO ROM INITIALIZATION ROUTINE
    IO_ROM_SEG:     0x469,              // PC AT: POINTER TO I/O ROM SEGMENT
    INTR_FLAG:      0x46B,              // PC AT: FLAG INDICATING AN INTERRUPT HAPPENED
    /*
     * TIMER DATA AREA
     */
    TIMER_LOW:      0x46C,              // LOW WORD OF TIMER COUNT (word)
    TIMER_HIGH:     0x46E,              // HIGH WORD OF TIMER COUNT (word)
    TIMER_OFL:      0x470,              // TIMER HAS ROLLED OVER SINCE LAST READ (byte)
    /*
     * SYSTEM DATA AREA
     */
    BIOS_BREAK:     0x471,              // BIT 7 = 1 IF BREAK KEY HAS BEEN DEPRESSED (byte)
    /*
     * RESET_FLAG is the traditional end of the RBDA, as originally defined by the IBM PC
     */
    RESET_FLAG: {
        ADDR:       0x472,              // SET TO 0x1234 IF KEYBOARD RESET UNDERWAY (word)
        WARMBOOT:       0x1234          // this value indicates a "warm boot", bypassing memory tests
    },
    /*
     * FIXED DISK DATA AREAS
     */
    DISK_STATUS1:   0x474,              // PC AT: FIXED DISK STATUS (byte)
    HF_NUM:         0x475,              // PC AT: COUNT OF FIXED DISK DRIVES (byte)
    CONTROL_BYTE:   0x476,              // PC AT: HEAD CONTROL BYTE (byte)
    PORT_OFF:       0x477,              // PC AT: RESERVED (PORT OFFSET) (byte)
    /*
     * TIME-OUT VARIABLES
     */
    PRINT_TIM_OUT:  0x478,              // PC AT: TIME OUT COUNTERS FOR PRINTER RESPONSE (4 bytes)
    RS232_TIM_OUT:  0x47C,              // PC AT: TIME OUT COUNTERS FOR RS232 RESPONSE (4 bytes)
    /*
     * ADDITIONAL KEYBOARD DATA AREA
     */
    BUFFER_START:   0x480,              // PC AT: OFFSET OF KEYBOARD BUFFER START WITHIN SEGMENT 40H
    BUFFER_END:     0x482,              // PC AT: OFFSET OF END OF BUFFER
    /*
     * EGA/PGA DISPLAY WORK AREA
     */
    ROWS:           0x484,              // PC AT: ROWS ON THE ACTIVE SCREEN (LESS 1) (byte)
    POINTS:         0x485,              // PC AT: BYTES PER CHARACTER (word)
    INFO:           0x487,              // PC AT: MODE OPTIONS (byte)
    /*
     * INFO BITS:
     *
     *      0x80: HIGH BIT OF MODE SET, CLEAR/NOT CLEAR REGEN
     *      0x60: 256K OF VRAM
     *      0x40: 192K OF VRAM
     *      0x20: 128K OF VRAM
     *      0x10: RESERVED
     *      0x08: EGA ACTIVE MONITOR (0), EGA NOT ACTIVE (1)
     *      0x04: WAIT FOR DISPLAY ENABLE (1)
     *      0x02: EGA HAS A MONOCHROME ATTACHED
     *      0x01: SET C_TYPE EMULATE ACTIVE (0)
     */
    INFO_3:         0x488,              // PC AT: FEATURE BIT SWITCHES (1 byte, plus 2 reserved bytes)
    /*
     *     40:88  byte  PCjr: third keyboard status byte
     *                  EGA feature bit switches, emulated on VGA
     *
     *         |7|6|5|4|3|2|1|0| EGA feature bit switches (EGA+)
     *          | | | | | | | `-- EGA SW1 config (1=off)
     *          | | | | | | `--- EGA SW2 config (1=off)
     *          | | | | | `---- EGA SW3 config (1=off)
     *          | | | | `----- EGA SW4 config (1=off)
     *          | | | `------ Input FEAT0 (ISR0 bit 5) after output on FCR0
     *          | | `------- Input FEAT0 (ISR0 bit 6) after output on FCR0
     *          | `-------- Input FEAT1 (ISR0 bit 5) after output on FCR1
     *          `--------- Input FEAT1 (ISR0 bit 6) after output on FCR1
     *
     *     40:89  byte  Video display data area (MCGA and VGA)
     *
     *         |7|6|5|4|3|2|1|0| Video display data area (MCGA and VGA)
     *          | | | | | | | `-- 1=VGA is active
     *          | | | | | | `--- 1=gray scale is enabled
     *          | | | | | `---- 1=using monochrome monitor
     *          | | | | `----- 1=default palette loading is disabled
     *          | | | `------ see table below
     *          | | `------- reserved
     *          | `--------  1=display switching enabled
     *          `--------- alphanumeric scan lines (see table below)
     *
     *           Bit7    Bit4   Scan Lines
     *             0       0    350 line mode
     *             0       1    400 line mode
     *             1       0    200 line mode
     *             1       1    reserved
     */
    /*
     * ADDITIONAL MEDIA DATA
     */
    LASTRATE:       0x48B,              // PC AT: LAST DISKETTE DATA RATE SELECTED (byte)
    HF_STATUS:      0x48C,              // PC AT: STATUS REGISTER (byte)
    HF_ERROR:       0x48D,              // PC AT: ERROR REGISTER (byte)
    HF_INT_FLAG:    0x48E,              // PC AT: FIXED DISK INTERRUPT FLAG (byte)
    HF_CNTRL:       0x48F,              // PC AT: COMBO FIXED DISK/DISKETTE CARD BIT 0=1 (byte)
    DSK_STATE:      0x490,              // PC AT: DRIVE 0/1 MEDIA/OPERATION STATES (4 bytes)
    DSK_TRK:        0x494,              // PC AT: DRIVE 0/1 PRESENT CYLINDER (2 bytes)
    /*
     * ADDITIONAL KEYBOARD FLAGS
     */
    KB_FLAG_3: {
        ADDR:       0x496,              // PC AT: KEYBOARD MODE STATE AND TYPE FLAGS (byte)
        LC_E1:          0b00000001,     // LAST CODE WAS THE E1 HIDDEN CODE
        LC_E0:          0b00000010,     // LAST CODE WAS THE E0 HIDDEN CODE
        R_CTL_SHIFT:    0b00000100,     // RIGHT CTL KEY DOWN
        R_ALT_SHIFT:    0b00001000,     // RIGHT ALT KEY DOWN
        GRAPH_ON:       0b00001000,     // ALT GRAPHICS KEY DOWN (WT ONLY)
        KBX:            0b00010000,     // ENHANCED KEYBOARD INSTALLED
        SET_NUM_LK:     0b00100000,     // FORCE NUM LOCK IF READ ID AND KBX
        LC_AB:          0b01000000,     // LAST CHARACTER WAS FIRST ID CHARACTER
        RD_ID:          0b10000000      // DOING A READ ID (MUST BE BIT0)
    },
    KB_FLAG_2: {
        ADDR:       0x497,              // PC AT: KEYBOARD LED FLAGS (byte)
        KB_LEDS:        0b00000111,     // KEYBOARD LED STATE BITS
        SCROLL_LOCK:    0b00000001,     // SCROLL LOCK INDICATOR
        NUM_LOCK:       0b00000010,     // NUM LOCK INDICATOR
        CAPS_LOCK:      0b00000100,     // CAPS LOCK INDICATOR
        KB_FA:          0b00010000,     // ACKNOWLEDGMENT RECEIVED
        KB_FE:          0b00100000,     // RESEND RECEIVED FLAG
        KB_PR_LED:      0b01000000,     // MODE INDICATOR UPDATE
        KB_ERR:         0b10000000      // KEYBOARD TRANSMIT ERROR FLAG
    },
    /*
     * REAL TIME CLOCK DATA AREA
     */
    USER_FLAG:      0x498,              // PC AT: OFFSET ADDRESS OF USERS WAIT FLAG (word)
    USER_FLAG_SEG:  0x49A,              // PC AT: SEGMENT ADDRESS OF USER WAIT FLAG (word)
    RTC_LOW:        0x49C,              // PC AT: LOW WORD OF USER WAIT FLAG (word)
    RTC_HIGH:       0x49E,              // PC AT: HIGH WORD OF USER WAIT FLAG (word)
    RTC_WAIT_FLAG:  0x4A0,              // PC AT: WAIT ACTIVE FLAG (01=BUSY, 80=POSTED, 00=POST ACKNOWLEDGED) (byte)
    /*
     * AREA FOR NETWORK ADAPTER
     */
    NET:            0x4A1,              // PC AT: RESERVED FOR NETWORK ADAPTERS (7 bytes)
    /*
     * EGA/PGA PALETTE POINTER
     */
    SAVE_PTR:       0x4A8,              // PC AT: POINTER TO EGA PARAMETER CONTROL BLOCK (2 words)
    /*
     * DATA AREA - PRINT SCREEN
     */
    STATUS_BYTE:    0x500               // PRINT SCREEN STATUS BYTE (00=READY/OK, 01=BUSY, FF=ERROR) (byte)
};

/*
 * NOTE: There's currently no need for this component to have a reset() function, since
 * once the ROM data is loaded, it can't be changed, so there's nothing to reinitialize.
 *
 * OK, well, I take that back, because the Debugger, if installed, has the ability to modify
 * ROM contents, so in that case, having a reset() function that restores the original ROM data
 * might be useful; then again, it might not, depending on what you're trying to debug.
 *
 * If we do add reset(), then we'll want to change copyROM() to hang onto the original
 * ROM data; currently, we release it after copying it into the read-only memory allocated
 * via bus.addMemory().
 */

/*
 * Initialize all the ROM modules on the page.
 */
Web.onInit(ROMX86.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/ram.js (C) Jeff Parsons 2012-2018
 */


/**
 * class RAM
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class RAM extends Component {
    /**
     * RAM(parmsRAM)
     *
     * The RAM component expects the following (parmsRAM) properties:
     *
     *      addr: starting physical address of RAM (default is 0)
     *      size: amount of RAM, in bytes (default is 0, which means defer to motherboard switch settings)
     *      test: true (default) means don't interfere with any BIOS memory tests, false means "fake a warm boot"
     *
     * The 'test' parm can also be overridden by the machine-specific 'testRAM' parm.
     *
     * NOTE: We make a note of the specified size, but no memory is initially allocated for the RAM until the
     * Computer component calls powerUp().
     *
     * @this {RAM}
     * @param {Object} parmsRAM
     */
    constructor(parmsRAM)
    {
        super("RAM", parmsRAM);

        this.addrRAM = parmsRAM['addr'];
        this.sizeRAM = parmsRAM['size'];
        this.fTestRAM = parmsRAM['test'];
        this.fInstalled = (!!this.sizeRAM);     // 0 is the default value for 'size' when none is specified
        this.fAllocated = false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {RAM}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.chipset = cmp.getMachineComponent("ChipSet");
        this.fTestRAM = cmp.getMachineBoolean('testRAM', this.fTestRAM);
        this.setReady();
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {RAM}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            /*
             * The Computer powers up the CPU last, at which point CPUX86 state is restored,
             * which includes the Bus state, and since we use the Bus to allocate all our memory,
             * memory contents are already restored for us, so we don't need the usual restore
             * logic.  We just need to call reset(), to allocate memory for the RAM.
             *
             * The only exception is when there's a custom Memory controller (eg, CompaqController).
             */
            this.reset();
            if (data && this.controller) {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {RAM}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        /*
         * The Computer powers down the CPU first, at which point CPUX86 state is saved,
         * which includes the Bus state, and since we use the Bus component to allocate all
         * our memory, memory contents are already saved for us, so we don't need the usual
         * save logic.
         *
         * The only exception is when there's a custom Memory controller (eg, CompaqController).
         */
        return (fSave && this.controller)? this.save() : true;
    }

    /**
     * reset()
     *
     * NOTE: When we were initialized, we were given an amount of INSTALLED memory (see sizeRAM above).
     * The ChipSet component, on the other hand, tells us how much SPECIFIED memory there is -- which,
     * like a real PC, may not match the amount of installed memory (due to either user error or perhaps
     * an attempt to prevent some portion of the installed memory from being used).
     *
     * However, since we're a virtual machine, we can defer allocation of RAM until we're able to query the
     * ChipSet component, and then allocate an amount of memory that matches the SPECIFIED memory, making
     * it easy to reconfigure the machine on the fly and prevent mismatches.
     *
     * But, we do that ONLY for the RAM instance configured with an addrRAM of 0x0000, and ONLY if that RAM
     * object was not given a specific size (see fInstalled).  If there are other RAM objects in the system,
     * they must necessarily specify a non-conflicting, non-zero start address, in which case their sizeRAM
     * value will never be affected by the ChipSet settings.
     *
     * @this {RAM}
     */
    reset()
    {
        if (!this.addrRAM && !this.fInstalled && this.chipset) {
            let baseRAM = this.chipset.getDIPMemorySize() * 1024;
            if (this.sizeRAM && baseRAM != this.sizeRAM) {
                this.bus.removeMemory(this.addrRAM, this.sizeRAM);
                this.fAllocated = false;
            }
            this.sizeRAM = baseRAM;
        }
        if (!this.fAllocated && this.sizeRAM) {
            if (this.bus.addMemory(this.addrRAM, this.sizeRAM, Memory.TYPE.RAM)) {
                this.fAllocated = true;

                /*
                 * NOTE: I'm specifying MAXDEBUG for status() messages because I'm not yet sure I want these
                 * messages buried in the app, since they're seen only when a Control Panel is active.  Another
                 * and perhaps better alternative is to add "comment" attributes to the XML configuration file
                 * for these components, which the Computer component will display as it "powers up" components.
                 */
                if (MAXDEBUG && !this.addrRAM && this.fInstalled) this.status("specified size overrides SW1");

                /*
                 * Memory with an ID of "ramCPQ" is reserved for built-in memory located just below the 16Mb
                 * boundary on COMPAQ DeskPro 386 machines.
                 *
                 * Technically, that memory is part of the first 1Mb of memory that also provides up to 640Kb
                 * of conventional memory (ie, memory below 1Mb).
                 *
                 * However, PCx86 doesn't support individual memory allocations that (a) are discontiguous
                 * or (b) dynamically change location.  Components must simulate those features by performing
                 * a separate allocation for each starting address, and removing/adding memory allocations
                 * whenever their starting address changes.
                 *
                 * Therefore, a DeskPro 386's first 1Mb of physical memory is allocated by PCx86 in two pieces,
                 * and the second piece must have an ID of "ramCPQ", triggering the additional allocation of
                 * COMPAQ-specific memory-mapped registers.
                 *
                 * See CompaqController for more details.
                 */
                if (DESKPRO386) {
                    if (this.idComponent == "ramCPQ") {
                        this.controller = new CompaqController(this);
                        this.bus.addMemory(CompaqController.ADDR, 4, Memory.TYPE.CTRL, this.controller);
                    }
                }
            }
        }
        if (this.fAllocated) {
            if (!this.addrRAM && !this.fTestRAM) {
                /*
                 * HACK: Set the word at 40:72 in the ROM BIOS Data Area (RBDA) to 0x1234 to bypass the ROM BIOS
                 * memory storage tests. See rom.js for all RBDA definitions.
                 */
                if (MAXDEBUG) this.status("ROM BIOS memory test has been disabled");
                this.bus.setShortDirect(ROMX86.BIOS.RESET_FLAG.ADDR, ROMX86.BIOS.RESET_FLAG.WARMBOOT);
            }
            /*
             * Don't add the "ramCPQ" memory to the CMOS total, because addCMOSMemory() will add it to the extended
             * memory total, which will just confuse the COMPAQ BIOS.
             */
            if (!DESKPRO386 || this.idComponent != "ramCPQ") {
                if (this.chipset) this.chipset.addCMOSMemory(this.addrRAM, this.sizeRAM);
            }
        } else {
            Component.error("No RAM allocated");
        }
    }

    /**
     * save()
     *
     * This implements save support for the RAM component.
     *
     * @this {RAM}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        if (this.controller) state.set(0, this.controller.save());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the RAM component.
     *
     * @this {RAM}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        if (this.controller) return this.controller.restore(data[0]);
        return true;
    }

    /**
     * RAM.init()
     *
     * This function operates on every HTML element of class "ram", extracting the
     * JSON-encoded parameters for the RAM constructor from the element's "data-value"
     * attribute, invoking the constructor to create a RAM component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeRAM = Component.getElementsByClass(document, PCX86.APPCLASS, "ram");
        for (let iRAM = 0; iRAM < aeRAM.length; iRAM++) {
            let eRAM = aeRAM[iRAM];
            let parmsRAM = Component.getComponentParms(eRAM);
            let ram = new RAM(parmsRAM);
            Component.bindComponentControls(ram, eRAM, PCX86.APPCLASS);
        }
    }
}

/**
 * class CompaqController
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class CompaqController extends Controller {
    /**
     * CompaqController(ram)
     *
     * DeskPro 386 machines came with a minimum of 1Mb of RAM, which could be configured (via jumpers)
     * for 256Kb, 512Kb or 640Kb of conventional memory, starting at address 0x00000000, with the
     * remainder (768Kb, 512Kb, or 384Kb) accessible only at an address just below 0x01000000.  In PCx86,
     * this second chunk of RAM must be separately allocated, with an ID of "ramCPQ".
     *
     * The typical configuration was 640Kb of conventional memory, leaving 384Kb accessible at 0x00FA0000.
     * Presumably, the other configurations (256Kb and 512Kb) would leave 768Kb and 512Kb accessible at
     * 0x00F40000 and 0x00F80000, respectively.
     *
     * The DeskPro 386 also contained two memory-mapped registers at 0x80C00000.  The first is a write-only
     * mapping register that provides the ability to map the 128Kb at 0x00FE0000 to 0x000E0000, replacing
     * any ROMs in the range 0x000E0000-0x000FFFFF, and optionally write-protecting that 128Kb; internally,
     * this register corresponds to wMappings.
     *
     * The second register is a read-only diagnostics register that indicates jumper configuration and
     * parity errors; internally, this register corresponds to wSettings.
     *
     * To emulate the memory-mapped registers at 0x80C00000, the RAM component allocates a block at that
     * address using this custom controller once it sees an allocation for "ramCPQ".
     *
     * Later, when the addressability of "ramCPQ" memory is altered, we record the blocks in all the
     * memory slots spanning 0x000E0000-0x000FFFFF, and then update those slots with the blocks from
     * 0x00FE0000-0x00FFFFFF.  Note that only the top 128Kb of "ramCPQ" addressability is affected; the
     * rest of that memory, ranging anywhere from 256Kb to 640Kb, remains addressable at its original
     * location.  COMPAQ's CEMM and VDISK utilities were generally the only software able to access that
     * remaining memory (what COMPAQ refers to as "Compaq Built-in Memory").
     *
     * @this {CompaqController}
     * @param {RAM} ram
     */
    constructor(ram)
    {
        super();

        this.ram = ram;
        this.wMappings = CompaqController.MAPPINGS.DEFAULT;
        /*
         * TODO: wSettings needs to reflect the actual amount of configured memory....
         */
        this.wSettings = CompaqController.SETTINGS.DEFAULT;
        this.wRAMSetup = CompaqController.RAMSETUP.DEFAULT;
        this.aBlocksDst = null;
    }

    /**
     * save()
     *
     * This implements save support for the CompaqController component.
     *
     * @this {CompaqController}
     * @return {Array}
     */
    save()
    {
        return [this.wMappings, this.wRAMSetup];
    }

    /**
     * restore(data)
     *
     * This implements restore support for the CompaqController component.
     *
     * @this {CompaqController}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        this.setByte(0, data[0] & 0xff);
        this.setByte(2, data[1] & 0xff);
        return true;
    }

    /**
     * getByte(off)
     *
     * @this {CompaqController}
     * @param {number} off
     * @return {number}
     */
    getByte(off)
    {
        /*
         * Offsets 0-3 correspond to reads from 0x80C00000-0x80C00003; anything outside that range
         * returns our standard non-responsive value of 0xff.
         */
        let b = 0xff;
        if (off < 0x02) {
            b = (off & 0x1)? (this.wSettings >> 8) : (this.wSettings & 0xff);
        }
        else if (off < 0x4) {
            b = (off & 0x1)? (this.wRAMSetup >> 8) : (this.wRAMSetup & 0xff);
        }
        return b;
    }

    /**
     * setByte(off, b)
     *
     * @this {CompaqController}
     * @param {number} off (relative to 0x80C00000)
     * @param {number} b
     */
    setByte(off, b)
    {
        if (!off) {
            /*
             * This is a write to 0x80C00000
             */
            if (b != (this.wMappings & 0xff)) {
                let bus = this.ram.bus;
                if (!(b & CompaqController.MAPPINGS.UNMAPPED)) {
                    if (!this.aBlocksDst) {
                        this.aBlocksDst = bus.getMemoryBlocks(CompaqController.MAP_DST, CompaqController.MAP_SIZE);
                    }
                    /*
                     * You might think that the next three lines could ALSO be moved to the preceding IF,
                     * but it's possible for the write-protection feature to be enabled/disabled separately
                     * from the mapping feature.  We could avoid executing this code as well by checking the
                     * current read-write state, but this is an infrequent operation, so there's no point.
                     */
                    let aBlocks = bus.getMemoryBlocks(CompaqController.MAP_SRC, CompaqController.MAP_SIZE);
                    let type = (b & CompaqController.MAPPINGS.READWRITE)? Memory.TYPE.RAM : Memory.TYPE.ROM;
                    bus.setMemoryBlocks(CompaqController.MAP_DST, CompaqController.MAP_SIZE, aBlocks, type);
                }
                else {
                    if (this.aBlocksDst) {
                        bus.setMemoryBlocks(CompaqController.MAP_DST, CompaqController.MAP_SIZE, this.aBlocksDst);
                        this.aBlocksDst = null;
                    }
                }
                this.wMappings = (this.wMappings & ~0xff) | b;
            }
        }
        else if (off == 0x2) {
            /*
             * This is a write to 0x80C00002
             */
            this.wRAMSetup = (this.wRAMSetup & ~0xff) | b;
        }
    }

    /**
     * getMemoryAccess()
     *
     * @this {CompaqController}
     * @return {Array.<function()>}
     */
    getMemoryAccess()
    {
        return CompaqController.ACCESS;
    }

    /**
     * getMemoryBuffer(addr)
     *
     * @this {CompaqController}
     * @param {number} addr
     * @return {Array} containing the buffer (and an offset within that buffer)
     */
    getMemoryBuffer(addr)
    {
        return CompaqController.BUFFER;
    }

    /**
     * readByte(off, addr)
     *
     * NOTE: Even though we asked bus.addMemory() for only 4 bytes, corresponding to the 4 memory-mapped register
     * locations we must manage, we're at the mercy of the Bus component's physical block allocation granularity,
     * which, on 80386-based machines, is fixed at 4K (the same as the 80386 page size, to simplify emulation of paging).
     *
     * So we must allow for requests outside that 4-byte range.
     *
     * @this {Memory}
     * @param {number} off (relative to 0x80C00000)
     * @param {number} [addr]
     * @return {number}
     */
    static readByte(off, addr)
    {
        let b = this.controller.getByte(off);
        if (DEBUG) {
            this.controller.ram.printMessage("CompaqController.readByte(" + Str.toHexWord(off) + ") returned " + Str.toHexByte(b), 0, true);
        }
        return b;
    }

    /**
     * writeByte(off, b, addr)
     *
     * NOTE: Even though we asked bus.addMemory() for only 4 bytes, corresponding to the 4 memory-mapped register
     * locations we must manage, we're at the mercy of the Bus component's physical memory allocation granularity,
     * which, on 80386-based machines, is fixed at 4K (the same as the 80386 page size, to simplify emulation of paging).
     *
     * So we must allow for requests outside that 4-byte range.
     *
     * @this {Memory}
     * @param {number} off (relative to 0x80C00000)
     * @param {number} b
     * @param {number} [addr]
     */
    static writeByte(off, b, addr)
    {
        this.controller.setByte(off, b);
        /*
         * All bits in 0x80C00001 and 0x80C00003 are reserved, so we can simply ignore those writes.
         */
        if (DEBUG) {
            this.controller.ram.printMessage("CompaqController.writeByte(" + Str.toHexWord(off) + "," + Str.toHexByte(b) + ")", 0, true);
        }
    }
}

CompaqController.ADDR       = 0x80C00000|0;
CompaqController.MAP_SRC    = 0x00FE0000;
CompaqController.MAP_DST    = 0x000E0000;
CompaqController.MAP_SIZE   = 0x00020000;

/*
 * Bit definitions for the 16-bit write-only memory-mapping register (wMappings)
 *
 * NOTE: Although COMPAQ says the memory at %FE0000 is "relocated", it actually remains addressable
 * at %FE0000; it simply becomes addressable at %0E0000 as well, displacing any ROMs that used to be
 * addressable at %0E0000 through %0FFFFF.
 */
CompaqController.MAPPINGS = {
    UNMAPPED:   0x0001,             // is this bit is CLEAR, the last 128Kb (at 0x00FE0000) is mapped to 0x000E0000
    READWRITE:  0x0002,             // if this bit is CLEAR, the last 128Kb (at 0x00FE0000) is read-only (ie, write-protected)
    RESERVED:   0xFFFC,             // the remaining 6 bits are reserved and should always be SET
    DEFAULT:    0xFFFF              // our default settings (no mapping, no write-protection)
};

/*
 * Bit definitions for the 16-bit read-only settings/diagnostics register (wSettings)
 *
 * SW1-7 and SW1-8 are mapped to bits 5 and 4 of wSettings, respectively, as follows:
 *
 *      SW1-7   SW1-8   Bit5    Bit4    Amount (of base memory provided by the COMPAQ 32-bit memory board)
 *      -----   -----   ----    ----    ------
 *        ON      ON      0       0     640Kb
 *        ON      OFF     0       1     Invalid
 *        OFF     ON      1       0     512Kb
 *        OFF     OFF     1       1     256Kb
 *
 * Other SW1 switches include:
 *
 *      SW1-1:  ON enables fail-safe timer
 *      SW1-2:  ON indicates 80387 coprocessor installed
 *      SW1-3:  ON sets memory from 0xC00000 to 0xFFFFFF (between 12 and 16 megabytes) non-cacheable
 *      SW1-4:  ON selects AUTO system speed (OFF selects HIGH system speed)
 *      SW1-5:  RESERVED (however, the system can read its state; see below)
 *      SW1-6:  COMPAQ Dual-Mode Monitor or Color Monitor (OFF selects Monochrome monitor other than COMPAQ)
 *
 * While SW1-7 and SW1-8 are connected to this memory-mapped register, other SW1 DIP switches are accessible
 * through the 8042 Keyboard Controller's KBC.INPORT register, as follows:
 *
 *      SW1-1:  TODO: Determine
 *      SW1-2:  ChipSet.KC8042.INPORT.COMPAQ_NO80387 clear if ON, set (0x04) if OFF
 *      SW1-3:  TODO: Determine
 *      SW1-4:  ChipSet.KC8042.INPORT.COMPAQ_HISPEED clear if ON, set (0x10) if OFF
 *      SW1-5:  ChipSet.KC8042.INPORT.COMPAQ_DIP5OFF clear if ON, set (0x20) if OFF
 *      SW1-6:  ChipSet.KC8042.INPORT.COMPAQ_NONDUAL clear if ON, set (0x40) if OFF
 */
CompaqController.SETTINGS = {
    B0_PARITY:  0x0001,         // parity OK in byte 0
    B1_PARITY:  0x0002,         // parity OK in byte 1
    B2_PARITY:  0x0004,         // parity OK in byte 2
    B3_PARITY:  0x0008,         // parity OK in byte 3
    BASE_640KB: 0x0000,         // SW1-7,8: ON  ON   Bits 5,4: 00
    BASE_ERROR: 0x0010,         // SW1-7,8: ON  OFF  Bits 5,4: 01
    BASE_512KB: 0x0020,         // SW1-7,8: OFF ON   Bits 5,4: 10
    BASE_256KB: 0x0030,         // SW1-7,8: OFF OFF  Bits 5,4: 11
    /*
     * TODO: The DeskPro 386/25 TechRef says bit 6 (0x40) is always set,
     * but setting it results in memory configuration errors; review.
     */
    ADDED_1MB:  0x0040,
    /*
     * TODO: The DeskPro 386/25 TechRef says bit 7 (0x80) is always clear; review.
     */
    PIGGYBACK:  0x0080,
    SYS_4MB:    0x0100,         // 4Mb on system board
    SYS_1MB:    0x0200,         // 1Mb on system board
    SYS_NONE:   0x0300,         // no memory on system board
    MODA_4MB:   0x0400,         // 4Mb on module A board
    MODA_1MB:   0x0800,         // 1Mb on module A board
    MODA_NONE:  0x0C00,         // no memory on module A board
    MODB_4MB:   0x1000,         // 4Mb on module B board
    MODB_1MB:   0x2000,         // 1Mb on module B board
    MODB_NONE:  0x3000,         // no memory on module B board
    MODC_4MB:   0x4000,         // 4Mb on module C board
    MODC_1MB:   0x8000,         // 1Mb on module C board
    MODC_NONE:  0xC000,         // no memory on module C board
    /*
     * NOTE: It doesn't seem to matter to the ROM whether I set any of bits 8-15 or not....
     */
    DEFAULT:    0x0A0F          // our default settings (ie, parity OK, 640Kb base memory, 1Mb system memory, 1Mb module A memory)
};

CompaqController.RAMSETUP = {
    SETUP:      0x000F,
    CACHE:      0x0040,
    RESERVED:   0xFFB0,
    DEFAULT:    0x0002          // our default settings (ie, 2Mb, cache disabled)
};

CompaqController.BUFFER = [null, 0];
CompaqController.ACCESS = [CompaqController.readByte, null, null, CompaqController.writeByte, null, null];

/*
 * Initialize all the RAM modules on the page.
 */
Web.onInit(RAM.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/keyboard.js (C) Jeff Parsons 2012-2018
 */


/**
 * class Keyboard
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Keyboard extends Component {
    /**
     * Keyboard(parmsKbd)
     *
     * The Keyboard component can be configured with the following (parmsKbd) properties:
     *
     *      model: keyboard model string, which must match one of the values listed in Keyboard.MODELS:
     *
     *          "US83" (default)
     *          "US84"
     *          "US101" (not fully supported yet)
     *
     *      autoType: string of keys to automatically inject when the machine is ready (undefined if none)
     *
     *      softKeys: boolean set to true to enable the machine's soft keyboard, if any (default is false)
     *
     * Its main purpose is to receive binding requests for various keyboard events, and to use those events
     * to simulate the PC's keyboard hardware.
     *
     * TODO: Consider finishing 101-key keyboard support, even though that's sort of a "PS/2" thing, and I'm not
     * really interested in taking PCjs into the PS/2 line (that's also why we still support only serial mice, not
     * "PS/2" mice).  In addition, all keyboards *after* the original PC 83-key keyboard supported their own unique
     * scan code sets, which the 8042 controller would then convert to PC-compatible scan codes.  That's probably
     * more important to implement, because that feature was introduced with the 84-key keyboard on the PC AT.
     *
     * @this {Keyboard}
     * @param {Object} parmsKbd
     */
    constructor(parmsKbd)
    {
        super("Keyboard", parmsKbd, Messages.KBD);

        this.setModel(parmsKbd['model']);

        this.fMobile = Web.isMobile("!iPad");
        this.printMessage("mobile keyboard support: " + (this.fMobile? "true" : "false"));

        /*
         * This flag (formerly fMSIE, for all versions of Microsoft Internet Explorer, up to and including v11)
         * has been updated to reflect the Microsoft Windows *platform* rather than the *browser*, because it appears
         * that all Windows-based browsers (at least now, as of 2018) have the same behavior with respect to "lock"
         * keys: keys like CAPS-LOCK generate both UP and DOWN events on every press.  On other platforms (eg, macOS),
         * those keys generate only a DOWN event when "locking" and only an UP event when "unlocking".
         */
        this.fMSWindows = Web.isUserAgent("Windows");

        /*
         * This is count of the number of "soft keyboard" keys present.  At the moment, its only
         * purpose is to signal findBinding() whether to waste any time looking for SOFTCODE matches.
         */
        this.cSoftCodes = 0;
        this.fSoftKeyboard = parmsKbd['softKeys'];
        this.controlSoftKeyboard = null;
        this.controlTextKeyboard = null;

        /*
         * Updated by onFocusChange()
         */
        this.fHasFocus = true;

        /*
         * This can be used to delay ALT key generation (ie, until some other key in conjunction with the
         * ALT is pressed as well); however, it is currently off by default, because there are apps (eg, the
         * MS-DOS Manager) that don't deal well the rapid back-to-back ALT+key generation that this work-around
         * necessitates.
         */
        this.fDelayALT = false;

        /*
         * This is true whenever the physical Escape key is disabled (eg, by pointer locking code),
         * giving us the opportunity to map a different physical key to machine's virtual Escape key.
         */
        this.fEscapeDisabled = false;

        /*
         * This is set whenever we notice a discrepancy between our internal CAPS_LOCK state and its
         * apparent state; we check whenever aKeysActive has been emptied.
         */
        this.fToggleCapsLock = false;

        /*
         * New unified approach to key event processing: When we process a key on the "down" event,
         * we check the aKeysActive array: if the key is already active, do nothing; otherwise, insert
         * it into the table, generate the "make" scan code(s), and set a timeout for "repeat" if it's
         * a repeatable key (most are).
         *
         * Similarly, when a key goes "up", if it's already not active, do nothing; otherwise, generate
         * the "break" scan code(s), cancel any pending timeout, and remove it from the active key table.
         *
         * If a "press" event is received, then if the key is already active, remove it and (re)insert
         * it at the head of the table, generate the "make" scan code(s), set nRepeat to -1, and set a
         * timeout for "break".
         *
         * This requires an aKeysActive array that keeps track of the status of every active key; only the
         * first entry in the array is allowed to repeat.  Each entry is a key object with the following
         * properties:
         *
         *      simCode:    our simulated keyCode from onKeyChange or onKeyPress
         *      bitsState:  snapshot of the current bitsState when the key is added (currently not used)
         *      fDown:      next state to simulate (true for down, false for up)
         *      nRepeat:    > 0 if timer should generate more "make" scan code(s), -1 for "break" scan code(s)
         *      timer:      timer for next key operation, if any
         *
         * Keys are inserted at the head of aKeysActive, using splice(0, 0, key), but not before zeroing
         * nRepeat of any repeating key that already occupies the head (index 0), so that at most only one
         * key (ie, the most recent) will ever be in a repeating state.
         *
         * IBM PC keyboard repeat behavior: when pressing CTRL, then C, and then releasing CTRL while still
         * holding C, the repeated CTRL_C characters turn into 'c' characters.  We emulate that behavior.
         * However, when pressing C, then CTRL, all repeating stops: not a single CTRL_C is generated, and
         * even if the CTRL is released before the C, no more more 'c' characters are generated either.
         * We do NOT fully emulate that behavior -- we DO stop the repeating, but we also generate one CTRL_C.
         * More investigation is required, because I need to confirm whether the IBM keyboard automatically
         * "breaks" all non-shift keys before it "makes" the CTRL.
         */
        this.aKeysActive = [];

        /*
         * msTransmit was originally 10ms, but I was getting some warning "beeps" in this machine:
         *
         *      /devices/pcx86/machine/5170/ega/2048kb/rev3/debugger/machine.xml
         *
         * while typing very fast, so let's see if throttling transmissions a bit more helps with that.
         */
        this.msTransmit      = 15;          // minimum number of milliseconds between data transmissions
        this.msAutoRepeat    = 500;
        this.msNextRepeat    = 100;
        this.msAutoRelease   = 50;
        this.msInjectDefault = 100;         // number of milliseconds between injected keystrokes
        this.msInjectDelay   = 0;           // set by the initial injectKeys() call
        this.msDoubleClick   = 250;         // used by mousedown/mouseup handlers to soft-lock modifier keys
        this.cKeysPressed    = 0;           // count of keys pressed since the last time it was reset
        this.softCodeKeys    = Object.keys(Keyboard.SOFTCODES);

        /*
         * Remove all single-character SOFTCODE keys from the softCodeKeys array, because those SOFTCODES
         * are not supported by injectKeys(); they can be specified normally using their single-character identity.
         */
        for (let i = 0; i < this.softCodeKeys.length; i++) {
            if (this.softCodeKeys[i].length < 2) {
                this.softCodeKeys.splice(i, 1);
                i--;
            }
        }

        /*
         * autoType records the machine's specified autoType sequence, if any, and when injectInit() is called
         * with the appropriate INJECTION signal, injectInit() pass autoType to injectKeys().
         */
        this.autoType = parmsKbd['autoType'];
        this.fDOSReady = false;
        this.fnDOSReady = this.fnInjectReady = null;
        this.nInjection = Keyboard.INJECTION.ON_INPUT;

        /*
         * HACK: We set fAllDown to false to ignore all down/up events for keys not explicitly marked as ONDOWN;
         * even though that prevents those keys from being repeated properly (ie, at the simulation's repeat rate
         * rather than the browser's repeat rate), it's the safest thing to do when dealing with international keyboards,
         * because our mapping tables are designed for US keyboards, and testing all the permutations of international
         * keyboards and web browsers is more work than I can take on right now.  TODO: Dig into this some day.
         */
        this.fAllDown = false;

        this['exports'] = {
            'type':         this.injectKeys,
            'wait':         this.waitReady
        };

        this.setReady();
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {Keyboard}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "esc")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let kbd = this;
        let className;
        let id = sHTMLType + '-' + sBinding;
        let controlText = /** @type {HTMLTextAreaElement} */ (control);

        if (this.bindings[id] === undefined) {
            switch (sBinding) {
            case "keyboard":
                try {
                    /*
                     * TODO: Fix this rather fragile code, which depends on the current structure of the given xxxx-softkeys.xml
                     */
                    let controlSoftKeyboard = control.parentElement.parentElement.nextElementSibling;
                    className = controlSoftKeyboard.className;
                    if (this.fMobile != (className.indexOf('mobile') >= 0)) {
                        controlSoftKeyboard = controlSoftKeyboard.nextElementSibling;
                    }
                    if (controlSoftKeyboard) {
                        this.controlSoftKeyboard = controlSoftKeyboard;
                        if (this.fSoftKeyboard != null) {
                            this.enableSoftKeyboard(this.fSoftKeyboard);
                        } else {
                            this.fSoftKeyboard = (controlSoftKeyboard.style.display != "none");
                        }
                        control.onclick = function onToggleKeyboard(event) {
                            kbd.enableSoftKeyboard(!kbd.fSoftKeyboard);
                        };
                        /*
                         * This is added simply to prevent the page from "zooming" around if you accidentally touch between the keys.
                         */
                        if ('ontouchstart' in window) {
                            controlSoftKeyboard.ontouchstart = function onTouchKeyboard(event) {
                                event.preventDefault();
                            };
                        }
                    }
                } catch(err) {}
                return true;

            case "screen":
                /*
                 * This is a special binding that the Video component uses to effectively bind its screen to the
                 * entire keyboard; eg:
                 *
                 *      this.kbd.setBinding(this.inputTextArea? "textarea" : "canvas", "screen", this.inputScreen);
                 *
                 * Recording the binding ID prevents multiple controls (or components) from attempting to erroneously
                 * bind a control to the same ID, but in the case of a "dual display" configuration, we actually want
                 * to allow BOTH video components to call setBinding() for "screen", so that it doesn't matter which
                 * display the user gives focus to.
                 *
                 *      this.bindings[id] = control;
                 */
                if (sHTMLType == "textarea") {
                    this.controlTextKeyboard = controlText;
                }
                controlText.onkeydown = function onKeyDown(event) {
                    return kbd.onKeyChange(event, true);
                };
                controlText.onkeypress = function onKeyPressKbd(event) {
                    return kbd.onKeyPress(event);
                };
                controlText.onkeyup = function onKeyUp(event) {
                    return kbd.onKeyChange(event, false);
                };
                return true;

            case "caps-lock":
                if (sHTMLType == 'led') {
                    this.bindings[id] = control;
                    control.onclick = function onClickCapsLock(event) {
                        event.preventDefault();
                        if (kbd.cmp) kbd.cmp.updateFocus();
                        return kbd.toggleCapsLock();
                    };
                    return true;
                }
                /* falls through */

            case "num-lock":
                if (sHTMLType == 'led') {
                    this.bindings[id] = control;
                    control.onclick = function onClickNumLock(event) {
                        event.preventDefault();
                        if (kbd.cmp) kbd.cmp.updateFocus();
                        return kbd.toggleNumLock();
                    };
                    return true;
                }
                /* falls through */

            case "scroll-lock":
                if (sHTMLType == 'led') {
                    this.bindings[id] = control;
                    control.onclick = function onClickScrollLock(event) {
                        event.preventDefault();
                        if (kbd.cmp) kbd.cmp.updateFocus();
                        return kbd.toggleScrollLock();
                    };
                    return true;
                }
                /* falls through */

            default:
                /*
                 * Maintain support for older button codes; eg, map button code "ctrl-c" to CLICKCODE "CTRL_C"
                 */
                let sCode = sBinding.toUpperCase().replace(/-/g, '_');
                if (Keyboard.CLICKCODES[sCode] !== undefined && sHTMLType == "button") {
                    this.bindings[id] = controlText;
                    if (MAXDEBUG) console.log("binding click-code '" + sCode + "'");
                    controlText.onclick = function(kbd, sKey, simCode) {
                        return function onKeyboardBindingClick(event) {
                            if (kbd.messageEnabled()) kbd.printMessage(sKey + " clicked", Messages.EVENT | Messages.KEY);
                            event.preventDefault();                 // preventDefault() is necessary...
                            if (kbd.cmp) kbd.cmp.updateFocus();     // ...for the updateFocus() call to actually work
                            kbd.sInjectBuffer = "";                 // key events should stop any injection currently in progress
                            kbd.updateShiftState(simCode, true);    // future-proofing if/when any LOCK keys are added to CLICKCODES
                            kbd.addActiveKey(simCode, true);
                        };
                    }(this, sCode, Keyboard.CLICKCODES[sCode]);
                    return true;
                }
                else if (Keyboard.SOFTCODES[sBinding] !== undefined) {
                    /*
                     * TODO: Fix this rather fragile code, which depends on the current structure of the given xxxx-softkeys.xml
                     */
                    className = control.parentElement.parentElement.className;
                    if (className && this.fMobile != (className.indexOf('mobile') >= 0)) {
                        break;
                    }
                    this.cSoftCodes++;
                    this.bindings[id] = controlText;
                    if (MAXDEBUG) console.log("binding soft-code '" + sBinding + "'");
                    let msLastEvent = 0, nClickState = 0;
                    let fStateKey = (Keyboard.KEYSTATES[Keyboard.SOFTCODES[sBinding]] <= Keyboard.STATE.ALL_MODIFIERS);
                    let fnDown = function(kbd, sKey, simCode) {
                        return function onKeyboardBindingDown(event) {
                            let msDelta = event.timeStamp - msLastEvent;
                            nClickState = (nClickState && msDelta < kbd.msDoubleClick? (nClickState << 1) : 1);
                            msLastEvent = event.timeStamp;
                            event.preventDefault();                 // preventDefault() is necessary to avoid "zooming" when you type rapidly
                            kbd.sInjectBuffer = "";                 // key events should stop any injection currently in progress
                            kbd.addActiveKey(simCode);
                        };
                    }(this, sBinding, Keyboard.SOFTCODES[sBinding]);
                    let fnUp = function(kbd, sKey, simCode) {
                        return function onKeyboardBindingUp(event) {
                            if (nClickState) {
                                let msDelta = event.timeStamp - msLastEvent;
                                nClickState = (fStateKey && msDelta < kbd.msDoubleClick? (nClickState << 1) : 0);
                                msLastEvent = event.timeStamp;
                                if (nClickState < 8) {
                                    kbd.removeActiveKey(simCode);
                                } else {
                                    if (MAXDEBUG) console.log("soft-locking '" + sBinding + "'");
                                    nClickState = 0;
                                }
                            }
                        };
                    }(this, sBinding, Keyboard.SOFTCODES[sBinding]);
                    if ('ontouchstart' in window) {
                        controlText.ontouchstart = fnDown;
                        controlText.ontouchend = fnUp;
                    } else {
                        controlText.onmousedown = fnDown;
                        controlText.onmouseup = controlText.onmouseout = fnUp;
                    }
                    return true;
                }
                else if (sValue) {
                    /*
                     * Instead of just having a dedicated "test" control, we now treat any unrecognized control with
                     * a "value" attribute as a test control.  The only caveat is that such controls must have binding IDs
                     * that do not conflict with predefined controls (which, of course, is the only way you can get here).
                     */
                    this.bindings[id] = control;
                    control.onclick = function onClickTest(event) {
                        event.preventDefault();                     // preventDefault() is necessary...
                        if (kbd.cmp) kbd.cmp.updateFocus();         // ...for the updateFocus() call to actually work
                        return kbd.injectKeys(sValue);
                    };
                    return true;
                }
                break;
            }
        }
        return false;
    }

    /**
     * findBinding(simCode, sType, fDown)
     *
     * TODO: This function is woefully inefficient, because the SOFTCODES table is designed for converting
     * soft key presses into SIMCODES, whereas this function is doing the reverse: looking for the soft key,
     * if any, that corresponds to a SIMCODE, simply so we can provide visual feedback of keys activated
     * by other means (eg, real keyboard events, button clicks that generate key sequences like CTRL-ALT-DEL,
     * etc).
     *
     * To minimize this function's cost, we would want to dynamically create a reverse-lookup table after
     * all the setBinding() calls for the soft keys have been established; note that the reverse-lookup table
     * would contain MORE entries than the SOFTCODES table, because there are multiple simCodes that correspond
     * to a given soft key (eg, '1' and '!' both map to the same soft key).
     *
     * @this {Keyboard}
     * @param {number} simCode
     * @param {string} sType is the type of control (eg, "button" or "key")
     * @param {boolean} [fDown] is true if the key is going down, false if up, or undefined if unchanged
     * @return {Object} is the HTML control DOM object (eg, HTMLButtonElement), or undefined if no such control exists
     */
    findBinding(simCode, sType, fDown)
    {
        let control;
        if (this.cSoftCodes && this.fSoftKeyboard) {
            for (let code in Keys.SHIFTED_KEYCODES) {
                if (simCode == Keys.SHIFTED_KEYCODES[code]) {
                    simCode = +code;
                    code = Keys.NONASCII_KEYCODES[code];
                    if (code) simCode = +code;
                    break;
                }
            }
            /*
             * TODO: Create a table that maps these SIMCODEs to the corresponding entries in the SOFTCODES table;
             * these SIMCODEs can be generated by CLICKCODEs or by the special key remapping HACKs in onKeyChange().
             */
            if (simCode == Keyboard.SIMCODE.CTRL_PAUSE) {
                simCode = Keyboard.SIMCODE.NUM_LOCK;
            }
            else if (simCode == Keyboard.SIMCODE.CTRL_BREAK) {
                simCode = Keyboard.SIMCODE.SCROLL_LOCK;
            }
            else if (simCode == Keyboard.SIMCODE.CTRL_ALT_DEL) {
                simCode = Keyboard.SIMCODE.DEL;
            }
            else if (simCode == Keyboard.SIMCODE.CTRL_ALT_INS) {
                simCode = Keyboard.SIMCODE.INS;
            }
            else if (simCode == Keyboard.SIMCODE.CTRL_ALT_ADD) {
                simCode = Keyboard.SIMCODE.NUM_ADD;
            }
            else if (simCode == Keyboard.SIMCODE.CTRL_ALT_SUB) {
                simCode = Keyboard.SIMCODE.NUM_SUB;
            }
            for (let sBinding in Keyboard.SOFTCODES) {
                if (Keyboard.SOFTCODES[sBinding] == simCode || Keyboard.SOFTCODES[sBinding] == this.toUpperKey(simCode)) {
                    let id = sType + '-' + sBinding;
                    control = this.bindings[id];
                    if (control && fDown !== undefined) {
                        this.setSoftKeyState(control, fDown);
                    }
                    break;
                }
            }
        }
        return control;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {Keyboard}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;

        let kbd = this;
        this.timerInject = this.cpu.addTimer(this.id + ".inject", function injectKeysTimer() {
            kbd.injectKeys();
        });

        this.timerTransmit = this.cpu.addTimer(this.id + ".transmit", function transmitDataTimer() {
            kbd.transmitData();
        });

        this.chipset = cmp.getMachineComponent("ChipSet");
        this.autoType = cmp.getMachineParm('autoType') || this.autoType;

        let softKeys = cmp.getMachineParm('softKeys');
        if (softKeys) this.enableSoftKeyboard(softKeys != "false");

        cpu.addIntNotify(Interrupts.DOS, this.intDOS.bind(this));
    }

    /**
     * start()
     *
     * Notification from the Computer that it's starting.
     *
     * @this {Keyboard}
     */
    start()
    {
        this.injectInit(Keyboard.INJECTION.ON_START);
    }

    /**
     * intDOS()
     *
     * Monitors selected DOS interrupts for signals to initialize 'autoType' injection.
     *
     * @this {Keyboard}
     * @param {number} addr
     * @return {boolean} true to proceed with the INT 0x21 software interrupt, false to skip
     */
    intDOS(addr)
    {
        let AH = (this.cpu.regEAX >> 8) & 0xff;
        if (AH == 0x0A) {
            this.fDOSReady = true;
            if (this.fnDOSReady) {
                this.fnDOSReady();
                this.fnDOSReady = null;
                this.fDOSReady = false;
            } else {
                this.injectInit(Keyboard.INJECTION.ON_INPUT);
            }
        }
        return true;
    }

    /**
     * notifyEscape(fDisabled, fAllDown)
     *
     * When ESC is used by the browser to disable pointer lock, this gives us the option of mapping a different key to ESC.
     *
     * @this {Keyboard}
     * @param {boolean} fDisabled
     * @param {boolean} [fAllDown] (an experimental option to re-enable processing of all onkeydown/onkeyup events)
     */
    notifyEscape(fDisabled, fAllDown)
    {
        this.fEscapeDisabled = fDisabled;
        if (fAllDown !== undefined) this.fAllDown = fAllDown;
    }

    /**
     * resetDevice()
     *
     * @this {Keyboard}
     */
    resetDevice()
    {
        /*
         * TODO: There's more to reset, like LED indicators, default type rate, and emptying the scan code buffer.
         */
        this.printMessage("keyboard reset", Messages.KBD | Messages.PORT);
        this.abBuffer = [];
        this.setResponse(Keyboard.CMDRES.BAT_OK);
    }

    /**
     * setModel(sModel)
     *
     * This breaks a model string (eg, "US83") into two parts: modelCountry (eg, "US") and modelKeys (eg, 83).
     * If the model string isn't recognized, we use Keyboard.MODELS[0] (ie, the first entry in the model array).
     *
     * @this {Keyboard}
     * @param {string|undefined} sModel
     */
    setModel(sModel)
    {
        let iModel = 0;
        this.model = null;
        if (typeof sModel == "string") {
            this.model = sModel.toUpperCase();
            iModel = Keyboard.MODELS.indexOf(this.model);
            if (iModel < 0) iModel = 0;
        }
        sModel = Keyboard.MODELS[iModel];
        if (sModel) {
            this.modelCountry = sModel.substr(0, 2);
            this.modelKeys = parseInt(sModel.substr(2), 10);
        }
    }

    /**
     * checkBuffer(b)
     *
     * This is the ChipSet's interface to let us know it's ready.
     *
     * @this {Keyboard}
     * @param {number} [b] (set to the data, if any, that the ChipSet just delivered)
     */
    checkBuffer(b)
    {
        let fReady = false;
        if (b) {
            /*
             * The following hack is for the 5170 ROM BIOS keyboard diagnostic, which expects the keyboard
             * to report BAT_OK immediately after the ACK from a RESET command.  The BAT_OK response should already
             * be in the keyboard's buffer; we just need to give it a little nudge.
             */
            if (b == Keyboard.CMDRES.ACK) {
                fReady = true;
            }
            if (this.cpu) {
                this.cpu.setTimer(this.timerTransmit, this.msTransmit, true);
            }
        }
        this.transmitData(fReady);
    }

    /**
     * flushBuffer()
     *
     * This is the ChipSet's interface to flush any buffered keyboard data.
     *
     * @this {Keyboard}
     */
    flushBuffer()
    {
        this.abBuffer = [];
        if (!COMPILED && this.messageEnabled()) this.printMessage("keyboard data flushed");
    }

    /**
     * receiveCmd(bCmd)
     *
     * This is the ChipSet's interface for controlling "Model M" keyboards (ie, those used with MODEL_5170
     * machines).  Commands are delivered through the ChipSet's 8042 Keyboard Controller.
     *
     * @this {Keyboard}
     * @param {number} bCmd should be one of the Keyboard.CMD.* command codes (Model M keyboards only)
     * @return {number} response should be one of the Keyboard.CMDRES.* response codes, or -1 if unrecognized
     */
    receiveCmd(bCmd)
    {
        let b = -1;

        if (!COMPILED && this.messageEnabled()) this.printMessage("receiveCmd(" + Str.toHexByte(bCmd) + ")");

        switch(this.bCmdPending || bCmd) {

        case Keyboard.CMD.RESET:            // 0xFF
            b = Keyboard.CMDRES.ACK;
            this.resetDevice();
            break;

        case Keyboard.CMD.SET_RATE:         // 0xF3
            if (this.bCmdPending) {
                this.setRate(bCmd);
                bCmd = 0;
            }
            this.setResponse(Keyboard.CMDRES.ACK);
            this.bCmdPending = bCmd;
            break;

        case Keyboard.CMD.SET_LEDS:         // 0xED
            if (this.bCmdPending) {
                this.setLEDs(bCmd);
                bCmd = 0;
            }
            this.setResponse(Keyboard.CMDRES.ACK);
            this.bCmdPending = bCmd;
            break;

        default:
            if (!COMPILED) this.printMessage("receiveCmd(): unrecognized command");
            break;
        }

        return b;
    }

    /**
     * setEnabled(fData, fClock)
     *
     * This is the ChipSet's interface for toggling keyboard "data" and "clock" lines.
     *
     * For MODEL_5150 and MODEL_5160 machines, this function is called from the ChipSet's PPI_B
     * output handler.  For MODEL_5170 machines, this function is called when selected CMD
     * "data bytes" have been written.
     *
     * @this {Keyboard}
     * @param {boolean} fData is true if the keyboard simulated data line should be enabled
     * @param {boolean} fClock is true if the keyboard's simulated clock line should be enabled
     * @return {boolean} true if keyboard was re-enabled, false if not (or no change)
     */
    setEnabled(fData, fClock)
    {
        let fReset = false;
        if (this.fClock !== fClock) {
            if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.PORT)) {
                this.printMessage("keyboard clock line changing to " + fClock, true);
            }
            /*
             * Toggling the clock line low and then high signals a "reset", which we acknowledge once the
             * data line is high as well.
             */
            this.fClock = this.fResetOnEnable = fClock;
        }
        if (this.fData !== fData) {
            if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.PORT)) {
                this.printMessage("keyboard data line changing to " + fData, true);
            }
            this.fData = fData;
            if (fData && !this.fResetOnEnable) {
                this.transmitData(true);
            }
        }
        if (this.fData && this.fResetOnEnable) {
            this.resetDevice();
            this.fResetOnEnable = false;
            fReset = true;
        }
        return fReset;
    }

    /**
     * setLEDs(b)
     *
     * This processes the option byte received after a SET_LEDS command byte.
     *
     * @this {Keyboard}
     * @param {number} b
     */
    setLEDs(b)
    {
        this.bLEDs = b;             // TODO: Implement
    }

    /**
     * setRate(b)
     *
     * This processes the rate parameter byte received after a SET_RATE command byte.
     *
     * @this {Keyboard}
     * @param {number} b
     */
    setRate(b)
    {
        this.bRate = b;             // TODO: Implement
    }

    /**
     * setResponse(b)
     *
     * @this {Keyboard}
     * @param {number} b
     */
    setResponse(b)
    {
        if (this.chipset) {
            this.abBuffer.unshift(b);
            if (!COMPILED && this.messageEnabled()) this.printMessage("keyboard response " + Str.toHexByte(b) + " buffered");
            this.transmitData();
        }
    }

    /**
     * transmitData(fReady)
     *
     * This manages communication with the ChipSet's receiveKbdData() interface.
     *
     * @this {Keyboard}
     * @param {boolean} [fReady]
     */
    transmitData(fReady)
    {
        if (this.chipset) {
            if (fReady || !this.cpu.isTimerSet(this.timerTransmit)) {
                /*
                 * The original IBM PC BIOS performs a "stuck key" test by resetting the keyboard
                 * (by toggling the CLOCK line), then checking for a BAT_OK response (0xAA), and then
                 * clocking in the next byte (by toggling the DATA line); if that next byte isn't 0x00,
                 * then the BIOS reports a "301" error, along with "AA" if we failed to properly flush
                 * the BAT_OK response.
                 */
                let b = this.abBuffer.length? this.abBuffer[0] : 0;
                if (this.chipset.receiveKbdData(b)) {
                    if (!COMPILED && this.messageEnabled()) this.printMessage("keyboard data " + Str.toHexByte(b) + " delivered");
                    this.abBuffer.shift();
                }
                if (b) this.cpu.setTimer(this.timerTransmit, this.msTransmit);
            }
        }
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Keyboard}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            /*
             * TODO: Save/restore support for Keyboard is the barest minimum.  In fact, originally, I wasn't
             * saving/restoring anything, and that was OK, but if we don't at least re-initialize fClock/fData,
             * we can get a spurious reset following a restore.  In an ideal world, we might choose to save/restore
             * abBuffer as well, but realistically, I think it's going to be safer to always start with an
             * empty buffer--and who's going to notice anyway?
             *
             * So, like Debugger, we deviate from the typical save/restore pattern: instead of reset OR restore,
             * we always reset and then perform a (very limited) restore.
             */
            this.reset();
            if (data && this.restore) {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Keyboard}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {Keyboard}
     */
    reset()
    {
        /*
         * If no keyboard model was specified, our initial setModel() call will select the "US83" keyboard as the
         * default, but now that the ChipSet is initialized, we can pick a better default, based on the ChipSet model.
         */
        if (!this.model && this.chipset) {
            switch(this.chipset.model) {
            case ChipSet.MODEL_5150:
            case ChipSet.MODEL_5160:
                this.setModel(Keyboard.MODELS[0]);
                break;
            case ChipSet.MODEL_5170:
            default:
                this.setModel(Keyboard.MODELS[1]);
                break;
            }
        }
        this.initState();
    }

    /**
     * save()
     *
     * This implements save support for the Keyboard component.
     *
     * @this {Keyboard}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveState());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the Keyboard component.
     *
     * @this {Keyboard}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initState(data[0]);
    }

    /**
     * initState(data)
     *
     * @this {Keyboard}
     * @param {Array} [data]
     * @return {boolean} true if successful, false if failure
     */
    initState(data)
    {
        if (!data) {
            data = [false, false, Keyboard.INJECTION.ON_INPUT];
        } else {
            /*
             * If there is a predefined state for this machine, then the assumption is that any injection
             * sequence can be injected as soon as the machine starts.  Any other kind of state must disable
             * injection, because injection depends on the machine being in a known state.
             */
            data[2] = this.cmp.sStatePath? Keyboard.INJECTION.ON_START : (data[2] || Keyboard.INJECTION.NONE);
        }

        let i = 0;
        this.fClock = data[i++];
        this.fData = data[i++];
        this.nInjection = data[i++];
        this.sInjectBuffer = data[i++] || "";
        this.msInjectDelay = data[i] || this.msInjectDefault;

        this.bCmdPending = 0;       // when non-zero, a command is pending (eg, SET_LED or SET_RATE)

        /*
         * The current (assumed) physical (and simulated) modifier/lock key states, along with a set
         * of (fake) modifier key states maintained by simulateKey() to keep track of faked modifiers.
         *
         * TODO: Determine how (or whether) we can query the browser's initial shift/lock key states.
         */
        this.bitsState = this.bitsStateSim = this.bitsStateFake = 0;

        /*
         * New scan codes are "pushed" onto abBuffer and then "shifted" off.
         */
        this.abBuffer = [];

        return true;
    }

    /**
     * saveState()
     *
     * @this {Keyboard}
     * @return {Array}
     */
    saveState()
    {
        let data = [], i = 0;
        data[i++] = this.fClock;
        data[i++] = this.fData;
        data[i++] = this.nInjection;
        data[i++] = this.sInjectBuffer;
        data[i] = this.msInjectDelay;
        return data;
    }

    /**
     * enableSoftKeyboard(fEnable)
     *
     * In addition to enabling or disabling our own soft keyboard (if any), this also attempts to disable or enable
     * (as appropriate) the textarea control (if any) that machines use to trigger a touch device's built-in keyboard.
     *
     * @this {Keyboard}
     * @param {boolean} fEnable
     */
    enableSoftKeyboard(fEnable)
    {
        if (this.controlSoftKeyboard) {
            if (!fEnable) {
                this.controlSoftKeyboard.style.display = "none";
                if (this.controlTextKeyboard) {
                    this.controlTextKeyboard.readOnly = false;
                }
            } else {
                this.controlSoftKeyboard.style.display = "block";
                if (this.controlTextKeyboard) {
                    this.controlTextKeyboard.readOnly = true;
                }
            }
        }
        this.fSoftKeyboard = fEnable;
    }

    /**
     * setSoftKeyState(control, f)
     *
     * @this {Keyboard}
     * @param {HTMLElement} control is an HTML control DOM object
     * @param {boolean} f is true if the key represented by e should be "on", false if "off"
     */
    setSoftKeyState(control, f)
    {
        control.style.color = (f? "#ffffff" : "#000000");
        control.style.backgroundColor = (f? "#000000" : "#ffffff");
    }

    /**
     * addScanCode(bScan)
     *
     * @this {Keyboard}
     * @param {number} bScan
     */
    addScanCode(bScan)
    {
        /*
         * Prepare for the possibility that our reset() function may not have been called yet.
         *
         * TODO: Determine whether we need to reset() the Keyboard sooner (ie, in the constructor),
         * or if we need to protect other methods from prematurely accessing certain Keyboard structures,
         * as a result of calls from any of the key event handlers established by setBinding().
         */
        if (this.abBuffer) {
            if (this.abBuffer.length < Keyboard.LIMIT.MAX_SCANCODES) {
                if (DESKPRO386) {
                    if (this.chipset && this.chipset.model == ChipSet.MODEL_COMPAQ_DESKPRO386) {
                        /*
                         * COMPAQ keyclick support is being disabled because we are currently unable to properly
                         * simulate the keyclick sound, due to the way the COMPAQ DeskPro 386 ROM rapidly toggles
                         * the speaker bit.  And there isn't really a better time to disable it, because the
                         * COMPAQ_KEYCLICK byte is set by IBMBIO.COM initialization code in COMPAQ MS-DOS, if the
                         * machine model byte is FC (indicating PC AT):
                         *
                         *      &0070:2EF7 2E               CS:
                         *      &0070:2EF8 803E442DFC       CMP      [2D44],FC
                         *      &0070:2EFD 750C             JNZ      2F0B (IBMBIO.COM+0x3174)
                         *      &0070:2EFF 26               ES:
                         *      &0070:2F00 C606160401       MOV      [0416],01
                         */
                        if (!this.cpu.isProtMode()) {
                            this.bus.setByteDirect(ROMX86.BIOS.COMPAQ_KEYCLICK, 0);
                        }
                    }
                }
                this.abBuffer.push(bScan);
                if (!COMPILED && this.messageEnabled()) this.printMessage("keyboard data " + Str.toHexByte(bScan) + " buffered");
                this.transmitData();
                return;
            }
            if (this.abBuffer.length == Keyboard.LIMIT.MAX_SCANCODES) {
                this.abBuffer.push(Keyboard.CMDRES.BUFF_FULL);
            }
            this.printMessage("keyboard buffer overflow");
        }
    }

    /**
     * injectInit(nCondition)
     *
     * @this {Keyboard}
     * @param {number} nCondition
     */
    injectInit(nCondition)
    {
        if (this.nInjection == nCondition) {
            this.nInjection = Keyboard.INJECTION.NONE;
            if (this.autoType) this.injectKeys(this.autoType);
        }
    }

    /**
     * injectKeys(sKeys, msDelay)
     *
     * @this {Keyboard}
     * @param {string} [sKeys]
     * @param {number} [msDelay] is an optional injection delay (default is msInjectDefault)
     * @return {boolean}
     */
    injectKeys(sKeys, msDelay)
    {
        if (sKeys) {
            let sInjectBuffer = this.parseKeys(sKeys);
            if (sInjectBuffer) {
                this.nInjection = Keyboard.INJECTION.NONE;
                this.sInjectBuffer = sInjectBuffer;
                if (!COMPILED) this.log("injectKeys(\"" + this.sInjectBuffer.split("\n").join("\\n") + "\")");
                this.msInjectDelay = msDelay || this.msInjectDefault;
                this.injectKeys();
                return true;
            }
            return false;
        }
        /*
         * Any delay of one second or more ($10 and up) is automatically reverted to the default.
         */
        if (this.msInjectDelay >= 1000) {
            this.msInjectDelay = this.msInjectDefault;
        }
        let simCode = 0;
        while (this.sInjectBuffer.length > 0 && !simCode) {
            let ch = this.sInjectBuffer.charAt(0);
            if (ch == '$') {
                /*
                 * $<number> pauses injection by the specified number of tenths of a second; eg,
                 * $5 pauses for 1/2 second.  $0 reverts the default injection delay (eg, 100ms).
                 * Also, you may end the number with a period if you need to avoid an injected digit
                 * being misinterpreted as part of the delay (eg, $5.1) pauses for 1/2 second and
                 * then injects "1").
                 */
                let digits = this.sInjectBuffer.match(/^\$([0-9]+)\.?/);
                if (digits) {
                    this.msInjectDelay = (+digits[1] * 100) || this.msInjectDefault;
                    this.sInjectBuffer = this.sInjectBuffer.substr(digits[0].length);
                    break;
                }
                /*
                 * Yes, this code is slow and gross, but it's simple, and key injection doesn't have
                 * to be that fast anyway.  The added check for SOFTCODES that have omitted the 'num-'
                 * prefix adds to the slowness, but it's a nice convenience, allowing you to specify
                 * non-ASCII keys like 'num-right' or 'num-up' more succinctly as  "$right" or "$up".
                 */
                for (let i = 0; i < this.softCodeKeys.length; i++) {
                    let name = this.softCodeKeys[i];
                    if (this.sInjectBuffer.indexOf(name) == 1) {
                        simCode = Keyboard.SOFTCODES[name];
                        this.sInjectBuffer = this.sInjectBuffer.substr(name.length + 1);
                        break;
                    }
                    let shortName = (name.indexOf('num-') == 0? name.substr(4) : "");
                    if (shortName && this.sInjectBuffer.indexOf(shortName) == 1) {
                        simCode = Keyboard.SOFTCODES[name];
                        this.sInjectBuffer = this.sInjectBuffer.substr(shortName.length + 1);
                        break;
                    }
                }
            }
            if (simCode) break;
            this.sInjectBuffer = this.sInjectBuffer.substr(1);
            let charCode = ch.charCodeAt(0);
            /*
             * charCodes 0x01-0x1A correspond to key combinations CTRL-A through CTRL-Z, unless they
             * are \t, \n, or \r, which are reserved for TAB, LINE-FEED, and RETURN, respectively, so if
             * you need to simulate CTRL-I, CTRL-J, or CTRL-M, those must be specified using \x1C, \x1D,
             * or \x1E, respectively.  Also, since PCs have no dedicated LINE-FEED key, and since \n is
             * often used instead of \r, we map LINE-FEED (LF) to RETURN (CR) below.
             */
            if (charCode <= Keys.ASCII.CTRL_Z) {
                simCode = charCode;
                /*
                 * I could require all callers to supply CRs instead of LFs, but this is friendlier; besides,
                 * PCs don't have a dedicated LINE-FEED key, so the LF charCode is somewhat meaningless.
                 */
                if (charCode == 0x0A) simCode = 0x0D;
                if (charCode != Keys.ASCII.CTRL_I && charCode != Keys.ASCII.CTRL_J && charCode != Keys.ASCII.CTRL_M) {
                    simCode += Keys.KEYCODE.FAKE;
                }
            }
            else if (charCode == 0x1C) {
                simCode = Keys.ASCII.CTRL_I + Keys.KEYCODE.FAKE;
            }
            else if (charCode == 0x1D) {
                simCode = Keys.ASCII.CTRL_J + Keys.KEYCODE.FAKE;
            }
            else if (charCode == 0x1E) {
                simCode = Keys.ASCII.CTRL_M + Keys.KEYCODE.FAKE;
            }
            else if (charCode == 0x1F) {
                simCode = Keys.ASCII['$'];
            }
            else if (charCode <= 0x7F) {
                simCode = charCode;
            }
        }

        if (simCode) {
            let fPress = (Keyboard.MODIFIERS[simCode] === undefined);
            this.addActiveKey(simCode, fPress);
            if (fPress) this.clearActiveKeys(true);
        }

        if (!this.sInjectBuffer.length) {
            if (this.fnInjectReady) {
                this.fnInjectReady();
                this.fnInjectReady = null;
            }
        } else {
            this.cpu.setTimer(this.timerInject, this.msInjectDelay);
        }
        return true;
    }

    /**
     * parseKeys(sKeys)
     *
     * The following special "macro" sequences are recognized:
     *
     *      $date:  converted to MM-DD-YYYY
     *      $time:  converted to HH:MM
     *
     * In addition, property keys in the SOFTCODES tables can be prefixed with "$" if you want to specify
     * a key by its SOFTCODE; eg:
     *
     *      $f1:    the F1 function key
     *      $alt:   the ALT key
     *
     * Not all SOFTCODES are allowed; for example, SOFTCODES that begin with a digit or other non-alpha symbol,
     * or that contain only one letter, because those SOFTCODES can already be specified as-is, WITHOUT a leading
     * "$".  Also, all we replace here are the "macro" sequences, leaving any prefixed SOFTCODES in place so that
     * injectKeys() can convert them on the fly.
     *
     * If you want any of those sequences to be typed as-is, then you must specify two "$" (eg, "$$date").
     * Pairs of dollar signs will be automatically converted to single dollar signs, and single dollar signs
     * will be used as-is, provided they don't precede any of the above "macro" or SOFTCODE sequences.
     *
     * WARNING: the JavaScript replace() function ALWAYS interprets "$" specially in replacement strings,
     * even when the search string is NOT a RegExp; specifically:
     *
     *      $$  Inserts a "$"
     *      $&  Inserts the matched substring
     *      $`  Inserts the portion of the string that precedes the matched substring
     *      $'  Inserts the portion of the string that follows the matched substring
     *      $n  Where n is a positive integer less than 100, inserts the nth parenthesized sub-match string,
     *          provided the first argument was a RegExp object
     *
     * Since we build machine definitions on a page from a potentially indeterminate number of string replace()
     * operations, multiple dollar signs could eventually get reduced to a single dollar sign BEFORE we get here.
     *
     * To compensate, I've changed a few replace() methods, like MarkOut's convertMDMachineLinks() and HTMLOut's
     * addFilesToHTML(), from the conventional string replace() to my own Str.replace(), and for situations like the
     * embed.js parseXML() function, which needs to use a RegExp-style replace(), I've added a preliminary
     * replace(/\$/g, "$$$$") to the replacement string.
     *
     * Unfortunately, this is something that will be extremely difficult to prevent from breaking down the road.
     * So, heads up to future me....
     *
     * @this {Keyboard}
     * @param {string|undefined} sKeys
     * @return {string|undefined}
     */
    parseKeys(sKeys)
    {
        if (sKeys) {
            let match, reSpecial = /(?:^|[^$])\$([a-z0-9][a-z0-9-]+)/g;
            while (match = reSpecial.exec(sKeys)) {
                let sReplace = "";
                if (reSpecial.lastIndex) reSpecial.lastIndex--;
                switch (match[1]) {
                case 'date':
                    sReplace = Usr.formatDate("n-j-Y");
                    break;
                case 'time':
                    sReplace = Usr.formatDate("h:i:s");
                    break;
                default:
                    continue;
                }
                sKeys = sKeys.replace('$' + match[1], sReplace);
            }
            /*
             * Any lingering "$$" sequences are now converted to a special code (\x1F) that injectKeys() knows about.
             */
            sKeys = sKeys.replace(/\$\$/g, '\x1F');
        }
        return sKeys;
    }

    /**
     * waitReady(fnCallReady, sOption)
     *
     * @this {Keyboard}
     * @param {function()|null} fnCallReady
     * @param {string} [sOption]
     * @return {boolean} false if wait required, true otherwise
     */
    waitReady(fnCallReady, sOption)
    {
        let fReady = false;

        switch(sOption) {
        case "DOS":
            if (this.fDOSReady) {
                fReady = true;
            } else {
                this.fnDOSReady = fnCallReady;
            }
            break;

        default:
            if (!this.sInjectBuffer.length) {
                fReady = true;
            } else {
                this.fnInjectReady = fnCallReady;
            }
            break;
        }
        return fReady;
    }

    /**
     * setLED(control, f)
     *
     * @this {Keyboard}
     * @param {HTMLElement} control is an HTML control DOM object
     * @param {boolean} f is true if the LED represented by control should be "on", false if "off"
     */
    setLED(control, f)
    {
        /*
         * TODO: Add support for user-definable LED colors
         */
        control.style.backgroundColor = (f? "#00ff00" : "#000000");
    }

    /**
     * updateLEDs(bitState)
     *
     * Updates any and all shift-related LEDs with the corresponding state in bitsStateSim.
     *
     * @this {Keyboard}
     * @param {number} [bitState] is the bit in bitsStateSim that may have changed, if known; undefined if not
     */
    updateLEDs(bitState)
    {
        let control;
        for (let sBinding in Keyboard.LEDSTATES) {
            let id = "led-" + sBinding;
            let bitLED = Keyboard.LEDSTATES[sBinding];
            if ((!bitState || bitState == bitLED) && (control = this.bindings[id])) {
                this.setLED(control, !!(this.bitsStateSim & bitLED));
            }
        }
    }

    /**
     * toggleCapsLock()
     *
     * @this {Keyboard}
     */
    toggleCapsLock()
    {
        this.addActiveKey(Keyboard.SIMCODE.CAPS_LOCK, true);
    }

    /**
     * toggleNumLock()
     *
     * @this {Keyboard}
     */
    toggleNumLock()
    {
        this.addActiveKey(Keyboard.SIMCODE.NUM_LOCK, true);
    }

    /**
     * toggleScrollLock()
     *
     * @this {Keyboard}
     */
    toggleScrollLock()
    {
        this.addActiveKey(Keyboard.SIMCODE.SCROLL_LOCK, true);
    }

    /**
     * updateShiftState(simCode, fSim, fDown)
     *
     * For non-locking shift keys, this function is straightforward: when fDown is true, the corresponding bitState
     * is set, and when fDown is false, it's cleared.  However, for LOCK keys, fDown true means toggle, and fDown false
     * means no change.
     *
     * @this {Keyboard}
     * @param {number} simCode (includes any ONDOWN and/or ONRIGHT modifiers)
     * @param {boolean} [fSim] is true to update simulated state only
     * @param {boolean|null} [fDown] is true for down, false for up, undefined for toggle
     * @return {number} 0 if not a shift key, 1 if shift key down, -1 if shift key up
     */
    updateShiftState(simCode, fSim, fDown)
    {
        let result = 0;
        if (Keyboard.SIMCODES[simCode]) {
            let fRight = (Math.floor(simCode / 1000) & 2);
            let bitState = Keyboard.KEYSTATES[simCode] || 0;
            if (bitState) {
                if (fRight && !(bitState & Keyboard.STATE.ALL_RIGHT)) {
                    bitState >>= 1;
                }
                if (bitState & Keyboard.STATE.ALL_LOCKS) {
                    if (fDown === false) return -1;
                    fDown = null;
                }
                if (fDown == null) {        // ie, null or undefined
                    fDown = !((fSim? this.bitsStateSim : this.bitsState) & bitState);
                }
                else if (!fDown && !fSim) {
                    /*
                     * In current webkit browsers, pressing and then releasing both left and right shift keys together
                     * (or both ALT keys, or both CMD/Windows keys, or presumably both CTRL keys) results in 4 events,
                     * as you would expect, but 3 of the 4 are "down" events; only the last of the 4 is an "up" event.
                     *
                     * Perhaps this is a browser accessibility feature (ie, deliberately suppressing the "up" event
                     * of one of the shift keys to implement a "sticky shift mode"?), but in any case, to maintain our
                     * internal consistency, if this is an "up" event and the shift state bit is any of ALL_MODIFIERS,
                     * then we set it to ALL_MODIFIERS, so that we'll automatically clear ALL shift states.
                     *
                     * TODO: The only downside to this work-around is that the simulation will still think a shift key is
                     * down.  So in effect, we have enabled a "sticky shift mode" inside the simulation, whether or not that
                     * was the browser's intent.  To fix that, we would have to identify the shift key that never went up
                     * and simulate the "up".  That's more work than I think the problem merits.  The user just needs to tap
                     * a single shift key to get out that mode.
                     */
                    if (bitState & Keyboard.STATE.ALL_MODIFIERS) bitState = Keyboard.STATE.ALL_MODIFIERS;
                }
                if (!fSim) {
                    this.bitsState &= ~bitState;
                    if (fDown) this.bitsState |= bitState;
                } else {
                    /*
                     * This next line reflects the fact that we don't want to modify any simulated LOCK states if a simulated
                     * shift state (ie, CTRL, ALT, SHIFT, etc) is also active.  For example, CTRL-NUM-LOCK is a special sequence
                     * (Pause) that isn't supposed to alter the NUM-LOCK state; similarly, CTRL-SCROLL-LOCK (aka Ctrl-Break)
                     * isn't supposed to alter the SCROLL-LOCK state.
                     */
                    if (!(this.bitsStateSim & Keyboard.STATE.ALL_MODIFIERS) || !(bitState & Keyboard.STATE.ALL_LOCKS)) {
                        this.bitsStateSim &= ~bitState;
                        if (fDown) this.bitsStateSim |= bitState;
                        this.updateLEDs(bitState);
                    }
                }
                result = fDown? 1 : -1;
            }
        }
        return result;
    }

    /**
     * addActiveKey(simCode, fPress)
     *
     * @this {Keyboard}
     * @param {number} simCode
     * @param {boolean} [fPress]
     * @return {boolean} true if added, false if not (eg, not recognized, already added, etc)
     */
    addActiveKey(simCode, fPress)
    {
        let wCode = Keyboard.SIMCODES[simCode] || Keyboard.SIMCODES[simCode += Keys.KEYCODE.ONDOWN];

        if (!wCode) {
            if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.KEY)) {
                this.printMessage("addActiveKey(" + simCode + "," + (fPress? "press" : "down") + "): unrecognized", true);
            }
            return false;
        }

        /*
         * Ignore all active keys if the CPU is not running.
         */
        if (!this.cpu || !this.cpu.isRunning()) return false;

        /*
         * If this simCode is in the KEYSTATE table, then stop all repeating.
         */
        if (Keyboard.KEYSTATES[simCode] && this.aKeysActive.length) {
            if (this.aKeysActive[0].nRepeat > 0) this.aKeysActive[0].nRepeat = 0;
        }

        let i, key;
        for (i = 0; i < this.aKeysActive.length; i++) {
            key = this.aKeysActive[i];
            if (key.simCode == simCode) {
                /*
                 * This key is already active, so if this a "down" request (or a "press" for a key we already
                 * processed as a "down"), ignore it.
                 */
                if (!fPress || key.nRepeat >= 0) {
                    i = -1;
                    break;
                }
                if (i > 0) {
                    if (this.aKeysActive[0].nRepeat > 0) this.aKeysActive[0].nRepeat = 0;
                    this.aKeysActive.splice(i, 1);
                }
                break;
            }
        }

        if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.KEY)) {
            this.printMessage("addActiveKey(" + simCode + "," + (fPress? "press" : "down") + "): " + (i < 0? "already active" : (i == this.aKeysActive.length? "adding" : "updating")), true);
        }

        if (i < 0) return false;

        if (i == this.aKeysActive.length) {
            key = {simCode};                            // create a new Key object
            // key.bitsState = this.bitsState;          // not needed unless we revive checkActiveKeyShift()
            this.findBinding(simCode, "key", true);
            i++;
        }

        if (i > 0) {
            this.aKeysActive.splice(0, 0, key);         // aka aKeysActive.unshift(key)
        }

        key.fDown = true;
        key.nRepeat = (fPress? -1: (Keyboard.KEYSTATES[simCode]? 0 : 1));

        this.updateActiveKey(key);
        return true;
    }

    /**
     * checkActiveKey()
     *
     * @this {Keyboard}
     * @return {number} simCode of active key, 0 if none
     */
    checkActiveKey()
    {
        return this.aKeysActive.length? this.aKeysActive[0].simCode : 0;
    }

    /**
     * isAlphaKey(code)
     *
     * @this {Keyboard}
     * @param {number} code
     * @returns {boolean} true if alpha key, false if not
     */
    isAlphaKey(code)
    {
        return (code >= Keys.ASCII.A && code <= Keys.ASCII.Z || code >= Keys.ASCII.a && code <= Keys.ASCII.z);
    }

    /**
     * toUpperKey(code)
     *
     * @this {Keyboard}
     * @param {number} code
     * @returns {number}
     */
    toUpperKey(code)
    {
        if (code >= Keys.ASCII.a && code <= Keys.ASCII.z) {
            code -= (Keys.ASCII.a - Keys.ASCII.A);
        }
        return code;
    }

    /**
     * clearActiveKeys(fModifiers)
     *
     * Force all active keys to "deactivate" (or, optionally, just any modifiers)
     *
     * @this {Keyboard}
     * @param {boolean} [fModifiers] (true to clear modifier keys only; default is ALL keys)
     */
    clearActiveKeys(fModifiers)
    {
        for (let i = 0; i < this.aKeysActive.length; i++) {
            let key = this.aKeysActive[i];
            if (fModifiers && !Keyboard.MODIFIERS[key.simCode]) continue;
            if (this.removeActiveKey(key.simCode)) i--;
        }
    }

    /**
     * removeActiveKey(simCode, fFlush)
     *
     * @param {number} simCode
     * @param {boolean} [fFlush] is true whenever the key must be removed, independent of other factors
     * @return {boolean} true if successfully removed, false if not
     */
    removeActiveKey(simCode, fFlush)
    {
        if (!Keyboard.SIMCODES[simCode]) {
            if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.KEY)) {
                this.printMessage("removeActiveKey(" + simCode + "): unrecognized", true);
            }
            return false;
        }

        /*
         * Ignore all active keys if the CPU is not running.
         */
        if (!fFlush && (!this.cpu || !this.cpu.isRunning())) return false;

        let fRemoved = false;
        for (let i = 0; i < this.aKeysActive.length; i++) {
            let key = this.aKeysActive[i];
            if (key.simCode == simCode || key.simCode == Keys.SHIFTED_KEYCODES[simCode]) {
                this.aKeysActive.splice(i, 1);
                if (key.timer) clearTimeout(key.timer);
                if (key.fDown && !fFlush) this.simulateKey(key.simCode, false);
                this.findBinding(simCode, "key", false);
                fRemoved = true;
                break;
            }
        }
        if (!COMPILED && !fFlush && this.messageEnabled(Messages.KBD | Messages.KEY)) {
            this.printMessage("removeActiveKey(" + simCode + "): " + (fRemoved? "removed" : "not active"), true);
        }
        if (!this.aKeysActive.length && this.fToggleCapsLock) {
            if (!COMPILED) this.printMessage("removeActiveKey(): inverting caps-lock now", Messages.KBD | Messages.KEY);
            this.updateShiftState(Keyboard.SIMCODE.CAPS_LOCK);
            this.fToggleCapsLock = false;
        }
        return fRemoved;
    }

    /**
     * updateActiveKey(key, msTimer)
     *
     * When called by addActiveKey(), msTimer is undefined; that's used only when we're called by our own timeout handler.
     *
     * @param {Object} key
     * @param {number} [msTimer]
     */
    updateActiveKey(key, msTimer)
    {
        /*
         * All active keys are automatically removed once the CPU stops running.
         */
        if (!this.cpu || !this.cpu.isRunning()) {
            this.removeActiveKey(key.simCode, true);
            return;
        }

        if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.KEY)) {
            this.printMessage("updateActiveKey(" + key.simCode + (msTimer? "," + msTimer + "ms" : "") + "): " + (key.fDown? "down" : "up"), true);
        }

        if (msTimer && key.nRepeat < 0) {
            key.fDown = false;
        }

        if (!this.simulateKey(key.simCode, key.fDown) || !key.nRepeat) {
            /*
             * Why isn't there a simple return here? In order to set breakpoints on two different return conditions, of course!
             */
            if (!msTimer) {
                return;
            }
            return;
        }

        let ms;
        if (key.nRepeat < 0) {
            if (!key.fDown) {
                this.removeActiveKey(key.simCode);
                return;
            }
            ms = this.msAutoRelease;
        }
        else {
            ms = (key.nRepeat++ == 1? this.msAutoRepeat : this.msNextRepeat);
        }

        if (key.timer) {
            clearTimeout(key.timer);
        }

        key.timer = setTimeout(function(kbd) {
            return function onUpdateActiveKey() {
                kbd.updateActiveKey(key, ms);
            };
        }(this), ms);
    }

    /**
     * getSimCode(keyCode)
     *
     * @this {Keyboard}
     * @param {number} keyCode
     * @param {boolean} fShifted
     * @return {number} simCode
     */
    getSimCode(keyCode, fShifted)
    {
        let code;
        let simCode = keyCode;

        if (keyCode >= Keys.ASCII.A && keyCode <= Keys.ASCII.Z) {
            if (!(this.bitsState & (Keyboard.STATE.SHIFT | Keyboard.STATE.RSHIFT | Keyboard.STATE.CAPS_LOCK)) == fShifted) {
                simCode = keyCode + (Keys.ASCII.a - Keys.ASCII.A);
            }
        }
        else if (keyCode >= Keys.ASCII.a && keyCode <= Keys.ASCII.z) {
            if (!!(this.bitsState & (Keyboard.STATE.SHIFT | Keyboard.STATE.RSHIFT | Keyboard.STATE.CAPS_LOCK)) == fShifted) {
                simCode = keyCode - (Keys.ASCII.a - Keys.ASCII.A);
            }
        }
        else if (!!(this.bitsState & (Keyboard.STATE.SHIFT | Keyboard.STATE.RSHIFT)) == fShifted) {
            if (code = Keys.SHIFTED_KEYCODES[keyCode]) {
                simCode = code;
            }
        }
        else {
            if (code = Keys.NONASCII_KEYCODES[keyCode]) {
                simCode = code;
            }
        }
        return simCode;
    }

    /**
     * onFocusChange(fFocus)
     *
     * @this {Keyboard}
     * @param {boolean} fFocus is true if gaining focus, false if losing it
     */
    onFocusChange(fFocus)
    {
        if (!COMPILED && this.fHasFocus != fFocus && this.messageEnabled(Messages.EVENT)) {
            this.printMessage("onFocusChange(" + (fFocus? "true" : "false") + ")", true);
        }
        this.fHasFocus = fFocus;
        /*
         * Since we can't be sure of any shift states after losing focus, we clear them all.
         */
        if (!fFocus) {
            this.bitsState &= ~Keyboard.STATE.ALL_MODIFIERS;
            this.clearActiveKeys(true);
        }
    }

    /**
     * onKeyChange(event, fDown)
     *
     * @this {Keyboard}
     * @param {Object} event
     * @param {boolean} fDown is true for a keyDown event, false for a keyUp event
     * @return {boolean} true to pass the event along, false to consume it
     */
    onKeyChange(event, fDown)
    {
        let fPass = true;
        let fPress = false;
        let fIgnore = false;
        let keyCode = event.keyCode;

        if (!this.cmp.notifyKbdEvent(event, fDown)) {
            return false;
        }

        if (fDown) this.cKeysPressed++;
        this.sInjectBuffer = "";                        // actual key events should stop any injection in progress
        Component.processScript(this.idMachine);        // and any script, too

        /*
         * Although it would be nice to pay attention ONLY to these "up" and "down" events, and ignore "press"
         * events, iOS devices force us to process "press" events, because they don't give us shift-key events,
         * so we have to infer the shift state from the character code in the "press" event.
         *
         * So, to seamlessly blend "up" and "down" events with "press" events, we must convert any keyCodes we
         * receive here to a compatibly shifted simCode.
         */
        let simCode = this.getSimCode(keyCode, true);

        if (this.fEscapeDisabled && simCode == Keys.ASCII['`']) {
            keyCode = simCode = Keys.KEYCODE.ESC;
        }

        if (Keyboard.SIMCODES[keyCode + Keys.KEYCODE.ONDOWN]) {

            simCode += Keys.KEYCODE.ONDOWN;
            if (event.location == Keys.LOCATION.RIGHT) {
                simCode += Keys.KEYCODE.ONRIGHT;
            }

            let nShiftState = this.updateShiftState(simCode, false, fDown);
            if (nShiftState) {

                if (keyCode == Keys.KEYCODE.CAPS_LOCK || keyCode == Keys.KEYCODE.NUM_LOCK || keyCode == Keys.KEYCODE.SCROLL_LOCK) {
                    /*
                     * FYI, "lock" keys generate a DOWN event ONLY when getting locked and an UP event ONLY
                     * when getting unlocked--which is a little odd, since the key did go UP and DOWN each time.
                     *
                     * We must treat each event like a "down", and also as a "press", so that addActiveKey() will
                     * automatically generate both the "make" and "break".
                     *
                     * Of course, there have to be exceptions, most notably both Microsoft Internet Explorer and Edge
                     * (and, apparently, pretty much any other browser running on the Windows platform), which send both
                     * UP and DOWN events on every press, so there's no need for this trickery.
                     */
                    if (!this.fMSWindows) {
                        fDown = fPress = true;
                    }
                }

                /*
                 * HACK for Windows (as the host operating system): the ALT key is often used with key combinations
                 * not meant for our machine (eg, Alt-Tab to switch to a different window, or simply tapping the ALT
                 * key by itself to switch focus to the browser's menubar).  And sadly, browsers are quite happy to
                 * give us the DOWN event for the ALT key, but not an UP event, leaving our machine with the impression
                 * that the ALT key is still down, which the user user has no easy way to detect OR correct.
                 *
                 * So we still record the ALT state in bitsState as best we can, and clear it whenever we lose focus
                 * in onFocusChange(), but we no longer pass through DOWN events to our machine.  Instead, we now
                 * check bitsState prior to simulating any other key, and if the ALT bit is set, we simulate an
                 * active ALT key first; you'll find that check at the end of both onKeyChange() and onKeyPress().
                 *
                 * NOTE: Even though this is a hack intended largely for browsers running on Windows, I'm implementing
                 * it for all platforms, for consistency.
                 */
                if (this.fDelayALT && keyCode == Keys.KEYCODE.ALT) {
                    if (fDown) {
                        /*
                         * One exception to this hack is the "Sidekick" exception: if the CTRL key is also down,
                         * we'll still simulate ALT immediately, for those users who press CTRL and then ALT to pop up
                         * Sidekick (as opposed to pressing ALT and then CTRL, which should also work, regardless).
                         */
                        if (!(this.bitsState & Keyboard.STATE.CTRL)) fIgnore = true;
                        /*
                         * Reset cKeysPressed so that we can detect the mere "tapping" of the ALT key, which some PCjs
                         * demos depend on (eg, Multi-tasking MS-DOS 4.0).
                         */
                        this.cKeysPressed = 0;
                    }
                    else {
                        if (!this.cKeysPressed) {
                            /*
                             * Since cKeysPressed is zero, the assumption here is that the ALT key (and the Alt key ALONE)
                             * was just tapped, so as long the ALT key was not already "soft-locked" (based on bitsStateSim),
                             * we will transform this "up" event into a "fake press" event.
                             */
                            if (!(this.bitsStateSim & (Keyboard.STATE.ALT | Keyboard.STATE.RALT))) {
                                fDown = fPress = true;
                            }
                        }
                    }
                }

                /*
                 * As a safeguard, whenever the CMD key goes up, clear all active keys, because there appear to be
                 * cases where we don't always get notification of a CMD key's companion key going up (this probably
                 * overlaps with most if not all situations where we also lose focus).
                 */
                if (!fDown && (keyCode == Keys.KEYCODE.CMD || keyCode == Keys.KEYCODE.RCMD)) {
                    this.clearActiveKeys();
                }
            }
            else {
                /*
                 * Here we have all the non-shift keys in the ONDOWN category; eg, BS, TAB, ESC, UP, DOWN, LEFT, RIGHT,
                 * and many more.
                 *
                 * For various reasons (some of which are discussed below), we don't want to pass these on (ie, we want
                 * to suppress their "press" event), which means we must perform all key simulation on the "up" and "down"
                 * events.
                 *
                 * Regarding BS: I never want the browser to act on BS, since it does double-duty as the BACK button,
                 * leaving the current page.
                 *
                 * Regarding TAB: If I don't consume TAB on the "down" event, then that's all I'll see, because the browser
                 * acts on it by giving focus to the next control.
                 *
                 * Regarding ESC: This key generates "down" and "up" events (LOTS of "down" events for that matter), but no
                 * "press" event.
                 */

                /*
                 * HACKs for mapping CTRL-BACKSPACE and CTRL-ALT-BACKSPACE to CTRL-BREAK and CTRL-ALT-DEL, respectively.
                 */
                if (keyCode == Keys.KEYCODE.BS && (this.bitsState & (Keyboard.STATE.CTRL|Keyboard.STATE.ALT)) == Keyboard.STATE.CTRL) {
                    simCode = Keyboard.SIMCODE.CTRL_BREAK;
                }
                if (keyCode == Keys.KEYCODE.BS && (this.bitsState & (Keyboard.STATE.CTRL|Keyboard.STATE.ALT)) == (Keyboard.STATE.CTRL|Keyboard.STATE.ALT)) {
                    simCode = Keyboard.SIMCODE.CTRL_ALT_DEL;
                }

                /*
                 * There are a number of other common key sequences that interfere with our machines; for example,
                 * the up/down arrows have a "default" behavior of scrolling the web page up and down, which is
                 * definitely NOT a behavior we want.  Since we mark those keys as ONDOWN, we'll catch them all here.
                 */
                fPass = false;
            }
        }
        else {
            /*
             * HACKs for mapping assorted CTRL-ALT sequences involving "normal" keys (eg, PERIOD, EQUALS, and DASH).
             */
            if ((this.bitsState & (Keyboard.STATE.CTRL|Keyboard.STATE.ALT)) == (Keyboard.STATE.CTRL|Keyboard.STATE.ALT)) {
                if (keyCode == Keys.KEYCODE.PERIOD) {
                    simCode = Keyboard.SIMCODE.CTRL_ALT_DEL;    // in case your operating system won't let you type CTRL-ALT-BACKSPACE either
                }
                if (keyCode == Keys.KEYCODE.EQUALS) {
                    simCode = Keyboard.SIMCODE.CTRL_ALT_ADD;    // in case your keyboard doesn't have a numeric keypad '+'
                }
                else if (keyCode == Keys.KEYCODE.DASH) {
                    simCode = Keyboard.SIMCODE.CTRL_ALT_SUB;    // in case your keyboard doesn't have a numeric keypad '-'
                }
            }

            /*
             * When I have defined system-wide CTRL-key sequences to perform common editing operations (eg, CTRL_W
             * and CTRL_Z to scroll pages of text), the browser likes to act on those operations, so let's set fPass
             * to false to prevent that.
             *
             * Also, we don't want to set fIgnore in such cases, because the browser may not give us a press event for
             * these CTRL-key sequences, so we can't risk ignoring them.
             */
            if (Keyboard.SIMCODES[simCode] && (this.bitsState & (Keyboard.STATE.CTRLS | Keyboard.STATE.ALTS))) {
                fPass = false;
            }

            /*
             * Don't simulate any key not explicitly marked ONDOWN, as well as any key sequence with the CMD key held.
             */
            if (!this.fAllDown && fPass && fDown || (this.bitsState & Keyboard.STATE.CMDS)) {
                fIgnore = true;
            }
        }

        if (!fPass) {
            event.preventDefault();
        }

        if (this.messageEnabled(Messages.EVENT | Messages.KEY)) {
            this.printMessage("onKeyChange(" + keyCode + "): " + (fDown? "down" : "up") + (fIgnore? ",ignore" : (fPass? "" : ",consume")), true);
        }

        /*
         * Mobile (eg, iOS) keyboards don't fully support onkeydown/onkeyup events; for example, they usually
         * don't generate ANY events when a shift key is pressed, and even for normal keys, they seem to generate
         * rapid (ie, fake) "up" and "down" events around "press" events, probably more to satisfy compatibility
         * issues rather than making a serious effort to indicate when a key ACTUALLY went down or up.
         */
        if (!fIgnore && (!this.fMobile || !fPass)) {
            if (fDown) {
                /*
                 * This is the companion code to the onKeyChange() hack for Windows that suppresses DOWN events
                 * for ALT keys: if we're about to activate another key and we believe that an ALT key is still down,
                 * we fake an ALT activation first.
                 */
                if (this.fDelayALT && (this.bitsState & Keyboard.STATE.ALTS)) {
                    let simCodeAlt = Keyboard.SIMCODE.ALT;
                    this.printMessage("onKeyChange(" + simCodeAlt + "): simulating ALT down", Messages.EVENT);
                    this.addActiveKey(simCodeAlt);
                }
                this.addActiveKey(simCode, fPress);
            } else {
                if (!this.removeActiveKey(simCode)) {
                    let code = this.getSimCode(keyCode, false);
                    if (code != simCode) this.removeActiveKey(code);
                }
            }
        }

        return fPass;
    }

    /**
     * onKeyPress(event)
     *
     * @this {Keyboard}
     * @param {Object} event
     * @return {boolean} true to pass the event along, false to consume it
     */
    onKeyPress(event)
    {
        event = event || window.event;
        let keyCode = event.which || event.keyCode;

        if (!this.cmp.notifyKbdEvent(event)) {
            return false;
        }

        this.cKeysPressed++;
        this.sInjectBuffer = "";        // actual key events should stop any injection currently in progress

        if (this.fAllDown) {
            let simCode = this.checkActiveKey();
            if (simCode && this.isAlphaKey(simCode) && this.isAlphaKey(keyCode) && simCode != keyCode) {
                if (!COMPILED && this.messageEnabled(Messages.EVENT | Messages.KEY)) {
                    this.printMessage("onKeyPress(" + keyCode + ") out of sync with " + simCode + ", invert caps-lock", true);
                }
                this.fToggleCapsLock = true;
                keyCode = simCode;
            }
        }

        let fPass = !Keyboard.SIMCODES[keyCode] || !!(this.bitsState & Keyboard.STATE.CMD);

        if (this.messageEnabled(Messages.EVENT | Messages.KEY)) {
            this.printMessage("onKeyPress(" + keyCode + "): " + (fPass? "true" : "false"), true);
        }

        if (!fPass) {
            /*
             * This is the companion code to the onKeyChange() hack for Windows that suppresses DOWN events
             * for ALT keys: if we're about to activate another key and we believe that an ALT key is still down,
             * we fake an ALT activation first.
             */
            if (this.fDelayALT && (this.bitsState & Keyboard.STATE.ALTS)) {
                let simCodeAlt = Keyboard.SIMCODE.ALT;
                this.printMessage("onKeyPress(" + simCodeAlt + "): simulating ALT down", Messages.EVENT);
                this.addActiveKey(simCodeAlt);
            }
            this.addActiveKey(keyCode, true);
        }

        return fPass;
    }

    /**
     * simulateKey(simCode, fDown)
     *
     * @this {Keyboard}
     * @param {number} simCode
     * @param {boolean} fDown
     * @return {boolean} true if successfully simulated, false if unrecognized/unsupported key
     */
    simulateKey(simCode, fDown)
    {
        let fSimulated = false;

        this.updateShiftState(simCode, true, fDown);

        let wCode = Keyboard.SIMCODES[simCode] || Keyboard.SIMCODES[simCode + Keys.KEYCODE.ONDOWN];

        if (wCode !== undefined) {

            let abScanCodes = [];
            let bCode = wCode & 0xff;

            /*
             * TODO: Update the following restrictions to address 84-key and 101-key keyboard limitations.
             */
            if (bCode > 83 && this.modelKeys == 83) {
                return false;
            }

            abScanCodes.push(bCode | (fDown? 0 : Keyboard.SCANCODE.BREAK));

            let fAlpha = (simCode >= Keys.ASCII.A && simCode <= Keys.ASCII.Z || simCode >= Keys.ASCII.a && simCode <= Keys.ASCII.z);

            while (wCode >>>= 8) {
                let bScan = wCode & 0xff;
                /*
                 * TODO: The handling of SIMCODE entries with "extended" codes still needs to be tested, and
                 * moreover, if any of them need to perform any shift-state modifications, those modifications
                 * may need to be encoded differently.
                 */
                if (bCode == Keyboard.SCANCODE.EXTEND1 || bCode == Keyboard.SCANCODE.EXTEND2) {
                    abScanCodes.push(bCode | (fDown? 0 : Keyboard.SCANCODE.BREAK));
                    continue;
                }
                let bitsFake = 0;
                if (bScan == Keyboard.SCANCODE.SHIFT) {
                    if (!(this.bitsStateSim & (Keyboard.STATE.SHIFT | Keyboard.STATE.RSHIFT))) {
                        if (!(this.bitsStateSim & Keyboard.STATE.CAPS_LOCK) || !fAlpha) {
                            bitsFake |= Keyboard.STATE.SHIFT;
                        }
                    }
                }
                else if (bScan == Keyboard.SCANCODE.CTRL) {
                    if (!(this.bitsStateSim & (Keyboard.STATE.CTRL | Keyboard.STATE.RCTRL))) {
                        bitsFake |= Keyboard.STATE.CTRL;
                    }
                }
                else if (bScan == Keyboard.SCANCODE.ALT) {
                    if (!(this.bitsStateSim & (Keyboard.STATE.ALT | Keyboard.STATE.RALT))) {
                        bitsFake |= Keyboard.STATE.ALT;
                    }
                }
                else {
                    abScanCodes.push(bCode | (fDown? 0 : Keyboard.SCANCODE.BREAK));
                }
                /*
                 * If we have to fake a modifier key (eg, because some caller wants to simulate a modified key
                 * for which the modifier is not currently down), then if the modified key is going DOWN, make a
                 * note that the modifier is being faked, and if the modified key is going UP, make sure that
                 * the modifier was actually faked before "unfaking" it.
                 *
                 * Otherwise, the BIOS may complain (ie, beep) if it sees an UP event for a modifier key that it
                 * thinks is already up.  For example, if you press SHIFT, then press '?', then release SHIFT, then
                 * release '?', since we didn't have to fake a SHIFT when pressing '?', we should also avoid faking
                 * it when releasing '?'.
                 */
                if (bitsFake) {
                    if (fDown) {
                        this.bitsStateFake |= bitsFake;
                    } else if (this.bitsStateFake & bitsFake) {
                        this.bitsStateFake &= ~bitsFake;
                    } else {
                        bitsFake = 0;
                    }
                }
                if (bitsFake) {
                    if (fDown)
                        abScanCodes.unshift(bScan);
                    else
                        abScanCodes.push(bScan | Keyboard.SCANCODE.BREAK);
                }
            }

            for (let i = 0; i < abScanCodes.length; i++) {
                this.addScanCode(abScanCodes[i]);
            }

            fSimulated = true;
        }

        if (!COMPILED && this.messageEnabled(Messages.KBD | Messages.KEY)) {
            this.printMessage("simulateKey(" + simCode + "," + (fDown? "down" : "up") + "): " + (fSimulated? "true" : "false"), true);
        }

        return fSimulated;
    }

    /**
     * checkActiveKeyShift()
     *
     * @this {Keyboard}
     * @return {number|null} bitsState for active key, null if none
     *
     checkActiveKeyShift()
     {
         return this.aKeysActive.length? this.aKeysActive[0].bitsState : null;
     }
     */

    /**
     * Keyboard.init()
     *
     * This function operates on every HTML element of class "keyboard", extracting the
     * JSON-encoded parameters for the Keyboard constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Keyboard component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeKbd = Component.getElementsByClass(document, PCX86.APPCLASS, "keyboard");
        for (let iKbd = 0; iKbd < aeKbd.length; iKbd++) {
            let eKbd = aeKbd[iKbd];
            let parmsKbd = Component.getComponentParms(eKbd);
            let kbd = new Keyboard(parmsKbd);
            Component.bindComponentControls(kbd, eKbd, PCX86.APPCLASS);
        }
    }
}

/*
 * Supported keyboard models (the first entry is the default if the specified model isn't recognized)
 */
Keyboard.MODELS = ["US83", "US84", "US101"];

Keyboard.SIMCODE = {
    BS:             Keys.KEYCODE.BS          + Keys.KEYCODE.ONDOWN,
    TAB:            Keys.KEYCODE.TAB         + Keys.KEYCODE.ONDOWN,
    SHIFT:          Keys.KEYCODE.SHIFT       + Keys.KEYCODE.ONDOWN,
    RSHIFT:         Keys.KEYCODE.SHIFT       + Keys.KEYCODE.ONDOWN + Keys.KEYCODE.ONRIGHT,
    CTRL:           Keys.KEYCODE.CTRL        + Keys.KEYCODE.ONDOWN,
    ALT:            Keys.KEYCODE.ALT         + Keys.KEYCODE.ONDOWN,
    RALT:           Keys.KEYCODE.ALT         + Keys.KEYCODE.ONDOWN + Keys.KEYCODE.ONRIGHT,
    CAPS_LOCK:      Keys.KEYCODE.CAPS_LOCK   + Keys.KEYCODE.ONDOWN,
    ESC:            Keys.KEYCODE.ESC         + Keys.KEYCODE.ONDOWN,
    /*
     * It seems that a recent change to Safari on iOS (first noticed in iOS 9.1) treats SPACE
     * differently now, at least with regard to <textarea> controls, and possibly only readonly
     * or hidden controls, like the hidden <textarea> we overlay on the Video <canvas> element.
     *
     * Whatever the exact criteria are, Safari on iOS now performs SPACE's default behavior
     * after the onkeydown event but before the onkeypress event.  So we must now process SPACE
     * as an ONDOWN key, so that we can call preventDefault() and properly simulate the key at
     * the time the key goes down.
     */
    SPACE:          Keys.KEYCODE.SPACE       + Keys.KEYCODE.ONDOWN,
    F1:             Keys.KEYCODE.F1          + Keys.KEYCODE.ONDOWN,
    F2:             Keys.KEYCODE.F2          + Keys.KEYCODE.ONDOWN,
    F3:             Keys.KEYCODE.F3          + Keys.KEYCODE.ONDOWN,
    F4:             Keys.KEYCODE.F4          + Keys.KEYCODE.ONDOWN,
    F5:             Keys.KEYCODE.F5          + Keys.KEYCODE.ONDOWN,
    F6:             Keys.KEYCODE.F6          + Keys.KEYCODE.ONDOWN,
    F7:             Keys.KEYCODE.F7          + Keys.KEYCODE.ONDOWN,
    F8:             Keys.KEYCODE.F8          + Keys.KEYCODE.ONDOWN,
    F9:             Keys.KEYCODE.F9          + Keys.KEYCODE.ONDOWN,
    F10:            Keys.KEYCODE.F10         + Keys.KEYCODE.ONDOWN,
    F11:            Keys.KEYCODE.F11         + Keys.KEYCODE.ONDOWN,
    F12:            Keys.KEYCODE.F12         + Keys.KEYCODE.ONDOWN,
    NUM_LOCK:       Keys.KEYCODE.NUM_LOCK    + Keys.KEYCODE.ONDOWN,
    SCROLL_LOCK:    Keys.KEYCODE.SCROLL_LOCK + Keys.KEYCODE.ONDOWN,
    PRTSC:          Keys.KEYCODE.PRTSC       + Keys.KEYCODE.ONDOWN,
    HOME:           Keys.KEYCODE.HOME        + Keys.KEYCODE.ONDOWN,
    UP:             Keys.KEYCODE.UP          + Keys.KEYCODE.ONDOWN,
    PGUP:           Keys.KEYCODE.PGUP        + Keys.KEYCODE.ONDOWN,
    LEFT:           Keys.KEYCODE.LEFT        + Keys.KEYCODE.ONDOWN,
    NUM_INS:        Keys.KEYCODE.NUM_INS     + Keys.KEYCODE.ONDOWN,
    NUM_END:        Keys.KEYCODE.NUM_END     + Keys.KEYCODE.ONDOWN,
    NUM_DOWN:       Keys.KEYCODE.NUM_DOWN    + Keys.KEYCODE.ONDOWN,
    NUM_PGDN:       Keys.KEYCODE.NUM_PGDN    + Keys.KEYCODE.ONDOWN,
    NUM_LEFT:       Keys.KEYCODE.NUM_LEFT    + Keys.KEYCODE.ONDOWN,
    NUM_CENTER:     Keys.KEYCODE.NUM_CENTER  + Keys.KEYCODE.ONDOWN,
    NUM_RIGHT:      Keys.KEYCODE.NUM_RIGHT   + Keys.KEYCODE.ONDOWN,
    NUM_HOME:       Keys.KEYCODE.NUM_HOME    + Keys.KEYCODE.ONDOWN,
    NUM_UP:         Keys.KEYCODE.NUM_UP      + Keys.KEYCODE.ONDOWN,
    NUM_PGUP:       Keys.KEYCODE.NUM_PGUP    + Keys.KEYCODE.ONDOWN,
    NUM_ADD:        Keys.KEYCODE.NUM_ADD     + Keys.KEYCODE.ONDOWN,
    NUM_SUB:        Keys.KEYCODE.NUM_SUB     + Keys.KEYCODE.ONDOWN,
    NUM_DEL:        Keys.KEYCODE.NUM_DEL     + Keys.KEYCODE.ONDOWN,
    RIGHT:          Keys.KEYCODE.RIGHT       + Keys.KEYCODE.ONDOWN,
    END:            Keys.KEYCODE.END         + Keys.KEYCODE.ONDOWN,
    DOWN:           Keys.KEYCODE.DOWN        + Keys.KEYCODE.ONDOWN,
    PGDN:           Keys.KEYCODE.PGDN        + Keys.KEYCODE.ONDOWN,
    INS:            Keys.KEYCODE.INS         + Keys.KEYCODE.ONDOWN,
    DEL:            Keys.KEYCODE.DEL         + Keys.KEYCODE.ONDOWN,
    CMD:            Keys.KEYCODE.CMD         + Keys.KEYCODE.ONDOWN,
    RCMD:           Keys.KEYCODE.RCMD        + Keys.KEYCODE.ONDOWN,
    FF_CMD:         Keys.KEYCODE.FF_CMD      + Keys.KEYCODE.ONDOWN,
    CTRL_A:         Keys.ASCII.CTRL_A        + Keys.KEYCODE.FAKE,
    CTRL_B:         Keys.ASCII.CTRL_B        + Keys.KEYCODE.FAKE,
    CTRL_C:         Keys.ASCII.CTRL_C        + Keys.KEYCODE.FAKE,
    CTRL_D:         Keys.ASCII.CTRL_D        + Keys.KEYCODE.FAKE,
    CTRL_E:         Keys.ASCII.CTRL_E        + Keys.KEYCODE.FAKE,
    CTRL_F:         Keys.ASCII.CTRL_F        + Keys.KEYCODE.FAKE,
    CTRL_G:         Keys.ASCII.CTRL_G        + Keys.KEYCODE.FAKE,
    CTRL_H:         Keys.ASCII.CTRL_H        + Keys.KEYCODE.FAKE,
    CTRL_I:         Keys.ASCII.CTRL_I        + Keys.KEYCODE.FAKE,
    CTRL_J:         Keys.ASCII.CTRL_J        + Keys.KEYCODE.FAKE,
    CTRL_K:         Keys.ASCII.CTRL_K        + Keys.KEYCODE.FAKE,
    CTRL_L:         Keys.ASCII.CTRL_L        + Keys.KEYCODE.FAKE,
    CTRL_M:         Keys.ASCII.CTRL_M        + Keys.KEYCODE.FAKE,
    CTRL_N:         Keys.ASCII.CTRL_N        + Keys.KEYCODE.FAKE,
    CTRL_O:         Keys.ASCII.CTRL_O        + Keys.KEYCODE.FAKE,
    CTRL_P:         Keys.ASCII.CTRL_P        + Keys.KEYCODE.FAKE,
    CTRL_Q:         Keys.ASCII.CTRL_Q        + Keys.KEYCODE.FAKE,
    CTRL_R:         Keys.ASCII.CTRL_R        + Keys.KEYCODE.FAKE,
    CTRL_S:         Keys.ASCII.CTRL_S        + Keys.KEYCODE.FAKE,
    CTRL_T:         Keys.ASCII.CTRL_T        + Keys.KEYCODE.FAKE,
    CTRL_U:         Keys.ASCII.CTRL_U        + Keys.KEYCODE.FAKE,
    CTRL_V:         Keys.ASCII.CTRL_V        + Keys.KEYCODE.FAKE,
    CTRL_W:         Keys.ASCII.CTRL_W        + Keys.KEYCODE.FAKE,
    CTRL_X:         Keys.ASCII.CTRL_X        + Keys.KEYCODE.FAKE,
    CTRL_Y:         Keys.ASCII.CTRL_Y        + Keys.KEYCODE.FAKE,
    CTRL_Z:         Keys.ASCII.CTRL_Z        + Keys.KEYCODE.FAKE,
    SYS_REQ:        Keys.KEYCODE.ESC         + Keys.KEYCODE.FAKE,
    CTRL_PAUSE:     Keys.KEYCODE.NUM_LOCK    + Keys.KEYCODE.FAKE,
    CTRL_BREAK:     Keys.KEYCODE.SCROLL_LOCK + Keys.KEYCODE.FAKE,
    CTRL_ALT_DEL:   Keys.KEYCODE.DEL         + Keys.KEYCODE.FAKE,
    CTRL_ALT_INS:   Keys.KEYCODE.INS         + Keys.KEYCODE.FAKE,
    CTRL_ALT_ADD:   Keys.KEYCODE.NUM_ADD     + Keys.KEYCODE.FAKE,
    CTRL_ALT_SUB:   Keys.KEYCODE.NUM_SUB     + Keys.KEYCODE.FAKE,
    CTRL_ALT_ENTER: Keys.KEYCODE.NUM_CR      + Keys.KEYCODE.FAKE
};

/*
 * Scan code constants
 */
Keyboard.SCANCODE = {
    /* 0x01 */ ESC:         1,
    /* 0x02 */ ONE:         2,
    /* 0x03 */ TWO:         3,
    /* 0x04 */ THREE:       4,
    /* 0x05 */ FOUR:        5,
    /* 0x06 */ FIVE:        6,
    /* 0x07 */ SIX:         7,
    /* 0x08 */ SEVEN:       8,
    /* 0x09 */ EIGHT:       9,
    /* 0x0A */ NINE:        10,
    /* 0x0B */ ZERO:        11,
    /* 0x0C */ DASH:        12,
    /* 0x0D */ EQUALS:      13,
    /* 0x0E */ BS:          14,
    /* 0x0F */ TAB:         15,
    /* 0x10 */ Q:           16,
    /* 0x11 */ W:           17,
    /* 0x12 */ E:           18,
    /* 0x13 */ R:           19,
    /* 0x14 */ T:           20,
    /* 0x15 */ Y:           21,
    /* 0x16 */ U:           22,
    /* 0x17 */ I:           23,
    /* 0x18 */ O:           24,
    /* 0x19 */ P:           25,
    /* 0x1A */ LBRACK:      26,
    /* 0x1B */ RBRACK:      27,
    /* 0x1C */ ENTER:       28,
    /* 0x1D */ CTRL:        29,
    /* 0x1E */ A:           30,
    /* 0x1F */ S:           31,
    /* 0x20 */ D:           32,
    /* 0x21 */ F:           33,
    /* 0x22 */ G:           34,
    /* 0x23 */ H:           35,
    /* 0x24 */ J:           36,
    /* 0x25 */ K:           37,
    /* 0x26 */ L:           38,
    /* 0x27 */ SEMI:        39,
    /* 0x28 */ QUOTE:       40,
    /* 0x29 */ BQUOTE:      41,
    /* 0x2A */ SHIFT:       42,
    /* 0x2B */ BSLASH:      43,
    /* 0x2C */ Z:           44,
    /* 0x2D */ X:           45,
    /* 0x2E */ C:           46,
    /* 0x2F */ V:           47,
    /* 0x30 */ B:           48,
    /* 0x31 */ N:           49,
    /* 0x32 */ M:           50,
    /* 0x33 */ COMMA:       51,
    /* 0x34 */ PERIOD:      52,
    /* 0x35 */ SLASH:       53,
    /* 0x36 */ RSHIFT:      54,
    /* 0x37 */ PRTSC:       55,         // unshifted '*'; becomes dedicated 'Print Screen' key on 101-key keyboards
    /* 0x38 */ ALT:         56,
    /* 0x39 */ SPACE:       57,
    /* 0x3A */ CAPS_LOCK:   58,
    /* 0x3B */ F1:          59,
    /* 0x3C */ F2:          60,
    /* 0x3D */ F3:          61,
    /* 0x3E */ F4:          62,
    /* 0x3F */ F5:          63,
    /* 0x40 */ F6:          64,
    /* 0x41 */ F7:          65,
    /* 0x42 */ F8:          66,
    /* 0x43 */ F9:          67,
    /* 0x44 */ F10:         68,
    /* 0x45 */ NUM_LOCK:    69,
    /* 0x46 */ SCROLL_LOCK: 70,
    /* 0x47 */ NUM_HOME:    71,
    /* 0x48 */ NUM_UP:      72,
    /* 0x49 */ NUM_PGUP:    73,
    /* 0x4A */ NUM_SUB:     74,
    /* 0x4B */ NUM_LEFT:    75,
    /* 0x4C */ NUM_CENTER:  76,
    /* 0x4D */ NUM_RIGHT:   77,
    /* 0x4E */ NUM_ADD:     78,
    /* 0x4F */ NUM_END:     79,
    /* 0x50 */ NUM_DOWN:    80,
    /* 0x51 */ NUM_PGDN:    81,
    /* 0x52 */ NUM_INS:     82,
    /* 0x53 */ NUM_DEL:     83,
    /* 0x54 */ SYS_REQ:     84,         // 84-key keyboard only (simulated with 'alt'+'prtsc' on 101-key keyboards)
    /* 0x54 */ PAUSE:       84,         // 101-key keyboard only
    /* 0x57 */ F11:         87,
    /* 0x58 */ F12:         88,
    /* 0x5B */ WIN:         91,         // aka CMD
    /* 0x5C */ RWIN:        92,
    /* 0x5D */ MENU:        93,         // aka CMD + ONRIGHT
    /* 0x7F */ MAKE:        127,
    /* 0x80 */ BREAK:       128,
    /* 0xE0 */ EXTEND1:     224,
    /* 0xE1 */ EXTEND2:     225
};

/**
 * These internal "shift key" states are used to indicate BOTH the physical shift-key states (in bitsState)
 * and the simulated shift-key states (in bitsStateSim).  The LOCK keys are problematic in both cases: the
 * browsers give us no way to query the LOCK key states, so we can only infer them, and because they are "soft"
 * locks, the machine's notion of their state is subject to change at any time as well.  Granted, the IBM PC
 * ROM BIOS will store its LOCK states in the ROM BIOS Data Area (@0040:0017), but that's just a BIOS convention.
 *
 * Also, because this is purely for internal use, don't make the mistake of thinking that these bits have any
 * connection to the ROM BIOS bits @0040:0017 (they don't).  We emulate hardware, not ROMs.
 *
 * TODO: Consider taking notice of the ROM BIOS Data Area state anyway, even though I'd rather remain ROM-agnostic;
 * at the very least, it would help us keep our LOCK LEDs in sync with the machine's LOCK states.  However, the LED
 * issue will be largely moot (at least for MODEL_5170 machines) once we add support for PC AT keyboard LED commands.
 *
 * Note that right-hand state bits are equal to the left-hand bits shifted right 1 bit; makes sense, "right"? ;-)
 *
 * @enum {number}
 */
Keyboard.STATE = {
    RSHIFT:         0x0001,
    SHIFT:          0x0002,
    SHIFTS:         0x0003,
    RCTRL:          0x0004,             // 101-key keyboard only
    CTRL:           0x0008,
    CTRLS:          0x000C,
    RALT:           0x0010,             // 101-key keyboard only
    ALT:            0x0020,
    ALTS:           0x0030,
    RCMD:           0x0040,             // 101-key keyboard only
    CMD:            0x0080,             // 101-key keyboard only
    CMDS:           0x00C0,
    ALL_RIGHT:      0x0055,             // RSHIFT | RCTRL | RALT | RCMD
    ALL_MODIFIERS:  0x00FF,             // SHIFT | RSHIFT | CTRL | RCTRL | ALT | RALT | CMD | RCMD
    INSERT:         0x0100,             // TODO: Placeholder (we currently have no notion of any "insert" states)
    CAPS_LOCK:      0x0200,
    NUM_LOCK:       0x0400,
    SCROLL_LOCK:    0x0800,
    ALL_LOCKS:      0x0E00              // CAPS_LOCK | NUM_LOCK | SCROLL_LOCK
};

/*
 * Maps KEYCODES of modifier keys to their corresponding (default) STATES bit above.
 */
Keyboard.MODIFIERS = {
    [Keyboard.SIMCODE.RSHIFT]:      Keyboard.STATE.RSHIFT,
    [Keyboard.SIMCODE.SHIFT]:       Keyboard.STATE.SHIFT,
    [Keyboard.SIMCODE.CTRL]:        Keyboard.STATE.CTRL,
    [Keyboard.SIMCODE.ALT]:         Keyboard.STATE.ALT,
    [Keyboard.SIMCODE.RALT]:        Keyboard.STATE.ALT,
    [Keyboard.SIMCODE.CMD]:         Keyboard.STATE.CMD,
    [Keyboard.SIMCODE.RCMD]:        Keyboard.STATE.RCMD,
    [Keyboard.SIMCODE.FF_CMD]:      Keyboard.STATE.CMD
};

/*
 * Maps KEYCODES of all modifier and lock keys to their corresponding (default) STATES bit above.
 */
Keyboard.KEYSTATES = {
    [Keyboard.SIMCODE.RSHIFT]:      Keyboard.STATE.RSHIFT,
    [Keyboard.SIMCODE.SHIFT]:       Keyboard.STATE.SHIFT,
    [Keyboard.SIMCODE.CTRL]:        Keyboard.STATE.CTRL,
    [Keyboard.SIMCODE.ALT]:         Keyboard.STATE.ALT,
    [Keyboard.SIMCODE.RALT]:        Keyboard.STATE.ALT,
    [Keyboard.SIMCODE.CMD]:         Keyboard.STATE.CMD,
    [Keyboard.SIMCODE.RCMD]:        Keyboard.STATE.RCMD,
    [Keyboard.SIMCODE.FF_CMD]:      Keyboard.STATE.CMD,
    [Keyboard.SIMCODE.CAPS_LOCK]:   Keyboard.STATE.CAPS_LOCK,
    [Keyboard.SIMCODE.NUM_LOCK]:    Keyboard.STATE.NUM_LOCK,
    [Keyboard.SIMCODE.SCROLL_LOCK]: Keyboard.STATE.SCROLL_LOCK
};

/*
 * Maps CLICKCODE (string) to SIMCODE (number).
 *
 * NOTE: Unlike SOFTCODES, CLICKCODES are upper-case and use underscores instead of dashes, so that this
 * and other components can reference them using "dot" property syntax; using upper-case merely adheres to
 * our convention for constants.  setBinding() will automatically convert any incoming CLICKCODE bindings
 * that use lower-case and dashes to upper-case and underscores before performing property lookup.
 */
Keyboard.CLICKCODES = {
    'TAB':              Keyboard.SIMCODE.TAB,
    'ESC':              Keyboard.SIMCODE.ESC,
    'F1':               Keyboard.SIMCODE.F1,
    'F2':               Keyboard.SIMCODE.F2,
    'F3':               Keyboard.SIMCODE.F3,
    'F4':               Keyboard.SIMCODE.F4,
    'F5':               Keyboard.SIMCODE.F5,
    'F6':               Keyboard.SIMCODE.F6,
    'F7':               Keyboard.SIMCODE.F7,
    'F8':               Keyboard.SIMCODE.F8,
    'F9':               Keyboard.SIMCODE.F9,
    'F10':              Keyboard.SIMCODE.F10,
    'LEFT':             Keyboard.SIMCODE.LEFT,
    'UP':               Keyboard.SIMCODE.UP,
    'RIGHT':            Keyboard.SIMCODE.RIGHT,
    'DOWN':             Keyboard.SIMCODE.DOWN,
    'NUM_HOME':         Keyboard.SIMCODE.HOME,
    'NUM_END':          Keyboard.SIMCODE.END,
    'NUM_PGUP':         Keyboard.SIMCODE.PGUP,
    'NUM_PGDN':         Keyboard.SIMCODE.PGDN,
    'ALT':              Keyboard.SIMCODE.ALT,
    'SYS_REQ':          Keyboard.SIMCODE.SYS_REQ,
    /*
     * These bindings are for convenience (common key combinations that can be bound to a single control)
     */
    'CTRL_C':           Keyboard.SIMCODE.CTRL_C,
    'CTRL_PAUSE':       Keyboard.SIMCODE.CTRL_PAUSE,
    'CTRL_BREAK':       Keyboard.SIMCODE.CTRL_BREAK,
    'CTRL_ALT_DEL':     Keyboard.SIMCODE.CTRL_ALT_DEL,
    'CTRL_ALT_INS':     Keyboard.SIMCODE.CTRL_ALT_INS,
    'CTRL_ALT_ADD':     Keyboard.SIMCODE.CTRL_ALT_ADD,
    'CTRL_ALT_SUB':     Keyboard.SIMCODE.CTRL_ALT_SUB,
    'CTRL_ALT_ENTER':   Keyboard.SIMCODE.CTRL_ALT_ENTER
};

/*
 * Maps SOFTCODE (string) to SIMCODE (number) -- which may be the same as KEYCODE for ASCII keys.
 *
 * We define identifiers for all possible keys, based on their primary (unshifted) character or function.
 * This also serves as a definition of all supported keys, making it possible to create full-featured
 * "soft keyboards".
 *
 * One exception to the (unshifted) rule above is 'prtsc': on the original IBM 83-key and 84-key keyboards,
 * its primary (unshifted) character was '*', but on 101-key keyboards, it became a separate key ('prtsc',
 * now labeled "Print Screen"), as did the num-pad '*' ('num-mul'), so 'prtsc' seems worthy of an exception
 * to the rule.
 *
 * On 83-key and 84-key keyboards, 'ctrl'+'num-lock' triggered a "pause" operation and 'ctrl'+'scroll-lock'
 * triggered a "break" operation.
 *
 * On 101-key keyboards, IBM decided to move both those special operations to a new 'pause' ("Pause/Break")
 * key, near the new dedicated 'prtsc' ("Print Screen/SysRq") key -- and to drop the "e" from "Sys Req".
 * Those keys behave as follows:
 *
 *      When 'pause' is pressed alone, it generates 0xe1 0x1d 0x45 0xe1 0x9d 0xc5 on make (nothing on break),
 *      which essentially simulates the make-and-break of the 'ctrl' and 'num-lock' keys (ignoring the 0xe1),
 *      triggering a "pause" operation.
 *
 *      When 'pause' is pressed with 'ctrl', it generates 0xe0 0x46 0xe0 0xc6 on make (nothing on break) and
 *      does not repeat, which essentially simulates the make-and-break of 'scroll-lock', which, in conjunction
 *      with the separate make-and-break of 'ctrl', triggers a "break" operation.
 *
 *      When 'prtsc' is pressed alone, it generates 0xe0 0x2a 0xe0 0x37, simulating the make of both 'shift'
 *      and 'prtsc'; when pressed with 'shift' or 'ctrl', it generates only 0xe0 0x37; and when pressed with
 *      'alt', it generates only 0x54 (to simulate 'sys-req').
 *
 * TODO: Implement the above behaviors, whenever we get around to actually supporting 101-key keyboards.
 *
 * All key identifiers must be quotable using single-quotes, because that's how components.xsl will encode them
 * *inside* the "data-value" attribute of the corresponding HTML control.  Which, in turn, is why the single-quote
 * key is defined as 'quote' rather than "'".  Similarly, if there was unshifted "double-quote" key, it could
 * not be called '"', because components.xsl quotes the *entire* "data-value" attribute using double-quotes.
 *
 * The (commented) numbering of keys below is purely for my own reference.  Two keys are deliberately numbered 84,
 * reflecting the fact that the 'sys-req' key was added to the 84-key keyboard but later dropped from the 101-key
 * keyboard (as a stand-alone key, that is).
 *
 * With the introduction of the PC AT and the 84-key keyboard, IBM developed a new key numbering scheme and
 * key code generation; the 8042 keyboard controller would then convert those key codes into the PC scan codes
 * defined by the older 83-key keyboard.  That's a layer of complexity we currently bypass; instead, we continue
 * to convert browser key codes directly into PC scan codes, which is what our 8042 controller implementation
 * assumes we're doing.
 */
Keyboard.SOFTCODES = {
    /*  1 */    'esc':          Keyboard.SIMCODE.ESC,
    /*  2 */    '1':            Keys.ASCII['1'],
    /*  3 */    '2':            Keys.ASCII['2'],
    /*  4 */    '3':            Keys.ASCII['3'],
    /*  5 */    '4':            Keys.ASCII['4'],
    /*  6 */    '5':            Keys.ASCII['5'],
    /*  7 */    '6':            Keys.ASCII['6'],
    /*  8 */    '7':            Keys.ASCII['7'],
    /*  9 */    '8':            Keys.ASCII['8'],
    /* 10 */    '9':            Keys.ASCII['9'],
    /* 11 */    '0':            Keys.ASCII['0'],
    /* 12 */    '-':            Keys.ASCII['-'],
    /* 13 */    '=':            Keys.ASCII['='],
    /* 14 */    'bs':           Keyboard.SIMCODE.BS,
    /* 15 */    'tab':          Keyboard.SIMCODE.TAB,
    /* 16 */    'q':            Keys.ASCII.q,
    /* 17 */    'w':            Keys.ASCII.w,
    /* 18 */    'e':            Keys.ASCII.e,
    /* 19 */    'r':            Keys.ASCII.r,
    /* 20 */    't':            Keys.ASCII.t,
    /* 21 */    'y':            Keys.ASCII.y,
    /* 22 */    'u':            Keys.ASCII.u,
    /* 23 */    'i':            Keys.ASCII.i,
    /* 24 */    'o':            Keys.ASCII.o,
    /* 25 */    'p':            Keys.ASCII.p,
    /* 26 */    '[':            Keys.ASCII['['],
    /* 27 */    ']':            Keys.ASCII[']'],
    /* 28 */    'enter':        Keys.KEYCODE.CR,
    /* 29 */    'ctrl':         Keyboard.SIMCODE.CTRL,
    /* 30 */    'a':            Keys.ASCII.a,
    /* 31 */    's':            Keys.ASCII.s,
    /* 32 */    'd':            Keys.ASCII.d,
    /* 33 */    'f':            Keys.ASCII.f,
    /* 34 */    'g':            Keys.ASCII.g,
    /* 35 */    'h':            Keys.ASCII.h,
    /* 36 */    'j':            Keys.ASCII.j,
    /* 37 */    'k':            Keys.ASCII.k,
    /* 38 */    'l':            Keys.ASCII.l,
    /* 39 */    ';':            Keys.ASCII[';'],
    /* 40 */    'quote':        Keys.ASCII["'"],                // formerly "squote"
    /* 41 */    '`':            Keys.ASCII['`'],                // formerly "bquote"
    /* 42 */    'shift':        Keyboard.SIMCODE.SHIFT,         // formerly "lshift"
    /* 43 */    '\\':           Keys.ASCII['\\'],               // formerly "bslash"
    /* 44 */    'z':            Keys.ASCII.z,
    /* 45 */    'x':            Keys.ASCII.x,
    /* 46 */    'c':            Keys.ASCII.c,
    /* 47 */    'v':            Keys.ASCII.v,
    /* 48 */    'b':            Keys.ASCII.b,
    /* 49 */    'n':            Keys.ASCII.n,
    /* 50 */    'm':            Keys.ASCII.m,
    /* 51 */    ',':            Keys.ASCII[','],
    /* 52 */    '.':            Keys.ASCII['.'],
    /* 53 */    '/':            Keys.ASCII['/'],
    /* 54 */    'right-shift':  Keyboard.SIMCODE.RSHIFT,        // formerly "rshift"
    /* 55 */    'prtsc':        Keyboard.SIMCODE.PRTSC,         // unshifted '*'; becomes dedicated 'Print Screen' key on 101-key keyboards
    /* 56 */    'alt':          Keyboard.SIMCODE.ALT,
    /* 57 */    'space':        Keyboard.SIMCODE.SPACE,
    /* 58 */    'caps-lock':    Keyboard.SIMCODE.CAPS_LOCK,
    /* 59 */    'f1':           Keyboard.SIMCODE.F1,
    /* 60 */    'f2':           Keyboard.SIMCODE.F2,
    /* 61 */    'f3':           Keyboard.SIMCODE.F3,
    /* 62 */    'f4':           Keyboard.SIMCODE.F4,
    /* 63 */    'f5':           Keyboard.SIMCODE.F5,
    /* 64 */    'f6':           Keyboard.SIMCODE.F6,
    /* 65 */    'f7':           Keyboard.SIMCODE.F7,
    /* 66 */    'f8':           Keyboard.SIMCODE.F8,
    /* 67 */    'f9':           Keyboard.SIMCODE.F9,
    /* 68 */    'f10':          Keyboard.SIMCODE.F10,
    /* 69 */    'num-lock':     Keyboard.SIMCODE.NUM_LOCK,
    /* 70 */    'scroll-lock':  Keyboard.SIMCODE.SCROLL_LOCK,   // TODO: 0xe046 on 101-key keyboards?

    /*
     * Yes, distinguishing keys 71 through 83 with the 'num-' prefix seems like overkill, but it was
     * intended to be future-proofing, for the day when we might eventually add support for 101-key keyboards,
     * because they have their own dedicated non-numeric-keypad versions of these keys (in other words, they
     * account for most of the bloat on the 101-key keyboard, a trend that more modern keyboards have gradually
     * been reversing).
     *
     * To offset 'num-' prefix overkill, injectKeys() allows SOFTCODES to be used with or without the prefix,
     * on the theory that key injection users won't really care precisely which version of the key is used.
     */

    /* 71 */    'num-home':     Keyboard.SIMCODE.HOME,          // formerly "home"
    /* 72 */    'num-up':       Keyboard.SIMCODE.UP,            // formerly "up-arrow"
    /* 73 */    'num-pgup':     Keyboard.SIMCODE.PGUP,          // formerly "page-up"
    /* 74 */    'num-sub':      Keyboard.SIMCODE.NUM_SUB,       // formerly "num-minus"
    /* 75 */    'num-left':     Keyboard.SIMCODE.LEFT,          // formerly "left-arrow"
    /* 76 */    'num-center':   Keyboard.SIMCODE.NUM_CENTER,    // formerly "center"
    /* 77 */    'num-right':    Keyboard.SIMCODE.RIGHT,         // formerly "right-arrow"
    /* 78 */    'num-add':      Keyboard.SIMCODE.NUM_ADD,       // formerly "num-plus"
    /* 79 */    'num-end':      Keyboard.SIMCODE.END,           // formerly "end"
    /* 80 */    'num-down':     Keyboard.SIMCODE.DOWN,          // formerly "down-arrow"
    /* 81 */    'num-pgdn':     Keyboard.SIMCODE.PGDN,          // formerly "page-down"
    /* 82 */    'num-ins':      Keyboard.SIMCODE.INS,           // formerly "ins"
    /* 83 */    'num-del':      Keyboard.SIMCODE.DEL,           // formerly "del"
    /* 84 */    'sys-req':      Keyboard.SIMCODE.SYS_REQ        // 84-key keyboard only (simulated with 'alt'+'prtsc' on 101-key keyboards)

    /*
     * If I ever add 101-key keyboard support (and it's not clear that I will), then the following entries
     * will have to be converted to SIMCODE indexes, and each SIMCODE index will need an entry in the SIMCODES
     * table that defines the appropriate SCANCODE(S); as this component has evolved, SOFTCODES are no longer
     * mapped directly to SCANCODES.
     */

//  /* 84 */    'pause':        Keyboard.SCANCODE.PAUSE,        // 101-key keyboard only
//  /* 85 */    'f11':          Keyboard.SCANCODE.F11,
//  /* 86 */    'f12':          Keyboard.SCANCODE.F12,
//  /* 87 */    'num-enter':    Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.ENTER << 8),
//  /* 88 */    'right-ctrl':   Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.CTRL << 8),
//  /* 89 */    'num-div':      Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.SLASH << 8),
//  /* 90 */    'num-mul':      Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.PRTSC << 8),
//  /* 91 */    'right-alt':    Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.ALT << 8),
//  /* 92 */    'home':         Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_HOME << 8),
//  /* 93 */    'up':           Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_UP << 8),
//  /* 94 */    'pgup':         Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_PGUP << 8),
//  /* 95 */    'left':         Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_LEFT << 8),
//  /* 96 */    'right':        Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_RIGHT << 8),
//  /* 97 */    'end':          Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_END << 8),
//  /* 98 */    'down':         Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_DOWN << 8),
//  /* 99 */    'pgdn':         Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_PGDN << 8),
//  /*100 */    'ins':          Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_INS << 8),
//  /*101 */    'del':          Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.NUM_DEL << 8),

//  /*102 */    'win':          Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.WIN << 8),
//  /*103 */    'right-win':    Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.RWIN << 8),
//  /*104 */    'menu':         Keyboard.SCANCODE.EXTEND1 | (Keyboard.SCANCODE.MENU << 8)
};

/*
 * Maps "soft-key" definitions (above) of shift/modifier keys to their corresponding (default) STATES bit.
 */
Keyboard.LEDSTATES = {
    'caps-lock':    Keyboard.STATE.CAPS_LOCK,
    'num-lock':     Keyboard.STATE.NUM_LOCK,
    'scroll-lock':  Keyboard.STATE.SCROLL_LOCK
};

/*
 * Maps SIMCODE (number) to SCANCODE (number(s)).
 *
 * This array is used by simulateKey() to lookup a given SIMCODE and convert it to a SCANCODE
 * (lower byte), plus any required shift key SCANCODES (upper bytes).
 *
 * Using keyCodes from keyPress events proved to be more robust than using keyCodes from keyDown and
 * keyUp events, in part because of differences in the way browsers generate the keyDown and keyUp events.
 * For example, Safari on iOS devices will not generate up/down events for shift keys, and for other keys,
 * the up/down events are usually generated after the actual press is complete, and in rapid succession.
 *
 * The other problem (which is more of a problem with keyboards like the C1P than any IBM keyboards) is
 * that the shift/modifier state for a character on the "source" keyboard may not match the shift/modifier
 * state for the same character on the "target" keyboard.  And since this code is inherited from C1Pjs,
 * we've inherited the same solution: simulateKey() has the ability to "undo" any states in bitsState
 * that conflict with the state(s) required for the character in question.
 */
Keyboard.SIMCODES = {
    [Keyboard.SIMCODE.ESC]:         Keyboard.SCANCODE.ESC,
    [Keys.ASCII['1']]:              Keyboard.SCANCODE.ONE,
    [Keys.ASCII['!']]:              Keyboard.SCANCODE.ONE    | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['2']]:              Keyboard.SCANCODE.TWO,
    [Keys.ASCII['@']]:              Keyboard.SCANCODE.TWO    | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['3']]:              Keyboard.SCANCODE.THREE,
    [Keys.ASCII['#']]:              Keyboard.SCANCODE.THREE  | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['4']]:              Keyboard.SCANCODE.FOUR,
    [Keys.ASCII['$']]:              Keyboard.SCANCODE.FOUR   | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['5']]:              Keyboard.SCANCODE.FIVE,
    [Keys.ASCII['%']]:              Keyboard.SCANCODE.FIVE   | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['6']]:              Keyboard.SCANCODE.SIX,
    [Keys.ASCII['^']]:              Keyboard.SCANCODE.SIX    | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['7']]:              Keyboard.SCANCODE.SEVEN,
    [Keys.ASCII['&']]:              Keyboard.SCANCODE.SEVEN  | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['8']]:              Keyboard.SCANCODE.EIGHT,
    [Keys.ASCII['*']]:              Keyboard.SCANCODE.EIGHT  | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['9']]:              Keyboard.SCANCODE.NINE,
    [Keys.ASCII['(']]:              Keyboard.SCANCODE.NINE   | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['0']]:              Keyboard.SCANCODE.ZERO,
    [Keys.ASCII[')']]:              Keyboard.SCANCODE.ZERO   | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['-']]:              Keyboard.SCANCODE.DASH,
    [Keys.ASCII['_']]:              Keyboard.SCANCODE.DASH   | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['=']]:              Keyboard.SCANCODE.EQUALS,
    [Keys.ASCII['+']]:              Keyboard.SCANCODE.EQUALS | (Keyboard.SCANCODE.SHIFT << 8),
    [Keyboard.SIMCODE.BS]:          Keyboard.SCANCODE.BS,
    [Keyboard.SIMCODE.TAB]:         Keyboard.SCANCODE.TAB,
    [Keys.ASCII.q]:                 Keyboard.SCANCODE.Q,
    [Keys.ASCII.Q]:                 Keyboard.SCANCODE.Q      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.w]:                 Keyboard.SCANCODE.W,
    [Keys.ASCII.W]:                 Keyboard.SCANCODE.W      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.e]:                 Keyboard.SCANCODE.E,
    [Keys.ASCII.E]:                 Keyboard.SCANCODE.E      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.r]:                 Keyboard.SCANCODE.R,
    [Keys.ASCII.R]:                 Keyboard.SCANCODE.R      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.t]:                 Keyboard.SCANCODE.T,
    [Keys.ASCII.T]:                 Keyboard.SCANCODE.T      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.y]:                 Keyboard.SCANCODE.Y,
    [Keys.ASCII.Y]:                 Keyboard.SCANCODE.Y      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.u]:                 Keyboard.SCANCODE.U,
    [Keys.ASCII.U]:                 Keyboard.SCANCODE.U      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.i]:                 Keyboard.SCANCODE.I,
    [Keys.ASCII.I]:                 Keyboard.SCANCODE.I      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.o]:                 Keyboard.SCANCODE.O,
    [Keys.ASCII.O]:                 Keyboard.SCANCODE.O      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.p]:                 Keyboard.SCANCODE.P,
    [Keys.ASCII.P]:                 Keyboard.SCANCODE.P      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['[']]:              Keyboard.SCANCODE.LBRACK,
    [Keys.ASCII['{']]:              Keyboard.SCANCODE.LBRACK | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII[']']]:              Keyboard.SCANCODE.RBRACK,
    [Keys.ASCII['}']]:              Keyboard.SCANCODE.RBRACK | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.KEYCODE.CR]:              Keyboard.SCANCODE.ENTER,
    [Keyboard.SIMCODE.CTRL]:        Keyboard.SCANCODE.CTRL,
    [Keys.ASCII.a]:                 Keyboard.SCANCODE.A,
    [Keys.ASCII.A]:                 Keyboard.SCANCODE.A      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.s]:                 Keyboard.SCANCODE.S,
    [Keys.ASCII.S]:                 Keyboard.SCANCODE.S      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.d]:                 Keyboard.SCANCODE.D,
    [Keys.ASCII.D]:                 Keyboard.SCANCODE.D      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.f]:                 Keyboard.SCANCODE.F,
    [Keys.ASCII.F]:                 Keyboard.SCANCODE.F      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.g]:                 Keyboard.SCANCODE.G,
    [Keys.ASCII.G]:                 Keyboard.SCANCODE.G      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.h]:                 Keyboard.SCANCODE.H,
    [Keys.ASCII.H]:                 Keyboard.SCANCODE.H      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.j]:                 Keyboard.SCANCODE.J,
    [Keys.ASCII.J]:                 Keyboard.SCANCODE.J      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.k]:                 Keyboard.SCANCODE.K,
    [Keys.ASCII.K]:                 Keyboard.SCANCODE.K      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.l]:                 Keyboard.SCANCODE.L,
    [Keys.ASCII.L]:                 Keyboard.SCANCODE.L      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII[';']]:              Keyboard.SCANCODE.SEMI,
    [Keys.ASCII[':']]:              Keyboard.SCANCODE.SEMI   | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII["'"]]:              Keyboard.SCANCODE.QUOTE,
    [Keys.ASCII['"']]:              Keyboard.SCANCODE.QUOTE  | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['`']]:              Keyboard.SCANCODE.BQUOTE,
    [Keys.ASCII['~']]:              Keyboard.SCANCODE.BQUOTE | (Keyboard.SCANCODE.SHIFT << 8),
    [Keyboard.SIMCODE.SHIFT]:       Keyboard.SCANCODE.SHIFT,
    [Keys.ASCII['\\']]:             Keyboard.SCANCODE.BSLASH,
    [Keys.ASCII['|']]:              Keyboard.SCANCODE.BSLASH | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.z]:                 Keyboard.SCANCODE.Z,
    [Keys.ASCII.Z]:                 Keyboard.SCANCODE.Z      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.x]:                 Keyboard.SCANCODE.X,
    [Keys.ASCII.X]:                 Keyboard.SCANCODE.X      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.c]:                 Keyboard.SCANCODE.C,
    [Keys.ASCII.C]:                 Keyboard.SCANCODE.C      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.v]:                 Keyboard.SCANCODE.V,
    [Keys.ASCII.V]:                 Keyboard.SCANCODE.V      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.b]:                 Keyboard.SCANCODE.B,
    [Keys.ASCII.B]:                 Keyboard.SCANCODE.B      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.n]:                 Keyboard.SCANCODE.N,
    [Keys.ASCII.N]:                 Keyboard.SCANCODE.N      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII.m]:                 Keyboard.SCANCODE.M,
    [Keys.ASCII.M]:                 Keyboard.SCANCODE.M      | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII[',']]:              Keyboard.SCANCODE.COMMA,
    [Keys.ASCII['<']]:              Keyboard.SCANCODE.COMMA  | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['.']]:              Keyboard.SCANCODE.PERIOD,
    [Keys.ASCII['>']]:              Keyboard.SCANCODE.PERIOD | (Keyboard.SCANCODE.SHIFT << 8),
    [Keys.ASCII['/']]:              Keyboard.SCANCODE.SLASH,
    [Keys.ASCII['?']]:              Keyboard.SCANCODE.SLASH  | (Keyboard.SCANCODE.SHIFT << 8),
    [Keyboard.SIMCODE.RSHIFT]:      Keyboard.SCANCODE.RSHIFT,
    [Keyboard.SIMCODE.PRTSC]:       Keyboard.SCANCODE.PRTSC,
    [Keyboard.SIMCODE.ALT]:         Keyboard.SCANCODE.ALT,
    [Keyboard.SIMCODE.RALT]:        Keyboard.SCANCODE.ALT,
    [Keyboard.SIMCODE.SPACE]:       Keyboard.SCANCODE.SPACE,
    [Keyboard.SIMCODE.CAPS_LOCK]:   Keyboard.SCANCODE.CAPS_LOCK,
    [Keyboard.SIMCODE.F1]:          Keyboard.SCANCODE.F1,
    [Keyboard.SIMCODE.F2]:          Keyboard.SCANCODE.F2,
    [Keyboard.SIMCODE.F3]:          Keyboard.SCANCODE.F3,
    [Keyboard.SIMCODE.F4]:          Keyboard.SCANCODE.F4,
    [Keyboard.SIMCODE.F5]:          Keyboard.SCANCODE.F5,
    [Keyboard.SIMCODE.F6]:          Keyboard.SCANCODE.F6,
    [Keyboard.SIMCODE.F7]:          Keyboard.SCANCODE.F7,
    [Keyboard.SIMCODE.F8]:          Keyboard.SCANCODE.F8,
    [Keyboard.SIMCODE.F9]:          Keyboard.SCANCODE.F9,
    [Keyboard.SIMCODE.F10]:         Keyboard.SCANCODE.F10,
    [Keyboard.SIMCODE.NUM_LOCK]:    Keyboard.SCANCODE.NUM_LOCK,
    [Keyboard.SIMCODE.SCROLL_LOCK]: Keyboard.SCANCODE.SCROLL_LOCK,
    [Keyboard.SIMCODE.HOME]:        Keyboard.SCANCODE.NUM_HOME,
    [Keyboard.SIMCODE.NUM_HOME]:    Keyboard.SCANCODE.NUM_HOME,
    [Keyboard.SIMCODE.UP]:          Keyboard.SCANCODE.NUM_UP,
    [Keyboard.SIMCODE.NUM_UP]:      Keyboard.SCANCODE.NUM_UP,
    [Keyboard.SIMCODE.PGUP]:        Keyboard.SCANCODE.NUM_PGUP,
    [Keyboard.SIMCODE.NUM_PGUP]:    Keyboard.SCANCODE.NUM_PGUP,
    [Keyboard.SIMCODE.LEFT]:        Keyboard.SCANCODE.NUM_LEFT,
    [Keyboard.SIMCODE.NUM_LEFT]:    Keyboard.SCANCODE.NUM_LEFT,
    [Keyboard.SIMCODE.NUM_CENTER]:  Keyboard.SCANCODE.NUM_CENTER,
    [Keyboard.SIMCODE.RIGHT]:       Keyboard.SCANCODE.NUM_RIGHT,
    [Keyboard.SIMCODE.NUM_RIGHT]:   Keyboard.SCANCODE.NUM_RIGHT,
    [Keyboard.SIMCODE.END]:         Keyboard.SCANCODE.NUM_END,
    [Keyboard.SIMCODE.NUM_END]:     Keyboard.SCANCODE.NUM_END,
    [Keyboard.SIMCODE.DOWN]:        Keyboard.SCANCODE.NUM_DOWN,
    [Keyboard.SIMCODE.NUM_DOWN]:    Keyboard.SCANCODE.NUM_DOWN,
    [Keyboard.SIMCODE.PGDN]:        Keyboard.SCANCODE.NUM_PGDN,
    [Keyboard.SIMCODE.NUM_PGDN]:    Keyboard.SCANCODE.NUM_PGDN,
    [Keyboard.SIMCODE.INS]:         Keyboard.SCANCODE.NUM_INS,
    [Keyboard.SIMCODE.NUM_INS]:     Keyboard.SCANCODE.NUM_INS,
    [Keyboard.SIMCODE.NUM_ADD]:     Keyboard.SCANCODE.NUM_ADD,
    [Keyboard.SIMCODE.NUM_SUB]:     Keyboard.SCANCODE.NUM_SUB,
    [Keyboard.SIMCODE.DEL]:         Keyboard.SCANCODE.NUM_DEL,
    [Keyboard.SIMCODE.NUM_DEL]:     Keyboard.SCANCODE.NUM_DEL,
    [Keyboard.SIMCODE.SYS_REQ]:     Keyboard.SCANCODE.SYS_REQ,
    /*
     * Entries beyond this point are for keys that existed only on 101-key keyboards (well, except for 'sys-req',
     * which also existed on the 84-key keyboard), which ALSO means that these keys essentially did not exist
     * for a MODEL_5150 or MODEL_5160 machine, because those machines could use only 83-key keyboards.  Remember
     * that IBM machines and IBM keyboards are our reference point here, so while there were undoubtedly 5150/5160
     * clones that could use newer keyboards, as well as 3rd-party keyboards that could work with older machines,
     * support for non-IBM configurations is left for another day.
     *
     * TODO: The only relevance of newer keyboards to older machines is the fact that you're probably using a newer
     * keyboard with your browser, which raises the question of what to do with newer keys that older machines
     * wouldn't understand.  I don't attempt to filter out any of the entries below based on machine model, but that
     * would seem like a wise thing to do.
     *
     * TODO: Add entries for 'num-mul', 'num-div', 'num-enter', the stand-alone arrow keys, etc, AND at the same time,
     * make sure that keys with multi-byte sequences (eg, 0xe0 0x1c) work properly.
     */
    [Keyboard.SIMCODE.F11]:         Keyboard.SCANCODE.F11,
    [Keyboard.SIMCODE.F12]:         Keyboard.SCANCODE.F12,
    [Keyboard.SIMCODE.CMD]:         Keyboard.SCANCODE.WIN,
    [Keyboard.SIMCODE.RCMD]:        Keyboard.SCANCODE.MENU,
    [Keyboard.SIMCODE.FF_CMD]:      Keyboard.SCANCODE.WIN,

    [Keyboard.SIMCODE.CTRL_A]:      Keyboard.SCANCODE.A           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_B]:      Keyboard.SCANCODE.B           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_C]:      Keyboard.SCANCODE.C           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_D]:      Keyboard.SCANCODE.D           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_E]:      Keyboard.SCANCODE.E           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_F]:      Keyboard.SCANCODE.F           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_G]:      Keyboard.SCANCODE.G           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_H]:      Keyboard.SCANCODE.H           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_I]:      Keyboard.SCANCODE.I           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_J]:      Keyboard.SCANCODE.J           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_K]:      Keyboard.SCANCODE.K           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_L]:      Keyboard.SCANCODE.L           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_M]:      Keyboard.SCANCODE.M           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_N]:      Keyboard.SCANCODE.N           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_O]:      Keyboard.SCANCODE.O           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_P]:      Keyboard.SCANCODE.P           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_Q]:      Keyboard.SCANCODE.Q           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_R]:      Keyboard.SCANCODE.R           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_S]:      Keyboard.SCANCODE.S           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_T]:      Keyboard.SCANCODE.T           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_U]:      Keyboard.SCANCODE.U           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_V]:      Keyboard.SCANCODE.V           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_W]:      Keyboard.SCANCODE.W           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_X]:      Keyboard.SCANCODE.X           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_Y]:      Keyboard.SCANCODE.Y           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_Z]:      Keyboard.SCANCODE.Z           | (Keyboard.SCANCODE.CTRL << 8),
    [Keyboard.SIMCODE.CTRL_BREAK]:  Keyboard.SCANCODE.SCROLL_LOCK | (Keyboard.SCANCODE.CTRL << 8),

    [Keyboard.SIMCODE.CTRL_ALT_DEL]:    Keyboard.SCANCODE.NUM_DEL | (Keyboard.SCANCODE.CTRL << 8) | (Keyboard.SCANCODE.ALT << 16),
    [Keyboard.SIMCODE.CTRL_ALT_INS]:    Keyboard.SCANCODE.NUM_INS | (Keyboard.SCANCODE.CTRL << 8) | (Keyboard.SCANCODE.ALT << 16),
    [Keyboard.SIMCODE.CTRL_ALT_ADD]:    Keyboard.SCANCODE.NUM_ADD | (Keyboard.SCANCODE.CTRL << 8) | (Keyboard.SCANCODE.ALT << 16),
    [Keyboard.SIMCODE.CTRL_ALT_SUB]:    Keyboard.SCANCODE.NUM_SUB | (Keyboard.SCANCODE.CTRL << 8) | (Keyboard.SCANCODE.ALT << 16),
    [Keyboard.SIMCODE.CTRL_ALT_ENTER]:  Keyboard.SCANCODE.ENTER   | (Keyboard.SCANCODE.CTRL << 8) | (Keyboard.SCANCODE.ALT << 16)
};

/**
 * Commands that can be sent to the Keyboard via the 8042; see receiveCmd()
 *
 * Aside from the commands listed below, 0xEF-0xF2 and 0xF7-0xFD are expressly documented as NOPs; ie:
 *
 *      These commands are reserved and are effectively no-operation or NOP. The system does not use these codes.
 *      If sent, the keyboard will acknowledge the command and continue in its prior scanning state. No other
 *      operation will occur.
 *
 * However, IBM's documentation is silent with regard to 0x00-0xEC.  It's likely that most if not all of those
 * commands are NOPs as well.
 *
 * @enum {number}
 */
Keyboard.CMD = {
    /*
     * RESET (0xFF)
     *
     * The system issues a RESET command to start a program reset and a keyboard internal self-test. The keyboard
     * acknowledges the command with an 'acknowledge' signal (ACK) and ensures the system accepts the ACK before
     * executing the command. The system signals acceptance of the ACK by raising the clock and data for a minimum
     * of 500 microseconds. The keyboard is disabled from the time it receives the RESET command until the ACK is
     * accepted or until another command overrides the previous one. Following acceptance of the ACK, the keyboard
     * begins the reset operation, which is similar to a power-on reset. The keyboard clears the output buffer and
     * sets up default values for typematic and delay rates.
     */
    RESET:      0xFF,

    /*
     * RESEND (0xFE)
     *
     * The system can send this command when it detects an error in any transmission from the keyboard. It can be
     * sent only after a keyboard transmission and before the system enables the interface to allow the next keyboard
     * output. Upon receipt of RESEND, the keyboard sends the previous output again unless the previous output was
     * RESEND. In this case, the keyboard will resend the last byte before the RESEND command.
     */
    RESEND:     0xFE,

    /*
     * SET DEFAULT (0xF6)
     *
     * The SET DEFAULT command resets all conditions to the power-on default state. The keyboard responds with ACK,
     * clears its output buffer, sets default conditions, and continues scanning (only if the keyboard was previously
     * enabled).
     */
    DEF_ON:     0xF6,

    /*
     * DEFAULT DISABLE (0xF5)
     *
     * This command is similar to SET DEFAULT, except the keyboard stops scanning and awaits further instructions.
     */
    DEF_OFF:    0xF5,

    /*
     * ENABLE (0xF4)
     *
     * Upon receipt of this command, the keyboard responds with ACK, clears its output buffer, and starts scanning.
     */
    ENABLE:     0xF4,

    /*
     * SET TYPEMATIC RATE/DELAY (0xF3)
     *
     * The system issues this command, followed by a parameter, to change the typematic rate and delay. The typematic
     * rate and delay parameters are determined by the value of the byte following the command. Bits 6 and 5 serve as
     * the delay parameter and bits 4,3,2, 1, and 0 (the least-significant bit) are the rate parameter. Bit 7, the
     * most-significant bit, is always 0. The delay is equal to 1 plus the binary value of bits 6 and 5 multiplied by
     * 250 milliseconds Â±20%.
     */
    SET_RATE:   0xF3,

    /*
     * ECHO (0xEE)
     *
     * ECHO is a diagnostic aid. When the keyboard receives this command, it issues a 0xEE response and continues
     * scanning if the keyboard was previously enabled.
     */
    ECHO:       0xEE,

    /*
     * SET/RESET MODE INDICATORS (0xED)
     *
     * Three mode indicators on the keyboard are accessible to the system. The keyboard activates or deactivates
     * these indicators when it receives a valid command from the system. They can be activated or deactivated in
     * any combination.
     *
     * The system remembers the previous state of an indicator so that its setting does not change when a command
     * sequence is issued to change the state of another indicator.
     *
     * A SET/RESET MODE INDICATORS command consists of 2 bytes. The first is the command byte and has the following
     * bit setup:
     *
     *      11101101 - 0xED
     *
     * The second byte is an option byte. It has a list of the indicators to be acted upon. The bit assignments for
     * this option byte are as follows:
     *
     *      Bit         Indicator
     *      ---         ---------
     *       0          Scroll Lock Indicator
     *       1          Num Lock Indicator
     *       2          Caps Lock Indicator
     *      3-7         Reserved (must be 0's)
     *
     * NOTE: Bit 7 is the most-significant bit; bit 0 is the least-significant.
     *
     * The keyboard will respond to the set/reset mode indicators command with an ACK, discontinue scanning, and wait
     * for the option byte. The keyboard will respond to the option byte with an ACK, set the indicators, and continue
     * scanning if the keyboard was previously enabled. If another command is received in place of the option byte,
     * execution of the function of the SET/RESET MODE INDICATORS command is stopped with no change to the indicator
     * states, and the new command is processed. Then scanning is resumed.
     */
    SET_LEDS:   0xED
};

/**
 * Command responses returned to the Keyboard via the 8042; see receiveCmd()
 *
 * @enum {number}
 */
Keyboard.CMDRES = {
    /*
     * OVERRUN (0x00)
     *
     * An overrun character is placed in position 17 of the keyboard buffer, overlaying the last code if the
     * buffer becomes full. The code is sent to the system as an overrun when it reaches the top of the buffer.
     */
    OVERRUN:    0x00,

    LOAD_TEST:  0x65,   // undocumented "LOAD MANUFACTURING TEST REQUEST" response code

    /*
     * BAT Completion Code (0xAA)
     *
     * Following satisfactory completion of the BAT, the keyboard sends 0xAA. 0xFC (or any other code)
     * means the keyboard microprocessor check failed.
     */
    BAT_OK:     0xAA,

    /*
     * ECHO Response (0xEE)
     *
     * This is sent in response to an ECHO command (also 0xEE) from the system.
     */
    ECHO:       0xEE,

    /*
     * BREAK CODE PREFIX (0xF0)
     *
     * This code is sent as the first byte of a 2-byte sequence to indicate the release of a key.
     */
    BREAK_PREF: 0xF0,

    /*
     * ACK (0xFA)
     *
     * The keyboard issues an ACK response to any valid input other than an ECHO or RESEND command.
     * If the keyboard is interrupted while sending ACK, it will discard ACK and accept and respond
     * to the new command.
     */
    ACK:        0xFA,

    /*
     * BASIC ASSURANCE TEST FAILURE (0xFC)
     */
    BAT_FAIL:   0xFC,   // TODO: Verify this response code (is this just for older 83-key keyboards?)

    /*
     * DIAGNOSTIC FAILURE (0xFD)
     *
     * The keyboard periodically tests the sense amplifier and sends a diagnostic failure code if it detects
     * any problems. If a failure occurs during BAT, the keyboard stops scanning and waits for a system command
     * or power-down to restart. If a failure is reported after scanning is enabled, scanning continues.
     */
    DIAG_FAIL:  0xFD,

    /*
     * RESEND (0xFE)
     *
     * The keyboard issues a RESEND command following receipt of an invalid input, or any input with incorrect parity.
     * If the system sends nothing to the keyboard, no response is required.
     */
    RESEND:     0xFE,

    BUFF_FULL:  0xFF    // TODO: Verify this response code (is this just for older 83-key keyboards?)
};

Keyboard.LIMIT = {
    MAX_SCANCODES: 20   // TODO: Verify this limit for newer keyboards (84-key and up)
};

Keyboard.INJECTION = {
    NONE:       0,
    ON_START:   1,
    ON_INPUT:   2
};

/*
 * Initialize every Keyboard module on the page.
 */
Web.onInit(Keyboard.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/video.js (C) Jeff Parsons 2012-2018
 */


/*
 * MDA/CGA Support
 * ---------------
 *
 * Since there's a lot of similarity between the MDA and CGA (eg, their text-mode video buffer
 * format, and their use of the 6845 CRT controller), since the MDA ROM contains the fonts used
 * by both devices, and since the same ROM BIOS supports both (in fact, the BIOS indiscriminately
 * initializes both, regardless which is actually installed), this same component emulates both
 * devices.
 *
 * When no model is specified, this component supports the ability to dynamically switch between
 * MDA and CGA emulation, by simply toggling the SW1 motherboard "monitor type" switch settings
 * and resetting the machine.  In that model-less configuration, we install I/O port handlers for
 * both MDA and CGA cards, regardless which monitor type is initially selected.
 *
 * To simulate an IBM PC containing both an MDA and CGA (ie, a "dual display" system), the machine
 * configuration simply defines two video components, one with model "mda" and the other with model
 * "cga", resulting in two displays; setting a specific model forces each instance of this component
 * to register only those I/O ports belonging to that model.
 *
 * In a single-display system, dynamically switching cards (ie, between MDA and CGA) creates some
 * visual challenges.  For one, the MDA prefers a native screen size of 720x350, as it supports only
 * one video mode, 80x25, with a 9x14 cell size.  The CGA, on the other hand, has an 8x8 cell size,
 * so when using an MDA-size screen, an 80x25 CGA screen will end up with 40-pixel borders on the
 * left and right, and 75-pixel borders on the top and bottom.  The result is a rather tiny CGA font
 * surrounded by lots of wasted space, so it's best to turn on font scaling (see the "scale" property)
 * and go with a larger screen size of, say, 960x400 (50% larger in width, 100% larger in height).
 *
 * I've also added support for font-doubling in createFont().  We use the 8x8 font for 80-column
 * modes and the "doubled" 16x16 font for 40-column modes OR whenever the screen is large enough
 * to use the 16x16 font, since font rendering without scaling provides the sharpest results.
 * In fact, there's special logic in setDimensions() to ignore fScaleFont in certain cases (eg,
 * 40-column modes, to improve sharpness and avoid stretching the font beyond readability).
 *
 * Graphics modes, on the other hand, are always scaled to the screen size.  Pixels are captured
 * in an off-screen buffer, which is then drawn to match the size of the virtual screen.
 *
 * TODO: Whenever there are borders, they should be filled with the CGA's overscan colors.  However,
 * in the case of graphics modes (and text modes whenever font scaling is enabled), we don't reserve
 * any space for borders, so if borders are important, explicit border support will be required.
 *
 * EGA Support
 * -----------
 *
 * EGA support piggy-backs on the existing MDA/CGA support.  All the existing MDA/CGA port handlers
 * now refer to either cardMono or cardColor (instead of directly to cardMDA or cardCGA), enabling
 * the handlers to be redirected to cardMDA, cardCGA or cardEGA as appropriate.
 *
 * Note that an MDA card supported only a Monochrome Display and a CGA card supported only a Color
 * Display (well, OK, *or* a TV monitor, which we don't currently support), but the EGA is much
 * more flexible: the Enhanced Color Display was the preferred display, but the EGA also supported
 * older displays; a Color Display on EGA wasn't ideal (same low resolutions but with more colors),
 * but the EGA also brought high-resolution graphics to Monochrome displays, which was nice.  Anyway,
 * while all those EGA/monitor combinations will be nice to support, our virtual display support
 * will focus initially on the Enhanced Color Display.
 *
 * TODO: Add support for jumpers P1 and P3 (see EGA TechRef p.85).  P1 selects either 5-color-output
 * for a CGA monitor or 6-color-output for an EGA monitor; we would presumably use this only to
 * control certain assumptions about the virtual display's capabilities (ie, Color Display vs. Enhanced
 * Color Display).  P3 can switch all the I/O ports from 0x3nn to 0x2nn; the default is 0x3nn, and
 * that's the only port range the EGA ROM supports as well.
 *
 * For quick reference, IBM EGA register values for the standard EGA modes, from pages 63-68 of the
 * "IBM Enhanced Graphics Adapter" (http://minuszerodegrees.net/oa/OA - IBM Enhanced Graphics Adapter.pdf).
 *
 * WARNING: Some of these value are not programmed exactly as-is; for example, the CURSCANB values are
 * adjusted +1 by the ROM BIOS in most cases, due to an EGA idiosyncrasy that IBM may not have intended.
 *
 *      INT 0x10 Mode Requested:    00  01  02  03  04  05  06  07  0D  0E  0F  10  0F^ 10^ 00* 01* 02* 03*
 *
 *      BIOSMODE:                   01  01  03  03  04  04  06  07  0D  0E  0F  10  0F  10  01  01  03  03
 *      CRTC[0x00]: HTOTAL          37  37  70  70  37  37  70  60  37  70  60  5B  60  5B  2D  2D  5B  5B
 *      CRTC[0x01]: HDEND           27  27  4F  4F  27  27  4F  4F  27  4F  4F  4F  4F  4F  27  27  4F  4F
 *      CRTC[0x02]: HBSTART         2D  2D  5C  %C  2D  2D  59  56  2D  56  56  53  56  53  2B  2B  53  53
 *      CRTC[0x03]: HBEND           37  37  2F  2F  37  37  2D  3A  37  2D  1A  17  3A  37  2D  2D  37  37
 *      CRTC[0x04]: HRSTART         31  31  5F  5F  30  30  5E  51  30  5E  50  50  50  52  28  28  51  51
 *      CRTC[0x05]: HREND           15  15  07  07  14  14  06  60  14  06  E0  BA  60  00  6D  6D  5B  5B
 *      CRTC[0x06]: VTOTAL          04  04  04  04  04  04  04  70  04  04  70  6C  70  6C  6C  6C  6C  6C
 *      CRTC[0x07]: OVERFLOW        11  11  11  11  11  11  11  1F  11  11  1F  1F  1F  1F  1F  1F  1F  1F
 *      CRTC[0x08]: PRESCAN         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *      CRTC[0x09]: MAXSCAN         07  07  07  07  01  01  01  0D  00  00  00  00  00  00  0D  0D  0D  0D
 *      CRTC[0x0A]: CURSCAN         06  06  06  06  00  00  00  0B  00  00  00  00  00  00  0B  0B  0B  0B
 *      CRTC[0x0B]: CURSCANB        07  07  07  07  00  00  00  0C  00  00  00  00  00  00  0C  0C  0C  0C
 *      CRTC[0x0C]: STARTHI         --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
 *      CRTC[0x0D]: STARTLO         --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
 *      CRTC[0x0E]: CURSORHI        --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
 *      CRTC[0x0F]: CURSORLO        --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
 *      CRTC[0x10]: VRSTART         E1  E1  E1  E1  E1  E1  E0  5E  E1  E0  5E  5E  5E  5E  5E  5E  5E  5E
 *      CRTC[0x11]: VREND           24  24  24  24  24  24  23  2E  24  23  2E  2B  2E  2B  2B  2B  2B  2B
 *      CRTC[0x12]: VDEND           C7  C7  C7  C7  C7  C7  C7  5D  C7  C7  5D  5D  5D  5D  5D  5D  5D  5D
 *      CRTC[0x13]: OFFSET          14  14  28  28  14  14  28  28  14  28  14  14  28  28  14  14  28  28
 *      CRTC[0x14]: UNDERLINE       08  08  08  08  00  00  00  0D  00  00  0D  0F  0D  0F  0F  0F  0F  0F
 *      CRTC[0x15]: VBSTART         E0  E0  E0  E0  E0  E0  DF  5E  E0  DF  5E  5F  5E  5F  5E  5E  5E  5E
 *      CRTC[0x16]: VBEND           F0  F0  F0  F0  F0  F0  EF  6E  F0  EF  6E  0A  6E  0A  0A  0A  0A  0A
 *      CRTC[0x17]: MODECTRL        A3  A3  A3  A3  A2  A2  C2  A3  E3  E3  8B  8B  E3  E3  A3  A3  A3  A3
 *      CRTC[0x18]: LINECOMP        FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF
 *       GRC[0x00]: SRESET          00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x01]: ESRESET         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x02]: COLORCOMP       00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x03]: DATAROT         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x04]: READMAP         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x05]: MODE            10  10  10  10  30  30  00  10  00  00  10  10  00  00  10  10  10  10
 *       GRC[0x06]: MISC            0E  0E  0E  0E  0F  0F  0D  0A  05  05  07  07  05  05  0E  0E  0E  0E
 *       GRC[0x07]: COLORDC         00  00  00  00  00  00  00  00  0F  0F  0F  0F  0F  0F  00  00  00  00
 *       GRC[0x08]: BITMASK         FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF
 *       SEQ[0x00]: RESET           03  03  03  03  03  03  03  03  03  03  03  03  03  03  03  03  03  03
 *       SEQ[0x01]: CLKMODE         0B  0B  01  01  0B  0B  01  00  0B  01  05  05  01  01  0B  0B  01  01
 *       SEQ[0x02]: MAPMASK         03  03  03  03  03  03  01  03  0F  0F  0F  0F  0F  0F  03  03  03  03
 *       SEQ[0x03]: CHARMAP         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       SEQ[0x04]: MEMMODE         03  03  03  03  02  02  06  03  06  06  00  00  06  06  03  03  03  03
 *       ATC[0x00]: PAL00           00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       ATC[0x01]: PAL01           01  01  01  01  13  13  17  08  01  01  08  01  08  01  01  01  01  01
 *       ATC[0x02]: PAL02           02  02  02  02  15  15  17  08  02  02  00  00  00  02  02  02  02  02
 *       ATC[0x03]: PAL03           03  03  03  03  17  17  17  08  03  03  00  00  00  03  03  03  03  03
 *       ATC[0x04]: PAL04           04  04  04  04  02  02  17  08  04  04  18  04  18  04  04  04  04  04
 *       ATC[0x05]: PAL05           05  05  05  05  04  04  17  08  05  05  18  07  18  05  05  05  05  05
 *       ATC[0x06]: PAL06           06  06  06  06  06  06  17  08  06  06  00  00  00  06  14  14  14  14
 *       ATC[0x07]: PAL07           07  07  07  07  07  07  17  08  07  07  00  00  00  07  07  07  07  07
 *       ATC[0x08]: PAL08           10  10  10  10  10  10  17  10  10  10  00  00  00  38  38  38  38  38
 *       ATC[0x09]: PAL09           11  11  11  11  11  11  17  18  11  11  08  01  08  39  39  39  39  39
 *       ATC[0x0A]: PAL0A           12  12  12  12  12  12  17  18  12  12  00  00  00  3A  3A  3A  3A  3A
 *       ATC[0x0B]: PAL0B           13  13  13  13  13  13  17  18  13  13  00  00  00  3B  3B  3B  3B  3B
 *       ATC[0x0C]: PAL0C           14  14  14  14  14  14  17  18  14  14  00  04  00  3C  3C  3C  3C  3C
 *       ATC[0x0D]: PAL0D           15  15  15  15  15  15  17  18  15  15  18  07  18  3D  3D  3D  3D  3D
 *       ATC[0x0E]: PAL0E           16  16  16  16  16  16  17  18  16  16  00  00  00  3E  3E  3E  3E  3E
 *       ATC[0x0F]: PAL0F           17  17  17  17  17  17  18  17  17  00  00  00  3F  3F  3F  3F  3F  3F
 *       ATC[0x10]: MODE            08  08  08  08  01  01  01  0E  01  01  0B  0B  0B  01  08  08  08  08
 *       ATC[0x11]: OVERSCAN        00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       ATC[0x12]: PLANES          0F  0F  0F  0F  03  03  01  0F  0F  0F  05  05  05  0F  0F  0F  0F  0F
 *       ATC[0x13]: HPAN            00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *
 * VGA Support
 * -----------
 *
 * VGA support further piggy-backs on the existing EGA support, by adding the extra registers, I/O port
 * handlers, etc, that the VGA requires; any differences in registers common to both EGA and VGA are handled on
 * a case-by-case basis, usually according to the Video.CARD value stored in nCard.
 *
 * More will be said here about PCjs VGA support later.  But first, a word from IBM: "Video Graphics Array [VGA]
 * Programming Considerations":
 *
 *      Certain internal timings must be guaranteed by the user, in order to have the CRTC perform properly.
 *      This is due to the physical design of the chip. These timings can be guaranteed by ensuring that the
 *      rules listed below are followed when programming the CRTC.
 *
 *           1. The Horizontal Total [HTOTAL] register (R0) must be greater than or equal to a value of
 *              25 decimal.
 *
 *           2. The minimum positive pulse width of the HSYNC output must be four character clock units.
 *
 *           3. Register R5, Horizontal Sync End [HREND], must be programmed such that the HSYNC
 *              output goes to a logic 0 a minimum of one character clock time before the 'horizontal display enable'
 *              signal goes to a logical 1.
 *
 *           4. Register R16, Vsync Start [VRSTART], must be a minimum of one horizontal scan line greater
 *              than register R18 [VDEND].  Register R18 defines where the 'vertical display enable' signal ends.
 *
 *     When bit 5 of the Attribute Mode Control register equals 1, a successful line compare (see Line Compare
 *     [LINECOMP] register) in the CRT Controller forces the output of the PEL Panning register to 0's until Vsync
 *     occurs.  When Vsync occurs, the output returns to the programmed value.  This allows the portion of the screen
 *     indicated by the Line Compare register to be operated on by the PEL Panning register.
 *
 *     A write to the Character Map Select register becomes valid on the next whole character line.  No deformed
 *     characters are displayed by changing character generators in the middle of a character scan line.
 *
 *     For 256-color 320 x 200 graphics mode hex 13, the attribute controller is configured so that the 8-bit attribute
 *     stored in video memory for each PEL becomes the 8-bit address (P0 - P7) into the integrated DAC.  The user should
 *     not modify the contents of the internal Palette registers when using this mode.
 *
 *     The following sequence should be followed when accessing any of the Attribute Data registers pointed to by the
 *     Attribute Index register:
 *
 *           1. Disable interrupts
 *           2. Reset read/write flip/flop
 *           3. Write to Index register
 *           4. Read from or write to a data register
 *           5. Enable interrupts
 *
 *      The Color Select register in the Attribute Controller section may be used to rapidly switch between sets of colors
 *      in the video DAC.  When bit 7 of the Attribute Mode Control register equals 0, the 8-bit color value presented to the
 *      video DAC is composed of 6 bits from the internal Palette registers and bits 2 and 3 from the Color Select register.
 *      When bit 7 of the Attribute Mode Control register equals 1, the 8-bit color value presented to the video DAC is
 *      composed of the lower four bits from the internal Palette registers and the four bits in the Color Select register.
 *      By changing the value in the Color Select register, software rapidly switches between sets of colors in the video DAC.
 *      Note that BIOS does not support multiple sets of colors in the video DAC.  The user must load these colors if this
 *      function is to be used.  Also see the Attribute Controller block diagram on page 4-26.  Note that the above discussion
 *      applies to all modes except 256 Color Graphics mode.  In this mode the Color Select register is not used to switch
 *      between sets of colors.
 *
 *      An application that saves the "Video State" must store the 4 bytes of information contained in the system microprocessor
 *      latches in the graphics controller subsection. These latches are loaded with 32 bits from video memory (8 bits per map)
 *      each time the system microprocessor does a read from video memory.  The application needs to:
 *
 *           1. Use write mode 1 to write the values in the latches to a location in video memory that is not part of
 *              the display buffer.  The last location in the address range is a good choice.
 *
 *           2. Save the values of the latches by reading them back from video memory.
 *
 *           Note: If in a chain 4 or odd/even mode, it will be necessary to reconfigure the memory organization as four
 *           sequential maps prior to performing the sequence above.  BIOS provides support for completely saving and
 *           restoring video state.  See the IBM Personal System/2 and Personal Computer BIOS Interface Technical Reference
 *           for more information.
 *
 *      The description of the Horizontal PEL Panning register includes a figure showing the number of PELs shifted left
 *      for each valid value of the PEL Panning register and each valid video mode.  Further panning beyond that shown in
 *      the figure may be accomplished by changing the start address in the CRT Controller registers, Start Address High
 *      and Start Address Low.  The sequence involved in further panning would be as follows:
 *
 *           1. Use the PEL Panning register to shift the maximum number of bits to the left. See Figure 4-103 on page
 *              4-106 for the appropriate values.
 *
 *           2. Increment the start address.
 *
 *           3. If you are not using Modes 0 + , 1 + , 2 + , 3 + ,7, or7 + , set the PEL Panning register to 0.  If you
 *              are using these modes, set the PEL Panning register to 8.  The screen will now be shifted one PEL left
 *              of the position it was in at the end of step 1.  Step 1 through Step 3 may be repeated as desired.
 *
 *      The Line Compare register (CRTC register hex 18) should be programmed with even values in 200 line modes when
 *      used in split screen applications that scroll a second screen on top of a first screen.  This is a requirement
 *      imposed by the scan doubling logic in the CRTC.
 *
 *      If the Cursor Start register (CRTC register hex 0A) is programmed with a value greater than that in the Cursor End
 *      register (CRTC register hex 0B), then no cursor is displayed.  A split cursor is not possible.
 *
 *      In 8-dot character modes, the underline attribute produces a solid line across adjacent characters, as in the IBM
 *      Color/Graphics Monitor Adapter, Monochrome Display Adapter and the Enhanced Graphics Adapter.  In 9-dot modes, the
 *      underline across adjacent characters is dashed, as in the IBM 327X display terminals.  In 9-dot modes, the line
 *      graphics characters (C0 - DF character codes) have solid underlines.
 *
 *      For compatibility with the IBM Enhanced Graphics Adapter (EGA), the internal VGA palette is programmed the same
 *      as the EGA.  The video DAC is programmed by BIOS so that the compatible values in the internal VGA palette produce
 *      a color compatible with what was produced by EGA.  Mode hex 13 (256 colors) is programmed so that the first 16
 *      locations in the DAC produce compatible colors.
 *
 *      Summing: When BIOS is used to load the video DAC palette for a color mode and a monochrome display is connected
 *      to the system unit, the color palette is changed.  The colors are summed to produce shades of gray that allow
 *      color applications to produce a readable screen.
 *
 *      There are 4 bits that should not be modified unless the sequencer is reset by setting bit 1 of the Reset register
 *      to 0.  These bits are:
 *
 *           â¢ Bit 3, or bit 0 of the Clocking Mode register
 *           â¢ Bit 3, or bit 2 of the Miscellaneous Output register
 *
 * Also, for quick reference, IBM VGA register values for the standard VGA modes (from http://www.pcjs.org/blog/2015/06/01/):
 *
 *      INT 0x10 Mode Requested:    00  01  02  03  04  05  06  0D  0E  10  12  13
 *
 *      BIOSMODE:                   01  01  03  03  04  04  06  0D  0E  10  12  13
 *      CRTC[0x00]: HTOTAL          2D  2D  5F  5F  2D  2D  5F  2D  5F  5F  5F  5F
 *      CRTC[0x01]: HDEND           27  27  4F  4F  27  27  4F  27  4F  4F  4F  4F
 *      CRTC[0x02]: HBSTART         28  28  50  50  28  28  50  28  50  50  50  50
 *      CRTC[0x03]: HBEND           90  90  82  82  90  90  82  90  82  82  82  82
 *      CRTC[0x04]: HRSTART         2B  2B  55  55  2B  2B  54  2B  54  54  54  54
 *      CRTC[0x05]: HREND           A0  A0  81  81  80  80  80  80  80  80  80  80
 *      CRTC[0x06]: VTOTAL          BF  BF  BF  BF  BF  BF  BF  BF  BF  BF  0B  BF
 *      CRTC[0x07]: OVERFLOW        1F  1F  1F  1F  1F  1F  1F  1F  1F  1F  3E  1F
 *      CRTC[0x08]: PRESCAN         00  00  00  00  00  00  00  00  00  00  00  00
 *      CRTC[0x09]: MAXSCAN         4F  4F  4F  4F  C1  C1  C1  C0  C0  40  40  41
 *      CRTC[0x0A]: CURSCAN         0D  0D  0D  0D  00  00  00  00  00  00  00  00
 *      CRTC[0x0B]: CURSCANB        0E  0E  0E  0E  00  00  00  00  00  00  00  00
 *      CRTC[0x0C]: STARTHI         00  00  00  00  00  00  00  00  00  00  00  00
 *      CRTC[0x0D]: STARTLO         00  00  00  00  00  00  00  00  00  00  00  00
 *      CRTC[0x0E]: CURSORHI        01  01  01  01  01  01  01  01  01  01  01  00
 *      CRTC[0x0F]: CURSORLO        19  19  41  41  19  19  41  19  41  41  E1  A2
 *      CRTC[0x10]: VRSTART         9C  9C  9C  9C  9C  9C  9C  9C  9C  83  EA  9C
 *      CRTC[0x11]: VREND           8E  8E  8E  8E  8E  8E  8E  8E  8E  85  8C  8E
 *      CRTC[0x12]: VDEND           8F  8F  8F  8F  8F  8F  8F  8F  8F  5D  DF  8F
 *      CRTC[0x13]: OFFSET          14  14  28  28  14  14  28  14  28  28  28  28
 *      CRTC[0x14]: UNDERLINE       1F  1F  1F  1F  00  00  00  00  00  0F  00  40
 *      CRTC[0x15]: VBSTART         96  96  96  96  96  96  96  96  96  63  E7  96
 *      CRTC[0x16]: VBEND           B9  B9  B9  B9  B9  B9  B9  B9  B9  BA  04  B9
 *      CRTC[0x17]: MODECTRL        A3  A3  A3  A3  A2  A2  C2  E3  E3  E3  E3  A3
 *      CRTC[0x18]: LINECOMP        FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF
 *       GRC[0x00]: SRESET          00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x01]: ESRESET         00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x02]: COLORCOMP       00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x03]: DATAROT         00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x04]: READMAP         00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x05]: MODE            10  10  10  10  30  30  00  00  00  00  00  40
 *       GRC[0x06]: MISC            0E  0E  0E  0E  0F  0F  0D  05  05  05  05  05
 *       GRC[0x07]: COLORDC         00  00  00  00  00  00  00  0F  0F  0F  0F  0F
 *       GRC[0x08]: BITMASK         FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF
 *       SEQ[0x00]: RESET           03  03  03  03  03  03  03  03  03  03  03  03
 *       SEQ[0x01]: CLKMODE         08  08  00  00  09  09  01  09  01  01  01  01
 *       SEQ[0x02]: MAPMASK         03  03  03  03  03  03  01  0F  0F  0F  0F  0F
 *       SEQ[0x03]: CHARMAP         00  00  00  00  00  00  00  00  00  00  00  00
 *       SEQ[0x04]: MEMMODE         03  03  03  03  02  02  06  06  06  06  06  0E
 *       ATC[0x00]: PAL00           00  00  00  00  00  00  00  00  00  00  00  00
 *       ATC[0x01]: PAL01           01  01  01  01  13  13  17  01  01  01  01  01
 *       ATC[0x02]: PAL02           02  02  02  02  15  15  17  02  02  02  02  02
 *       ATC[0x03]: PAL03           03  03  03  03  17  17  17  03  03  03  03  03
 *       ATC[0x04]: PAL04           04  04  04  04  02  02  17  04  04  04  04  04
 *       ATC[0x05]: PAL05           05  05  05  05  04  04  17  05  05  05  05  05
 *       ATC[0x06]: PAL06           14  14  14  14  06  06  17  06  06  14  14  06
 *       ATC[0x07]: PAL07           07  07  07  07  07  07  17  07  07  07  07  07
 *       ATC[0x08]: PAL08           38  38  38  38  10  10  17  10  10  38  38  08
 *       ATC[0x09]: PAL09           39  39  39  39  11  11  17  11  11  39  39  09
 *       ATC[0x0A]: PAL0A           3A  3A  3A  3A  12  12  17  12  12  3A  3A  0A
 *       ATC[0x0B]: PAL0B           3B  3B  3B  3B  13  13  17  13  13  3B  3B  0B
 *       ATC[0x0C]: PAL0C           3C  3C  3C  3C  14  14  17  14  14  3C  3C  0C
 *       ATC[0x0D]: PAL0D           3D  3D  3D  3D  15  15  17  15  15  3D  3D  0D
 *       ATC[0x0E]: PAL0E           3E  3E  3E  3E  16  16  17  16  16  3E  3E  0E
 *       ATC[0x0F]: PAL0F           3F  3F  3F  3F  17  17  17  17  17  3F  3F  0F
 *       ATC[0x10]: MODE            0C  0C  0C  0C  01  01  01  01  01  01  01  41
 *       ATC[0x11]: OVERSCAN        00  00  00  00  00  00  00  00  00  00  00  00
 *       ATC[0x12]: PLANES          0F  0F  0F  0F  03  03  01  0F  0F  0F  0F  0F
 *       ATC[0x13]: HPAN            08  08  08  08  00  00  00  00  00  00  00  00
 */

/**
 * @class Card
 * @property {DebuggerX86} dbg
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Card extends Controller {
    /**
     * Card(video, nCard, data, cbMemory)
     *
     * Creates an object representing an initial video card state;
     * can also restore a video card from state data created by saveCard().
     *
     * WARNING: Since Card objects are low-level objects that have no UI requirements,
     * they do not inherit from the Component class, so you should only use class methods
     * of Component, such as Component.assert(), or methods of the parent (video) object.
     *
     * @this {Card}
     * @param {Video} [video]
     * @param {number} [nCard] (see Video.CARD.*)
     * @param {Array|null} [data]
     * @param {number} [cbMemory] is specified if the card must allocate its own memory buffer
     */
    constructor(video, nCard, data, cbMemory)
    {
        super();

        /*
         * If a card was originally not present (eg, EGA), then the state will be empty,
         * so we need to detect that case and continue indicating that the card is not present.
         */
        if (nCard !== undefined && (!data || data.length)) {

            this.video = video;

            let specs = Video.cardSpecs[nCard];
            let nMonitorType = video.nMonitorType || specs[5];

            if (!data || data.length < 6) {
                data = [false, 0, null, null, 0, new Array(nCard < Video.CARD.EGA? Card.CRTC.TOTAL_REGS : Card.CRTC.EGA.TOTAL_REGS)];
            }

            /*
             * If a Debugger is present, we want to stash a bit more info in each Card.
             */
            if (DEBUGGER) {
                this.dbg = video.dbg;
                this.type = specs[0];
                this.port = specs[1];
            }

            this.nCard = nCard;
            this.addrBuffer = specs[2];     // default (physical) video buffer address
            this.sizeBuffer = specs[3];     // default video buffer length (this is the total size, not the current visible size;
                                            // this.cbScreen is calculated on the fly to reflect the latter)

            /*
             * If no memory size is specified, then setMode() will use addMemory() to automatically add enough
             * memory blocks to cover the video buffer specified above; otherwise, it instructs addMemory() to call
             * getMemoryBuffer(), which will return a portion of the buffer (adwMemory) allocated below.  This allows
             * a card like the EGA to move/resize its video buffer as needed, as well as giving it total control over
             * the underlying memory.
             */
            this.cbMemory = cbMemory || specs[4];

            /*
             * All of our cardSpec video buffer sizes are based on the default text mode (eg, 4Kb for an MDA, 16Kb for
             * a CGA), but for a card with 64Kb or more of memory (ie, any EGA card), the default text mode video buffer
             * size should be dynamically recalculated as the smaller of: cbMemory divided by 4, or 32Kb.
             */
            if (this.cbMemory >= 0x10000 && this.addrBuffer >= 0xB0000) {
                this.sizeBuffer = Math.min(this.cbMemory >> 2, 0x8000);
            }

            this.fActive    = data[0];
            this.regMode    = data[1];      // see MDA.MODE* or CGA.MODE_*
                                            // use MDA.MODE.HIRES | MDA.MODE.VIDEO_ENABLE | MDA.MODE.BLINK_ENABLE
                                            // if you want to test blinking immediately after the initial power-on reset)
            this.regColor   = data[2];      // see CGA.COLOR.* (undefined on MDA)
            this.regStatus  = data[3];      // see MDA.STATUS.* or CGA.STATUS.*
            this.regCRTIndx = data[4] & 0xff;
            this.regCRTPrev = (data[4] >> 8) & 0xff;
            this.regCRTData = data[5];
            this.nCRTCRegs  = Card.CRTC.TOTAL_REGS;
            this.asCRTCRegs = DEBUGGER? Card.CRTC.REGS : [];
            this.offStart   = this.regCRTData[Card.CRTC.STARTLO] | (this.regCRTData[Card.CRTC.STARTHI] << 8);
            this.rowStart   = 0;            // initialize to zero and let the first latchStartAddress() call update it
            this.addrMaskHigh = 0x3F;       // card-specific mask for the high (bits 8 and up) of CRTC address registers

            if (nCard < Video.CARD.EGA) {
                this.initMemory(data[6], data[8]);
                this.setMemoryAccess(Card.ACCESS.READ.PAIRS | Card.ACCESS.WRITE.PAIRS);
            } else {
                this.addrMaskHigh = 0xFF;
                this.nCRTCRegs = Card.CRTC.EGA.TOTAL_REGS;
                this.asCRTCRegs = DEBUGGER? Card.CRTC.EGA_REGS : [];
                this.initEGA(data[6], nMonitorType);
            }

            let monitorSpecs = Video.monitorSpecs[nMonitorType] || Video.monitorSpecs[ChipSet.MONITOR.MONO];

            /*
             * nCyclesVertPeriod determines how frequently startVerticalRetrace() is called.  That function
             * snaps the current cycle count in nCyclesVertRetrace.  Then whenever getRetraceBits() is called,
             * it subtracts nCyclesVertRetrace from the current cycle count, and whenever the delta exceeds
             * nCyclesVertPeriod - nCyclesVertActive, vertical retrace has ended.  Similarly, horizontal retrace
             * ends whenever that delta MOD nCyclesHorzPeriod exceeds nCyclesHorzActive.
             */
            let nCyclesDefault = video.cpu.getBaseCyclesPerSecond();
            this.nCyclesHorzPeriod = (nCyclesDefault / monitorSpecs.nHorzPeriodsPerSec)|0;
            this.nCyclesHorzActive = (this.nCyclesHorzPeriod * monitorSpecs.percentHorzActive / 100)|0;
            this.nCyclesVertActive = (this.nCyclesHorzPeriod * monitorSpecs.nHorzPeriodsPerFrame)|0;
            this.nCyclesVertPeriod = (this.nCyclesVertActive / (monitorSpecs.percentVertActive / 100))|0;
            this.nCyclesVertRetrace = (data[7] || 0);
        }
    }

    /**
     * initEGA(data)
     *
     * Another one of my frustrations with JSON is that it encodes empty arrays with non-zero lengths as
     * arrays of nulls, which means that any uninitialized register arrays whose elements were all originally
     * undefined come back via the JSON round-trip as *initialized* arrays whose elements are now all null.
     *
     * I'm a bit surprised, because JavaScript purists tell us to always use the '===' operator (eg, use
     * 'aReg[i] === undefined' to determine if an element is initialized), but because of this JSON stupidity,
     * that would require all such tests to become 'aReg[i] === undefined || aReg[i] === null'.  I'm puzzled
     * why the coercion of '==' is considered evil but JSON's coercion of undefined to null is perfectly fine.
     *
     * The simple solution is to change such comparisons to 'aReg[i] == null', because undefined is coerced
     * to null, whereas numeric values are not.
     *
     * [What do I mean by "another" frustration?  Let me talk to you some day about disallowing hex constants,
     * or insisting that property names be quoted, or refusing to allow comments.  I think it's fine for
     * JSON.stringify() to produce output that adheres to rules like that -- although some parameters to control
     * the output would be nice -- but it's completely unnecessary for JSON.parse() to refuse to parse objects
     * that are perfectly valid.]
     *
     * @this {Card}
     * @param {Array|undefined} data
     * @param {number} nMonitorType
     */
    initEGA(data, nMonitorType)
    {
        if (data === undefined) {
            data = [
                /* 0*/  false,
                /* 1*/  0,
                /* 2*/  new Array(Card.ATC.TOTAL_REGS),
                /* 3*/  0,
                /* 4*/  (nMonitorType == ChipSet.MONITOR.MONO? 0: Card.MISC.IO_SELECT),
                /* 5*/  0,
                /* 6*/  0,
                /* 7*/  new Array(Card.SEQ.TOTAL_REGS),
                /* 8*/  0,
                /* 9*/  0,
                /*10*/  0,
                /*11*/  new Array(Card.GRC.TOTAL_REGS),
                /*12*/  0,
                /*13*/  [this.addrBuffer, this.sizeBuffer, this.cbMemory],
                /*14*/  null,
                /*
                 * Card.ACCESS.WRITE.MODE0 by itself is a pretty good default, but if we choose to "randomize" the screen with
                 * text characters prior to starting the machine, defaulting to Card.ACCESS.WRITE.EVENODD is more faithful to how
                 * characters and attributes are typically stored (ie, in planes 0 and 1, respectively).
                 *
                 *      Card.ACCESS.READ.MODE0 | Card.ACCESS.READ.EVENODD | Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.EVENODD | Card.ACCESS.V2
                 *
                 * Unfortunately, a typical ROM BIOS will almost immediately write to one of the original MDA or CGA mode registers,
                 * changing the default mode, so we may as well initialize the card to byte-pair access.
                 */
                /*15*/  Card.ACCESS.READ.PAIRS | Card.ACCESS.WRITE.PAIRS  | Card.ACCESS.V2,
                /*16*/  0,
                /*17*/  0xffffffff|0,
                /*18*/  0,
                /*19*/  0xffffffff|0,
                /*20*/  0,
                /*21*/  0xffffffff|0,
                /*22*/  0,
                /*23*/  0,
                /*24*/  0,
                /*25*/  0,
                /*26*/  Card.VGA_ENABLE.ENABLED,
                /*27*/  Card.DAC.MASK.DEFAULT,
                /*28*/  0,
                /*29*/  0,
                /*30*/  Card.DAC.STATE.MODE_WRITE,
                /*31*/  new Array(Card.DAC.TOTAL_REGS)
            ];
        }

        this.fATCData   = data[0];
        this.regATCIndx = data[1];
        this.regATCData = data[2];
        this.asATCRegs  = DEBUGGER? Card.ATC.REGS : [];
        this.regStatus0 = data[3];      // aka STATUS0 (not to be confused with this.regStatus, which the EGA refers to as STATUS1)
        this.regMisc    = data[4];
        this.regFeat    = data[5];      // for feature control bits, see Card.FEAT_CTRL.BITS; for feature status bits, see Card.STATUS0.FEAT
        this.regSEQIndx = data[6];
        this.regSEQData = data[7];
        this.asSEQRegs  = DEBUGGER? Card.SEQ.REGS : [];
        this.regGRCPos1 = data[8];
        this.regGRCPos2 = data[9];
        this.regGRCIndx = data[10];
        this.regGRCData = data[11];
        this.asGRCRegs  = DEBUGGER? Card.GRC.REGS : [];
        this.latches    = data[12];

        /*
         * Since we originally neglected to save/restore the card's active video buffer address and length,
         * we're now stashing all that information in data[13].  So if we're presented with an old data entry
         * that contains only the card's memory size, fix it up.
         *
         * TODO: This code just creates the required array; the correct video buffer address and length would
         * still need to be calculated from the current GRC registers; checkMode() knows how to do that, but I'm
         * not prepared to shoehorn in a call to checkMode() here, and potentially create more issues, for an
         * old problem that will eventually disappear anyway.
         */
        let a = data[13];
        if (typeof a == "number") {
            a = [this.addrBuffer, this.sizeBuffer, a];
        }
        this.addrBuffer = a[0];
        this.sizeBuffer = a[1];


        this.initMemory(data[14], this.cbMemory >> 2);

        let nAccess = data[15];
        if (nAccess) {
            if (nAccess & Card.ACCESS.V2) {
                nAccess &= ~Card.ACCESS.V2;
            } else {

                nAccess = Card.ACCESS.V1[nAccess & 0xff00] | Card.ACCESS.V1[nAccess & 0xff];
            }
        }
        this.setMemoryAccess(nAccess);

        /*
         * nReadMapShift must perfectly track how the GRC.READMAP register is programmed, so that Card.ACCESS.READ.MODE0
         * memory read functions read the appropriate plane.  This default is not terribly critical, unless Card.ACCESS.WRITE.MODE0
         * is chosen as our default AND you want the screen randomizer to work.
         */
        this.nReadMapShift  = data[16];

        /*
         * Similarly, nSeqMapMask must perfectly track how the SEQ.MAPMASK register is programmed, so that memory write
         * functions write the appropriate plane(s).  Again, this default is not terribly critical, unless Card.ACCESS.WRITE.MODE0
         * is chosen as our default AND you want the screen randomizer to work.
         */
        this.nSeqMapMask    = data[17];
        this.nDataRotate    = data[18];
        this.nBitMapMask    = data[19];
        this.nSetMapData    = data[20];
        this.nSetMapMask    = data[21];
        this.nSetMapBits    = data[22];
        this.nColorCompare  = data[23];
        this.nColorDontCare = data[24];
        this.offStart       = data[25];     // this is the last CRTC start address latched from CRTC.STARTHI,CRTC.STARTLO

        if (this.nCard == Video.CARD.VGA) {
            this.regVGAEnable   = data[26];
            this.regDACMask     = data[27];
            this.regDACAddr     = data[28];
            this.regDACShift    = data[29];
            this.regDACState    = data[30];
            this.regDACData     = data[31];
        }

        /*
         * While every Video memory block maintains its own DIRTY flag, used by the Bus cleanMemory() function to
         * quickly determine if anything changed within a given block, we supplement that information at the Card level
         * in certain memory controller functions that we know are used to modify font data in plane 2.
         *
         * Whenever plane 2 is modified, one of bits 0-7 in bitsDirtyBanks is modified as well, indicating which of
         * the corresponding font "banks" was modified.  The EGA supports only four font banks (0, 2, 4, and 6), while
         * the VGA supports four additional "interleaved" banks (1, 3, 5, and 7).
         *
         * NOTE: Our bank numbers (0-7) should not be confused with EGA INT 10h (AH=11h) "Character Generator Routine"
         * block numbers 0 to 3, which must be multiplied by 2 to obtain the corresponding bank number; VGA block numbers
         * 4 to 7 must also be multiplied by 2 and then reduced by 7 to produce the correct interleaved bank number.
         */
        this.bitsDirtyBanks = 0;
    }

    /**
     * initMemory(data, length)
     *
     * If we're restoring an older MDA or CGA buffer, where 4 bytes were stored in every dword instead of 2, then the
     * final size of adwMemory will be cbMemory >> 2.  Newer MDA and CGA buffers store only 2 bytes in every dword, to
     * make them compatible with their EGA and VGA counterparts, so their final size should be cbMemory >> 1.
     *
     * When we detect the older format, we must convert it to the newer.
     *
     * @this {Card}
     * @param {Array|null} data
     * @param {number} [length]
     */
    initMemory(data, length)
    {
        let cdw = this.cbMemory >> 2;
        this.adwMemory = data;
        if (!this.adwMemory || !this.adwMemory.length) {
            if (!length) length = cdw * 2;
            this.adwMemory = new Array(length);
        }
        else {
            cdw = length || cdw;
            if (this.adwMemory.length < cdw) {
                this.adwMemory = State.decompressEvenOdd(this.adwMemory, cdw);
            }
        }
        if (!length) {
            let adwOld = this.adwMemory;
            let adwNew = new Array(this.adwMemory.length * 2);

            for (let i = 0, j = 0; i < this.adwMemory.length; i++, j += 2) {
                adwNew[j] = adwOld[i] & 0xffff;
                adwNew[j+1] = (adwOld[i] >> 16) & 0xffff;
            }
            this.adwMemory = adwNew;
        } else {

        }
    }

    /**
     * saveCard()
     *
     * @this {Card}
     * @return {Array}
     */
    saveCard()
    {
        let data = [];
        if (this.nCard !== undefined) {
            data[0] = this.fActive;
            data[1] = this.regMode;
            data[2] = this.regColor;
            data[3] = this.regStatus;
            data[4] = this.regCRTIndx | (this.regCRTPrev << 8);
            data[5] = this.regCRTData;
            data[6] = (this.nCard < Video.CARD.EGA? State.compressEvenOdd(this.adwMemory) : this.saveEGA());
            data[7] = this.nCyclesVertRetrace;
            data[8] = this.adwMemory.length;
        }
        return data;
    }

    /**
     * saveEGA()
     *
     * @this {Card}
     * @return {Array}
     */
    saveEGA()
    {
        let data = [];
        data[0]  = this.fATCData;
        data[1]  = this.regATCIndx;
        data[2]  = this.regATCData;
        data[3]  = this.regStatus0;
        data[4]  = this.regMisc;
        data[5]  = this.regFeat;
        data[6]  = this.regSEQIndx;
        data[7]  = this.regSEQData;
        data[8]  = this.regGRCPos1;
        data[9]  = this.regGRCPos2;
        data[10] = this.regGRCIndx;
        data[11] = this.regGRCData;
        data[12] = this.latches;
        data[13] = [this.addrBuffer, this.sizeBuffer, this.cbMemory];
        data[14] = State.compressEvenOdd(this.adwMemory);
        data[15] = this.nAccess | Card.ACCESS.V2;
        data[16] = this.nReadMapShift;
        data[17] = this.nSeqMapMask;
        data[18] = this.nDataRotate;
        data[19] = this.nBitMapMask;
        data[20] = this.nSetMapData;
        data[21] = this.nSetMapMask;
        data[22] = this.nSetMapBits;
        data[23] = this.nColorCompare;
        data[24] = this.nColorDontCare;
        data[25] = this.offStart;

        if (this.nCard == Video.CARD.VGA) {
            data[26] = this.regVGAEnable;
            data[27] = this.regDACMask;
            data[28] = this.regDACAddr;
            data[29] = this.regDACShift;
            data[30] = this.regDACState;
            data[31] = this.regDACData;
        }
        return data;
    }

    /**
     * dumpRegs()
     *
     * Since we don't pre-allocate the register arrays (eg, ATC, CRTC, GRC, etc) on a Card, we can't
     * rely on their array length, so we instead rely on the number of register names supplied in asRegs.
     *
     * @this {Card}
     * @param {string} sName
     * @param {number} iReg
     * @param {Array} [aRegs]
     * @param {Array} [asRegs]
     */
    dumpRegs(sName, iReg, aRegs, asRegs)
    {
        if (DEBUGGER) {
            if (!aRegs) {
                this.dbg.println(sName + ": " + Str.toHex(iReg, 2));
                return;
            }
            let i, s = "";
            let nRegs = (asRegs? asRegs.length : aRegs.length);
            for (i = 0; i < nRegs; i++) {
                /*
                 * In the case of the CRTC, we call the helper function getCRTCReg() to automatically concatenate
                 * the extended bits of certain registers, so that we don't have to "mentally" concatenate them.
                 */
                let reg = (aRegs === this.regCRTData)? this.getCRTCReg(i) : aRegs[i];
                if (s) s += '\n';
                let sRegName = (asRegs? asRegs[i] : sName.substr(1) + Str.toDec(i, 3));
                s += Str.sprintf("%s[%02X]: %-12s %*X%s (%*d)", sName, i, sRegName, (asRegs? 4 : 6), reg, (i === iReg? '*' : ' '), (asRegs? 4 : 6), reg);
            }
            this.dbg.println(s);
        }
    }

    /**
     * dumpVideoCard()
     *
     * @this {Card}
     */
    dumpVideoCard()
    {
        if (DEBUGGER) {
            /*
             * Start with registers that are common to all cards....
             */
            this.dumpRegs("CRTC", this.regCRTIndx, this.regCRTData, this.asCRTCRegs);

            if (this.nCard >= Video.CARD.EGA) {
                this.dumpRegs(" GRC", this.regGRCIndx, this.regGRCData, this.asGRCRegs);
                this.dumpRegs(" SEQ", this.regSEQIndx, this.regSEQData, this.asSEQRegs);
                this.dumpRegs(" ATC", this.regATCIndx, this.regATCData, this.asATCRegs);
                this.dumpRegs(" ATCINDX", this.regATCIndx);
                this.dbg.println(" ATCDATA: " + this.fATCData);
                this.dumpRegs("    FEAT", this.regFeat);
                this.dumpRegs("    MISC", this.regMisc);
                this.dumpRegs(" STATUS0", this.regStatus0);
                /*
                 * There are few more EGA regs we could dump, like GRCPos1, GRCPos2, but does anyone care?
                 */
                if (this.nCard == Video.CARD.VGA) {
                    this.dumpRegs(" DAC", this.regDACAddr, this.regDACData);
                }
            }

            /*
             * TODO: This simply dumps the last value read from the STATUS1 register, not necessarily
             * its current state; consider dumping getRetraceBits() instead of (or in addition to) this.
             */
            this.dumpRegs(" STATUS1", this.regStatus);

            if (this.nCard == Video.CARD.MDA || this.nCard == Video.CARD.CGA) {
                this.dumpRegs(" MODEREG", this.regMode);
            }

            if (this.nCard == Video.CARD.CGA) {
                this.dumpRegs("   COLOR", this.regColor);
            }

            if (this.nCard >= Video.CARD.EGA) {
                this.dbg.println(" LATCHES: " + Str.toHex(this.latches));
                this.dbg.println("  ACCESS: " + Str.toHex(this.nAccess, 4));
                this.dbg.println("  PLANE2: " + Str.toHex(this.bitsDirtyBanks, 2));
                this.dbg.println("Use 'd video [addr]' to dump video memory");
                /*
                 * There are few more EGA regs we could dump, like GRCPos1, GRCPos2, but does anyone care?
                 */
            }
        }
    }

    /**
     * dumpVideoBuffer(asArgs)
     *
     * Rather than requiring the first parameter to ALWAYS be a frame buffer address OR a frame buffer
     * offset, we'll just make a guess as to what the user intended and support BOTH; basically, if the
     * value is less than the frame buffer address, we'll assume it's an offset.
     *
     * Also, we allow some special options to be encoded in asArgs: 'l' followed by a number means
     * print that many rows of data.  'n' followed by a number (1-8) means print only that number of
     * memory locations per row, and then adjust the starting address of the next row by the number
     * of bytes per row (or whatever is specified by the 'w' option) so that the dump reflects a
     * rectangular chunk of video data.  Finally, if asArgs contains 'p' followed by a number (0-3),
     * we display only the bits from that plane for each memory location, in binary instead of hex.
     *
     * For example, assuming a standard VGA frame buffer with 640x480 pixels across 38400 (0x9600) memory
     * locations, the following command will dump a vertical swath of bits from plane 0 that is 32 (0x20)
     * rows tall and 8 columns wide, from roughly the center of the screen (0x4B00 + 0x28 - 2 = 0x4B26).
     *
     *      d video 4b26 l20 n8 p0
     *
     * Subsequent commands that omit a starting address or offset will continue where the last dump
     * left off; eg:
     *
     *      d video n8 p0
     *
     * To dump a chunk of off-screen memory starting at 0x9600, where the Windows VGA driver typically
     * stores a copy of the video memory containing the current mouse pointer:
     *
     *      d video 9600 l20 n5 w5 p0
     *
     * Alternatively, you could use decimal values:
     *
     *      d video 9600 l32. n5. w5. p0.
     *
     * NOTE: If these commands look suspiciously like weird Hayes modem command strings, trust me,
     * that is ENTIRELY coincidental (but mildly amusing).
     *
     * TODO: Make these options more general-purpose (it currently assumes a conventional VGA planar layout).
     *
     * @this {Card}
     * @param {Array.<string>} asArgs (all numeric arguments default to base 16 unless otherwise specified)
     */
    dumpVideoBuffer(asArgs)
    {
        if (DEBUGGER) {
            if (!this.adwMemory) {
                this.dbg.println("no buffer");
                return;
            }

            let i, j, idw, fColAdjust = false;
            let l = 8, n = 8, p = -1, w = this.video.nCols >> 3;

            for (i = 0; i < asArgs.length; i++) {

                let s = asArgs[i];
                if (!i) {
                    idw = Str.parseInt(s, 16);
                    continue;
                }

                let ch = s.charAt(0);
                j = Str.parseInt(s.substr(1), 16);

                switch(ch) {
                case 'l':
                    l = j;
                    break;
                case 'n':
                    if (j >= 1 && j <= 8) {
                        n = j;
                        fColAdjust = true;
                    }
                    break;
                case 'p':
                    if (j >= 0 && j <= 3) p = j;
                    break;
                case 'w':
                    if (j < w) w = j;
                    break;
                default:
                    this.dbg.println("unrecognized argument: " + s);
                    break;
                }
            }

            if (idw === undefined) {
                idw = this.prevDump || 0;
            } else if (idw >= this.addrBuffer) {
                idw -= this.addrBuffer;
            }

            let sDump = "";
            for (i = 0; i < l; i++) {
                let sData = Str.toHex(this.addrBuffer + idw) + ":";
                for (j = 0; j < n && idw < this.adwMemory.length; j++) {
                    let dw = this.adwMemory[idw++];
                    sData += ' ' + ((p < 0)? Str.toHex(dw, 8) : Str.toBin((dw >> (p << 3)), 8));
                }
                if (fColAdjust) idw += w - n;
                if (sDump) sDump += "\n";
                sDump += sData;
            }

            if (sDump) this.dbg.println(sDump);
            this.prevDump = idw;
        }
    }

    /**
     * getMemoryBuffer(addr)
     *
     * If we passed a controller object (ie, this card) to addMemory(), then each allocated Memory block
     * will call this function to obtain a buffer.
     *
     * @this {Card}
     * @param {number} addr
     * @return {Array} containing the buffer (and the offset within that buffer that corresponds to the requested block)
     */
    getMemoryBuffer(addr)
    {
        return [this.adwMemory, addr - this.addrBuffer];
    }

    /**
     * getMemoryAccess()
     *
     * WARNING: This is a public method, whereas most Card methods are private to the Video component;
     * because a Card also acts as a Memory controller, it must provide getMemoryAccess() to the Memory component.
     *
     * Return the last set of memory access functions recorded by setMemoryAccess().
     *
     * @this {Card}
     * @return {Array.<function()>}
     */
    getMemoryAccess()
    {
        return this.afnAccess;
    }

    /**
     * setMemoryAccess(nAccess)
     *
     * This transforms the memory access value that getCardAccess() returns into the best available set of
     * memory access functions, which are then returned via getMemoryAccess() to any memory blocks we allocate
     * or modify.
     *
     * @this {Card}
     * @param {number|undefined} nAccess
     */
    setMemoryAccess(nAccess)
    {
        if (nAccess != null && nAccess != this.nAccess) {

            let nReadAccess = nAccess & Card.ACCESS.READ.MASK;
            let fnReadByte = Card.ACCESS.afn[nReadAccess];
            if (!fnReadByte) {
                if (DEBUG && this.dbg && this.dbg.messageEnabled(Messages.VIDEO)) {
                    this.dbg.message("Card.setMemoryAccess(" + Str.toHexWord(nAccess) + "): missing readByte handler");
                    /*
                     * I've taken a look, and the cases I've seen so far stem from the order in which the IBM VGA BIOS
                     * reprograms registers during a mode change: it reprograms the Sequencer registers BEFORE the Graphics
                     * Controller registers, so if GRC.MODE was set to READ.MODE1 prior to the mode change and the new mode
                     * clears SEQ.MEMMODE.SEQUENTIAL, we will briefly be in an "odd" (unsupported) state.
                     *
                     * This didn't used to occur when we relied on the GRC.MODE register instead of the SEQ.MEMMODE for
                     * determining the EVENODD state.  But, as explained in getCardAccess(), we've run into inconsistencies in
                     * how GRC.MODE.EVENODD is programmed, so we must live with this warning.
                     *
                     * The ultimate solution is to provide a EVENODD handler for READ.MODE1, since there is the remote
                     * possibility of third-party software that relies on that "odd" combination.
                     *
                     *      this.dbg.stopCPU();     // let's take a look
                     */
                }
                if (nReadAccess & Card.ACCESS.READ.EVENODD) {
                    fnReadByte = Card.ACCESS.afn[Card.ACCESS.READ.EVENODD];
                }
            }
            let nWriteAccess = nAccess & Card.ACCESS.WRITE.MASK;
            let fnWriteByte = Card.ACCESS.afn[nWriteAccess];
            if (!fnWriteByte) {
                if (DEBUG && this.dbg && this.dbg.messageEnabled(Messages.VIDEO)) {
                    this.dbg.message("Card.setMemoryAccess(" + Str.toHexWord(nAccess) + "): missing writeByte handler");
                    /*
                     * I've taken a look, and the cases I've seen so far stem from the order in which the IBM VGA BIOS
                     * reprograms registers during a mode change: it reprograms the Sequencer registers BEFORE the Graphics
                     * Controller registers, so if GRC.MODE was set to WRITE.MODE2 prior to the mode change and the new mode
                     * clears SEQ.MEMMODE.SEQUENTIAL, we will briefly be in an "odd" (unsupported) state.
                     *
                     * This didn't used to occur when we relied on the GRC.MODE register instead of the SEQ.MEMMODE for
                     * determining the EVENODD state.  But, as explained in getCardAccess(), we've run into inconsistencies in
                     * how GRC.MODE.EVENODD is programmed, so we must live with this warning.
                     *
                     * The ultimate solution is to provide EVENODD handlers for all modes other than WRITE.MODE0, since there
                     * is the remote possibility of third-party software that relies on one of those "odd" combinations.
                     *
                     *      this.dbg.stopCPU();     // let's take a look
                     */
                }
                if (nWriteAccess & Card.ACCESS.WRITE.EVENODD) {
                    fnWriteByte = Card.ACCESS.afn[Card.ACCESS.WRITE.EVENODD];
                }
            }
            if (!this.afnAccess) this.afnAccess = new Array(6);
            this.afnAccess[0] = fnReadByte;
            this.afnAccess[1] = fnWriteByte;
            this.nAccess = nAccess;
        }
    }

    /**
     * getCRTCReg()
     *
     * @this {Card}
     * @param {number} iReg
     * @return {number}
     */
    getCRTCReg(iReg)
    {
        let reg = this.regCRTData[iReg];
        if (reg != null && this.nCard >= Video.CARD.EGA) {
            let bOverflowBit8 = 0, bOverflowBit9 = 0, bMaxScanBit9 = 0;
            switch(iReg) {
            case Card.CRTC.EGA.VTOTAL:              // 0x06
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.VTOTAL_BIT8;         // 0x01
                if (this.nCard == Video.CARD.VGA) bOverflowBit9 = Card.CRTC.EGA.OVERFLOW.VTOTAL_BIT9;
                break;
            case Card.CRTC.EGA.CURSCAN:             // 0x0A
                if (this.nCard == Video.CARD.EGA) bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.CURSCAN_BIT8;
                break;
            case Card.CRTC.EGA.VRSTART:             // 0x10
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.VRSTART_BIT8;        // 0x04
                if (this.nCard == Video.CARD.VGA) bOverflowBit9 = Card.CRTC.EGA.OVERFLOW.VRSTART_BIT9;
                break;
            case Card.CRTC.EGA.VDEND:               // 0x12
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.VDEND_BIT8;          // 0x02
                if (this.nCard == Video.CARD.VGA) bOverflowBit9 = Card.CRTC.EGA.OVERFLOW.VDEND_BIT9;
                break;
            case Card.CRTC.EGA.VBSTART:             // 0x15
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.VBSTART_BIT8;        // 0x08
                if (this.nCard == Video.CARD.VGA) bMaxScanBit9 = Card.CRTC.EGA.MAXSCAN.VBSTART_BIT9;
                break;
            case Card.CRTC.EGA.LINECOMP:            // 0x18
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.LINECOMP_BIT8;       // 0x10
                if (this.nCard == Video.CARD.VGA) bMaxScanBit9 = Card.CRTC.EGA.MAXSCAN.LINECOMP_BIT9;
                break;
            }
            if (bOverflowBit8) {
                reg |= ((this.regCRTData[Card.CRTC.EGA.OVERFLOW.INDX] & bOverflowBit8)? 0x100 : 0);
                reg |= ((this.regCRTData[Card.CRTC.EGA.OVERFLOW.INDX] & bOverflowBit9)? 0x200 : 0);
                reg |= ((this.regCRTData[Card.CRTC.EGA.MAXSCAN.INDX] & bMaxScanBit9)? 0x200 : 0);
            }
        }
        return reg;
    }
}

/*
 * MDA Registers (ports 0x3B4, 0x3B5, 0x3B8, and 0x3BA)
 *
 * NOTE: All monochrome cards (at least all IBM cards) included a parallel interface at ports 0x3BC/0x3BD/0x3BE;
 * for the same functionality in PCx86, you must include a properly configured ParallelPort component.
 */
Card.MDA = {
    CRTC: {
        INDX: {
            PORT:           0x3B4,      // NOTE: the low byte of this port address (0xB4) is mirrored at 40:0063 (0x0463)
            MASK:           0x1F
        },
        DATA: {
            PORT:           0x3B5
        }
    },
    MODE: {
        PORT:               0x3B8,      // Mode Select Register, aka CRT Control Port 1 (write-only); the BIOS mirrors this register at 40:0065 (0x0465)
        HIRES:              0x01,
        VIDEO_ENABLE:       0x08,
        BLINK_ENABLE:       0x20
    },
    STATUS: {
        PORT:               0x3BA,
        HDRIVE:             0x01,
        BWVIDEO:            0x08
    }
};

/*
 * CGA Registers (ports 0x3D4, 0x3D5, 0x3D8, 0x3D9, and 0x3DA)
 */
Card.CGA = {
    CRTC: {
        INDX: {
            PORT:           0x3D4,      // NOTE: the low byte of this port address (0xB4) is mirrored at 40:0063 (0x0463)
            MASK:           0x1F
        },
        DATA: {
            PORT:           0x3D5
        }
    },
    MODE: {
        PORT:               0x3D8,      // Mode Select Register (write-only); the BIOS mirrors this register at 40:0065 (0x0465)
        _80X25:             0x01,
        GRAPHIC_SEL:        0x02,
        BW_SEL:             0x04,
        VIDEO_ENABLE:       0x08,       // same as MDA.MODE.VIDEO_ENABLE
        HIRES_BW:           0x10,
        BLINK_ENABLE:       0x20        // same as MDA.MODE.BLINK_ENABLE
    },
    COLOR: {
        PORT:               0x3D9,      // write-only
        BORDER:             0x07,
        BRIGHT:             0x08,
        BGND_ALT:           0x10,       // alternate, intensified background colors in text mode
        COLORSET1:          0x20        // selects aCGAColorSet1 colors for 320x200 graphics mode; aCGAColorSet0 otherwise
    },
    STATUS: {
        PORT:               0x3DA,      // read-only; same for EGA (although the EGA calls this STATUS1, to distinguish it from STATUS0)
        RETRACE:            0x01,
        PEN_TRIGGER:        0x02,
        PEN_ON:             0x04,
        VRETRACE:           0x08        // when set, this indicates the CGA is performing a vertical retrace
    },
    /*
     * TODO: Add support for light pen port(s) someday....
     */
    CLEAR_PEN: {
        PORT:               0x3DB
    },
    PRESET_PEN: {
        PORT:               0x3DC
    }
};

/*
 * Common CRT hardware registers (ports 0x3B4/0x3B5 or 0x3D4/0x3D5)
 *
 * NOTE: In this implementation, because we have to make at least two of the registers readable (CURSORHI and CURSORLO),
 * we end up making ALL the registers readable, otherwise we would have to explicitly block any register marked write-only.
 * I don't think making the CRT registers fully readable presents any serious compatibility issues, and it actually offers
 * some benefits (eg, improved debugging).
 *
 * However, some things are broken: the (readable) light pen registers on the EGA are overloaded as (writable) vertical retrace
 * registers, so the vertical retrace registers cannot actually be read that way.  I'm sure the VGA solved that problem, but I haven't
 * looked into it yet.
 */
Card.CRTC = {
    HTOTAL:             0x00,           // Horizontal Total
    HDISP:              0x01,           // Horizontal Displayed
    HSPOS:              0x02,           // Horizontal Sync Position
    HSWIDTH:            0x03,           // Horizontal Sync Width
    VTOTAL:             0x04,           // Vertical Total
    VTOTADJ:            0x05,           // Vertical Total Adjust
    VDISP:              0x06,           // Vertical Displayed
    VSPOS:              0x07,           // Vertical Sync Position
    ILMODE:             0x08,           // Interlace Mode
    MAXSCAN:            0x09,           // Max Scan Line Address
    CURSCAN:            0x0A,           // Cursor Scan Line Top
    CURSCAN_SLMASK:         0x1F,       // Scan Line Mask
    /*
     * I don't entirely understand the cursor blink control bits.  Here's what the MC6845 datasheet says:
     *
     *      Bit 5 is the blink timing control.  When bit 5 is low, the blink frequency is 1/16 of the vertical field rate,
     *      and when bit 5 is high, the blink frequency is 1/32 of the vertical field rate.  Bit 6 is used to enable a blink.
     */
    CURSCAN_BLINKON:        0x00,       // (supposedly, 0x40 has the same effect as 0x00?)
    CURSCAN_BLINKOFF:       0x20,       // if blinking is disabled, the cursor is effectively hidden (TODO: CGA and VGA only?)
    CURSCAN_BLINKFAST:      0x60,       // default is 1/16 of the frame rate; this switches to 1/32 of the frame rate (TODO: CGA only?)
    CURSCANB:           0x0B,           // Cursor Scan Line Bottom
    STARTHI:            0x0C,           // Start Address High
    STARTLO:            0x0D,           // Start Address Low
    CURSORHI:           0x0E,           // Cursor Address High
    CURSORLO:           0x0F,           // Cursor Address Low
    PENHI:              0x10,           // Light Pen High
    PENLO:              0x11,           // Light Pen Low
    TOTAL_REGS:         0x12,           // total CRT registers on MDA/CGA
    EGA: {
        HDEND:          0x01,
        HBSTART:        0x02,
        HBEND:          0x03,
        HRSTART:        0x04,
        HREND:          0x05,
        VTOTAL:         0x06,
        OVERFLOW: {
            INDX:       0x07,
            VTOTAL_BIT8:    0x01,       // bit 8 of register 0x06
            VDEND_BIT8:     0x02,       // bit 8 of register 0x12
            VRSTART_BIT8:   0x04,       // bit 8 of register 0x10
            VBSTART_BIT8:   0x08,       // bit 8 of register 0x15
            LINECOMP_BIT8:  0x10,       // bit 8 of register 0x18
            CURSCAN_BIT8:   0x20,       // bit 8 of register 0x0A (EGA only; TODO: What is this for? The CURSCAN register doesn't even use bit 7, so why would it need a bit 8?)
            VTOTAL_BIT9:    0x20,       // bit 9 of register 0x06 (VGA only)
            VDEND_BIT9:     0x40,       // bit 9 of register 0x12 (VGA only, unused on EGA)
            VRSTART_BIT9:   0x80        // bit 9 of register 0x10 (VGA only, unused on EGA)
        },
        PRESCAN:        0x08,
        /*
         * NOTE: EGA/VGA CRTC registers 0x09-0x0F are the same as the MDA/CGA CRTC registers defined above
         */
        MAXSCAN: {
            INDX:       0x09,           // (same as MDA/CGA)
            SLMASK:         0x1F,       // Scan Line Mask
            VBSTART_BIT9:   0x20,       // (VGA only)
            LINECOMP_BIT9:  0x40,       // (VGA only)
            CONVERT400:     0x80        // 200-to-400 scan-line conversion is in effect (VGA only)
        },
        CURSCAN:        0x0A,           // (same as MDA/CGA)
        CURSCANB:       0x0B,           // (same as MDA/CGA)
        STARTHI:        0x0C,           // (same as MDA/CGA)
        STARTLO:        0x0D,           // (same as MDA/CGA)
        CURSORHI:       0x0E,           // (same as MDA/CGA)
        CURSORLO:       0x0F,           // (same as MDA/CGA)
        VRSTART:        0x10,           // (formerly PENHI on MDA/CGA)
        VREND:          {               // (formerly PENLO on MDA/CGA; last register on the original 6845 controller)
            INDX:       0x11,
            HSCAN:          0x0F,       // the horizontal scan count value when the vertical retrace output signal becomes inactive
            UNCLEAR_VRINT:  0x10,       // clear vertical retrace interrupt if NOT set
            DISABLE_VRINT:  0x20        // enable vertical retrace interrupt if NOT set
        },
        VDEND:          0x12,
        /*
         * The OFFSET register (bits 0-7) specifies the logical line width of the screen.  The starting memory address
         * for the next character row is larger than the current character row by two or four times this amount.
         * The OFFSET register is programmed with a word address.  Depending on the method of clocking the CRT Controller,
         * this word address is [effectively] either a word or double-word address. #IBMVGATechRef
         */
        OFFSET:         0x13,
        UNDERLINE: {
            INDX:       0x14,
            SLMASK:         0x1F,
            COUNT_BY_4:     0x20,       // (VGA only)
            DWORD:          0x40        // (VGA only)
        },
        VBSTART:        0x15,
        VBEND:          0x16,
        MODECTRL: {
            INDX:       0x17,
            COMPAT_MODE:    0x01,       // Compatibility Mode Support (CGA A13 control)
            SEL_ROW_SCAN:   0x02,       // Select Row Scan Counter
            SEL_HRETRACE:   0x04,       // Horizontal Retrace Select
            COUNT_BY_2:     0x08,       // Count By Two
            OUTPUT_CTRL:    0x10,       // Output Control
            ADDR_WRAP:      0x20,       // Address Wrap (in Word mode, 1 maps A15 to A0 and 0 maps A13; use the latter when only 64Kb is installed)
            BYTE_MODE:      0x40,       // Byte Mode (1 selects Byte Mode; 0 selects Word Mode)
            HARD_RESET:     0x80        // Hardware Reset
        },
        LINECOMP:       0x18,
        TOTAL_REGS:     0x19            // total CRT registers on EGA/VGA
    }
};

/*
 * TODO: These mask tables need to be card-specific.  For example, the STARTHI and CURSORHI registers used to be
 * limited to 0x3F, because the MC6845 controller used with the original MDA and CGA cards was limited to 16Kb of RAM,
 * whereas later cards like the EGA and VGA had anywhere from 64Kb to 256Kb, so all the bits of those registers were
 * significant.  Currently, I'm doing very little masking, which means most CRTC registers are treated as full 8-bit
 * registers (and fully readable as well), which might cause some compatibility problems for any MDA/CGA apps that
 * were sloppy about how they programmed registers.
 *
 * I do make an exception, however, in the case of STARTHI and CURSORHI, due to the way the MC6845 controller wraps
 * addresses around to the beginning of the buffer, because that seems like a high-risk case.  See the card-specific
 * variable addrMaskHigh.
 */
Card.CRTCMASKS = {
    [Card.CRTC.HTOTAL]:     0xFF,       // R0
    [Card.CRTC.HDISP]:      0xFF,       // R1
    [Card.CRTC.HSPOS]:      0xFF,       // R2
    [Card.CRTC.HSWIDTH]:    0x0F,       // R3
    [Card.CRTC.VTOTAL]:     0x7F,       // R4
    [Card.CRTC.VTOTADJ]:    0x1F,       // R5
    [Card.CRTC.VDISP]:      0x7F,       // R6
    [Card.CRTC.VSPOS]:      0x7F,       // R7
    [Card.CRTC.ILMODE]:     0x03,       // R8
    [Card.CRTC.MAXSCAN]:    0x1F,       // R9
    [Card.CRTC.CURSCAN]:    0x7F,       // R10
    [Card.CRTC.CURSCANB]:   0x1F,       // R11
    [Card.CRTC.STARTHI]:    0x3F,       // R12
    [Card.CRTC.STARTLO]:    0xFF,       // R13
    [Card.CRTC.CURSORHI]:   0x3F,       // R14
    [Card.CRTC.CURSORLO]:   0xFF,       // R15
    [Card.CRTC.PENHI]:      0x3F,       // R16
    [Card.CRTC.PENLO]:      0xFF        // R17
};

if (DEBUGGER) {
    Card.CRTC.REGS = [
        "HTOTAL","HDISP","HSPOS","HSWIDTH","VTOTAL","VTOTADJ",
        "VDISP","VSPOS","ILMODE","MAXSCAN","CURSCAN","CURSCANB",
        "STARTHI","STARTLO","CURSORHI","CURSORLO","PENHI","PENLO"];

    Card.CRTC.EGA_REGS = [
        "HTOTAL","HDEND","HBSTART","HBEND","HRSTART","HREND",
        "VTOTAL","OVERFLOW","PRESCAN","MAXSCAN","CURSCAN","CURSCANB",
        "STARTHI","STARTLO","CURSORHI","CURSORLO","VRSTART","VREND",
        "VDEND","OFFSET","UNDERLINE","VBSTART","VBEND","MODECTRL","LINECOMP"];
}

/*
 * EGA/VGA Input Status 1 Register (port 0x3DA)
 *
 * STATUS1 bit 0 has confusing documentation: the EGA Tech Ref says "Logical 0 indicates the CRT raster is in a
 * horizontal or vertical retrace interval", whereas the VGA Tech Ref says "Logical 1 indicates a horizontal or
 * vertical retrace interval," but then clarifies: "This bit is the real-time status of the INVERTED display enable
 * signal".  So, instead of calling bit 0 DISP_ENABLE (or more precisely, DISP_ENABLE_INVERTED), it's simply RETRACE.
 *
 * STATUS1 diagnostic bits 5 and 4 are set according to the Card.ATC.PLANES.MUX bits:
 *
 *      MUX     Bit 5   Bit 4
 *      ---     ----    ----
 *      00:     Red     Blue
 *      01:     SecBlue Green
 *      10:     SecRed  SecGreen
 *      11:     unused  unused
 */
Card.STATUS1 = {
    PORT:                   0x3DA,
    RETRACE:                0x01,       // bit 0: logical OR of horizontal and vertical retrace
    VRETRACE:               0x08,       // bit 3: set during vertical retrace interval
    DIAGNOSTIC:             0x30,       // bits 5,4 are controlled by the Card.ATC.PLANES.MUX bits
    RESERVED:               0xC6
};

/*
 * EGA/VGA Attribute Controller Registers (port 0x3C0: regATCIndx and regATCData)
 *
 * The current ATC INDX value is stored in cardEGA.regATCIndx (including the Card.ATC.INDX_ENABLE bit), and the
 * ATC DATA values are stored in cardEGA.regATCData.  The state of the ATC INDX/DATA flip-flop is stored in fATCData.
 *
 * Note that the ATC palette registers (0x0-0xf) all use the following 6 bit assignments, with bits 6 and 7 unused:
 *
 *      0: Blue
 *      1: Green
 *      2: Red
 *      3: SecBlue (or mono video)
 *      4: SecGreen (or intensity)
 *      5: SecRed
 */
Card.ATC = {
    PORT:                   0x3C0,      // ATC Index/Data Port
    INDX_MASK:              0x1F,
    INDX_PAL_ENABLE:        0x20,       // must be clear when loading palette registers
    PALETTE: {
        INDX:               0x00,       // 16 registers: 0x00 - 0x0F
        MASK:               0x3f,
        BLUE:               0x01,
        GREEN:              0x02,
        RED:                0x04,
        SECBLUE:            0x08,
        BRIGHT:             0x10,       // NOTE: The IBM EGA manual (p.56) also calls this the "intensity" bit
        SECGREEN:           0x10,
        SECRED:             0x20
    },
    PALETTE_REGS:           0x10,       // 16 total palette registers
    MODE: {
        INDX:               0x10,       // ATC Mode Control Register
        GRAPHICS:           0x01,       // bit 0: set for graphics mode, clear for alphanumeric mode
        MONOEM:             0x02,       // bit 1: set for monochrome emulation mode, clear for color emulation
        TEXT_9DOT:          0x04,       // bit 2: set for 9-dot replication in character codes 0xC0-0xDF
        BLINK_ENABLE:       0x08,       // bit 3: set for text/graphics blink, clear for background intensity
        RESERVED:           0x10,       // bit 4: reserved
        PANCOMPAT:          0x20,       // bit 5: set for pixel-panning compatibility
        PELWIDTH:           0x40,       // bit 6: set for 256-color modes, clear for all other modes
        COLORSEL_ALL:       0x80        // bit 7: set to enable all COLORSEL bits (ie, COLORSEL.DAC_BIT5 and COLORSEL.DAC_BIT4)
    },
    OVERSCAN: {
        INDX:               0x11        // ATC Overscan Color Register
    },
    PLANES: {
        INDX:               0x12,       // ATC Color Plane Enable Register
        MASK:               0x0F,
        MUX:                0x30,
        RESERVED:           0xC0
    },
    HPAN: {
        INDX:               0x13,       // ATC Horizontal PEL Panning Register
        SHIFT_LEFT:         0x0F        // bits 0-3 indicate # of pixels to shift left
    },
    COLORSEL: {
        INDX:               0x14,       // ATC Color Select Register (VGA only)
        DAC_BIT7:           0x08,       // specifies bit 7 of DAC values (ignored in 256-color modes)
        DAC_BIT6:           0x04,       // specifies bit 6 of DAC values (ignored in 256-color modes)
        DAC_BIT5:           0x02,       // specifies bit 5 of DAC values (if ATC.MODE.COLORSEL_ALL is set; ignored in 256-color modes)
        DAC_BIT4:           0x01        // specifies bit 4 of DAC values (if ATC.MODE.COLORSEL_ALL is set; ignored in 256-color modes)
    },
    TOTAL_REGS:             0x14
};

if (DEBUGGER) {
    Card.ATC.REGS = [
        "ATC00","ATC01","ATC02","ATC03","ATC04","ATC05","ATC06","ATC07",
        "ATC08","ATC09","ATC0A","ATC0B","ATC0C","ATC0D","ATC0E","ATC0F", "ATCMODE","OVERSCAN","PLANES","HPAN"];
}

/*
 * EGA/VGA Feature Control Register (port 0x3BA or 0x3DA: regFeat)
 *
 * The EGA BIOS writes 0x1 to Card.FEAT_CTRL.BITS and reads Card.STATUS0.FEAT, then writes 0x2 to
 * Card.FEAT_CTRL.BITS and reads Card.STATUS0.FEAT.  The bits from the first and second reads are shifted
 * into the high nibble of the byte at 40:88h.
 */
Card.FEAT_CTRL = {
    PORT_MONO:              0x3BA,      // write port address (other than the two bits below, the rest are reserved and/or unused)
    PORT_COLOR:             0x3DA,      // write port address (other than the two bits below, the rest are reserved and/or unused)
    PORT_READ:              0x3CA,      // read port address (VGA only)
    BITS:                   0x03        // feature control bits
};

/*
 * EGA/VGA Miscellaneous Output Register (port 0x3C2: regMisc)
 */
Card.MISC = {
    PORT_WRITE:             0x3C2,      // write port address (EGA and VGA)
    PORT_READ:              0x3CC,      // read port address (VGA only)
    IO_SELECT:              0x01,       // 0 sets CRT ports to 0x3Bn, 1 sets CRT ports to 0x3Dn
    ENABLE_RAM:             0x02,       // 0 disables video RAM, 1 enables
    CLOCK_SELECT:           0x0C,       // 0x0: 14Mhz I/O clock, 0x4: 16Mhz on-board clock, 0x8: external clock, 0xC: unused
    DISABLE_DRV:            0x10,       // 0 activates internal video drivers, 1 activates feature connector direct drive outputs
    PAGE_ODD_EVEN:          0x20,       // 0 selects the low 64Kb page of video RAM for text modes, 1 selects the high page
    HPOLARITY:              0x40,       // 0 selects positive horizontal retrace
    VPOLARITY:              0x80        // 0 selects positive vertical retrace
};

/*
 * EGA/VGA Input Status 0 Register (port 0x3C2: regStatus0)
 */
Card.STATUS0 = {
    PORT:                   0x3C2,      // read-only (aka STATUS0, to distinguish it from PORT_CGA_STATUS)
    RESERVED:               0x0F,
    SWSENSE:                0x10,
    SWSENSE_SHIFT:          4,
    FEAT:                   0x60,       // VGA: reserved
    INTERRUPT:              0x80        // 1: video is being displayed; 0: vertical retrace is occurring
};

/*
 * VGA Subsystem Enable Register (port 0x3C3: regVGAEnable)
 */
Card.VGA_ENABLE = {
    PORT:                   0x3C3,
    ENABLED:                0x01,       // when set, all VGA I/O and memory decoding is enabled; otherwise disabled (TODO: Implement)
    RESERVED:               0xFE
};

/*
 * EGA/VGA Sequencer Registers (ports 0x3C4/0x3C5: regSEQIndx and regSEQData)
 */
Card.SEQ = {
    INDX: {
        PORT:               0x3C4,      // Sequencer Index Port
        MASK:               0x07
    },
    DATA: {
        PORT:               0x3C5       // Sequencer Data Port
    },
    RESET: {
        INDX:               0x00,       // Sequencer Reset Register
        ASYNC:              0x01,
        SYNC:               0x02
    },
    CLKMODE: {
        INDX:               0x01,       // Sequencer Clocking Mode Register
        DOTS8:              0x01,       // 1: 8 dots; 0: 9 dots
        BANDWIDTH:          0x02,       // 0: CRTC has access 4 out of every 5 cycles (for high-res modes); 1: CRTC has access 2 out of 5 (VGA: reserved)
        SHIFTLOAD:          0x04,
        DOTCLOCK:           0x08,       // 0: normal dot clock; 1: master clock divided by two (used for 320x200 modes: 0, 1, 4, 5, and D)
        SHIFT4:             0x10,       // VGA only
        SCREEN_OFF:         0x20,       // VGA only
        RESERVED:           0xC0
    },
    MAPMASK: {
        INDX:               0x02,       // Sequencer Map Mask Register
        PL0:                0x01,
        PL1:                0x02,
        PL2:                0x04,
        PL3:                0x08,
        MAPS:               0x0F,
        RESERVED:           0xF0
    },
    CHARMAP: {
        INDX:               0x03,       // Sequencer Character Map Select Register
        SELB:               0x03,       // 0x0: 1st 8Kb of plane 2; 0x1: 2nd 8Kb; 0x2: 3rd 8Kb; 0x3: 4th 8Kb (used when attribute bit 3 is 0)
        SELA:               0x0C,       // 0x0: 1st 8Kb of plane 2; 0x4: 2nd 8Kb; 0x8: 3rd 8Kb; 0xC: 4th 8Kb (used when attribute bit 3 is 1)
        SELB_HI:            0x10,       // VGA only
        SELA_HI:            0x20        // VGA only
    },
    MEMMODE: {
        INDX:               0x04,       // Sequencer Memory Mode Register
        ALPHA:              0x01,       // set for alphanumeric (A/N) mode, clear for graphics (APA or "All Points Addressable") mode (EGA only)
        EXT:                0x02,       // set if memory expansion installed, clear if not installed
        SEQUENTIAL:         0x04,       // set for sequential memory access, clear for mapping even addresses to planes 0/2, odd addresses to planes 1/3
        CHAIN4:             0x08        // VGA only: set to select memory map (plane) based on low 2 bits of address
    },
    TOTAL_REGS:             0x05
};

if (DEBUGGER) Card.SEQ.REGS = ["RESET","CLKMODE","MAPMASK","CHARMAP","MEMMODE"];

/*
 * VGA Digital-to-Analog Converter (DAC) Registers (regDACMask, regDACState, regDACAddr, and regDACData)
 *
 * To write DAC data, write an address to DAC.ADDR.PORT_WRITE, then write 3 bytes to DAC.DATA.PORT; the low 6 bits
 * of each byte will be concatenated to form an 18-bit DAC value (red is least significant, followed by green, then blue).
 * When the final byte is received, the 18-bit DAC value is updated and regDACAddr is auto-incremented.
 *
 * To read DAC data, the process is similar, but the initial address is written to DAC.ADDR.PORT_READ instead.
 *
 * DAC.STATE.PORT and DAC.ADDR.PORT_WRITE can be read at any time and will not interfere with a read or write operation
 * in progress.  To prevent "snow", reading or writing DAC values should be limited to retrace intervals (see regStatus1),
 * or by using the SCREEN_OFF bit in the SEQ.CLKMODE register.
 */
Card.DAC = {
    MASK: {
        PORT:               0x3C6,      // initialized to 0xFF and should not be changed
        DEFAULT:            0xFF
    },
    STATE: {
        PORT:               0x3C7,
        MODE_WRITE:         0x00,       // the DAC is in write mode if bits 0 and 1 are clear
        MODE_READ:          0x03        // the DAC is in read mode if bits 0 and 1 are set
    },
    ADDR: {
        PORT_READ:          0x3C7,      // write to initiate a read
        PORT_WRITE:         0x3C8       // write to initiate a write; read to determine the current ADDR
    },
    DATA: {
        PORT:               0x3C9
    },
    TOTAL_REGS:             0x100
};

/*
 * EGA/VGA Graphics Controller Registers (ports 0x3CE/0x3CF: regGRCIndx and regGRCData)
 *
 * The VGA added Write Mode 3, which is described as follows:
 *
 *      "Each map is written with 8 bits of the value contained in the Set/Reset register for that map
 *      (the Enable Set/Reset register has no effect). Rotated system microprocessor data is ANDed with the
 *      Bit Mask register data to form an 8-bit value that performs the same function as the Bit Mask register
 *      does in write modes 0 and 2."
 */
Card.GRC = {
    POS1_PORT:              0x3CC,      // EGA only, write-only
    POS2_PORT:              0x3CA,      // EGA only, write-only
    INDX: {
        PORT:               0x3CE,      // GRC Index Port
        MASK:               0x0F
    },
    DATA: {
        PORT:               0x3CF       // GRC Data Port
    },
    SRESET: {
        INDX:               0x00        // GRC Set/Reset Register (write-only; each bit used only if WRITE.MODE0 and corresponding ESR bit set)
    },
    ESRESET: {
        INDX:               0x01        // GRC Enable Set/Reset Register
    },
    COLORCOMP: {
        INDX:               0x02        // GRC Color Compare Register
    },
    DATAROT: {
        INDX:               0x03,       // GRC Data Rotate Register
        COUNT:              0x07,
        AND:                0x08,
        OR:                 0x10,
        XOR:                0x18,
        FUNC:               0x18,
        MASK:               0x1F
    },
    READMAP: {
        INDX:               0x04,       // GRC Read Map Select Register
        NUM:                0x03
    },
    MODE: {
        INDX:               0x05,       // GRC Mode Register
        WRITE: {
            MODE0:          0x00,       // write mode 0: each plane written with CPU data, rotated as needed, unless SR enabled
            MODE1:          0x01,       // write mode 1: each plane written with contents of the processor latches (loaded by a read)
            MODE2:          0x02,       // write mode 2: memory plane N is written with 8 bits matching data bit N
            MODE3:          0x03,       // write mode 3: VGA only
            MASK:           0x03
        },
        TEST:               0x04,
        READ: {
            MODE0:          0x00,       // read mode 0: read map mode
            MODE1:          0x08,       // read mode 1: color compare mode
            MASK:           0x08
        },
        EVENODD:            0x10,
        SHIFT:              0x20,
        COLOR256:           0x40        // VGA only
    },
    MISC: {
        INDX:               0x06,       // GRC Miscellaneous Register
        GRAPHICS:           0x01,       // set for graphics mode addressing, clear for text mode addressing
        CHAIN:              0x02,       // set for odd/even planes selected with odd/even values of the processor AO bit
        MAPMEM:             0x0C,       //
        MAPA0128:           0x00,       //
        MAPA064:            0x04,       //
        MAPB032:            0x08,       //
        MAPB832:            0x0C        //
    },
    COLORDC: {
        INDX:               0x07        // GRC Color "Don't Care" Register
    },
    BITMASK: {
        INDX:               0x08        // GRC Bit Mask Register
    },
    TOTAL_REGS:             0x09
};

if (DEBUGGER) Card.GRC.REGS = ["SRESET","ESRESET","COLORCOMP","DATAROT","READMAP","GRCMODE","GRCMISC","COLORDC","BITMASK"];

/*
 * EGA Memory Access Functions
 *
 * Here's where we define all the getMemoryAccess() functions that know how to deal with "planar" EGA memory,
 * which consists of 32-bit values for every byte of address space, allowing us to internally store plane 0
 * bytes in bits 0-7, plane 1 bytes in bits 8-15, plane 2 bytes in bits 16-23, and plane 3 bytes in bits 24-31.
 *
 * All our functions have slightly more overhead than the standard Bus memory access functions, because the
 * offset (off) parameter is block-relative, which we must transform into a buffer-relative offset.  Fortunately,
 * all our Memory objects know this and have already recorded their buffer-relative offset in "this.offset".
 *
 * Also, the EGA includes a set of latches, one for each plane, which must be updated on most reads/writes;
 * we rely on the Memory object's "this.controller" property to give us access to the Card's state.
 *
 * And we take a little extra time to conditionally set DIRTY on writes, meaning if a write did not actually
 * change the value of the memory, we will not set DIRTY.  The default write functions in memory.js don't take
 * that performance hit, but here, it may be worthwhile, because if it results in fewer dirty blocks, display
 * updates may be faster.
 *
 * Note that we don't have to worry about dealing with word accesses that straddle block boundaries, because
 * the Bus component automatically breaks those accesses into separate byte requests.  Similarly, byte and word
 * values for the write functions have already been pre-masked by the Bus component to 8 and 16 bits, respectively.
 *
 * My motto: Be paranoid, but also be careful not to do any more work than you absolutely have to.
 *
 *
 * CGA Emulation on the EGA
 *
 * Modes 4/5 (320x200 low-res graphics) emulate the same buffer format that the CGA uses.  To recap: 1 byte contains
 * 4 pixels (pixel 0 in bits 7-6, pixel 1 in bits 5-4, etc), and thus one row of pixels is 80 (0x50) bytes long.
 * Moreover, all even rows are stored in the first 8K of the video buffer (at 0xB8000), and all odd rows are stored
 * in the second 8K (at 0xBA000).  Of each 8K, only 8000 (0x1F40) bytes are used (80 bytes X 100 rows); the remaining
 * 192 bytes of each 8K are unused.
 *
 * For these modes, the EGA's GRC.MODE is programmed with 0x30: Card.GRC.MODE.EVENODD and Card.GRC.MODE.SHIFT.
 * The latter claims to work by forming each 2-bit pixel with even bits from plane 0 and odd bits from plane 1;
 * however, I'm unclear how that works if even bytes are only written to plane 0 and odd bytes are only written to
 * plane 1, as Card.GRC.MODE.EVENODD implies, because plane 0 would never have any bits for the odd bytes, and
 * plane 1 would never have any bits for the even bytes.  TODO: Figure this out.
 *
 *
 * Even/Odd Memory Access Functions
 *
 * The "EVENODD" functions deal with the EGA's default text-mode addressing, where EVEN addresses are mapped to
 * plane 0 (and 2) and ODD addresses are mapped to plane 1 (and 3).  This occurs when SEQ.MEMMODE.SEQUENTIAL is
 * clear (and GRC.MODE.EVENODD is set), turning address bit 0 (A0) into a "plane select" bit.  Whether A0 is also
 * used as a memory address bit depends on CRTC.MODECTRL.BYTE_MODE: if it's set, then we're in "Byte Mode" and A0 is
 * used as-is; if it's clear, then we're in "Word Mode", and either A15 (when CRTC.MODECTRL.ADDR_WRAP is set) or A13
 * (when CRTC.MODECTRL.ADDR_WRAP is clear, typically when only 64Kb of EGA memory is installed) is substituted for A0.
 *
 * Note that A13 remains clear until addresses reach 8K, at which point we've spanned 32Kb of EGA memory, so it makes
 * sense to propagate A13 to A0 at that point, so that the next 8K of addresses start using ODD instead of EVEN bytes,
 * and no memory is wasted on a 64Kb EGA card.
 *
 * These functions, however, don't yet deal with all those subtleties: A0 is currently used only as a "plane select"
 * bit and set to zero for addressing purposes, meaning that only the EVEN bytes in EGA memory will ever be used.
 * TODO: Implement the subtleties.
 */

/*
 * Values returned by getCardAccess(); the high byte describes the read mode, and the low byte describes the write mode.
 *
 * V2 should never appear in any values used by getCardAccess() or setCardAccess(); the sole purpose of V2 is to
 * distinguish newer (V2) access values from older (V1) access values in saved contexts.  It's set when the context
 * is saved, and cleared when the context is restored.  Thus, if V2 is not set on restore, we assume we're dealing with
 * a V1 value, so we run it through the V1 table (below) to produce a V2 value.  Hopefully at some point V1 contexts
 * can be deprecated, and the V2 bit can be eliminated/repurposed.
 */
Card.ACCESS = {
    READ: {                             // READ values are designed to be OR'ed with WRITE values
        MODE0:              0x0400,
        MODE1:              0x0500,
        PAIRS:              0x0800,
        EVENODD:            0x1000,
        CHAIN4:             0x4000,
        MASK:               0xFF00
    },
    WRITE: {                            // and WRITE values are designed to be OR'ed with READ values
        MODE0:              0x0000,
        MODE1:              0x0001,
        MODE2:              0x0002,
        MODE3:              0x0003,     // VGA only
        CHAIN4:             0x0004,
        PAIRS:              0x0008,
        EVENODD:            0x0010,
        ROT:                0x0020,
        AND:                0x0060,
        OR:                 0x00A0,
        XOR:                0x00E0,
        MASK:               0x00FF
    },
    V2:             (0x80000000|0)      // this is a signature bit used ONLY to differentiate V2 access values from V1
};

/*
 * Table of older (V1) access values and their corresponding new values; the new values are similar but more orthogonal
 */
Card.ACCESS.V1 = [];
Card.ACCESS.V1[0x0002] = Card.ACCESS.READ.MODE0;
Card.ACCESS.V1[0x0003] = Card.ACCESS.READ.MODE0  | Card.ACCESS.READ.EVENODD;
Card.ACCESS.V1[0x0010] = Card.ACCESS.READ.MODE1;
Card.ACCESS.V1[0x0200] = Card.ACCESS.WRITE.MODE0;
Card.ACCESS.V1[0x0400] = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.ROT;
Card.ACCESS.V1[0x0600] = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.AND;
Card.ACCESS.V1[0x0A00] = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.OR;
Card.ACCESS.V1[0x0E00] = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.XOR;
Card.ACCESS.V1[0x0300] = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.EVENODD;
Card.ACCESS.V1[0x1000] = Card.ACCESS.WRITE.MODE1;
Card.ACCESS.V1[0x2000] = Card.ACCESS.WRITE.MODE2;
Card.ACCESS.V1[0x6000] = Card.ACCESS.WRITE.MODE2 | Card.ACCESS.WRITE.AND;
Card.ACCESS.V1[0xA000] = Card.ACCESS.WRITE.MODE2 | Card.ACCESS.WRITE.OR;
Card.ACCESS.V1[0xE000] = Card.ACCESS.WRITE.MODE2 | Card.ACCESS.WRITE.XOR;

/**
 * readBytePairs(off, addr)
 *
 * Used for MDA/CGA byte-pair access (ie, pairs of bytes stored in a single dword).
 *
 * Externally, this makes the buffer look like a linear series of byte pairs, perfect for emulating MDA and CGA
 * character/attribute text modes, while internally, it looks similar to an EvenOdd arrangement, except that odd
 * dwords not skipped (ie, wasted).  This similarity makes life simpler for updateScreenText().
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} [addr]
 * @return {number}
 */
Card.ACCESS.readBytePairs = function readByte(off, addr)
{
    off += this.offset;
    return ((this.adw[off >> 1] >>> ((off & 0x1) << 3)) & 0xff);
};

/**
 * readByteMode0(off, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} [addr]
 * @return {number}
 */
Card.ACCESS.readByteMode0 = function readByteMode0(off, addr)
{
    off += this.offset;
    let dw = this.controller.latches = this.adw[off];
    return (dw >> this.controller.nReadMapShift) & 0xff;
};

/**
 * readByteMode0Chain4(off, addr)
 *
 * See writeByteMode0Chain4 for a description of how writes are distributed across planes.
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} [addr]
 * @return {number}
 */
Card.ACCESS.readByteMode0Chain4 = function readByteMode0Chain4(off, addr)
{
    let idw = (off & ~0x3) + this.offset;
    let shift = (off & 0x3) << 3;
    return ((this.controller.latches = this.adw[idw]) >> shift) & 0xff;
};

/**
 * readByteMode0EvenOdd(off, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} [addr]
 * @return {number}
 */
Card.ACCESS.readByteMode0EvenOdd = function readByteMode0EvenOdd(off, addr)
{
    /*
     * TODO: As discussed in getCardAccess(), we need to run some tests on real EGA/VGA hardware to determine
     * exactly what gets latched (ie, from which address) when EVENODD is in effect.  Whatever we learn may also
     * dictate a special EVENODD function for READ.MODE1 as well.
     */
    let idw = (off += this.offset) & ~0x1;
    let dw = this.controller.latches = this.adw[idw];
    return (!(off & 1)? dw : (dw >> 8)) & 0xff;
};

/**
 * readByteMode1(off, addr)
 *
 * This mode requires us to step through each of the 8 sets of 4 bits in the specified DWORD of video memory,
 * returning a 1 wherever all 4 match the Color Compare (COLORCOMP) Register and a 0 otherwise.  An added wrinkle
 * is that the Color Don't Care (COLORDC) Register can specify that any/all/none of the 4 bits must be ignored.
 *
 * We perform the comparison from most to least significant bit, because that matches how the nColorCompare and
 * nColorDontCare masks are initialized; we could have gone either way, but this is more consistent with the rest
 * of the component (eg, pixels are drawn across the screen from left to right, starting with the most significant
 * bit of each byte).
 *
 * Also note that, while not well-documented, this mode also affects the internal latches, so we make sure those
 * are updated as well.
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} [addr]
 * @return {number}
 */
Card.ACCESS.readByteMode1 = function readByteMode1(off, addr)
{
    let card = this.controller;
    let dw = card.latches = this.adw[off + this.offset];
    /*
     * Minor optimization: we could pre-mask nColorCompare with nColorDontCare, whenever either register
     * is updated, but that's a drop in the bucket compared to all the other work this function must do.
     */
    let mask = card.nColorDontCare;
    let color = card.nColorCompare & mask;
    let b = 0, bit = 0x80;
    while (bit) {
        if ((dw & mask) == color) b |= bit;
        color >>>= 1;  mask >>>= 1;  bit >>= 1;
    }
    return b;
};

/**
 * writeBytePairs(off, b, addr)
 *
 * Used for MDA/CGA byte-pair access (ie, pairs of bytes stored in a single dword).
 *
 * Externally, this makes the buffer look like a linear series of byte pairs, perfect for emulating MDA and CGA
 * character/attribute text modes, while internally, it looks similar to an EvenOdd arrangement, except that odd
 * dwords not skipped (ie, wasted).  This similarity makes life simpler for updateScreenText().
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeBytePairs = function writeByte(off, b, addr)
{
    off += this.offset;
    let idw = off >> 1;
    let nShift = (off & 0x1) << 3;
    let dw = (this.adw[idw] & ~(0xff << nShift)) | (b << nShift);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
};

/**
 * writeByteMode0(off, b, addr)
 *
 * Supporting Set/Reset means that for every plane for which Set/Reset is enabled, we must
 * replace the corresponding byte in dw with a byte of zeros or ones.  This is accomplished with
 * nSetMapMask, nSetMapData, and nSetMapBits.  nSetMapMask is the inverse of the ESRESET bits,
 * because we use it to mask the processor data, nSetMapData records the desired SRESET bits,
 * and nSetMapBits contains the bits to replace those that we masked in the processor data.
 *
 * We could have done this:
 *
 *      dw = (dw & card.nSetMapMask) | (card.nSetMapData & ~card.nSetMapMask)
 *
 * but by maintaining nSetMapBits equal to (nSetMapData & ~nSetMapMask), we are able to make the
 * writes slightly more efficient.
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode0 = function writeByteMode0(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    let dw = b | (b << 8) | (b << 16) | (b << 24);
    dw = (dw & card.nSetMapMask) | card.nSetMapBits;
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    let delta = (this.adw[idw] ^ dw);
    if (delta) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
        // card.bitsDirtyPlanes |= delta;       // we no longer track dirty planes, just dirty font banks
        if (delta & 0x00ff0000) {               // if any plane 2 bits were modified, mark the appropriate font bank dirty
            let bitDirtyBank = (1 << ((idw >> 13) & 7));
            if (!(card.bitsDirtyBanks & bitDirtyBank)) {
                card.bitsDirtyBanks |= bitDirtyBank;
                if (DEBUG && card.video.messageEnabled(Messages.VIDEO)) {
                    card.video.printf("writeByteMode0(0x%08X): modified font bank 0x%02X\n", addr, bitDirtyBank);
                }
            }
        }
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printf("writeByteMode0(0x%08X): 0x%02X -> 0x%08X%s\n", addr, b, dw);
    }
};

/**
 * writeByteMode0Chain4(off, b, addr)
 *
 * This is how we distribute writes of 0xff across the address space to the planes (assuming that all
 * planes are enabled by the Sequencer's MAPMASK register):
 *
 *      off     idw     adw[idw]
 *      ------  ------  ----------
 *      0x0000: 0x0000  0x000000ff
 *      0x0001: 0x0000  0x0000ff00
 *      0x0002: 0x0000  0x00ff0000
 *      0x0003: 0x0000  0xff000000
 *      0x0004: 0x0004  0x000000ff
 *      0x0005: 0x0004  0x0000ff00
 *      0x0006: 0x0004  0x00ff0000
 *      0x0007: 0x0004  0xff000000
 *      ...
 *
 * Some VGA emulations calculate the video buffer index (idw) by shifting the offset (off) right 2 bits,
 * instead of simply masking off the low 2 bits, as we do here.  That would be a more "pleasing" arrangement,
 * because we would be using sequential video buffer locations, instead of multiples of 4, and would match how
 * pixels are stored in "Mode X".  However, I don't think that's how CHAIN4 modes operate (although that still
 * needs to be confirmed, because multiple sources conflict on this point).  TODO: Confirm CHAIN4 operation on
 * actual VGA hardware, including the extent to which ALU and other writeByteMode0() functionality needs to
 * be folded into this.
 *
 * Address decoding may not matter that much, as long as both the read and write CHAIN4 functions decode their
 * addresses in exactly the same manner; we'd only get into trouble with software that "unchained" or otherwise
 * reconfigured the planes and then made assumptions about existing data in the video buffer.
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode0Chain4 = function writeByteMode0Chain4(off, b, addr)
{
    let card = this.controller;
    let idw = (off & ~0x3) + this.offset;
    let shift = (off & 0x3) << 3;
    /*
     * TODO: Consider adding a separate "unmasked" version of this CHAIN4 write function when nSeqMapMask is -1
     * (or removing nSeqMapMask from the equation altogether, if CHAIN4 is never used with any planes disabled).
     */
    let dw = ((b << shift) & card.nSeqMapMask) | (this.adw[idw] & ~((0xff << shift) & card.nSeqMapMask));
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode0Chain4(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode0EvenOdd(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode0EvenOdd = function writeByteMode0EvenOdd(off, b, addr)
{
    let card = this.controller;
    let idw = (off += this.offset) & ~0x1;
    let dw = b | (b << 8) | (b << 16) | (b << 24);
    /*
     * When even/odd addressing is enabled, nSeqMapMask must be cleared for planes 1
     * and 3 if the address is even, and cleared for planes 0 and 2 if the address is odd.
     */
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    let maskMaps = card.nSeqMapMask & (idw == off? 0x00ff00ff : (0xff00ff00|0));
    dw = (dw & maskMaps) | (this.adw[idw] & ~maskMaps);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode0EvenOdd(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode0Rot(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode0Rot = function writeByteMode0Rot(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
    let dw = b | (b << 8) | (b << 16) | (b << 24);
    dw = (dw & card.nSetMapMask) | card.nSetMapBits;
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode0Rot(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode0And(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode0And = function writeByteMode0And(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
    let dw = b | (b << 8) | (b << 16) | (b << 24);
    dw = (dw & card.nSetMapMask) | card.nSetMapBits;
    dw &= card.latches;
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode0And(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode0Or(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode0Or = function writeByteMode0Or(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
    let dw = b | (b << 8) | (b << 16) | (b << 24);
    dw = (dw & card.nSetMapMask) | card.nSetMapBits;
    dw |= card.latches;
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode0Or(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode0Xor(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode0Xor = function writeByteMode0Xor(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
    let dw = b | (b << 8) | (b << 16) | (b << 24);
    dw = (dw & card.nSetMapMask) | card.nSetMapBits;
    dw ^= card.latches;
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode0Xor(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode1(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (ignored; the EGA latches provide the source data)
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode1 = function writeByteMode1(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    let dw = (this.adw[idw] & ~card.nSeqMapMask) | (card.latches & card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode1(" + Str.toHexLong(addr) + "): " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode1EvenOdd(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (ignored; the EGA latches provide the source data)
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode1EvenOdd = function writeByteMode1EvenOdd(off, b, addr)
{
    /*
     * When even/odd addressing is enabled, nSeqMapMask must be cleared for planes 1 and 3 if the
     * address is even, and cleared for planes 0 and 2 if the address is odd.
     *
     * TODO: As discussed in getCardAccess(), we need to run some tests on real EGA/VGA hardware to
     * determine exactly where latches are written (ie, to which address) when EVENODD is in effect.
     */
    let card = this.controller;
    let idw = (off += this.offset) & ~0x1;
    let maskMaps = card.nSeqMapMask & (idw == off? 0x00ff00ff : (0xff00ff00|0));
    let dw = (this.adw[idw] & ~maskMaps) | (card.latches & maskMaps);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode1EvenOdd(" + Str.toHexLong(addr) + "): " + Str.toHexByte(dw));
    }
};

/**
 * writeByteMode2(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode2 = function writeByteMode2(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    let dw = Video.aEGAByteToDW[b & 0xf];
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode2(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode2And(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode2And = function writeByteMode2And(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    let dw = Video.aEGAByteToDW[b & 0xf];
    dw &= card.latches;
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode2And(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode2Or(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode2Or = function writeByteMode2Or(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    let dw = Video.aEGAByteToDW[b & 0xf];
    dw |= card.latches;
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode2Or(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode2Xor(off, b, addr)
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode2Xor = function writeByteMode2Xor(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    let dw = Video.aEGAByteToDW[b & 0xf];
    dw ^= card.latches;
    dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode2Xor(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/**
 * writeByteMode3(off, b, addr)
 *
 * In MODE3, Set/Reset is always enabled, so the ESRESET bits (and therefore nSetMapMask and nSetMapBits)
 * are ignored; we look only at the SRESET bits, which are stored in nSetMapData.
 *
 * Unlike MODE0, we currently have no non-rotate function for MODE3.  If performance dictates, we can add one;
 * ditto for other features like the Sequencer's MAPMASK register (nSeqMapMask).
 *
 * @this {Memory}
 * @param {number} off
 * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
 * @param {number} [addr]
 */
Card.ACCESS.writeByteMode3 = function writeByteMode3(off, b, addr)
{
    let card = this.controller;
    let idw = off + this.offset;
    b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
    let dw = b | (b << 8) | (b << 16) | (b << 24);
    let dwMask = (dw & card.nBitMapMask);
    dw = (card.nSetMapData & dwMask) | (card.latches & ~dwMask);
    dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
    if (this.adw[idw] != dw) {
        this.adw[idw] = dw;
        this.flags |= Memory.FLAGS.DIRTY;
    }
    if (DEBUG && card.video.messageEnabled(Messages.MEM | Messages.VIDEO)) {
        card.video.printMessage("writeByteMode3(" + Str.toHexLong(addr) + "): " + Str.toHexByte(b) + " -> " + Str.toHexLong(dw));
    }
};

/*
 * Mappings from getCardAccess() values to access functions above
 */
Card.ACCESS.afn = [];

Card.ACCESS.afn[Card.ACCESS.READ.MODE0]  = Card.ACCESS.readByteMode0;
Card.ACCESS.afn[Card.ACCESS.READ.MODE0  |  Card.ACCESS.READ.CHAIN4]  = Card.ACCESS.readByteMode0Chain4;
Card.ACCESS.afn[Card.ACCESS.READ.MODE0  |  Card.ACCESS.READ.EVENODD] = Card.ACCESS.readByteMode0EvenOdd;
Card.ACCESS.afn[Card.ACCESS.READ.MODE1]  = Card.ACCESS.readByteMode1;
Card.ACCESS.afn[Card.ACCESS.READ.PAIRS]  = Card.ACCESS.readBytePairs;

Card.ACCESS.afn[Card.ACCESS.WRITE.MODE0] = Card.ACCESS.writeByteMode0;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE0 |  Card.ACCESS.WRITE.ROT] = Card.ACCESS.writeByteMode0Rot;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE0 |  Card.ACCESS.WRITE.AND] = Card.ACCESS.writeByteMode0And;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE0 |  Card.ACCESS.WRITE.OR]  = Card.ACCESS.writeByteMode0Or;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE0 |  Card.ACCESS.WRITE.XOR] = Card.ACCESS.writeByteMode0Xor;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE0 |  Card.ACCESS.WRITE.CHAIN4]  = Card.ACCESS.writeByteMode0Chain4;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE0 |  Card.ACCESS.WRITE.EVENODD] = Card.ACCESS.writeByteMode0EvenOdd;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE1] = Card.ACCESS.writeByteMode1;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE1 |  Card.ACCESS.WRITE.EVENODD] = Card.ACCESS.writeByteMode1EvenOdd;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE2] = Card.ACCESS.writeByteMode2;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE2 |  Card.ACCESS.WRITE.AND] = Card.ACCESS.writeByteMode2And;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE2 |  Card.ACCESS.WRITE.OR]  = Card.ACCESS.writeByteMode2Or;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE2 |  Card.ACCESS.WRITE.XOR] = Card.ACCESS.writeByteMode2Xor;
Card.ACCESS.afn[Card.ACCESS.WRITE.MODE3] = Card.ACCESS.writeByteMode3;
Card.ACCESS.afn[Card.ACCESS.WRITE.PAIRS] = Card.ACCESS.writeBytePairs;

/**
 * @class Video
 * @property {CPUX86} cpu
 * @property {DebuggerX86} dbg
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Video extends Component {
    /**
     * Video(parmsVideo, canvas, context, textarea, container, aDiagElements)
     *
     * The Video component can be configured with the following (parmsVideo) properties:
     *
     *      model: model (eg, "mda" for Monochrome Display Adapter)
     *      mode: initial video mode (default is null, which selects a mode based on model)
     *      screenWidth: width of the screen canvas, in pixels
     *      screenHeight: height of the screen canvas, in pixels
     *      screenColor: background color of the screen canvas (default is black)
     *      flicker: 1 enables screen flicker, 0 disables (default is 0)
     *      scale: true for font scaling, false (default) to center the display on the screen
     *      charCols: number of character columns
     *      charRows: number of character rows
     *      fontROM: path to .rom file (or a JSON representation) containing the character set
     *      touchScreen: string specifying desired touch-screen support (default is none)
     *      autoLock: true to (attempt to) auto-lock the mouse to the canvas (default is false)
     *      randomize: 1 enables screen randomization, 0 disables (default is 1)
     *
     * An EGA/VGA may specify the following additional properties:
     *
     *      switches: string representing EGA switches (see "SW1-SW4" documentation below)
     *      memory: the size of the EGA's on-board memory (overrides EGA's Video.cardSpecs)
     *
     * This calls the Bus to allocate a video buffer at the appropriate memory location whenever
     * a reset() or setMode() occurs; setMode() is called whenever a mode change is detected at
     * the port level, and whenever reset() is called.  setMode() also invokes updateScreen(true),
     * which forces reallocation of our internal buffer (aCellCache) that mirrors the video buffer.
     *
     * Our initBus() handler defines a timer that periodically calls updateScreen() for each Video
     * instance.  These updates should occur at a rate of 60 times/second, to update any blinking
     * elements (the cursor and any cells with the blink attribute), to compare/update the contents
     * of our internal buffer with the video buffer, and to render any differences between the two
     * buffers into the associated screen canvas, via either updateChar() or setPixel().
     *
     * Thanks to the Bus' new block-based memory manager that allows us to sparse-allocate memory
     * (in 4Kb increments), updateScreen() can also ask the CPU for the "dirty" state of all the
     * blocks underlying the video buffer, bypassing the update completely if the buffer is still clean.
     *
     * Sadly, that optimization is defeated if the count of active blink elements is non-zero,
     * because we must rescan the entire buffer to locate and redraw them all; I'm assuming for now
     * that, more often than not, very few (if any) blink attributes will be present, and therefore
     * they're not worth a separate caching mechanism.  If the only blinking element is the cursor,
     * that's no problem, as we redraw only the one cell containing the cursor (assuming the buffer
     * is otherwise clean).
     *
     * @this {Video}
     * @param {Object} parmsVideo
     * @param {HTMLCanvasElement} [canvas]
     * @param {CanvasRenderingContext2D} [context]
     * @param {HTMLTextAreaElement} [textarea]
     * @param {HTMLElement} [container]
     * @param {Array.<HTMLElement>} [aDiagElements]
     */
    constructor(parmsVideo, canvas, context, textarea, container, aDiagElements)
    {
        super("Video", parmsVideo, Messages.VIDEO);

        let video = this, sProp, sEvent;
        this.fGecko = Web.isUserAgent("Gecko/");
        this.bindingsExternal = [];

        /*
         * This records the model specified (eg, "mda", "cga", "ega", "vga" or "" if none specified);
         * when a model is specified, it overrides whatever model we infer from the ChipSet's switches
         * (since those motherboard switches tell us only the type of monitor, not the type of card).
         */
        this.model = parmsVideo['model'];
        let aModelDefaults = Video.MODEL[this.model] || Video.MODEL['mda'];

        this.nCard = aModelDefaults[0];
        this.nIRQ = (this.nCard >= Video.CARD.EGA)? ChipSet.IRQ.VID : undefined;

        this.nCardFont = 0;
        this.nActiveFont = this.nAlternateFont = 0;
        this.nFontSelect = 0;                       // current set of selectable logical fonts
        this.cbMemory = parmsVideo['memory'] || 0;  // zero means fallback to the cardSpec's default size
        this.sSwitches = parmsVideo['switches'];
        this.nRandomize = parmsVideo['randomize'];
        if (this.nRandomize == null) this.nRandomize = 1;

        /*
         * powerUp() uses the default mode ONLY if ChipSet doesn't give us a default.
         */
        this.nModeDefault = parmsVideo['mode'];
        if (this.nModeDefault == null || Video.aModeParms[this.nModeDefault] == null) {
            this.nModeDefault = aModelDefaults[1];
        }

        /*
         * setDimensions() uses these values ONLY if it doesn't recognize the video mode.
         */
        this.nColsDefault = parmsVideo['charCols'];
        this.nRowsDefault = parmsVideo['charRows'];
        if (this.nColsDefault === undefined || this.nRowsDefault === undefined) {
            this.nColsDefault = Video.aModeParms[this.nModeDefault][0];
            this.nRowsDefault = Video.aModeParms[this.nModeDefault][1];
        }

        /*
         * setDimensions() uses these values unconditionally, as the machine has no idea what the
         * physical screen size should be.
         */
        this.cxScreen = parmsVideo['screenWidth'];
        this.cyScreen = parmsVideo['screenHeight'];

        /*
         * The font 'scale' parameter is deprecated (we ALWAYS scale now), and the internal fDoubleFont
         * setting is now always true, but it is retained in case we want to revisit the benefits (or lack
         * thereof) of font-doubling.
         *
         *      this.fScaleFont = parmsVideo['scale'];
         *
         * When fScaleFont was false, one key difference was these additional lines in setDimensions():
         *
         *      if (!this.fScaleFont) {
         *          this.cxScreenCell = font.cxCell;
         *          this.cyScreenCell = font.cyCell;
         *      }
         *
         * which meant that if the font was only 8 pixels wide (instead of 16), then 40-column mode would
         * simply display normal size characters with large black borders on either of the screen.
         */
        this.fDoubleFont = true;

        this.canvasScreen = canvas;
        this.contextScreen = context;
        this.inputTextArea = textarea;
        this.inputScreen = textarea || canvas || null;

        /*
         * We now ensure that a colorScreen property is always set (to "black" if nothing else), and
         * set BOTH the canvas element's AND the container element's backgroundColor to match that color.
         *
         * This gives us option of doing "cute" things like flipping the canvas element's opacity from
         * 1 to 0 briefly, alternately revealing and hiding the underlying container element, to simulate
         * screen "flicker".
         */
        this.colorScreen = parmsVideo['screenColor'] || "black";
        this.opacityFlicker = (1 - (Web.getURLParm('flicker') || parmsVideo['flicker'] || 0)).toString();
        this.fOpacityReduced = false;
        if (canvas) canvas.style.backgroundColor = this.colorScreen;
        if (container) container.style.backgroundColor = this.colorScreen;

        /*
         * Support for disabling (or, less commonly, enabling) image smoothing, which all browsers
         * seem to support now (well, OK, I still have to test the latest MS Edge browser), despite
         * it still being labelled "experimental technology".  Let's hope the browsers standardize
         * on this.  I see other options emerging, like the CSS property "image-rendering: pixelated"
         * that's apparently been added to Chrome.  Sigh.
         *
         * UPDATE: Now that fDoubleFont is always true, and now that we're loading fonts (eg, VGA 9x16)
         * that may have a significantly different aspect ratio from that of the preferred screen size
         * (eg, 640x480), I've decided to turn smoothing ON just for text modes.  So now we just record
         * the default property name and value, and leave it to setDimensions() to do the actual setting.
         */
        let fSmoothing = parmsVideo['smoothing'];
        let sSmoothing = Web.getURLParm('smoothing');
        if (sSmoothing) fSmoothing = (sSmoothing == "true");
        this.fSmoothing = fSmoothing;
        this.sSmoothing = Web.findProperty(this.contextScreen, 'imageSmoothingEnabled');

        /*
         * initBus() will determine touch-screen support; for now, just record values and set defaults.
         */
        this.sTouchScreen = parmsVideo['touchScreen'];
        this.nTouchConfig = Video.TOUCH.NONE;

        /*
         * If a Mouse exists, we'll be notified when it requests our canvas, and we make a note of it
         * so that if lockPointer() is ever invoked, we can notify the Mouse.
         */
        this.mouse = null;
        this.fAutoLock = parmsVideo['autoLock'];

        /*
         * Originally, setMode() would map/unmap the video buffer ONLY when the active card changed,
         * because as long as an MDA or CGA remained active, its video buffer never changed.  However,
         * since the EGA can change its video buffer on the fly, setMode() must also compare the card's
         * hard-coded and/or programmed buffer address/size to the "active" address/size; the latter
         * is recorded here.
         */
        this.addrBuffer = this.sizeBuffer = 0;

        /*
         * aFonts is an array of font objects indexed by FONT ID.  Font characters are arranged
         * in 16x16 grids, with one grid per canvas object in the aCanvas array of each font object.
         *
         * Each element is a Font object that describes the font size and provides bitmaps for all the font
         * color permutations.  aFonts.length will be non-zero if ANY fonts are loaded, but do NOT assume
         * that EVERY font has been loaded; check for the existence of a font by checking for its unique ID
         * within this sparse array.
         */
        this.aFonts = [];

        /*
         * aFontDiff entries are created by createFontDiff(), and each entry is a 256-element array of either
         * 0 (no difference) or -1 for every character code that differs between the fonts that correspond to
         * the aFontDiff index.
         */
        this.aFontDiff = [];

        /*
         * Instead of (re)allocating a new color array every time getCardColors() is called, we preallocate
         * an array and simply update the entries as needed.  Note that for an EGA (or a VGA operating in an
         * EGA-compatible mode), only the first 16 entries get used (derived from the ATC); only when a VGA
         * is operating in an 8bpp mode are 256 entries used (derived from the DAC rather than the ATC).
         */
        this.aRGB = new Array(this.nCard == Video.CARD.VGA? 256 : 16);
        this.fRGBValid = false;     // whenever this is false, it signals getCardColors() to rebuild aRGB

        this.aCellCache = [];
        this.nCellCache = 0;
        this.iCellCacheValid = 0;   // 0: invalid, 1: partially valid, 2: completely valid
        this.fShifted = false;      // set to true whenever the image has been shifted by one or more pixels
        this.nShiftLeft = this.nShiftUp = 0;

        /*
         * Since I've not found clear documentation on a reliable way to check whether a particular DOM element
         * (other than the BODY element) has focus at any given time, I've added onfocus() and onblur() handlers
         * to the screen to maintain my own focus state.
         */
        this.fHasFocus = false;

        /*
         * Here's the gross code to handle full-screen support across all supported browsers.  The lack of standards
         * is exasperating; browsers can't agree on 'Fullscreen' (most common) or 'FullScreen' (least common), and while
         * some browsers honor other browser prefixes, most don't.  Event handlers tend to be more consistent (ie, all
         * lower-case).
         */
        this.container = container;
        if (this.container) {
            sProp = Web.findProperty(container, 'requestFullscreen') || Web.findProperty(container, 'requestFullScreen');
            if (sProp) {
                this.container.doFullScreen = container[sProp];
                sEvent = Web.findProperty(document, 'on', 'fullscreenchange');
                if (sEvent) {
                    let sFullScreen = Web.findProperty(document, 'fullscreenElement') || Web.findProperty(document, 'fullScreenElement');
                    document.addEventListener(sEvent, function onFullScreenChange() {
                        video.notifyFullScreen(document[sFullScreen] != null);
                    }, false);
                }
                sEvent = Web.findProperty(document, 'on', 'fullscreenerror');
                if (sEvent) {
                    document.addEventListener(sEvent, function onFullScreenError() {
                        video.notifyFullScreen();
                    }, false);
                }
            }
        }

        /*
         * More gross code to handle pointer-locking support across all supported browsers.
         */
        if (this.inputScreen) {
            this.inputScreen.onfocus = function onFocusScreen() {
                return video.onFocusChange(true);
            };
            this.inputScreen.onblur = function onBlurScreen() {
                return video.onFocusChange(false);
            };
            this.inputScreen.lockPointer = (sProp = Web.findProperty(this.inputScreen, 'requestPointerLock')) && this.inputScreen[sProp];
            this.inputScreen.unlockPointer = (sProp = Web.findProperty(this.inputScreen, 'exitPointerLock')) && this.inputScreen[sProp];
            if (this.inputScreen.lockPointer) {
                sEvent = Web.findProperty(document, 'on', 'pointerlockchange');
                if (sEvent) {
                    let sPointerLock = Web.findProperty(document, 'pointerLockElement');
                    document.addEventListener(sEvent, function onPointerLockChange() {
                        let fLocked = !!(sPointerLock && document[sPointerLock] === video.inputScreen);
                        video.notifyPointerLocked(fLocked);
                    }, false);
                }
            }
        }

        this.sFileURL = parmsVideo['fontROM'];

        if (this.sFileURL) {
            let sFileExt = Str.getExtension(this.sFileURL);
            if (sFileExt != "json") {
                this.sFileURL = Web.getHostOrigin() + DumpAPI.ENDPOINT + '?' + DumpAPI.QUERY.FILE + '=' + this.sFileURL + '&' + DumpAPI.QUERY.FORMAT + '=' + DumpAPI.FORMAT.BYTES;
            }
        }

        /*
         * TODO: A complete list of what we want to support in terms of "diagnostic elements" needs to be fleshed out
         * at some point.  For now, all I do is save the contexts of all supplied canvas elements and use them in createFont()
         * to display the font data (for as many font banks as there are canvas elements) whenever the font(s) get rebuilt.
         */
        this.aDiagContexts = [];
        if (aDiagElements) {
            for (let i = 0; i < aDiagElements.length; i++) {
                let element = aDiagElements[i];
                if (element.tagName == "CANVAS") {
                    let context = element.getContext("2d");
                    this.aDiagContexts.push(context);
                }
            }
        }
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * This is a notification issued by the Computer component, after all the other components (notably the CPU)
     * have had a chance to initialize.
     *
     * @this {Video}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        let video = this;

        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;

        let nRandomize = +cmp.getMachineParm('randomize');
        if (nRandomize >= 0 && nRandomize <= 1) this.nRandomize = nRandomize;

        /*
         * nCard will be undefined if no model was explicitly set (whereas this.nCard is ALWAYS defined).
         */
        let aModel = Video.MODEL[this.model], nCard = aModel && aModel[0];

        /*
         * The only time we do NOT want to trap MDA ports is when the model has been explicitly set to CGA.
         */
        if (nCard !== Video.CARD.CGA) {
            bus.addPortInputTable(this, Video.aMDAPortInput);
            bus.addPortOutputTable(this, Video.aMDAPortOutput);
        }

        /*
         * Similarly, the only time we do NOT want to trap CGA ports is when the model is explicitly set to MDA.
         */
        if (nCard !== Video.CARD.MDA) {
            bus.addPortInputTable(this, Video.aCGAPortInput);
            bus.addPortOutputTable(this, Video.aCGAPortOutput);
        }

        /*
         * Note that in the case of EGA and VGA models, the above code ensures that we will trap both MDA and CGA
         * port ranges -- which is good, because both the EGA and VGA can be reprogrammed to respond to those ports,
         * but also potentially bad if you want to simulate a "dual display" system, where one of the displays is
         * driven by either an MDA or CGA.
         *
         * However, you should still be able to make that work by loading the MDA or CGA video component first, because
         * components should be initialized in the order they appear in the machine configuration file.  Any attempt
         * by another component to trap the same ports should be ignored.
         */
        if (this.nCard >= Video.CARD.EGA) {
            bus.addPortInputTable(this, Video.aEGAPortInput);
            bus.addPortOutputTable(this, Video.aEGAPortOutput);
        }

        if (this.nCard == Video.CARD.VGA) {
            bus.addPortInputTable(this, Video.aVGAPortInput);
            bus.addPortOutputTable(this, Video.aVGAPortOutput);
        }

        if (DEBUGGER && dbg) {
            dbg.messageDump(Messages.VIDEO, function onDumpVideo(asArgs) {
                video.dumpVideo(asArgs);
            });
        }

        /*
         * If we have an associated keyboard, then ensure that the keyboard will be notified whenever the canvas
         * gets focus and receives input.
         */
        this.kbd = cmp.getMachineComponent("Keyboard");
        if (this.kbd && this.inputScreen) {
            this.kbd.setBinding(this.inputTextArea? "textarea" : "canvas", "screen", this.inputScreen);
        }

        this.panel = cmp.getMachineComponent("Panel");
        for (let i = 0; i < this.bindingsExternal.length; i++) {
            let binding = this.bindingsExternal[i];
            if (this.kbd && this.kbd.setBinding(...binding)) continue;
            if (this.panel && this.panel.setBinding(...binding)) continue;
        }

        this.bEGASwitches = 0x09;   // our default "switches" setting (see aEGAMonitorSwitches)
        this.chipset = cmp.getMachineComponent("ChipSet");
        if (this.chipset && this.sSwitches) {
            if (this.nCard == Video.CARD.EGA) {
                this.bEGASwitches = this.chipset.parseDIPSwitches(this.sSwitches, this.bEGASwitches);
            }
        }

        /*
         * The default value for the 'touchScreen' parameter is an empty string; machine configs must explicitly
         * select one of the following values, via the 'touchscreen' attribute in the <video> element, to enable any
         * touch-screen support.
         */
        if (this.sTouchScreen == "mouse") {
            this.mouse = cmp.getMachineComponent("Mouse");
            if (this.mouse) this.captureTouch(Video.TOUCH.MOUSE);
        }
        else if (this.sTouchScreen == "keygrid") {
            if (this.kbd) this.captureTouch(Video.TOUCH.KEYGRID);
        }

        /*
         * If no touch support was required or requested, we still want to do some minimal touch event processing;
         * eg, notifying the ChipSet component whenever a touchstart occurs, so that it can enable audio in response
         * to a user action on iOS devices.
         */
        if (!this.nTouchConfig) {
            this.captureTouch(Video.TOUCH.DEFAULT);
        }

        if (this.sFileURL) {
            let sProgress = "Loading " + this.sFileURL + "...";
            Web.getResource(this.sFileURL, null, true, function(sURL, sResponse, nErrorCode) {
                video.doneLoad(sURL, sResponse, nErrorCode);
            }, function(nState) {
                video.println(sProgress, Component.PRINT.PROGRESS);
            });
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {Video}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "refresh")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let video = this;

        if (!this.bindings[sBinding]) {

            /*
             * We now save every binding that comes in, so that if there are bindings for "caps-lock' and the like,
             * we can forward them to the Keyboard.  TODO: Perhaps we should limit this to sHTMLType == "led", and collect
             * them in a separate object (eg, ledBindings), so that initBus() can safely enumerate JUST the LEDs.  This
             * is what we do in PC8080.  Be aware that's there's also sHTMLType == "rled" now, too.
             */
            this.bindings[sBinding] = control;

            switch (sBinding) {

            case "fullScreen":
                if (this.container && this.container.doFullScreen) {
                    control.onclick = function onClickFullScreen() {
                        if (DEBUG) video.printMessage("fullScreen()");
                        video.goFullScreen();
                    };
                } else {
                    if (DEBUG) this.log("FullScreen API not available");
                    control.parentNode.removeChild(/** @type {Node} */ (control));
                }
                return true;

            case "lockPointer":
                this.sLockMessage = control.textContent;
                if (this.inputScreen && this.inputScreen.lockPointer) {
                    control.onclick = function onClickLockPointer() {
                        if (DEBUG) video.printMessage("lockPointer()");
                        video.lockPointer(true);
                    };
                } else {
                    if (DEBUG) this.log("Pointer Lock API not available");
                    control.parentNode.removeChild(/** @type {Node} */ (control));
                }
                return true;

            case "refresh":
                control.onclick = function onClickRefresh() {
                    if (DEBUG) video.printMessage("refreshScreen()");
                    video.updateScreen(true);
                };
                return true;

            default:
                this.bindingsExternal.push([sHTMLType, sBinding, control, sValue]);
                delete this.bindings[sBinding];
                break;
            }
        }
        return false;
    }

    /**
     * setFocus(fScroll)
     *
     * @this {Video}
     * @param {boolean} [fScroll]
     */
    setFocus(fScroll)
    {
        if (this.inputScreen) {
            this.inputScreen.focus();
            if (fScroll) {
                let element = document.getElementById(this.idMachine) || this.inputScreen;
                element.scrollIntoView();
            }
        }
    }

    /**
     * getScreen()
     *
     * This is an interface used by the Mouse component, so that it can capture mouse events from the screen.
     *
     * @this {Video}
     * @param {Mouse} [mouse]
     * @return {Object|undefined}
     */
    getScreen(mouse)
    {
        this.mouse = mouse;
        return this.inputScreen;
    }

    /**
     * getTextArea()
     *
     * This is an interface used by the Computer component, so that it can display resource status messages.
     *
     * @this {Video}
     * @return {HTMLTextAreaElement|undefined}
     */
    getTextArea()
    {
        return this.inputTextArea;
    }

    /**
     * goFullScreen()
     *
     * @this {Video}
     * @return {boolean} true if request successful, false if not (eg, failed OR not supported)
     */
    goFullScreen()
    {
        let fSuccess = false;
        if (this.container) {
            if (this.container.doFullScreen) {
                /*
                 * Styling the container with a width of "100%" and a height of "auto" works great when the aspect ratio
                 * of our virtual screen is at least roughly equivalent to the physical screen's aspect ratio, but now that
                 * we support virtual VGA screens with an aspect ratio of 1.33, that's very much out of step with modern
                 * wide-screen monitors, which usually have an aspect ratio of 1.6 or greater.
                 *
                 * And unfortunately, none of the browsers I've tested appear to make any attempt to scale our container to
                 * the physical screen's dimensions, so the bottom of our screen gets clipped.  To prevent that, I reduce
                 * the width from 100% to whatever percentage will accommodate the entire height of the virtual screen.
                 *
                 * NOTE: Mozilla recommends both a width and a height of "100%", but all my tests suggest that using "auto"
                 * for height works equally well, so I'm sticking with it, because "auto" is also consistent with how I've
                 * implemented a responsive canvas when the browser window is being resized.
                 */
                let sWidth = "100%";
                let sHeight = "auto";
                if (screen && screen.width && screen.height) {
                    let aspectPhys = screen.width / screen.height;
                    let aspectVirt = this.cxScreen / this.cyScreen;
                    if (aspectPhys > aspectVirt) {
                        sWidth = Math.round(aspectVirt / aspectPhys * 100) + '%';
                    }
                    // TODO: We may need to someday consider the case of a physical screen with an aspect ratio < 1.0....
                }
                if (!this.fGecko) {
                    this.container.style.width = sWidth;
                    this.container.style.height = sHeight;
                } else {
                    /*
                     * Sadly, the above code doesn't work for Firefox, because as:
                     *
                     *      http://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode
                     *
                     * explains:
                     *
                     *      'It's worth noting a key difference here between the Gecko and WebKit implementations at this time:
                     *      Gecko automatically adds CSS rules to the element to stretch it to fill the screen: "width: 100%; height: 100%".
                     *
                     * Which would be OK if Gecko did that BEFORE we're called, but apparently it does that AFTER, effectively
                     * overwriting our careful calculations.  So we style the inner element (canvasScreen) instead, which
                     * requires even more work to ensure that the canvas is properly centered.  FYI, this solution is consistent
                     * with Mozilla's recommendation for working around their automatic CSS rules:
                     *
                     *      '[I]f you're trying to emulate WebKit's behavior on Gecko, you need to place the element you want
                     *      to present inside another element, which you'll make fullscreen instead, and use CSS rules to adjust
                     *      the inner element to match the appearance you want.'
                     */
                    this.canvasScreen.style.width = sWidth;
                    this.canvasScreen.style.width = sWidth;
                    this.canvasScreen.style.display = "block";
                    this.canvasScreen.style.margin = "auto";
                }
                this.container.style.backgroundColor = this.colorScreen;
                this.container.doFullScreen();
                fSuccess = true;
            }
            this.setFocus();
        }
        return fSuccess;
    }

    /**
     * notifyFullScreen(fFullScreen)
     *
     * @this {Video}
     * @param {boolean} [fFullScreen] (undefined if there was a full-screen error)
     */
    notifyFullScreen(fFullScreen)
    {
        if (!fFullScreen && this.container) {
            if (!this.fGecko) {
                this.container.style.width = this.container.style.height = "";
            } else {
                this.canvasScreen.style.width = this.canvasScreen.style.height = "";
            }
        }
        if (DEBUG) this.printMessage("notifyFullScreen(" + fFullScreen + ")", true);
        if (this.kbd) this.kbd.notifyEscape(fFullScreen == true);
    }

    /**
     * lockPointer()
     *
     * @this {Video}
     * @param {boolean} fLock
     * @return {boolean} true if request successful, false if not (eg, failed OR not supported)
     */
    lockPointer(fLock)
    {
        let fSuccess = false;
        if (this.inputScreen && this.mouse) {
            if (fLock) {
                if (this.inputScreen.lockPointer) {
                    this.inputScreen.lockPointer();
                    this.mouse.notifyPointerLocked(true);
                    fSuccess = true;
                }
            } else {
                if (this.inputScreen.unlockPointer) {
                    this.inputScreen.unlockPointer();
                    this.mouse.notifyPointerLocked(false);
                    fSuccess = true;
                }
            }
            this.setFocus();
        }
        return fSuccess;
    }

    /**
     * notifyPointerActive(fActive)
     *
     * @this {Video}
     * @param {boolean} fActive
     * @return {boolean} true if autolock enabled AND pointer lock supported, false if not
     */
    notifyPointerActive(fActive)
    {
        if (this.fAutoLock) {
            return this.lockPointer(fActive);
        }
        return false;
    }

    /**
     * notifyPointerLocked(fLocked)
     *
     * @this {Video}
     * @param {boolean} fLocked
     */
    notifyPointerLocked(fLocked)
    {
        if (this.mouse) {
            this.mouse.notifyPointerLocked(fLocked);
            if (this.kbd) this.kbd.notifyEscape(fLocked);
        }
        let control = this.bindings["lockPointer"];
        if (control) control.textContent = (fLocked? "Press Esc to Unlock Pointer" : this.sLockMessage);
    }

    /**
     * captureTouch(nTouchConfig)
     *
     * @this {Video}
     * @param {number} nTouchConfig (must be one of the supported Video.TOUCH values)
     */
    captureTouch(nTouchConfig)
    {
        let control = this.inputScreen;
        if (control) {
            let video = this;
            if (!this.nTouchConfig) {

                this.nTouchConfig = nTouchConfig;

                let addPassive = false;
                if (nTouchConfig != Video.TOUCH.MOUSE) {
                    /*
                     * If we're not capturing touch events for mouse event simulation, then we won't be calling
                     * preventDefault(), which means we should tell Chrome and any other browser that supports
                     * passive event listeners that we're installing a "passive" event listener, so that the browser
                     * won't suspend us during `touchstart` and `touchmove` events.  But in order to know whether
                     * the browser supports that feature, we have to probe for it first.
                     */
                    try {
                        let opts = Object.defineProperty({}, 'passive', {
                            get: function() {
                                addPassive = true;
                            }
                        });
                        window.addEventListener("testPassive", null, opts);
                        window.removeEventListener("testPassive", null, opts);
                    } catch (e) {
                    }
                }

                control.addEventListener(
                    'touchstart',
                    function onTouchStart(event) {
                        video.onTouchStart(event);
                    },
                    addPassive? {passive: true} : false
                );

                if (nTouchConfig == Video.TOUCH.DEFAULT) {
                    return;
                }

                control.addEventListener(
                    'touchmove',
                    function onTouchMove(event) {
                        video.onTouchMove(event);
                    },
                    addPassive? {passive: true} : true
                );

                control.addEventListener(
                    'touchend',
                    function onTouchEnd(event) {
                        video.onTouchEnd(event);
                    },
                    false                   // we'll specify false for the 'useCapture' parameter for now...
                );

                /*
                 * Using desktop mouse events to simulate touch events should only be enabled as needed.
                 */
                if (MAXDEBUG) {
                    control.addEventListener(
                        'mousedown',
                        function onMouseDown(event) {
                            video.onTouchStart(event);
                        },
                        false               // we'll specify false for the 'useCapture' parameter for now...
                    );
                    control.addEventListener(
                        'mousemove',
                        function onMouseMove(event) {
                            video.onTouchMove(event);
                        },
                        true
                    );
                    control.addEventListener(
                        'mouseup',
                        function onMouseUp(event) {
                            video.onTouchEnd(event);
                        },
                        false               // we'll specify false for the 'useCapture' parameter for now...
                    );
                }

                // this.log("touch events captured");

                this.xTouch = this.yTouch = this.timeTouch = -1;

                /*
                 * As long as fTouchDefault is false, we call preventDefault() on every touch event, to prevent
                 * the page from moving/scrolling while the canvas is processing touch events.  However, there must
                 * also be exceptions to permit the soft keyboard to activate; see processTouchEvent() for details.
                 */
                this.fTouchDefault = false;

                /*
                 * I also need to come up with some rules for when the simulated mouse's primary button stays down.
                 * Let's try setting a timeout handler whenever a touchstart is received, which we'll immediately cancel
                 * as soon as a touchmove or touchend event is received, and if the timeout handler fires, we'll set
                 * fLongTouch to true.
                 */
                this.hLongTouch = null;
                this.fLongTouch = false;
                this.onLongTouch = function onLongTouch() {
                    video.startLongTouch();
                };
            }
        }
    }

    /**
     * onFocusChange(fFocus)
     *
     * @this {Video}
     * @param {boolean} fFocus is true if gaining focus, false if losing it
     */
    onFocusChange(fFocus)
    {
        /*
         * As per http://stackoverflow.com/questions/6740253/disable-scrolling-when-changing-focus-form-elements-ipad-web-app,
         * I decided to try this work-around to prevent the webpage from scrolling around whenever the canvas is given
         * focus.  That sort of scrolling-into-view sounds great in principle, but in practice, if you were reading some other
         * portion of the page, it can be irritating to be scrolled away from that portion when refreshing/returning to the page.
         *
         * However, this work-around doesn't seem to work with the latest version of Safari (or else I misunderstood something).
         *
         *  if (fFocus) {
         *      window.scrollTo(0, 0);
         *      document.body.scrollTop = 0;
         *  }
         */
        this.fHasFocus = fFocus;
        if (this.kbd) this.kbd.onFocusChange(fFocus);
    }

    /**
     * onTouchStart(event)
     *
     * @this {Video}
     * @param {Event} event object from a 'touch' event
     */
    onTouchStart(event)
    {
        if (DEBUG) this.printMessage("onTouchStart()");
        this.chipset.startAudio(event);
        if (this.nTouchConfig == Video.TOUCH.DEFAULT) return;
        this.processTouchEvent(event, true);
    }

    /**
     * onTouchMove(event)
     *
     * @this {Video}
     * @param {Event} event object from a 'touch' event
     */
    onTouchMove(event)
    {
        if (DEBUG) this.printMessage("onTouchMove()");
        this.processTouchEvent(event);
    }

    /**
     * onTouchEnd(event)
     *
     * @this {Video}
     * @param {Event} event object from a 'touch' event
     */
    onTouchEnd(event)
    {
        if (DEBUG) this.printMessage("onTouchEnd()");
        this.processTouchEvent(event, false);
    }

    /**
     * processTouchEvent(event, fStart)
     *
     * If nTouchConfig is non-zero, touch event handlers are installed, which pass their events to this function.
     *
     * What we do with those events here depends on the value of nTouchConfig.  Originally, the only supported
     * configuration was the experimental conversion of touch events into arrow keys, based on an invisible grid
     * that divided the screen into thirds; that configuration is now identified as Video.TOUCH.KEYGRID.
     *
     * The new preferred configuration is Video.TOUCH.MOUSE, which does little more than allow you to "push" the
     * simulated mouse around.  If Video.TOUCH.MOUSE is enabled, it's already been confirmed the machine has a mouse.
     *
     * @this {Video}
     * @param {Event|MouseEvent|TouchEvent} event object from a 'touch' event
     * @param {boolean} [fStart] (true if 'touchstart', false if 'touchend', undefined if 'touchmove')
     */
    processTouchEvent(event, fStart)
    {
        let xTouch, yTouch;

        // if (!event) event = window.event;

        /*
         * Touch coordinates (that is, the pageX and pageY properties) are relative to the page, so to make
         * them relative to the canvas, we must subtract the canvas's left and top positions.  This Apple web page:
         *
         *      https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingMouseandTouchControlstoCanvas/AddingMouseandTouchControlstoCanvas.html
         *
         * makes it sound simple, but it turns out we have to walk the canvas' entire "parentage" of DOM elements
         * to get the exact offsets.
         *
         * TODO: Determine whether the getBoundingClientRect() code used in panel.js for mouse events can also
         * be used here to simplify this annoyingly complicated code for touch events.
         */
        let xTouchOffset = 0;
        let yTouchOffset = 0;
        let eCurrent = this.canvasScreen;

        do {
            if (!isNaN(eCurrent.offsetLeft)) {
                xTouchOffset += eCurrent.offsetLeft;
                yTouchOffset += eCurrent.offsetTop;
            }
        } while ((eCurrent = eCurrent.offsetParent));

        /*
         * Due to the responsive nature of our pages, the displayed size of the canvas may be smaller than the
         * allocated size, and the coordinates we receive from touch events are based on the currently displayed size.
         */
        let xScale = this.cxScreen / this.canvasScreen.offsetWidth;
        let yScale = this.cyScreen / this.canvasScreen.offsetHeight;

        /**
         * @name Event
         * @property {Array} targetTouches
         */
        if (!event.targetTouches || !event.targetTouches.length) {
            xTouch = event.pageX;
            yTouch = event.pageY;
        } else {
            xTouch = event.targetTouches[0].pageX;
            yTouch = event.targetTouches[0].pageY;
        }

        xTouch = ((xTouch - xTouchOffset) * xScale);
        yTouch = ((yTouch - yTouchOffset) * yScale);

        if (this.nTouchConfig == Video.TOUCH.KEYGRID) {

            /*
             * We don't want to simulate a key on EVERY touch event; preferably, only touchstart or touchend.  And
             * I probably would have preferred triggering key presses on touchend, so that if you decided to move
             * your finger off-screen before releasing, you could avoid a key press, but sadly (as I've documented in
             * the Mandelbot project; see https://github.com/jeffpar/mandelbot/blob/master/src/mandelbot.js),
             * touchend doesn't reliably provide coordinates on all platforms, so we're going to go with touchstart.
             */
            if (fStart) {

                let xThird = (xTouch / (this.cxScreen / 3)) | 0;
                let yThird = (yTouch / (this.cyScreen / 3)) | 0;

                /*
                 * At this point, xThird and yThird should both be one of 0, 1 or 2, indicating which horizontal and
                 * vertical third of the virtual screen the touch event occurred.
                 */
                this.kbd.addActiveKey(Video.KEYGRID[yThird][xThird], true);
            }
        } else {

            if (this.mouse) {
                /*
                 * As long as fTouchDefault is false, we call preventDefault() on every touch event, to keep
                 * the page stable.  However, we must allow some touch event(s) to perform their default action,
                 * otherwise the soft keyboard can never be activated.  So if a touchstart occurs at least 1/2
                 * second (500ms) after the last touchstart, with no intervening touchmove events, fTouchDefault
                 * is allowed to become true.
                 */
                let fTouchDefault = this.fTouchDefault;
                let timeDelta = event.timeStamp - this.timeTouch;

                if (fStart === true) {
                    this.fTouchDefault = (timeDelta > 500);
                    this.timeTouch = event.timeStamp;
                    this.hLongTouch = setTimeout(this.onLongTouch, 500);
                } else {
                    if (this.hLongTouch != null) {
                        clearTimeout(this.hLongTouch);
                        this.hLongTouch = null;
                    }
                }
                if (fStart === undefined) {
                    this.fTouchDefault = false;
                }

                if (DEBUG) {
                    this.log("processTouchEvent(" + (fStart? "touchStart" : (fStart === false? "touchEnd" : "touchMove")) + "," + timeDelta + "ms," + fTouchDefault + ")");
                }

                if (!fTouchDefault) {
                    event.preventDefault();
                }

                if (fStart === false) {
                    /*
                     * NOTE: 200ms is merely my initial stab at a reasonable number of milliseconds to interpret a
                     * start/end touch sequence as a "tap"; I also make no note of any intervening move events (ie,
                     * events where fStart is undefined), and perhaps I should....
                     */
                    if (this.endLongTouch()) {
                        return;
                    }
                    if (timeDelta < 200) {
                        this.mouse.clickMouse(Mouse.BUTTON.LEFT, true);
                        this.mouse.clickMouse(Mouse.BUTTON.LEFT, false);
                        return;
                    }
                }
                /*
                 * This 'touchmove" code mimics the 'mousemove' event processing in processMouseEvent() in mouse.js, with
                 * one important difference: every time touching "restarts", we need to reset the variables used to calculate
                 * the deltas, so that the mere act of lifting and replacing your finger doesn't generate a delta by itself.
                 */
                if (fStart || this.xTouch < 0 || this.yTouch < 0) {
                    this.xTouch = xTouch;
                    this.yTouch = yTouch;
                }
                let xDelta = Math.round(xTouch - this.xTouch);
                let yDelta = Math.round(yTouch - this.yTouch);
                this.xTouch = xTouch;
                this.yTouch = yTouch;
                // this.println("moveMouse(" + xDelta + "," + yDelta + ")");
                this.mouse.moveMouse(xDelta, yDelta, this.xTouch, this.yTouch);
            }
        }
    }

    /**
     * startLongTouch()
     *
     * @this {Video}
     */
    startLongTouch()
    {
        this.fLongTouch = true;
        this.mouse.clickMouse(Mouse.BUTTON.LEFT, true);
    }

    /**
     * endLongTouch()
     *
     * @this {Video}
     * @return {boolean} true if long touch was active, false if not
     */
    endLongTouch()
    {
        if (this.fLongTouch) {
            this.mouse.clickMouse(Mouse.BUTTON.LEFT, false);
            this.fLongTouch = false;
            return true;
        }
        return false;
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Video}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
            if (this.timerRetrace == undefined) {
                /*
                 * Note that startVerticalRetrace() will fire every nCyclesVertPeriod, ensuring predictability
                 * and repeatability regardless of the machine's current speed multiplier or the whether the machine
                 * is achieving the desired target number of cycles per second.
                 *
                 * The only downside is that when the machine is recalibrating (or the multiplier is being increased),
                 * we may be called more than 60Hz (msUpdateNormal or 16.667ms).  So we don't allow the next update
                 * until at least msUpdateInterval has passed.  msUpdateInterval is initialized to msUpdateNormal, but
                 * can be increased if the updates are taking too long (eg, too many on-screen changes).
                 */
                this.msUpdateNormal = (1000 / Video.UPDATES_PER_SECOND)|0;
                this.msUpdateInterval = this.msUpdateNormal;
                this.msUpdatePrev = this.cmsUpdate = 0;

                let video = this;
                this.timerRetrace = this.cpu.addTimer(this.id, function startVerticalRetrace() {
                    let card = video.cardActive;
                    card.nCyclesVertRetrace = video.cpu.getCycles();
                    if (video.messageEnabled(Messages.VIDEO | Messages.INT)) {
                        video.printf("vertical retrace timer fired (%d cycles)\n", card.nCyclesVertRetrace);
                    }
                    if (video.nIRQ) {
                        if (!(card.regCRTData[Card.CRTC.EGA.VREND.INDX] & Card.CRTC.EGA.VREND.DISABLE_VRINT)) {
                            if (video.chipset) video.chipset.setIRR(video.nIRQ);
                        }
                    }
                    /*
                     * For simplicity, let's imagine that the normal screen update interval is 15ms.  If retraces are
                     * happening a bit too fast (eg, every 10ms), we'll skip the update on the first retrace, do it on
                     * the second retrace, skip on the third, and so on.  That's clearly too many skips, so when we
                     * do the second retrace, we should "bank" the extra 5ms by rewinding msUpdatePrev that amount.
                     * Just make sure we never "bank" too much (for example, on the first update, when msUpdatePrev is
                     * zero).
                     */
                    let msUpdate = Date.now();
                    let msDelta = (msUpdate - video.msUpdatePrev) - video.msUpdateInterval;
                    if (msDelta >= 0) {
                        let fUpdated = video.updateScreen();
                        if (fUpdated) {
                            let cmsUpdate = Date.now() - msUpdate;
                            /*
                             * Make sure that the modulo number here is always a multiple of the blink modulo in
                             * updateScreen(), so that we don't create blink irregularity every time we reset our
                             * average update time (cmsUpdate).
                             */
                            if (video.cUpdates % 120 == 1) {
                                video.cUpdates = 1;
                                video.cmsUpdate = cmsUpdate;
                            } else {
                                video.cmsUpdate += cmsUpdate;
                                cmsUpdate = video.cmsUpdate / video.cUpdates;
                            }
                            /*
                             * If cmsUpdate is taking more than 25% of the update interval (eg, 4ms of a 16ms interval),
                             * then we want to increase the interval, so that updates are a smaller percentage of the overall
                             * workload.
                             */
                            if (cmsUpdate >= video.msUpdateInterval / 4) {
                                video.msUpdateInterval = video.msUpdateNormal * 2;
                            }
                            else if (cmsUpdate < video.msUpdateNormal / 4) {
                                video.msUpdateInterval = video.msUpdateNormal;
                            }
                        }
                        video.msUpdatePrev = msUpdate - (msDelta >= video.msUpdateInterval? 0 : msDelta);
                    }
                    else if (video.messageEnabled(Messages.VIDEO | Messages.INT)) {
                        video.printf("skipping update (%dms too soon)\n", -msDelta);
                    }
                    video.latchStartAddress();
                }, -this.cardActive.nCyclesVertPeriod);
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * This is where we might add some method of blanking the display, without the disturbing the video
     * buffer contents, and blocking all further updates to the display.
     *
     * @this {Video}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {Video}
     */
    reset()
    {
        let nMonitorType = ChipSet.MONITOR.NONE;

        /*
         * We'll ask the ChipSet what SW1 indicates for monitor type, but we may override it if a specific
         * video card model is set.  For EGA, SW1 is supposed to be set to indicate NO monitor, and we rely
         * on the EGA's own switch settings instead.
         */
        if (this.chipset) {
            nMonitorType = this.chipset.getDIPVideoMonitor();
        }

        /*
         * As we noted in the constructor, when a model is specified, that takes precedence over any monitor
         * switch settings.  Conversely, when no model is specified, the nCard setting is considered provisional,
         * so the monitor switch settings, if any, are allowed to determine the card type.
         */
        if (!this.model) {
            this.nCard = (nMonitorType == ChipSet.MONITOR.MONO? Video.CARD.MDA : Video.CARD.CGA);
        }

        this.nModeDefault = Video.MODE.CGA_80X25;

        switch (this.nCard) {
        case Video.CARD.VGA:
            nMonitorType = ChipSet.MONITOR.VGACOLOR;
            break;

        case Video.CARD.EGA:
            let aMonitors = Video.aEGAMonitorSwitches[this.bEGASwitches];
            /*
             * TODO: Figure out how to deal with aMonitors[2], the boolean which indicates
             * whether the EGA is driving the primary monitor (true) or the secondary monitor (false).
             */
            if (aMonitors) nMonitorType = aMonitors[0];
            if (!nMonitorType) {
                nMonitorType = ChipSet.MONITOR.EGACOLOR;
                break;
            }
            if (nMonitorType != ChipSet.MONITOR.MONO) break;
            /* falls through */

        case Video.CARD.MDA:
            nMonitorType = ChipSet.MONITOR.MONO;
            this.nModeDefault = Video.MODE.MDA_80X25;
            break;

        case Video.CARD.CGA:
            /* falls through */

        default:
            nMonitorType = ChipSet.MONITOR.COLOR;
            break;
        }

        if (this.nMonitorType !== nMonitorType) {
            this.nMonitorType = nMonitorType;
        }

        this.cardActive = null;
        this.cardMono = this.cardMDA = new Card(this, Video.CARD.MDA);
        this.cardColor = this.cardCGA = new Card(this, Video.CARD.CGA);

        if (this.nCard < Video.CARD.EGA) {
            this.cardEGA = new Card();      // define a dummy (uninitialized) EGA card for now
        }
        else {
            this.cardEGA = new Card(this, this.nCard, null, this.cbMemory);
            this.enableEGA();
        }

        this.nMode = null;
        this.setMode(this.nModeDefault);

        if (this.cardActive.addrBuffer && this.nRandomize) {
            /*
             * On the initial power-on, we initialize the video buffer to random characters, as a way of testing
             * whether our font(s) were successfully loaded.  It's assumed that our default display mode is a text mode,
             * and that since this is a reset, the CRTC.START_ADDR registers are zero as well.
             *
             * If this is an MDA device, then the buffer should reside at 0xB0000 through 0xB0FFF, for a total length
             * of 4Kb (0x1000), where every even byte contains a character code, and every odd byte contains an attribute
             * code.  See the ATTR bit definitions above for applicable color, intensity, and blink values.  On a CGA
             * device, the buffer resides at 0xB8000 through 0xBBFFF, for a total length of 16Kb.
             *
             * Note that the only valid MDA display mode (7) is the 80x25 text mode, which uses 4000 bytes (2000 character
             * bytes + 2000 attribute bytes), not all 4096 bytes; addrScreenLimit reflects the visible limit, not the
             * physical limit.  Also, as noted in updateScreen(), this simplistic calculation of the extent of visible
             * screen memory is valid only for text modes; in general, it's safer to use cardActive.sizeBuffer as the extent.
             */
            let addrScreenLimit = this.cardActive.addrBuffer + this.cbScreen;
            for (let addrScreen = this.cardActive.addrBuffer; addrScreen < addrScreenLimit; addrScreen += 2) {
                let dataRandom = (Math.random() * 0x10000) | 0;
                let bChar, bAttr;
                if (this.nMonitorType == ChipSet.MONITOR.EGACOLOR || this.nMonitorType == ChipSet.MONITOR.VGACOLOR) {
                    /*
                     * For the EGA, we choose sequential characters; for random characters, copy the MDA/CGA code below.
                     */
                    bChar = (addrScreen >> 1) & 0xff;
                    bAttr = (dataRandom >> 8) & ~Video.ATTRS.BGND_BLINK;    // TODO: turn blink attributes off unless we can ensure blinking is initially disabled
                    if ((bAttr >> 4) == (bAttr & 0xf)) {
                        bAttr ^= 0x0f;      // if background matches foreground, invert foreground to ensure character visibility
                    }
                } else {
                    bChar = dataRandom & 0xff;
                    bAttr = ((dataRandom & 0x100)?
                        (Video.ATTRS.FGND_WHITE | Video.ATTRS.BGND_BLACK) :
                        (Video.ATTRS.FGND_BLACK | Video.ATTRS.BGND_WHITE)) | ((Video.ATTRS.FGND_BRIGHT /* | Video.ATTRS.BGND_BLINK */) & (dataRandom >> 8));
                }
                this.bus.setShortDirect(addrScreen, bChar | (bAttr << 8));
            }
            this.updateScreen(true);
        }
    }

    /**
     * enableEGA()
     *
     * Redirect cardMono or cardColor to cardEGA as appropriate.
     *
     * @this {Video}
     */
    enableEGA()
    {
        if (!(this.cardEGA.regMisc & Card.MISC.IO_SELECT)) {
            this.cardMono = this.cardEGA;
            this.cardColor = this.cardCGA;  // this is done mainly to siphon away any CGA I/O
        } else {
            this.cardMono = this.cardMDA;   // similarly, this is done to siphon away any MDA I/O
            this.cardColor = this.cardEGA;
        }
    }

    /**
     * save()
     *
     * This implements save support for the Video component.
     *
     * @this {Video}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.cardMDA.saveCard());
        state.set(1, this.cardCGA.saveCard());
        state.set(2, [this.nMonitorType, this.nModeDefault, this.nMode]);
        state.set(3, this.cardEGA.saveCard());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the Video component.
     *
     * @this {Video}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        let a = data[2];
        this.nMonitorType = a[0];
        this.nModeDefault = a[1];
        this.nMode = a[2];

        this.cardActive = null;
        this.cardMono = this.cardMDA = new Card(this, Video.CARD.MDA, data[0]);
        this.cardColor = this.cardCGA = new Card(this, Video.CARD.CGA, data[1]);

        /*
         * If no EGA was originally initialized, then cardEGA will remain uninitialized.
         */
        this.cardEGA = new Card(this, this.nCard, data[3], this.cbMemory);
        if (this.cardEGA.fActive) this.enableEGA();

        /*
         * While I could restore the active card here, it's better for setMode() to do it, because
         * setMode() will also take care of mapping the appropriate video buffer.  So, after restore() has
         * finished, we call checkMode(), because the current video mode (nMode) is determined by the
         * active card state.
         *
         * Unfortunately, that creates a chicken-and-egg problem, since I just said I didn't want to select
         * the active card here.
         *
         * So, we'll add some "cop-out" code to checkMode(): if there's no active card, then fall-back
         * to the last known video mode (nMode) and force a call to setMode().
         *
         *      this.cardActive = (this.cardMDA.fActive? this.cardMDA : (this.cardCGA.fActive? this.cardCGA : undefined));
         */
        if (!this.checkMode()) return false;

        this.checkCursor();
        return true;
    }

    /**
     * doneLoad(sURL, sFontData, nErrorCode)
     *
     * @this {Video}
     * @param {string} sURL
     * @param {string} sFontData
     * @param {number} nErrorCode (response from server if anything other than 200)
     */
    doneLoad(sURL, sFontData, nErrorCode)
    {
        if (nErrorCode) {
            this.notice("Unable to load font ROM (error " + nErrorCode + ": " + sURL + ")", nErrorCode < 0);
            return;
        }

        Component.addMachineResource(this.idMachine, sURL, sFontData);

        try {
            /*
             * The most likely source of any exception will be right here, where we're parsing the JSON-encoded data.
             */
            let abFontData = eval("(" + sFontData + ")");

            let ab = /** @type {Array} */ (abFontData['bytes'] || abFontData);

            if (!ab.length) {
                Component.error("Empty font ROM: " + sURL);
                return;
            }
            else if (ab.length == 1) {
                Component.error(ab[0]);
                return;
            }
            /*
             * Translate the character data into separate "fonts", each of which will be a separate canvas object, with all
             * 256 characters arranged in a 16x16 grid.
             */
            if (ab.length == 8192) {
                /*
                 * The assumption here is that we're dealing with the original (IBM) MDA/CGA font data, which apparently
                 * was identical on both MDA and CGA cards (even though the former had no use for the latter, and vice versa).
                 *
                 * First, let's take a look at the MDA portion of the data.  Here are the first few rows of MDA font data,
                 * at the 0K and 2K boundaries:
                 *
                 *      00000000  00 00 00 00 00 00 00 00  00 00 7e 81 a5 81 81 bd  |..........~.....|
                 *      00000010  00 00 7e ff db ff ff c3  00 00 00 36 7f 7f 7f 7f  |..~........6....|
                 *      ...
                 *      00000800  00 00 00 00 00 00 00 00  99 81 7e 00 00 00 00 00  |..........~.....|
                 *      00000810  e7 ff 7e 00 00 00 00 00  3e 1c 08 00 00 00 00 00  |..~.....>.......|
                 *
                 * 8 bytes of data from a row in each of the 2K chunks are combined to form a 8-bit wide character with
                 * a maximum height of 16 bits.  Assembling the bits for character 0x01 (a happy face), we observe the following:
                 *
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x0008
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x0009
                 *      0 1 1 1 1 1 1 0  <== 7e from offset 0x000A
                 *      1 0 0 0 0 0 0 1  <== 81 from offset 0x000B
                 *      1 0 1 0 0 1 0 1  <== a5 from offset 0x000C
                 *      1 0 0 0 0 0 0 1  <== 81 from offset 0x000D
                 *      1 0 0 0 0 0 0 1  <== 81 from offset 0x000E
                 *      1 0 1 1 1 1 0 1  <== bd from offset 0x000F
                 *      1 0 0 1 1 0 0 1  <== 99 from offset 0x0808
                 *      1 0 0 0 0 0 0 1  <== 81 from offset 0x0809
                 *      0 1 1 1 1 1 1 0  <== 7e from offset 0x080A
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080B
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080C
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080D
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080E
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080F
                 *
                 * In the second 2K chunk, we observe that the last two bytes of every font cell definition are zero;
                 * this confirms our understanding that MDA font cell size is 8x14.
                 *
                 * Finally, there's the issue of screen cell size, which is actually 9x14 on the MDA.  We compensate for that
                 * by building a 9x14 font, even though there's only 8x14 bits of data. As http://www.seasip.info/VintagePC/mda.html
                 * explains:
                 *
                 *      "For characters C0h-DFh, the ninth pixel column is a duplicate of the eighth; for others, it's blank."
                 *
                 * This last point is confirmed by "The IBM Personal Computer From The Inside Out", p.295:
                 *
                 *      "Another unique feature of the monochrome adapter is a set of line-drawing and area-fill characters
                 *      that give continuous lines and filled areas. This is unusual for a display with a 9x14 character box
                 *      because the character generator provides a row only eight dots wide. On most displays, a blank 9th
                 *      dot is then inserted between characters. On the monochrome display, there is circuitry that duplicates
                 *      the 8th dot into the 9th dot position for characters whose ASCII codes are 0xB0 [sic] through 0xDF."
                 *
                 * However, the above text is mistaken about the start of the range.  While there ARE line-drawing characters
                 * in the range 0xB0-0xBF, none of them extend all the way to the right edge; IBM carefully segregated them.
                 * And in fact, characters 0xB0-0xB2 contain hash patterns that you would NOT want extended into the 9th column.
                 *
                 * The CGA font is part of the same ROM.  In fact, there are TWO CGA fonts in the ROM: a thin 5x7 "single dot"
                 * font located at offset 0x1000, and a thick 7x7 "double dot" font at offset 0x1800.  The latter is the default
                 * font, unless overridden by a jumper setting on the CGA card, so it is our default CGA font as well (although
                 * someday we may provide a virtual jumper setting that allows you to select the thinner font).
                 *
                 * The first offset we must pass to setFontData() is the offset of the CGA font; we choose the thicker "double dot"
                 * CGA font at 0x1800 (which was the PC's default font as well), instead of the thinner "single dot" font at 0x1000.
                 * The second offset is for the MDA font.
                 */
                this.setFontData(ab, [0x1800, 0x0000]);
            }
            else if (ab.length == 2048) {
                /*
                 * The assumption here is that we're dealing strictly with CGA (8x8) font data, like the font data found
                 * in the Columbia Data Products (CDP) Font ROM.
                 */
                this.setFontData(ab, [0x0000]);
            }
            else {
                this.notice("Unrecognized font data length (" + ab.length + ")");
                return;
            }

        } catch (e) {
            this.notice("Font ROM data error: " + e.message);
            return;
        }
        /*
         * If we're still here, then we're ready!
         *
         * UPDATE: Per issue #21, I'm issuing setReady() *only* if a valid contextScreen exists *or* a Debugger is attached.
         *
         * TODO: Consider a more general-purpose solution for deciding whether or not the user wants to run in a "headless" mode.
         */
        if (this.contextScreen || this.dbg) this.setReady();
    }

    /**
     * onROMLoad(abRom, aParms)
     *
     * Called by the ROM's copyROM() function whenever a ROM component with a 'notify' attribute containing
     * our component ID has been loaded.
     *
     * @this {Video}
     * @param {Array.<number>} abROM
     * @param {Array.<number>} [aParms]
     */
    onROMLoad(abROM, aParms)
    {
        if (this.nCard == Video.CARD.EGA) {
            /*
             * TODO: Unlike the MDA/CGA font data, we may want to hang onto this data, so that we can
             * regenerate the color font(s) whenever the foreground and/or background colors have changed.
             */
            if (DEBUG) this.printMessage("onROMLoad(): EGA fonts loaded");
            /*
             * For EGA cards, in the absence of any parameters, we assume that we're receiving the original
             * IBM EGA ROM, which stores its 8x14 font data at 0x2230 as one continuous sequence; the total size
             * of the 8x14 font is 0xE00 bytes.
             *
             * At 0x3030, there is an "ALPHA SUPPLEMENT" table, which contains 15 bytes per row instead of 14,
             * because each row is preceded by one byte containing the corresponding ASCII code; there are 20
             * entries in the supplemental table, for a total size of 0x12C bytes.
             *
             * Finally, at 0x3160, we have the 8x8 font data (also known as the thicker "double dot" CGA font);
             * the total size of the 8x8 font is 0x800 bytes.  No other font data is present in the EGA ROM;
             * the thin 5x7 "single dot" CGA font is notably absent, which is fine, because we never loaded it for
             * the MDA/CGA either.
             *
             * TODO: Determine how the supplemental table is used and whether we need to add some "run-time"
             * font generation to support it (as opposed to "init-time" generation, which is all we do now).
             * There's probably a similar need for user-defined fonts; for now, they're simply not supported.
             */
            this.setFontData(abROM, aParms || [0x3160, 0x2230], 8);
        }
        else if (this.nCard == Video.CARD.VGA) {
            if (DEBUG) this.printMessage("onROMLoad(): VGA fonts loaded");
            /*
             * For VGA cards, in the absence of any parameters, we assume that we're receiving the original
             * IBM VGA ROM, which contains an 8x14 font at 0x3F8D (and corresponding supplemental table at 0x4D8D)
             * and an 8x8 font at 0x378D; however, it also contains an 8x16 font at 0x4EBA (and corresponding
             * supplemental table at 0x5EBA).  See our reconstructed source code in ibm-vga.nasm.
             */
            this.setFontData(abROM, aParms || [0x378d, 0x3f8d], 8);
        }
        this.setReady();
    }

    /**
     * setFontData(abFontData, aFontOffsets, cxFontChar)
     *
     * To support partial font rebuilds (required for the EGA), we now preserve the original font data (abFontData),
     * font offsets (aFontOffsets), and font character width (8 for the EGA, undefined for the MDA/CGA).
     *
     * TODO: Ultimately, we want to have exactly one dedicated font for the EGA, the data for which we'll read directly
     * from plane 2 of video memory, instead of relying on the original font data in ROM.  Relying on the ROM data was
     * originally just a crutch to help get EGA support bootstrapped.
     *
     * Also, for the MDA/CGA, we should be discarding the font data after the first buildFont() call, because we
     * should never need to rebuild the fonts for those cards (both their font patterns and colors were hard-coded).
     *
     * @this {Video}
     * @param {Array.<number>} abFontData is the raw font data, from the ROM font file
     * @param {Array.<number>} aFontOffsets contains offsets into abFontData: [0] for CGA, [1] for MDA
     * @param {number} [cxFontChar] is a fixed character width to use for all fonts; undefined to use MDA/CGA defaults
     */
    setFontData(abFontData, aFontOffsets, cxFontChar)
    {
        this.abFontData = abFontData;
        this.aFontOffsets = aFontOffsets;
        this.cxFontChar = cxFontChar;
    }

    /**
     * getCardColors(nBitsPerPixel)
     *
     * @this {Video}
     * @param {number} [nBitsPerPixel]
     * @return {Array}
     */
    getCardColors(nBitsPerPixel)
    {
        if (nBitsPerPixel == 1) {
            /*
             * Only 2 total colors.
             */
            this.aRGB[0] = Video.aCGAColors[Video.ATTRS.FGND_BLACK];
            this.aRGB[1] = Video.aCGAColors[Video.ATTRS.FGND_WHITE];
            return this.aRGB;
        }

        if (nBitsPerPixel == 2) {
            /*
             * Of the 4 colors returned, the first color comes from regColor and the other 3 come from one of
             * the two hard-coded CGA color sets:
             *
             *      Color Set 0             Color Set 1
             *      -----------------       -----------------
             *      Background (0x00)       Background (0x00)
             *      Green      (0x02)       Cyan       (0x03)
             *      Red        (0x04)       Magenta    (0x05)
             *      Brown      (0x06)       White      (0x07)
             *
             * The numbers in parentheses are the EGA ATC palette register values that the EGA BIOS uses for each
             * color set; I rely on those numbers to synthesize a fake CGA regColor value.
             */
            let regColor = this.cardActive.regColor;
            if (this.cardActive === this.cardEGA) {
                let bBackground = this.cardEGA.regATCData[0];
                regColor = bBackground & Card.CGA.COLOR.BORDER;
                if (bBackground & Card.ATC.PALETTE.BRIGHT) regColor |= Card.CGA.COLOR.BRIGHT;
                if ((this.cardEGA.regATCData[1] & 0x0f) == 0x03) regColor |= Card.CGA.COLOR.COLORSET1;
            }
            this.aRGB[0] = Video.aCGAColors[regColor & (Card.CGA.COLOR.BORDER | Card.CGA.COLOR.BRIGHT)];
            let aColorSet = (regColor & Card.CGA.COLOR.COLORSET1)? Video.aCGAColorSet1 : Video.aCGAColorSet0;
            for (let iColor = 0; iColor < aColorSet.length; iColor++) {
                this.aRGB[iColor + 1] = Video.aCGAColors[aColorSet[iColor]];
            }
            return this.aRGB;
        }

        if (this.cardColor === this.cardCGA) {
            /*
             * There's no need to update this.aRGB if we simply want to return a hard-coded set of 16 colors.
             */
            return Video.aCGAColors;
        }



        if (this.fRGBValid && nBitsPerPixel && !this.aRGB[16]) {
            this.fRGBValid = false;
        }

        if (!this.fRGBValid) {

            let card = this.cardEGA;
            let aDAC = card.regDACData;
            let aRegs, i, dw, b, bRed, bGreen, bBlue;

            if (nBitsPerPixel == 8) {
                /*
                 * The card must be a VGA, and it's using an (8bpp) mode that bypasses the ATC, so we need to pull
                 * RGB data exclusively from the 256-entry DAC; each entry contains 6-bit red, green, and blue values
                 * packed into bits 0-5, 6-11, and 12-17, respectively, each of which we effectively shift left 2 bits:
                 * a crude 6-to-8-bit color conversion.
                 */
                for (i = 0; i < 256; i++) {
                    dw = aDAC[i] || 0;

                    bRed = (dw << 2) & 0xfc;
                    bGreen = (dw >> 4) & 0xfc;
                    bBlue = (dw >> 10) & 0xfc;
                    this.aRGB[i] = [bRed, bGreen, bBlue, 0xff];
                }
            } else {
                /*
                 * We need to pull RGB data from the ATC; moreover, if the ATC hasn't been initialized yet,
                 * we go with a default EGA-compatible 16-color palette.  We'll also use the DAC if there is one
                 * (ie, this is actually a VGA) and it appears to be initialized (ie, the VGA BIOS has been run).
                 */
                let fDAC = (aDAC && aDAC[255] != null);
                aRegs = (card.regATCData[15] != null? card.regATCData : Video.aEGAPalDef);
                for (i = 0; i < 16; i++) {
                    b = aRegs[i] & Card.ATC.PALETTE.MASK;
                    /*
                     * If the DAC is valid, we need to supplement the 6 bits of each ATC palette entry with the values
                     * for bits 6 and 7 from the ATC COLORSEL register (and overwrite bits 4 and 5 if ATC.MODE.COLORSEL_ALL
                     * is set as well).
                     *
                     * The only reasons the DAC wouldn't be valid are if 1) we're trying to display an image before the machine
                     * and its BIOS have had a chance to initialize the DAC (because we don't preset it to anything, although
                     * perhaps we should), or 2) this is an EGA, which doesn't have a DAC.
                     */
                    if (fDAC) {
                        b |= (card.regATCData[Card.ATC.COLORSEL.INDX] & (Card.ATC.COLORSEL.DAC_BIT7 | Card.ATC.COLORSEL.DAC_BIT6)) << 4;
                        if (card.regATCData[Card.ATC.MODE.INDX] & Card.ATC.MODE.COLORSEL_ALL) {
                            b &= ~0x30;
                            b |= (card.regATCData[Card.ATC.COLORSEL.INDX] & (Card.ATC.COLORSEL.DAC_BIT5 | Card.ATC.COLORSEL.DAC_BIT4)) << 4;
                        }

                        dw = aDAC[b];

                        bRed = (dw << 2) & 0xfc;
                        bGreen = (dw >> 4) & 0xfc;
                        bBlue = (dw >> 10) & 0xfc;
                    } else {
                        bRed = (((b & 0x04)? 0xaa : 0) | ((b & 0x20)? 0x55 : 0));
                        bGreen = (((b & 0x02)? 0xaa : 0) | ((b & 0x10)? 0x55 : 0));
                        bBlue = (((b & 0x01)? 0xaa : 0) | ((b & 0x08)? 0x55 : 0));
                    }
                    this.aRGB[i] = [bRed, bGreen, bBlue, 0xff];
                }
            }
            this.fRGBValid = true;
        }

        return this.aRGB;
    }

    /**
     * getSelectedFonts()
     *
     * @this {Video}
     * @return {number} (low byte is "SELB" font number, used when attribute bit 3 is 0; high byte is "SELA" font number)
     */
    getSelectedFonts()
    {
        let bSelect = this.cardEGA.regSEQData[Card.SEQ.CHARMAP.INDX];
        if (this.nCard < Video.CARD.VGA) {
            bSelect &= (Card.SEQ.CHARMAP.SELA | Card.SEQ.CHARMAP.SELB);
        }
        if (!(this.cardEGA.regSEQData[Card.SEQ.MEMMODE.INDX] & Card.SEQ.MEMMODE.EXT)) {
            bSelect &= ~(Card.SEQ.CHARMAP.SELA | Card.SEQ.CHARMAP.SELB);
        }
        let nFontSelect0 = (bSelect & Card.SEQ.CHARMAP.SELB) | ((bSelect & Card.SEQ.CHARMAP.SELB_HI) >> 2);
        let nFontSelect1 = ((bSelect & Card.SEQ.CHARMAP.SELA) >> 2) | ((bSelect & Card.SEQ.CHARMAP.SELA_HI) >> 3);
        return nFontSelect0 | (nFontSelect1 << 8);
    }

    /**
     * buildFont(fRebuild)
     *
     * buildFont() is called whenever the Video component is reset or restored; we used to build fonts as soon as
     * the ROM containing them was loaded, and then throw away the underlying font data, but with the EGA's ability
     * to change the color or content of any font, font building must now be deferred until the reset or restore
     * notifications, ensuring we have access to the card's colors and other programmed state.
     *
     * We're also called whenever setDimensions() must update character cell dimensions and whenever EGA palette
     * registers are modified, in case one or more font colors changed.
     *
     * Calls to buildFont() should not be expensive though: the underlying createFont() function rebuilds a font only
     * if one or more of the following is true:
     *
     *  1) the font shape has changed (usually accompanied by a font data change)
     *  2) the font colors have changed (only affected colors are rebuilt, if there are no other changes)
     *  3) the font data has changed (EGA and VGA only, based on plane 2 changes recorded in bitsDirtyBanks)
     *
     * @this {Video}
     * @param {boolean} [fRebuild] (true if this is a rebuild; default is false)
     * @return {boolean}
     */
    buildFont(fRebuild = false)
    {
        let fChanges = false;
        this.nActiveFont = this.nAlternateFont = this.nCardFont;

        /*
         * There's no point building fonts unless we're in a windowed (non-command-line) environment, we're
         * in a font-based mode (nCardFont is set), and font data has been supplied (or can be extracted from RAM).
         */
        if (window && this.nCardFont) {

            /*
             * Build whatever font(s) we need for the current card.  In the case of the EGA/VGA, that can mean up to
             * 4 fonts, if all four font "banks" in plane 2 have been loaded with font data, but if we don't yet know
             * which bank is active, we'll build the default font, using the available font data (ie, abFontData).
             */
            let nFonts = 0;
            let abFontData = this.abFontData;

            let aRGBColors, aColorMap;
            if (this.nCardFont == Video.CARD.MDA || this.nMonitorType == ChipSet.MONITOR.MONO) {
                aRGBColors = Video.aMDAColors;
                aColorMap = Video.aMDAColorMap;
            } else {
                aRGBColors = this.getCardColors();
            }

            switch (this.nCardFont) {
            case Video.CARD.MDA:
                if (this.aFontOffsets[1] != null) {
                    if (this.createFont(this.nCardFont, this.cxFontChar || 9, 14, this.aFontOffsets[1], this.cxFontChar? 0 : 0x0800, abFontData, false, aRGBColors, aColorMap)) {
                        fChanges = true;
                    }
                }
                break;

            case Video.CARD.CGA:
                if (this.aFontOffsets[0] != null) {
                    if (this.createFont(this.nCardFont, this.cxFontChar || 8, 8, this.aFontOffsets[0], 0x0000, abFontData, false, aRGBColors, aColorMap)) {
                        fChanges = true;
                    }
                }
                break;

            case Video.CARD.VGA:
                nFonts += 4;
                /* falls through */

            case Video.CARD.EGA:
                nFonts += 4;
                let cxChar = this.cxFontChar || 8;
                let cyChar = 14;
                let offData = this.aFontOffsets[1];
                let bitsBanks = 0;
                let cx = (this.cardEGA.regSEQData[Card.SEQ.CLKMODE.INDX] & Card.SEQ.CLKMODE.DOTS8)? 8 : 9;
                let cy = (this.cardEGA.regCRTData[Card.CRTC.MAXSCAN] & Card.CRTCMASKS[Card.CRTC.MAXSCAN]);
                if (cy++) {
                    cxChar = cx;
                    cyChar = cy;
                    offData = 0;
                    abFontData = null;
                    if (bitsBanks = this.cardEGA.bitsDirtyBanks) {
                        if (DEBUG) this.printf("buildFont(%s): dirty font data detected (0x%02X)\n", fRebuild, bitsBanks);
                        this.cardEGA.bitsDirtyBanks = 0;
                    }
                    this.nFontSelect = this.getSelectedFonts();
                    this.nActiveFont = this.nCardFont + (this.nFontSelect & 0xff);
                    this.nAlternateFont = this.nCardFont + (this.nFontSelect >> 8);
                }
                if (offData != null) {
                    /*
                     * Logical fonts 0-3 (0-7 on the VGA) refer to banks in the following order: 0, 2, 4, 6, 1, 3, 5, 7.
                     *
                     * Note that we no longer build all possible fonts; we build ONLY those fonts that are currently selectable.
                     */
                    for (let nShift = 0, iFontPrev = -1; nShift < 16; nShift += 8) {
                        let iFont = (this.nFontSelect >> nShift) & 0xff;
                        if (iFont == iFontPrev) continue;
                        iFontPrev = iFont;
                        let iBank = (iFont << 1) - (iFont < 4? 0 : 7);
                        if (!abFontData) offData = iBank * 8192;
                        let fNewData = !!(bitsBanks & (0x1 << iBank));
                        if (this.createFont(this.nCardFont + iFont, cxChar, cyChar, offData, 0, abFontData, fNewData, aRGBColors, aColorMap)) {
                            fChanges = true;
                            if (abFontData || !iFont) continue;
                            for (let iFontPrev = 0; iFontPrev < iFont; iFontPrev++) {
                                this.createFontDiff(iFont, iFontPrev, cyChar);
                            }
                        }
                    }
                }
                break;
            }

            if (!fRebuild) {
                /*
                 * Perform some additional initialization common to both reset() and restore() sequences.
                 */
                this.iCellCursor = -1;  // initially, there is no visible cursor cell
                this.cBlinks = -1;      // initially, blinking is not active
                this.cBlinkVisible = 0; // no visible blinking characters (yet)
            }

            if (DEBUG && fChanges) this.printf("buildFont(%s): font changes detected\n", fRebuild);
        }

        return fChanges;
    }

    /**
     * createFont(nFont, cxChar, cyChar, offData, offSplit, abFontData, fNewData, aRGBColors, aColorMap)
     *
     * All color variations are stored on the same font canvas, arranged vertically as a series of grids, where each
     * grid is a 16x16 character glyph array.
     *
     * Since every character must be drawn first with its background color and then with the foreground shape on top,
     * I used to include a series of empty cells at the top every font canvas containing all supported background colors
     * (ie, before the character grids).  But now createFont() also creates an aCSSColors array that is saved alongside
     * the font canvas, and updateChar() uses that array in conjunction with fillRect() to draw character backgrounds.
     *
     * @this {Video}
     * @param {number} nFont
     * @param {number} cxChar is the width of the font characters
     * @param {number} cyChar is the height of the font characters
     * @param {number} offData is the offset of the font data
     * @param {number} offSplit is the offset of any split font data, or zero if not split
     * @param {Array.<number>|null} abFontData is the raw font data, from the ROM font file
     * @param {boolean} fNewData (true if abFontData contains potentially modified data, false if not)
     * @param {Array} aRGBColors is an array of color RGB variations, corresponding to supported FGND attribute values
     * @param {Array} [aColorMap] contains color indexes corresponding to attribute values (if not supplied, the mapping is assumed to be 1-1)
     * @return {boolean} true if any or all fonts were (re)created, false if nothing changed
     */
    createFont(nFont, cxChar, cyChar, offData, offSplit, abFontData, fNewData, aRGBColors, aColorMap)
    {
        let fChanges = false;
        let font = this.aFonts[nFont];
        let nColors = (aRGBColors.length < 16? aRGBColors.length : 16);

        if (!font || nColors != font.aRGBColors.length) {
            font = {
                cxChar:     cxChar,
                cyChar:     cyChar,
                cxCell:     0,
                cyCell:     0,
                aCSSColors: new Array(nColors),
                aRGBColors: aRGBColors.slice(0, nColors),   // make a copy of aRGBColors using slice()
                aColorMap:  aColorMap,
                aCanvas:    new Array(nColors)
            };
        }

        let nDouble = (this.fDoubleFont? 1 : 0);
        let cxCell = cxChar << nDouble;
        let cyCell = cyChar << nDouble;

        let fNewShape = false;
        if (font.cxCell != cxCell || font.cyCell != cyCell) {
            font.cxChar = cxChar;
            font.cyChar = cyChar;
            font.cxCell = cxCell;
            font.cyCell = cyCell;
            fNewShape = true;
        }

        for (let iColor = 0; iColor < nColors; iColor++) {
            let rgbColor = aRGBColors[iColor];
            /*
             * If any of the font's shape, data, or color has changed, then recreate it.  Also, we don't need to check
             * for a color change if we already know there was a shape or data change.
             */
            let fChanged = fNewShape || fNewData;
            if (!fChanged) {
                let rgbColorOrig = font.aCSSColors[iColor]? font.aRGBColors[iColor] : [];
                fChanged = (rgbColor[0] !== rgbColorOrig[0] || rgbColor[1] !== rgbColorOrig[1] || rgbColor[2] !== rgbColorOrig[2]);
            }
            if (fChanged) {
                if (!this.createFontColor(font, iColor, rgbColor, nDouble, offData, offSplit, cxChar, cyChar, abFontData)) {
                    this.printf("createFont(%d): no font data found\n", nFont);

                    font = null;
                    break;
                }
                if (DEBUG) {
                    if (!fChanges) {
                        this.printf("createFont(%d): creating %s font (%d,%d)\n", nFont, Video.cardSpecs[this.nCardFont][0], cxChar, cyChar);
                    }
                    this.printf("createFontColor(%d): [%s]\n", iColor, rgbColor);
                }
                fChanges = true;
            }
        }

        if (fChanges || font != this.aFonts[nFont]) {
            if (this.aDiagContexts.length) {
                let contextDst = this.aDiagContexts[nFont - this.nCardFont];
                if (contextDst) {
                    let canvasDst = contextDst.canvas;
                    if (!font) {
                        contextDst.fillStyle = "black";
                        contextDst.fillRect(0, 0, canvasDst.width, canvasDst.height);
                    }
                    else {
                        let cxDstColor = (canvasDst.width / nColors) | 0;
                        let cyDstColor = canvasDst.height;
                        let aspectDst = canvasDst.width / canvasDst.height;
                        for (let iColor = 0; iColor < nColors; iColor++) {
                            let canvasSrc = font.aCanvas[iColor];
                            contextDst.fillStyle = font.aCSSColors[(iColor + 9) % nColors];
                            contextDst.fillRect(iColor * cxDstColor, 0, cxDstColor, cyDstColor);
                            /*
                             * We want to draw whatever vertical slice of the font canvas will fit in the destination slice
                             * without altering the aspect ratio.  So the source and destination heights will be 100% of their
                             * respective canvases, while the source width will be multiplied by the ratio of the heights and
                             * then chopped.
                             */
                            let ratioHeight = canvasDst.height / canvasSrc.height;
                            let cxSrc = (canvasSrc.width * ratioHeight) | 0;
                            if (cxSrc > cxDstColor) cxSrc = cxDstColor;
                            let cySrc = canvasSrc.height;
                            contextDst.drawImage(canvasSrc, 0, 0, cxSrc, cySrc, iColor * cxDstColor, 0, cxDstColor, cyDstColor);
                        }
                    }
                }
            }
        }

        this.aFonts[nFont] = font;
        return fChanges;
    }

    /**
     * createFontColor(font, iColor, rgbColor, nDouble, offData, offSplit, cxChar, cyChar, abFontData)
     *
     * Now we're ready to create a 16x16 character grid for the specified color.  Note that all
     * the character bits are opaque (alpha=0xff) while all the surrounding bits are transparent
     * (alpha=0x00, as specified in the 4th byte of rgbOff).
     *
     * Originally, I created 256 ImageData objects, using context.createImageData(cxChar,cyChar),
     * then setting its pixels to match those of an individual character, and then drawing characters
     * with contextFont.putImageData().  But putImageData() is relatively slow....
     *
     * Now I create a new canvas, with dimensions that allow me to arrange all 256 characters in an
     * 16x16 grid -- much like the "chargen.png" bitmap used in the C1Pjs version of the Video component.
     * Then drawing becomes much the same as before, because it turns out that drawImage() accepts either
     * an image object OR a canvas object.
     *
     * This also yields better performance, since drawImage() is much faster than putImageData().
     * We still have to use putImageData() to build the font canvas, but that's a one-time operation.
     *
     * @this {Video}
     * @param {Font} font
     * @param {number} iColor
     * @param {Array} rgbColor contains the RGB values for iColor
     * @param {number} nDouble is 1 to double output font dimensions, 0 to match input dimensions
     * @param {number} offData is the offset of the font data
     * @param {number} offSplit is the offset of any split font data, or zero if not split
     * @param {number} cxChar is the width of the font characters
     * @param {number} cyChar is the height of the font characters
     * @param {Array.<number>|null} abFontData is the raw font data, from the ROM font file
     * @return {boolean} true if font created, false if not
     */
    createFontColor(font, iColor, rgbColor, nDouble, offData, offSplit, cxChar, cyChar, abFontData)
    {
        let rgbOff = [0x00, 0x00, 0x00, 0x00];
        let canvasFont = document.createElement("canvas");
        canvasFont.width = font.cxCell << 4;
        canvasFont.height = (font.cyCell << 4);
        let contextFont = canvasFont.getContext("2d");

        let imageChar = contextFont.createImageData(font.cxCell, font.cyCell);

        /*
         * If abFontData is null, we will use font data from plane 2 of video memory, which has a "hard-wired" layout
         * of 32 bytes per character (which, for 256 characters, amounts to 8Kb).  Note that on an EGA, up to 4 font
         * "banks" can be stored in plane 2, since each EGA font bank has a "hard-wired" length of 16Kb, whereas on a VGA,
         * up to 8 font banks can be stored in plane 2, since each VGA font bank has a "hard-wired" length of 8Kb.
         *
         * Note that for backward compatibility with the EGA, the VGA's additional 4 font banks are interleaved with the
         * EGA's original 4.
         */
        let iChar, y, x;
        let cyLimit = 32;
        let adwMemory = this.cardActive && this.cardActive.adwMemory;
        if (abFontData) {
            cyLimit = (cyChar < 8 || !offSplit)? cyChar : 8;
        }
        else {
            /*
             * When font data must be extracted from VRAM (instead of the supplied abFontData), we first do a "pre-scan"
             * to see if any font data actually exists.  For example. the video card's BIOS might zero ALL the font banks
             * (thereby making them "dirty") but then load only the first bank.
             */
            for (iChar = 0; iChar < 256; iChar++) {
                let offChar = offData + iChar * cyLimit;
                for (y = 0; y < cyChar; y++) {
                    let b = (adwMemory[offChar + y] >> 16) & 0xff;
                    if (b) break;
                }
                if (y < cyChar) break;
            }
            if (iChar == 256) return false;
        }

        for (iChar = 0; iChar < 256; iChar++) {
            let offChar = offData + iChar * cyLimit;
            for (y = 0; y < cyChar; y++) {

                /*
                 * fUnderline should be true only in the FONT_MDA case, and only for the odd color variations
                 * (1 and 3, out of variations 0 to 4), and only for the two bottom-most rows of the character cell
                 * (which I still need to confirm).
                 */
                let fUnderline = (font.aColorMap && (iColor & 0x1) && y >= cyChar - 2);
                let offScan = (y < cyLimit? offChar + y : offSplit + iChar * cyLimit + y - cyLimit);

                /*
                 * If abFontData is null, then we must extract the next byte of font data from plane 2 of video memory.
                 */
                let b = abFontData? abFontData[offScan] : ((adwMemory[offScan] >> 16) & 0xff);

                for (let nRowDoubler = 0; nRowDoubler <= nDouble; nRowDoubler++) {
                    for (x = 0; x < cxChar; x++) {
                        /*
                         * This "bit" of logic takes care of those characters (0xC0-0xDF) whose 9th bit must mirror the 8th bit;
                         * in all other cases, any bit past the 8th bit is automatically zero.  It also takes care of embedding a
                         * solid row of bits whenever fUnderline is true.
                         *
                         * TODO: For EGA/VGA, replication of the 9th dot needs to be based on the TEXT_9DOT bit of the ATC.MODE
                         * register, which is particularly important for user-defined fonts that do not want that bit replicated.
                         */
                        let bit = (fUnderline? 1 : (b & (0x80 >> (x >= 8 && iChar >= 0xC0 && iChar <= 0xDF? 7 : x))));
                        let xDst = (x << nDouble);
                        let yDst = (y << nDouble) + nRowDoubler;
                        let rgb = (bit? rgbColor : rgbOff);
                        this.setPixel(imageChar, xDst, yDst, rgb);
                        if (nDouble) this.setPixel(imageChar, xDst + 1, yDst, rgb);
                    }
                }
            }
            /*
             * (iChar >> 4) is the equivalent of Math.floor(iChar / 16), and (iChar & 0xf) is the equivalent of (iChar % 16).
             */
            contextFont.putImageData(imageChar, x = (iChar & 0xf) * font.cxCell, y = (iChar >> 4) * font.cyCell);
        }

        /*
         * The colors for cell backgrounds and cursor elements must be converted to CSS color strings.
         */
        font.aCSSColors[iColor] = Str.sprintf("#%02X%02X%02X", rgbColor[0], rgbColor[1], rgbColor[2]);
        font.aRGBColors[iColor] = rgbColor;
        font.aCanvas[iColor] = canvasFont;
        return true;
    }

    /**
     * createFontDiff(iFont, iFontPrev, cyChar, cyLimit)
     *
     * Since a programmable font was changed, we need to update the aFontDiff array.  For the EGA,
     * that array looks like this:
     *
     *      [0]: diffs between font 1 and 0     0 = 1 * (1 - 1) / 2
     *      [1]: diffs between font 2 and 0     1 = 2 * (2 - 1) / 2
     *      [2]: diffs between font 2 and 1
     *      [3]: diffs between font 3 and 0     3 = 3 * (3 - 1) / 2
     *      [4]: diffs between font 3 and 1
     *      [5]: diffs between font 3 and 2
     *
     * The VGA continues that progression:
     *
     *      [6]: diffs between font 4 and 0     6 = 4 * (4 - 1) / 2
     *      [7]: diffs between font 4 and 1
     *      [8]: diffs between font 4 and 2
     *      [9]: diffs between font 4 and 3
     *      ...
     *
     * So for a given logical font number (0-3 for the EGA or 0-7 for the VGA), the starting index of
     * "differable" fonts is n * (n - 1) / 2.
     *
     * @this {Video}
     * @param {number} iFont
     * @param {number} iFontPrev
     * @param {number} cyChar (height of every character in both fonts)
     * @param {number} [cyLimit] (default is 32)
     */
    createFontDiff(iFont, iFontPrev, cyChar, cyLimit = 32)
    {

        let i = ((iFont * (iFont - 1)) >> 1) + iFontPrev;
        let adwMemory = this.cardEGA.adwMemory;
        let aDiff = this.aFontDiff[i] || new Array(256);
        let iBank = (iFont << 1) - (iFont < 4? 0 : 7), offData = iBank * 8192;
        let iBankPrev = (iFontPrev << 1) - (iFontPrev < 4? 0 : 7), offDataPrev = iBankPrev * 8192;
        for (let iChar = 0; iChar < 256; iChar++) {
            aDiff[iChar] = 0;
            let offChar = offData + iChar * cyLimit, offCharPrev = offDataPrev + iChar * cyLimit;
            for (let y = 0; y < cyChar; y++) {
                if (((adwMemory[offChar++] >> 16) & 0xff) !== ((adwMemory[offCharPrev++] >> 16) & 0xff)) {
                    aDiff[iChar] = -1;
                    break;
                }
            }
        }
        this.aFontDiff[i] = aDiff;
    }

    /**
     * getFontDiff(iFont, iFontPrev)
     *
     * Unlike createFontDiff(), where iFontPrev is guaranteed to be less than iFont, that may not be true
     * for getFontDiff(), so we must swap them if iFont < iFontPrev.
     *
     * @this {Video}
     * @param {number} iFont
     * @param {number} iFontPrev
     * @return {Array.<number>}
     */
    getFontDiff(iFont, iFontPrev)
    {
        let i;
        if (iFont == iFontPrev) return [];
        if (iFont < iFontPrev) {
            i = iFont;
            iFont = iFontPrev;
            iFontPrev = i;
        }
        i = ((iFont * (iFont - 1)) >> 1) + iFontPrev;
        return this.aFontDiff[i];
    }

    /**
     * checkBlink()
     *
     * Called at the end of every updateScreenText(), which may have updated cBlinkVisible to a non-zero value.
     *
     * Also called at the end of every checkCursor(); ie, whenever the CRT register(s) affecting the position or shape
     * of the hardware cursor have been modified, and any of iCellCursor, yCursor or cyCursor have been modified as a result.
     *
     * Note that the cursor always blinks when it's ON; it can only be turned OFF, moved off-screen, or its rate set to half
     * the normal blink rate (by default, it blinks at the normal blink rate).  Bits 5-6 of the CRTC.CURSCAN register can
     * be set as follows:
     *
     *    00: Cursor blinks at normal blink rate
     *    01: Cursor is off
     *    10: (Same as 00)
     *    11: Cursor blinks at half the normal blink rate
     *
     * According to documentation, the normal blink rate is 1/16 of the frame rate (8 frames on, 8 off).
     *
     * TODO: As an aside, I've observed in the "real world" that the MDA cursor cycles about 3 times per second, and by "cycle"
     * I mean one full off-and-on-again cycle.  I'm assuming that's the normal rate (00), not the slower "half rate" (11).
     * Since that's faster than our current cursor blink rate, we should look into an option to boost our rate, without adversely
     * affecting the attribute blink rate (which is currently hard-coded at half the cursor blink rate), and we should look into
     * supporting "half rate" blinking, too.
     *
     * @this {Video}
     * @return {boolean} true if there are things to blink, false if not
     */
    checkBlink()
    {
        if (this.cBlinkVisible > 0 || this.iCellCursor >= 0) {
            if (this.cBlinks < 0) {
                this.cBlinks = 0;
                /*
                 * At this point, we can either fire up our own timer (doBlink), or rely on updateScreen() being
                 * called by the CPU at regular bursts (eg, Video.UPDATES_PER_SECOND = 60) and advance cBlinks at
                 * the start of updateScreen() accordingly.
                 *
                 * doBlink() wants to increment cBlinks every 266ms.  On the other hand, if updateScreen() is being
                 * called 60 times per second, that's about once every 16ms, so if every 16th updateScreen() increments
                 * cBlinks, cBlinks should advance at the same rate.
                 *
                 * One side-effect of relying on the CPU driving our blink count is that whenever the CPU is halted
                 * (eg, by our Debugger) all blinking stops -- all characters with the blink attribute AND the cursor.
                 *
                 * But that's more consistent with how we halt everything else (eg, the PITs, RTC, etc); our Debugger
                 * halts the entire machine, not just the CPU.
                 *
                 *      this.doBlink(true);
                 */
            }
            return true;
        }
        this.cBlinks = -1;
        return false;
    }

    /**
     * checkCursor()
     *
     * Called whenever a CRT data register is updated, since there are multiple registers that can affect the
     * visibility of the cursor (more than these, actually, but I'm going to limit my initial support to standard
     * ROM BIOS controller settings):
     *
     *      CRTC.MAXSCAN
     *      CRTC.CURSCAN
     *      CRTC.CURSCANB
     *      CRTC.STARTHI
     *      CRTC.STARTLO
     *      CRTC.CURSORHI
     *      CRTC.CURSORLO
     *
     * The top of the cursor starts at CURSCAN, and the bottom is CURSCANB - 1, except that if CURSCAN == CURSCANB
     * (or more precisely, if CURSCAN == CURSCANB mod 16), then a single scan line is still drawn.  Also, on the EGA,
     * if CURSCANB < CURSCAN, a split cursor is drawn.
     *
     * Also, at least on the EGA, if CURSCANB is set to a value > MAXSCAN (typically 13 on an EGA), cursor scan line
     * drawing wraps around to zero and does not stop until we reach CURSCAN again.  However, this happens only when
     * CURSCAN is <= MAXSCAN; if CURSCAN > MAXSCAN, then nothing is drawn, regardless of CURSCANB.
     *
     * @this {Video}
     * @return {boolean} true if the cursor is visible, false if not
     */
    checkCursor()
    {
        /*
         * The "hardware cursor" is never visible in graphics modes.
         */
        if (!this.nCardFont) return false;

        let card = this.cardActive;
        for (let i = Card.CRTC.CURSCAN; i <= Card.CRTC.CURSORLO; i++) {
            if (card.regCRTData[i] == null)
                return false;
        }

        let bCursorFlags = card.regCRTData[Card.CRTC.CURSCAN];
        let bCursorStart = bCursorFlags & Card.CRTC.CURSCAN_SLMASK;
        let bCursorEnd = card.regCRTData[Card.CRTC.CURSCANB] & Card.CRTCMASKS[Card.CRTC.CURSCANB];
        let bCursorMax = card.regCRTData[Card.CRTC.MAXSCAN] & Card.CRTCMASKS[Card.CRTC.MAXSCAN];
        let oCursorStart = bCursorStart, oCursorEnd = bCursorEnd;

        /*
         * Before range-checking CURSCAN and CURSCANB, let's see if the cursor is disabled by a starting value
         * outside the visible range; if so, simulate the condition by pretending the CURSCAN_BLINKOFF bit is set.
         *
         * For example, on a CGA, ThinkTank sets both CURSCAN and CURSCANB to 15, WordStar for PCjr sets CURSCAN and
         * CURSCANB to 12 and 13, respectively, and Rogue sets CURSCAN and CURSCANB to 15 and 0, respectively.
         */
        if (bCursorStart > bCursorMax) {
            bCursorFlags |= Card.CRTC.CURSCAN_BLINKOFF;
        }

        let bCursorWrap = 0;

        if (this.nCard != Video.CARD.EGA) {
            /*
             * Live and learn: I originally thought that the EGA introduced funky split cursors, but it turns
             * out that older cards did it, too (well, I've confirmed it on an actual MDA anyway; haven't tried
             * the CGA).  I've also confirmed that the MDA did NOT have the "mod 16" EGA anomaly described below.
             */
            if (bCursorEnd < bCursorStart) {
                bCursorWrap = bCursorEnd + 1;
                bCursorEnd = bCursorMax;
                /*
                 * The VGA didn't support funky split (aka wrap-around) cursors, so as above, we pretend that the
                 * cursor has simply been disabled.
                 */
                if (this.nCard == Video.CARD.VGA) {
                    bCursorFlags |= Card.CRTC.CURSCAN_BLINKOFF;
                    bCursorWrap = 0;
                }
            }
            else if (bCursorEnd > bCursorMax) {
                bCursorStart = 0;
                bCursorEnd = bCursorMax;
            }
            bCursorEnd++;
        }
        else {
            /*
             * HACK: The original EGA BIOS has a cursor emulation bug when 43-line mode is enabled; we used to
             * detect that particular combination of bad values and automatically fix them (see below),
             * but in retrospect, that doesn't seem very faithful.  Better to fix things like this 1) only if
             * the user asks, and 2) preferably with a BIOS patch rather than monkeying with the hardware registers.
             *
             *      if (this.nCard == Video.CARD.EGA) {
             *          if (bCursorMax == 7 && bCursorStart == 4 && !bCursorEnd) bCursorEnd = 7;
             *      }
            /*
             * Here's another strange EGA anomaly: if CURSCAN == CURSCANB mod 16, then it's treated the same as if
             * CURSCAN == CURSCANB.  For example, if you set (CURSCAN,CURSCANB) to either the decimal values
             * (4,19) or (4,21), you'll get a full block cursor, but if you set it to (4,20), you get a single line
             * cursor at row 4.  Go figure!
             */
            if (bCursorStart == bCursorEnd % 16) {
                bCursorEnd = bCursorStart + 1;
            }
            else if (bCursorEnd < bCursorStart) {
                bCursorWrap = bCursorEnd;
                bCursorEnd = bCursorMax + 1;
            }
            else if (bCursorEnd > bCursorMax) {
                bCursorStart = 0;
                bCursorEnd = bCursorMax + 1;
            }
        }

        let bCursorSize = bCursorEnd - bCursorStart;

        /*
         * One way of disabling the cursor is to set bit 5 (Card.CRTC.CURSCAN_BLINKOFF) of the CRTC.CURSCAN flags;
         * another way is setting bCursorStart > bCursorEnd, which implies that bCursorSize <= 0.
         */
        if ((bCursorFlags & Card.CRTC.CURSCAN_BLINKOFF) || bCursorSize <= 0) {
            this.removeCursor();
            return false;
        }

        /*
         * The least tricky way of disabling (ie, hiding) the cursor is to simply move it to an off-screen position.
         */
        let offCursor = card.regCRTData[Card.CRTC.CURSORLO] | ((card.regCRTData[Card.CRTC.CURSORHI] & card.addrMaskHigh) << 8);
        offCursor -= (card.regCRTData[Card.CRTC.STARTLO] | ((card.regCRTData[Card.CRTC.STARTHI] & card.addrMaskHigh) << 8));

        let iCellCursor = Math.trunc(offCursor / this.nColsLogical) * (this.nColsBuffer) + (offCursor % this.nColsLogical);

        if (this.iCellCursor != iCellCursor) {
            //
            // let rowFrom = (this.iCellCursor / this.nCols)|0;
            // let colFrom = (this.iCellCursor % this.nCols);
            // let rowTo = (iCellCursor / this.nCols)|0;
            // let colTo = (iCellCursor % this.nCols);
            // if (DEBUG) this.printf("checkCursor(): cursor moved from %d,%d to %d,%d\n", rowFrom, colFrom, rowTo, colTo);
            // this.removeCursor();
            //
            this.iCellCursor = iCellCursor;
            /*
             * We invalidate cBlinkVisible on a cursor position change to ensure the cursor will be redrawn on the
             * next call to updateScreenCells().  It has the downside of requiring ALL cells to be re-examined, not
             * just the old and new cursor cells, but the cell cache should prevent any unnecessary redrawing.
             */
            this.cBlinkVisible = -1;
        }

        /*
         * yCursor and cyCursor are no longer scaled at this point, because the necessary scaling will depend on
         * whether we're drawing the cursor to the on-screen or off-screen buffer, and updateChar() is in the best
         * position to determine that.
         *
         * We also record cyCursorCell, the hardware cell height, since we'll need to know what the yCursor and
         * cyCursor values are relative to when it's time to scale them.
         */
        if (this.yCursor !== bCursorStart || this.cyCursor !== bCursorSize || this.cyCursorWrap !== bCursorWrap) {
            if (DEBUG) this.printf("checkCursor(): cursor shape changed from %d,%d to %d,%d (0x%02X-0x%02X)\n", this.yCursor, this.cyCursor, bCursorStart, bCursorSize, oCursorStart, oCursorEnd);
            this.yCursor = bCursorStart;
            this.cyCursor = bCursorSize;
            this.cyCursorWrap = bCursorWrap;
            /*
             * The best redraw option for cursor shape changes used to be invalidating the cell cache, since merely
             * invalidating cBlinkVisible wouldn't have the desired effect if the cursor was still in the same location.
             * However, that option was rather drastic.  If the cursor had ALSO just moved (ie, this.cBlinkVisible < 0),
             * we didn't have to worry about it, so we could at least be more selective about when to invalidate the cache:
             *
             * But now we have the option of invalidating just a single cell (and marking the cache as "partially valid"),
             * so that's what we do.  Granted, a lot of hand-wringing over an uncommon operation, but that's how we roll.
             */
            if (this.iCellCacheValid && this.iCellCursor >= 0 && this.iCellCursor < this.aCellCache.length) {
                this.aCellCache[this.iCellCursor] = -1;
                this.iCellCacheValid = 1;
            }
        }

        this.cyCursorCell = bCursorMax + 1;

        /*
         * This next condition is critical; WordStar for PCjr (designed for the CGA) would program CURSCANB to 31,
         * whereas MAXSCAN was 7.  This resulted in cyCursorCell of 8 and cyCursor of 32, producing elongated cursors
         * in updateChar().  By range-checking CURSCAN and CURSCANB against MAXSCAN above, that should no longer happen.
         *
         * This condition can also happen while the CRT controller is in an inconsistent state (ie, in the middle of
         * being completely reprogrammed), so we mustn't freak out.
         */
        if (this.cyCursor > this.cyCursorCell) {
            this.cyCursor = this.cyCursorCell;
        }

        this.checkBlink();
        return true;
    }

    /**
     * removeCursor()
     *
     * @this {Video}
     */
    removeCursor()
    {
        if (this.iCellCursor >= 0) {
            if (this.aCellCache !== undefined && this.iCellCursor < this.aCellCache.length) {
                let drawCursor = (Video.ATTRS.DRAW_CURSOR << 8);
                let data = this.aCellCache[this.iCellCursor];
                if (data & drawCursor) {
                    data &= ~drawCursor;
                    let col = this.iCellCursor % this.nColsBuffer;
                    let row = (this.iCellCursor / this.nColsBuffer) | 0;
                    if (this.nActiveFont && this.aFonts[this.nActiveFont]) {
                        /*
                         * If we're using an off-screen buffer in text mode, then we need to keep it in sync with "reality".
                         */
                        if (this.contextBuffer) {
                            this.updateChar(col, row, data, this.contextBuffer);
                        }
                        /*
                         * While updating the on-screen canvas directly could open us up to potential subpixel artifacts again,
                         * I'm hopeful that won't be the case, since removeCursor() is called only during certain well-defined
                         * events.  The alternative to this simple updateChar() call is unappealing: redrawing the ENTIRE off-screen
                         * buffer to the on-screen canvas, just as updateScreen() does.
                         */
                        this.updateChar(col, row, data);
                    }
                    if (DEBUG) this.printf("removeCursor(): removed from %d,%d\n", row, col);
                    this.aCellCache[this.iCellCursor] = data;
                }
            }
            this.iCellCursor = -1;
        }
    }

    /**
     * getCardAccess()
     *
     * @this {Video}
     * @return {number} current memory access setting
     */
    getCardAccess()
    {
        let card = this.cardActive;
        let nAccess = Card.ACCESS.READ.PAIRS | Card.ACCESS.WRITE.PAIRS;

        if (card.nCard >= Video.CARD.EGA) {
            this.fColor256 = false;
            let regGRCMode = card.regGRCData[Card.GRC.MODE.INDX];
            if (regGRCMode != null) {
                let nReadAccess = Card.ACCESS.READ.MODE0;
                let nWriteAccess = Card.ACCESS.WRITE.MODE0;
                let nWriteMode = regGRCMode & Card.GRC.MODE.WRITE.MASK;
                let regDataRotate = card.regGRCData[Card.GRC.DATAROT.INDX] & Card.GRC.DATAROT.MASK;
                switch (nWriteMode) {
                case Card.GRC.MODE.WRITE.MODE0:
                    if (regDataRotate) {
                        nWriteAccess = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.ROT;
                        switch (regDataRotate & Card.GRC.DATAROT.FUNC) {
                        case Card.GRC.DATAROT.AND:
                            nWriteAccess = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.AND;
                            break;
                        case Card.GRC.DATAROT.OR:
                            nWriteAccess = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.OR;
                            break;
                        case Card.GRC.DATAROT.XOR:
                            nWriteAccess = Card.ACCESS.WRITE.MODE0 | Card.ACCESS.WRITE.XOR;
                            break;
                        default:
                            break;
                        }
                        card.nDataRotate = regDataRotate & Card.GRC.DATAROT.COUNT;
                    }
                    break;
                case Card.GRC.MODE.WRITE.MODE1:
                    nWriteAccess = Card.ACCESS.WRITE.MODE1;
                    break;
                case Card.GRC.MODE.WRITE.MODE2:
                    switch (regDataRotate & Card.GRC.DATAROT.FUNC) {
                    default:
                        nWriteAccess = Card.ACCESS.WRITE.MODE2;
                        break;
                    case Card.GRC.DATAROT.AND:
                        nWriteAccess = Card.ACCESS.WRITE.MODE2 | Card.ACCESS.WRITE.AND;
                        break;
                    case Card.GRC.DATAROT.OR:
                        nWriteAccess = Card.ACCESS.WRITE.MODE2 | Card.ACCESS.WRITE.OR;
                        break;
                    case Card.GRC.DATAROT.XOR:
                        nWriteAccess = Card.ACCESS.WRITE.MODE2 | Card.ACCESS.WRITE.XOR;
                        break;
                    }
                    break;
                case Card.GRC.MODE.WRITE.MODE3:
                    if (this.nCard == Video.CARD.VGA) {
                        nWriteAccess = Card.ACCESS.WRITE.MODE3;
                        card.nDataRotate = regDataRotate & Card.GRC.DATAROT.COUNT;
                    }
                    break;
                default:
                    if (DEBUG && this.messageEnabled()) {
                        this.printMessage("getCardAccess(): invalid GRC mode (" + Str.toHexByte(regGRCMode) + ")");
                    }
                    break;
                }
                if (regGRCMode & Card.GRC.MODE.READ.MODE1) {
                    nReadAccess = Card.ACCESS.READ.MODE1;
                }
                /*
                 * I discovered that when the IBM EGA ROM scrolls the screen in graphics modes 0x0D and 0x0E, it
                 * reprograms this register for WRITE.MODE1 (which is fine) *and* EVENODD (which is, um, very odd).
                 * Moreover, it does NOT make the complementary change to the SEQ.MEMMODE.SEQUENTIAL bit; under
                 * normal circumstances, those two bits are always supposed to programmed oppositely.
                 *
                 * Until I can perform some tests on real hardware, I have to assume that the EGA scroll operation
                 * is supposed to actually WORK in modes 0x0D and 0x0E, so I've decided to tie the trigger for my own
                 * EVENODD functions to SEQ.MEMMODE.SEQUENTIAL being clear, instead of GRC.MODE.EVENODD being set.
                 *
                 * It's also possible that my EVENODD read/write functions are not implemented properly; when EVENODD
                 * is in effect, which addresses get latched by a read, and to which addresses are latches written?
                 * If EVENODD has no effect on the effective address used with the latches, then I should change the
                 * EVENODD read/write functions accordingly.
                 *
                 * However, I've also done some limited testing with an emulated VGA running in text mode, and I've
                 * discovered that toggling the GRC.MODE.EVENODD bit *alone* doesn't seem to affect the delivery of
                 * text mode attributes from plane 1.  So maybe this is the wiser change after all.
                 *
                 * TODO: Perform some tests on actual EGA/VGA hardware, to determine the proper course of action.
                 *
                 *  if (regGRCMode & Card.GRC.MODE.EVENODD) {
                 *      nReadAccess |= Card.ACCESS.READ.EVENODD;
                 *      nWriteAccess |= Card.ACCESS.WRITE.EVENODD;
                 *  }
                 */
                let regSEQMode = card.regSEQData[Card.SEQ.MEMMODE.INDX];
                if (regSEQMode != null) {
                    if (!(regSEQMode & Card.SEQ.MEMMODE.SEQUENTIAL)) {
                        nReadAccess |= Card.ACCESS.READ.EVENODD;
                        nWriteAccess |= Card.ACCESS.WRITE.EVENODD;
                    }
                    if (regGRCMode & Card.GRC.MODE.COLOR256) {
                        if (regSEQMode & Card.SEQ.MEMMODE.CHAIN4) {
                            nReadAccess |= Card.ACCESS.READ.CHAIN4;
                            nWriteAccess |= Card.ACCESS.WRITE.CHAIN4;
                        }
                        this.fColor256 = true;
                    }
                }
                nAccess = nReadAccess | nWriteAccess;
            }
        }
        return nAccess;
    }

    /**
     * setCardAccess(nAccess)
     *
     * @this {Video}
     * @param {number} nAccess (one of the Card.ACCESS.* constants)
     * @return {boolean} true if access may have changed, false if not
     */
    setCardAccess(nAccess)
    {
        let card = this.cardActive;
        if (card && nAccess != card.nAccess) {

            if (DEBUG) this.printf("setCardAccess(0x%04X)\n", nAccess);

            card.setMemoryAccess(nAccess);

            /*
             * Note that setMemoryAccess() can fail, in which case it will an report error, indicating either a
             * misconfiguration or some sort of internal inconsistency; in any case, there's not much we can do about
             * it at this point, other than possibly reverting the current access setting.  There's probably not much
             * point, however, because there's no guarantee that setMemoryAccess() didn't modify one or more blocks
             * before choking.
             */
            this.bus.setMemoryAccess(card.addrBuffer, card.sizeBuffer, card.getMemoryAccess(), true);
            return true;
        }
        return false;
    }

    /**
     * setDimensions()
     *
     * This is the workhorse of setMode()
     *
     * @this {Video}
     */
    setDimensions()
    {
        this.nCardFont = this.nActiveFont = this.nAlternateFont = 0;
        this.nCols = this.nColsDefault;
        this.nRows = this.nRowsDefault;
        this.nPointsPerCell = Video.aModeParms[Video.MODE.MDA_80X25][2];
        this.nPointsPerByte = Video.aModeParms[Video.MODE.MDA_80X25][3];
        this.cxScreenCell = this.cyScreenCell = 1;
        this.fOverBuffer = false;

        let cbPadding = 0, cxCell = 1, cyCell = 1;
        let modeParms = Video.aModeParms[this.nMode];
        if (modeParms) {

            this.nCols = modeParms[0];
            this.nRows = modeParms[1];
            this.nPointsPerCell = modeParms[2];
            this.nPointsPerByte = modeParms[3];
            cbPadding = modeParms[4];       // undefined for EGA/VGA graphics modes only
            this.nCardFont = modeParms[5];  // this will be undefined for all graphics modes

            if (this.nCardFont) {
                /*
                 * Color text modes originally used an 8x8 font, but beginning with the EGA, they use whatever
                 * font is stored in plane 2, so if the card is "newer" than the default font, update the default
                 * to match the card.
                 */
                if (this.nCard > this.nCardFont) this.nCardFont = this.nCard;
                this.buildFont();           // this also updates nActiveFont and nAlternateFont
                let font = this.aFonts[this.nActiveFont];
                if (font) {
                    cxCell = font.cxCell;
                    cyCell = font.cyCell;
                    if (this.nCard >= Video.CARD.EGA) {
                        /*
                         * Since these cards have programmable font height (font.cyChar), we need to divide that
                         * into the screen height (cyScreen) to determine the effective (ie, visible) number of rows.
                         */
                        let cyScreen = this.cardEGA.getCRTCReg(Card.CRTC.EGA.VDEND);
                        if (cyScreen++) {
                            let nRows = (cyScreen / font.cyChar) | 0;
                            if (nRows) this.nRows = nRows;
                        }
                        this.fOverBuffer = true;
                    }
                }
                this.cxScreenCell = (this.cxScreen / this.nCols) | 0;
                this.cyScreenCell = (this.cyScreen / this.nRows) | 0;
            }
        }

        this.nColsBuffer = this.nColsLogical = this.nCols;
        this.nRowsBuffer = this.nRows;
        if (this.fOverBuffer) {
            this.nColsBuffer++;
            this.nRowsBuffer++;
        }
        this.nCells = (this.nColsBuffer * this.nRowsBuffer) | 0;
        this.nCellCache = (this.nCells / this.nPointsPerCell) | 0;
        this.cbScreen = this.nCellCache;
        this.cbSplit = 0;

        if (cbPadding !== undefined) {
            this.cbScreen <<= 1;
            this.cbScreen = (this.cbScreen + cbPadding) | 0;
            this.cbSplit = (this.cbScreen + cbPadding) >> 1;
        }

        this.cxBuffer = this.nColsBuffer * cxCell;
        this.cyBuffer = this.nRowsBuffer * cyCell;

        /*
         * Beyond calculating the theoretical dimensions, there's nothing more to do if we're in a "headless" mode.
         */
        if (!this.contextScreen) return;

        /*
         * Our 'smoothing' parameter defaults to null (which we treat the same as undefined), which means that
         * image smoothing will be selectively enabled (ie, true for text modes, false for graphics modes); otherwise,
         * we'll set image smoothing to whatever value was provided for ALL modes -- assuming the browser supports it.
         */
        if (this.sSmoothing) {
            this.contextScreen[this.sSmoothing] = (this.fSmoothing == null? !!this.nCardFont : this.fSmoothing);
        }

        /*
         * Allocate the off-screen buffers
         */
        this.imageBuffer = this.contextScreen.createImageData(this.cxBuffer, this.cyBuffer);
        this.canvasBuffer = document.createElement("canvas");
        this.canvasBuffer.width = this.cxBuffer;
        this.canvasBuffer.height = this.cyBuffer;
        this.contextBuffer = this.canvasBuffer.getContext("2d");

        /*
         * Since cxCell and cyCell were originally defined in terms of cxScreen/nCols and cyScreen/nRows, you might think
         * these border calculations would always be zero, but we used to have code that tried to avoid stretching 40-column
         * modes into an unpleasantly wide shape, so this code is being retained (for now).
         */
        this.xScreenOffset = this.yScreenOffset = 0;
        this.cxScreenOffset = this.cxScreen;
        this.cyScreenOffset = this.cyScreen;

        let cxBorder = this.cxScreen - (this.nCols * this.cxScreenCell);
        let cyBorder = this.cyScreen - (this.nRows * this.cyScreenCell);
        if (cxBorder > 0) {
            this.xScreenOffset = (cxBorder >> 1);
            this.cxScreenOffset -= cxBorder;
        }
        if (cyBorder > 0) {
            this.yScreenOffset = (cyBorder >> 1);
            this.cyScreenOffset -= cyBorder;
        }
        if (cxBorder || cyBorder) {
            this.contextScreen.fillStyle = this.canvasScreen.style.backgroundColor;
            this.contextScreen.fillRect(0, 0, this.cxScreen, this.cyScreen);
        }
    }

    /**
     * checkMode(fForce)
     *
     * Called whenever the MDA/CGA's mode register (eg, Card.MDA.MODE.PORT, Card.CGA.MODE.PORT) is updated,
     * or whenever the EGA/VGA's GRC.MISC register is updated, or when we've just finished a restore().
     *
     * @this {Video}
     * @param {boolean} [fForce] is used to force a mode update, if we recognize the current mode
     * @return {boolean} true if successful, false if not
     */
    checkMode(fForce)
    {
        let fRemap = false;
        let nMode = this.nMode;
        let card = this.cardActive;

        if (!card) {
            /*
             * We are likely being called after a restore(), which needs us to call setMode() to insure the proper video
             * buffer is mapped in.  So we unset this.nMode to guarantee that setMode() will be called, and if it wasn't set
             * to anything before, then we fall-back to the default mode.
             */
            this.nMode = null;
            if (nMode == null) nMode = this.nModeDefault;
        }
        else {
            if (card.nCard == Video.CARD.MDA) {
                nMode = Video.MODE.MDA_80X25;
            }
            else if (card.nCard >= Video.CARD.EGA) {
                /*
                 * The sizeBuffer we choose reflects the amount of physical address space that all 4 planes
                 * of EGA memory normally span, NOT the total amount of EGA memory.  So for a 64Kb EGA card,
                 * we would set card.sizeBuffer to 16Kb (0x4000).
                 *
                 * TODO: Need to take into account modes that "chain" planes together (eg, mode 0x0F, and
                 * presumably mode 0x10, on an EGA card with only 64Kb).
                 */
                nMode = null;
                let cbBuffer = card.cbMemory >> 2;
                let cbBufferText = (cbBuffer > 0x8000? 0x8000 : cbBuffer);

                let regGRCMisc = card.regGRCData[Card.GRC.MISC.INDX];
                if (regGRCMisc != null) {

                    let nCRTCMaxScan = card.regCRTData[Card.CRTC.EGA.MAXSCAN.INDX];

                    switch (regGRCMisc & Card.GRC.MISC.MAPMEM) {
                    case Card.GRC.MISC.MAPA0128:
                        card.addrBuffer = 0xA0000;
                        card.sizeBuffer = cbBuffer;     // 0x20000
                        if ((nCRTCMaxScan & Card.CRTC.EGA.MAXSCAN.SLMASK) <= 1) {
                            nMode = Video.MODE.UNKNOWN;     // no BIOS mode uses this mapping, but we don't want to leave nMode null if we've come this far
                        } else {
                            /*
                             * This mapping is used by Fantasy Land.
                             *
                             * TODO: Generalize this logic, outside of the context of the GRC.MISC mapping bits.
                             * For example, can we assume that as long as (MAXSCAN & SLMASK) > 1, we're always in text mode?
                             * And to what extent can we rely on the GRC.MISC.GRAPHICS bit?
                             */
                            nMode = (this.nMonitorType == ChipSet.MONITOR.MONO? Video.MODE.CGA_80X25_BW : Video.MODE.CGA_80X25);
                        }
                        break;
                    case Card.GRC.MISC.MAPA064:
                        card.addrBuffer = 0xA0000;
                        card.sizeBuffer = cbBuffer;     // 0x10000
                        nMode = (this.nMonitorType == ChipSet.MONITOR.MONO? Video.MODE.EGA_640X350_MONO : Video.MODE.EGA_640X350);
                        break;
                    case Card.GRC.MISC.MAPB032:
                        card.addrBuffer = 0xB0000;
                        card.sizeBuffer = cbBufferText;
                        nMode = Video.MODE.MDA_80X25;
                        break;
                    case Card.GRC.MISC.MAPB832:
                        card.addrBuffer = 0xB8000;
                        card.sizeBuffer = cbBufferText;
                        nMode = (this.nMonitorType == ChipSet.MONITOR.MONO? Video.MODE.CGA_80X25_BW : Video.MODE.CGA_80X25);
                        break;
                    default:
                        break;
                    }
                    /*
                     * TODO: The following mode discrimination code is all a bit haphazard, a byproduct of its slow evolution
                     * from increasingly greater EGA support to increasingly greater VGA support.  Make it more rational someday,
                     * so that as support is added for even more modes (eg, "Mode X" variations, monochrome modes, etc), it
                     * doesn't get totally out of control.
                     *
                     * One of the problems with the current approach is that it depends on the card's registers being programmed
                     * in at least roughly the same order that the IBM EGA and VGA ROMs program them.
                     */
                    let regGRCMode = card.regGRCData[Card.GRC.MODE.INDX];

                    /*
                     * This text/graphics hybrid test detects the way Windows 95 reprograms the VGA on boot; ie, switching
                     * to graphics mode 0x13 (320x200) without disturbing the text buffer contents, then reprogramming it
                     * to enable graphics mode 0x15 (320x400), then drawing a logo in the 2nd half of the video memory, and
                     * finally reprogramming regGRCMode and regGRCMisc to move the frame buffer back to its original text mode
                     * location.
                     */
                    let fTextGraphicsHybrid = (regGRCMode & (Card.GRC.MODE.COLOR256 | Card.GRC.MODE.EVENODD)) == (Card.GRC.MODE.COLOR256 | Card.GRC.MODE.EVENODD);

                    /*
                     * When fTextGraphicsHybrid is true, we should be at the end of the above process, so addrBuffer
                     * will have changed.  Since we don't (yet) assign a special mode to that configuration, we must at
                     * least set fForce to true, so that setMode() will notice the buffer address change and remap it.
                     *
                     * We have a similar situation when Fantasy Land selects the MAPA0128 buffer mapping, so this test is no
                     * longer limited to fTextGraphicsHybrid being true.
                     */
                    if (card.addrBuffer != this.addrBuffer || card.sizeBuffer != this.sizeBuffer) {
                        fRemap = true;
                    }

                    let nCRTCVertTotal = card.getCRTCReg(Card.CRTC.EGA.VTOTAL);
                    let nCRTCModeCtrl = card.regCRTData[Card.CRTC.EGA.MODECTRL.INDX];
                    let fSEQDotClock = (card.regSEQData[Card.SEQ.CLKMODE.INDX] & Card.SEQ.CLKMODE.DOTCLOCK);

                    if (nMode != Video.MODE.UNKNOWN) {
                        if (!(regGRCMisc & Card.GRC.MISC.GRAPHICS)) {
                            /*
                             * Here's where we handle text modes; since nMode will have been assigned a default
                             * of either 0x02 or 0x03, convert that to either 0x05 or 0x04 if we're in a low-res
                             * graphics mode, 0x06 otherwise.
                             */
                            nMode -= (fSEQDotClock? 2 : 0);
                        }
                        else if (card.addrBuffer != 0xA0000 && !fTextGraphicsHybrid && !(nCRTCModeCtrl & Card.CRTC.EGA.MODECTRL.COMPAT_MODE)) {
                            /*
                             * Here's where we handle CGA graphics modes; since nMode will have been assigned a
                             * default of either 0x02 or 0x03, convert that to either 0x05 or 0x04 if we're in a
                             * low-res graphics mode, 0x06 otherwise.
                             *
                             * For Windows 95, I've had to add BOTH the fTextGraphicsHybrid test, to avoid misdetecting
                             * the logo display mode, AND the COMPAT_MODE test, to avoid misinterpreting the VDD's physical
                             * (NOT logical) card reprogramming during windowed VM creation; the latter seems like a VDD bug,
                             * because only the Windows display driver should be *physically* reprogramming the card then.
                             */
                            nMode = fSEQDotClock? (7 - nMode) : Video.MODE.CGA_640X200;
                        } else {
                            /*
                             * Here's where we handle EGA/VGA graphics modes, discriminating among modes 0x0D and up;
                             * we've already defaulted to either 0x0F or 0x10.  If COLOR256 is set, then select mode
                             * 0x13 (or greater), else if 200-to-400 scan-line conversion is in effect, select either
                             * mode 0x0D or 0x0E, else if VGA resolution is set, select either mode 0x11 or 0x12.
                             */
                            if (card.regGRCData[Card.GRC.MODE.INDX] & Card.GRC.MODE.COLOR256) {
                                if (nCRTCMaxScan & Card.CRTC.EGA.MAXSCAN.SLMASK) {
                                    /*
                                     * NOTE: Technically, VDEND is one of those CRTC registers that should be read using
                                     * card.getCRTCReg(), because there are overflow bits (8 and 9).  However, all known modes
                                     * always SET bit 8 and CLEAR bit 9, so examining only bits 0-7 is sorta OK.
                                     */
                                    if (card.regCRTData[Card.CRTC.EGA.VDEND] <= 0x8F) {
                                        nMode = Video.MODE.VGA_320X200;
                                    }
                                    else { /* (card.regCRTData[Card.CRTC.EGA.VDEND] == 0xDF) */
                                        nMode = Video.MODE.VGA_320X240;
                                    }
                                } else {
                                    nMode = Video.MODE.VGA_320X400;
                                }
                            }
                            else if ((nCRTCMaxScan & Card.CRTC.EGA.MAXSCAN.CONVERT400) || nCRTCVertTotal < 350) {
                                nMode = (fSEQDotClock? Video.MODE.EGA_320X200 : Video.MODE.EGA_640X200);
                            } else if (nCRTCVertTotal >= 480) {
                                nMode = (this.nMonitorType == ChipSet.MONITOR.MONO? Video.MODE.VGA_640X480_MONO : Video.MODE.VGA_640X480);
                            }
                            if (DEBUG && this.messageEnabled()) {
                                this.printMessage("checkMode(): nCRTCVertTotal=" + nCRTCVertTotal + ", mode=" + Str.toHexByte(nMode));
                            }
                        }
                    }
                }
            }
            else if (card.regMode & Card.CGA.MODE.VIDEO_ENABLE) {
                /*
                 * NOTE: For the CGA, we precondition any mode change on CGA.MODE.VIDEO_ENABLE being set, otherwise
                 * we'll get spoofed by the ROM BIOS scroll code, which waits for vertical retrace and then turns CGA.MODE.VIDEO_ENABLE
                 * off, using a hard-coded mode value (0x25) that does NOT necessarily match the the CGA video mode currently in effect.
                 */
                if (!(card.regMode & Card.CGA.MODE.GRAPHIC_SEL)) {
                    nMode = ((card.regMode & Card.CGA.MODE._80X25)? Video.MODE.CGA_80X25 : Video.MODE.CGA_40X25);
                    if (card.regMode & Card.CGA.MODE.BW_SEL) {
                        nMode -= 1;
                    }
                } else {
                    nMode = ((card.regMode & Card.CGA.MODE.HIRES_BW)? Video.MODE.CGA_640X200 : Video.MODE.CGA_320X200_BW);
                    if (!(card.regMode & Card.CGA.MODE.BW_SEL)) {
                        nMode -= 1;
                    }
                }
                if (this.fOpacityReduced) {
                    this.canvasScreen.style.opacity = "1";
                    this.fOpacityReduced = false;
                }
            }
            else {
                /*
                 * This code is responsible for simulating flicker on a CGA screen.  Note that we have to also
                 * call yieldCPU() to ensure that the browser "comes up for air" and honors the new opacity, otherwise
                 * you'll see very intermittent flicker (which is actually more annoying than regular flicker, believe
                 * it or not).
                 *
                 * You also have the option of setting opacityFlicker to something greater than zero (eg, "0.5") to
                 * make the flicker less obtrusive; in fact, that might be more faithful to the persistence of a CGA
                 * screen's phosphor.  The downside is that if the VIDEO_ENABLE bit is ever turned for off a "long time",
                 * then you'll be treated to a very unnatural persistence effect.
                 */
                if (!this.fOpacityReduced && +this.opacityFlicker < 1) {
                    this.fOpacityReduced = true;
                    this.canvasScreen.style.opacity = this.opacityFlicker;
                    this.cpu.yieldCPU();
                }
            }
        }

        /*
         * NOTE: If setMode() remaps the video memory, that will trigger calls to setCardAccess() to also update the
         * memory's access functions.  However, if the memory access setting is about to change as well, those changes
         * will be moot until the setCardAccess() call that follows.  Basically, whenever both memory mapping AND access
         * functions are changing, the memory will be in an inconsistent state until both setMode() and setCardAccess()
         * are finished.
         *
         * The setMode() call takes precedence; if we called setCardAccess() first, it might attempt to modify memory access
         * functions based on the card's addrBuffer setting, and if that doesn't match what's currently mapped, assertions
         * will be triggered (probably not fatal, but it would defeat the point of the assertions).
         */
        if (!this.setMode(nMode, fForce, fRemap)) return false;

        this.setCardAccess(this.getCardAccess());

        return true;
    }

    /**
     * setMode(nMode, fForce, fRemap)
     *
     * Set fForce to true to update the mode regardless of previous mode, or false to perform a normal update
     * that bypasses updateScreen() but still calls initCellCache().
     *
     * @this {Video}
     * @param {number|null} nMode
     * @param {boolean} [fForce] is set when checkMode() wants to force a mode update
     * @param {boolean} [fRemap] is set when checkMode() detects a change in the buffer mapping
     * @return {boolean} true if successful, false if failure
     */
    setMode(nMode, fForce, fRemap)
    {
        let fReset = nMode != null && (nMode != this.nMode || fForce);
        if (fReset || fRemap) {

            if (DEBUG && this.messageEnabled()) {
                this.printMessage("setMode(" + Str.toHexByte(nMode) + (fForce? ",force" : "") + ")", true, true);
            }

            this.cUpdates = 0;      // count updateScreen() calls as a means of driving blink updates
            this.nMode = nMode;
            this.fRGBValid = false;

            /*
             * It's CRITICAL that a reset() invalidate cardActive, to ensure that the code below releases the
             * previous video buffer and installs a new one, even if there was no change in the video buffer
             * address or size, because otherwise memory blocks installed at the video buffer address may still
             * be using blocks of the previous memory buffer.
             *
             * When an EGA is reinitialized, a new memory buffer (adwMemory) is allocated (see initEGA()), and
             * this is where the mapping of that EGA memory buffer to the video buffer occurs.  Even if a card
             * (MDA or CGA) never reallocates its memory buffer, it's still a good idea to always force this operation
             * (eg, in case a switch setting changed the active video card).
             */
            let card = this.cardActive || (nMode == Video.MODE.MDA_80X25? this.cardMono : this.cardColor);

            if (card != this.cardActive || card.addrBuffer != this.addrBuffer || card.sizeBuffer != this.sizeBuffer) {

                this.removeCursor();

                if (this.addrBuffer) {

                    if (DEBUG) this.printf("setMode(0x%02X): removing 0x%08X bytes from 0x%08X\n", nMode, this.sizeBuffer, this.addrBuffer);

                    if (!this.bus.removeMemory(this.addrBuffer, this.sizeBuffer)) {
                        /*
                         * TODO: Force this failure case and see how well the Video component deals with it.
                         */
                        return false;
                    }
                    if (this.cardActive) this.cardActive.fActive = false;
                }

                this.cardActive = card;
                card.fActive = true;

                this.addrBuffer = card.addrBuffer;
                this.sizeBuffer = card.sizeBuffer;

                if (DEBUG) this.printf("setMode(0x%02X): adding 0x%08X bytes to 0x%08X\n", nMode, this.sizeBuffer, this.addrBuffer);

                if (!this.bus.addMemory(card.addrBuffer, card.sizeBuffer, Memory.TYPE.VIDEO, card)) {
                    /*
                     * TODO: Force this failure case and see how well the Video component deals with it.
                     */
                    return false;
                }

                /*
                 * As https://www.seasip.info/VintagePC/mda.html explains, the MDA's 4K buffer address is not
                 * fully decoded; it is also addressible at every 4K interval within a 32K (0x8000) address range.
                 * We simulate that now, and not just for purely theoretical reasons: the original monochrome-
                 * specific version of "Exploring the IBM Personal Computer":
                 *
                 *      https://www.pcjs.org/disks/pcx86/diags/ibm/5150/exploring/1.00/mda/
                 *
                 * has a bug where it attempts to clear one of the intro screens with a faulty INT 10h Scroll Up
                 * call, where the top left (CX) and bottom right (DX) coordinates are reversed, resulting in a
                 * scroll with negative coordinates that the BIOS converts into large positive off-screen coordinates,
                 * which just so happens to clear the video buffer anyway, because it's repeatedly addressible.
                 *
                 * The CGA's 16K buffer has a similar feature, but owing to its larger size, its buffer repeats only
                 * once within a 32K address range.  And yes, the color version of "Exploring the IBM Personal Computer"
                 * has a similar INT 10h scroll bug; the app is using graphics mode 0x04, so it's requesting a graphics
                 * scroll rather than a text scroll to clear the screen, but once again, the coordinates are reversed,
                 * so much of the memory it zeroes is above the first 16K.
                 */
                if (card.nCard < Video.CARD.EGA) {
                    let addrBuffer = this.addrBuffer;
                    let aBlocks = this.bus.getMemoryBlocks(addrBuffer, this.sizeBuffer);
                    while ((addrBuffer += this.sizeBuffer) < card.addrBuffer + 0x8000) {
                        this.bus.setMemoryBlocks(addrBuffer, this.sizeBuffer, aBlocks);
                    }
                }
            }

            this.setDimensions();
            this.invalidateCellCache();

            if (fReset) this.updateScreen();
        }
        return true;
    }

    /**
     * setPixel(imageData, x, y, rgb)
     *
     * Worker function used by createFontColor() and updateScreen() (graphics modes only).
     *
     * @this {Video}
     * @param {Object} imageData
     * @param {number} x
     * @param {number} y
     * @param {Array.<number>} rgb is a 4-element array containing the red, green, blue and alpha values
     */
    setPixel(imageData, x, y, rgb)
    {
        let index = (x + y * imageData.width) * rgb.length;
        imageData.data[index] = rgb[0];
        imageData.data[index + 1] = rgb[1];
        imageData.data[index + 2] = rgb[2];
        imageData.data[index + 3] = rgb[3];
    }

    /**
     * initCellCache()
     *
     * Initializes the contents of our internal cell cache.
     *
     * TODO: Consider changing this to a cache of RGB values, so that when the buffer is merely being color-cycled,
     * we don't have to update the entire screen.  This would also allow invalidateCellCache() to honor the fColors
     * flag and bypass initCellCache() when it's set.
     *
     * @this {Video}
     * @return {number}
     */
    initCellCache()
    {
        this.cBlinkVisible = -1;                // force updateScreen() to recount visible blinking characters
        this.iCellCacheValid = 0;
        let nCells = this.nCellCache;
        if (this.aCellCache === undefined || this.aCellCache.length != nCells) {
            this.aCellCache = new Array(nCells);
        }
        return nCells;
    }

    /**
     * invalidateCellCache(fColors, nFontSelect, nFontPrev)
     *
     * Ensures the next updateScreen() will examine and update every cell as needed, even if the underlying
     * data in the video buffer has not changed (eg, when the screen is being panned, the page is being flipped,
     * the palette is being cycled, the font is being changed, etc).
     *
     * @this {Video}
     * @param {boolean} [fColors] (true if color(s) *may* have changed)
     * @param {number} [nFontSelect] (set along with nFontPrev if font(s) *may* have changed)
     * @param {number} [nFontPrev]
     * @return {number} (number of cells invalidated; used for diagnostic purposes only)
     */
    invalidateCellCache(fColors, nFontSelect, nFontPrev)
    {
        if (this.iCellCacheValid) {
            if (fColors !== false) {
                this.fRGBValid = false;
            }
            else if (nFontSelect !== undefined) {
                /*
                 * We want to do a "smart" (aka selective) invalidation of the cell cache, invalidating only
                 * those cells containing characters whose current font data differs from the previous font data.
                 */
                if (nFontSelect == nFontPrev) return 0;
                let aCellCache = this.aCellCache;
                let nCells = 0;
                /*
                 * getFontDiff() returns an empty array if the current and previous fonts are the same, which
                 * is OK for the code below, because using the "|" operator with undefined values coerces them
                 * to zero, resulting in no change.  If BOTH FontDiff arrays were empty, then we could skip this
                 * code altogether, but we've already eliminated that possibility above, when we checked for
                 * nFontSelect == nFontPrev, so at least one of these arrays will NOT be empty.
                 */
                let aFontDiff0 = this.getFontDiff(nFontSelect & 0xff, nFontPrev & 0xff);
                let aFontDiff1 = this.getFontDiff(nFontSelect >> 8, nFontPrev >> 8);
                for (let i = 0; i < aCellCache.length; i++) {
                    let data = aCellCache[i];
                    if (data >= 0) {
                        /*
                         * The font referenced by any given cell data *usually* only depends on low 8 bits (ie, the
                         * character data), but when the active and alternate fonts differ, bit 3 of the attribute data
                         * must be examined as well, and if it's set, then the alternate font must be used.
                         */
                        let aFontDiff = (data & 0x800)? aFontDiff1 : aFontDiff0;
                        if ((aCellCache[i] |= aFontDiff[data & 0xff]) < 0) {
                            this.iCellCacheValid = 1;
                            nCells++;
                        }
                    }
                }
                return nCells;
            } else {
                /*
                 * When no color change AND no font change has occurred, since the cache was at least partially
                 * valid already, we make sure it's partially valid.
                 */
                this.iCellCacheValid = 1;
                return 0;
            }
        }
        return this.initCellCache();
    }

    /**
     * updateChar(col, row, data, context)
     *
     * Updates a particular character cell (row,col) in the associated window.
     *
     * The data parameter is the attribute byte from the display buffer (fgnd attribute in the low nibble,
     * bgnd attribute in the high nibble), but updateScreen() supplements data with a couple internal attribute bits:
     *
     *      ATTRS.DRAW_FGND:    set for every cell whose fgnd element is currently on (ie, non-blinking, or whenever blink is on)
     *      ATTRS.DRAW_CURSOR:  set only for the cell containing the cursor, if any
     *
     * To make a character blink, we alternately draw its cell with ATTRS.DRAW_FGND set, and then again with
     * ATTRS.DRAW_FGND clear (meaning only the cell background is drawn).
     *
     * To make the cursor blink, we must alternately draw its entire cell with ATTRS.DRAW_CURSOR set, and then
     * draw it again with ATTRS.DRAW_CURSOR clear.
     *
     * @this {Video}
     * @param {number} col
     * @param {number} row
     * @param {number} data (if text mode, character code in low byte, attribute code in high byte)
     * @param {CanvasRenderingContext2D} [context]
     */
    updateChar(col, row, data, context)
    {
        let bChar = data & 0xff;
        let bAttr = data >> 8;
        /*
         * The font referenced by any given cell data *usually* only depends on low 8 bits (ie, the
         * character data), but when the active and alternate fonts differ, bit 3 of the attribute data
         * must be examined as well, and if it's set, then the alternate font must be used.
         */
        let font = this.aFonts[this.nActiveFont];
        if ((bAttr & 0x08) && this.nActiveFont != this.nAlternateFont) {
            font = this.aFonts[this.nAlternateFont];
            bAttr &= ~0x08;
        }
        let iFgnd = bAttr & 0x0f;
        if (font.aColorMap) iFgnd = font.aColorMap[iFgnd];

        /*
         * Just as aColorMap maps the foreground attribute to the appropriate foreground character grid,
         * it also maps the background attribute to the appropriate background color.
         */
        let xDst, yDst;
        let iBgnd = (bAttr >> 4) & 0x0f;
        if (font.aColorMap) iBgnd = font.aColorMap[iBgnd];

        if (context) {
            xDst = col * font.cxCell;
            yDst = row * font.cyCell;
            context.fillStyle = font.aCSSColors[iBgnd];
            context.fillRect(xDst, yDst, font.cxCell, font.cyCell);
        } else {
            xDst = col * this.cxScreenCell + this.xScreenOffset;
            yDst = row * this.cyScreenCell + this.yScreenOffset;
            this.contextScreen.fillStyle = font.aCSSColors[iBgnd];
            this.contextScreen.fillRect(xDst, yDst, this.cxScreenCell, this.cyScreenCell);
        }

        if (MAXDEBUG && this.messageEnabled(Messages.VIDEO | Messages.BUFFER)) {
            this.log("updateCharBgnd(" + col + "," + row + "," + bChar + "): filled " + xDst + "," + yDst);
        }

        if (bAttr & Video.ATTRS.DRAW_FGND) {
            /*
             * (bChar & 0xf) is the equivalent of (bChar % 16), and (bChar >> 4) is the equivalent of Math.floor(bChar / 16)
             */
            let xSrcFgnd = (bChar & 0xf) * font.cxCell;
            let ySrcFgnd = (bChar >> 4) * font.cyCell;

            if (MAXDEBUG && this.messageEnabled(Messages.VIDEO | Messages.BUFFER)) {
                this.log("updateCharFgnd(" + col + "," + row + "," + bChar + "): draw from " + xSrcFgnd + "," + ySrcFgnd + " (" + font.cxCell + "," + font.cyCell + ") to " + xDst + "," + yDst);
            }

            if (context) {
                context.drawImage(font.aCanvas[iFgnd], xSrcFgnd, ySrcFgnd, font.cxCell, font.cyCell, xDst, yDst, font.cxCell, font.cyCell);
            } else {
                this.contextScreen.drawImage(font.aCanvas[iFgnd], xSrcFgnd, ySrcFgnd, font.cxCell, font.cyCell, xDst, yDst, this.cxScreenCell, this.cyScreenCell);
            }
        }

        if (bAttr & Video.ATTRS.DRAW_CURSOR) {
            if (this.cyCursorWrap) {
                this.drawCursor(0, this.cyCursorWrap, xDst, yDst, iFgnd, font, context);
            }
            this.drawCursor(this.yCursor, this.cyCursor, xDst, yDst, iFgnd, font, context);
        }
    }

    /**
     * drawCursor(yCursor, cyCursor, xDst, yDst, iFgnd, font, context)
     *
     * We have factored the cursor-drawing code out of updateChar() so that we can call this function multiple times,
     * in case we have to draw a "split cursor" (something that only happens on the EGA).
     *
     * @this {Video}
     * @param {number} yCursor
     * @param {number} cyCursor
     * @param {number} xDst
     * @param {number} yDst
     * @param {number} iFgnd
     * @param {Font} font
     * @param {CanvasRenderingContext2D} [context]
     */
    drawCursor(yCursor, cyCursor, xDst, yDst, iFgnd, font, context)
    {
        /*
         * Drawing the cursor with lineTo() seemed logical, but it was complicated by the fact that the
         * TOP of the line must appear at "yDst + this.yCursor", whereas lineTo() wants to know the CENTER
         * of the line. So it's simpler to draw the cursor with another fillRect().  Here's the old code:
         *
         *      this.contextScreen.strokeStyle = font.aCSSColors[iFgnd];
         *      this.contextScreen.lineWidth = this.cyCursor;
         *      this.contextScreen.beginPath();
         *      this.contextScreen.moveTo(xDst, yDst + this.yCursor);
         *      this.contextScreen.lineTo(xDst + this.cxScreenCell, yDst + this.yCursor);
         *      this.contextScreen.stroke();
         *
         * Also, note that we're scaling the yCursor and cyCursor values here, instead of in checkCursor(), because
         * this is where we have all the required information: in the first case (off-screen buffer), the scaling must
         * be based on the font cell size (cxCell, cyCell), whereas in the second case (on-screen buffer), the scaling
         * must be based on the screen cell size (cxScreenCell,cyScreenCell).
         *
         * yCursor and cyCursor are actual hardware values, both relative to another hardware value: cyCursorCell.
         */
        if (context) {
            if (this.cyCursorCell && this.cyCursorCell !== font.cyCell) {
                yCursor = Math.round((yCursor * font.cyCell) / this.cyCursorCell);
                cyCursor = Math.round((cyCursor * font.cyCell) / this.cyCursorCell);
            }
            context.fillStyle = font.aCSSColors[iFgnd];
            context.fillRect(xDst, yDst + yCursor, font.cxCell, cyCursor);
        } else {
            if (this.cyCursorCell && this.cyCursorCell !== this.cyScreenCell) {
                yCursor = Math.round((yCursor * this.cyScreenCell) / this.cyCursorCell);
                cyCursor = Math.round((cyCursor * this.cyScreenCell) / this.cyCursorCell);
            }
            this.contextScreen.fillStyle = font.aCSSColors[iFgnd];
            this.contextScreen.fillRect(xDst, yDst + yCursor, this.cxScreenCell, cyCursor);
        }
    }

    /**
     * latchStartAddress()
     *
     * @this {Video}
     */
    latchStartAddress()
    {
        let card = this.cardActive;
        let offStart = card.regCRTData[Card.CRTC.STARTLO];
        offStart |= (card.regCRTData[Card.CRTC.STARTHI] & card.addrMaskHigh) << 8;
        if (card.offStart !== offStart) {
            card.offStart = offStart;
            this.invalidateCellCache(false);
        }
        let rowStart = (card == this.cardEGA? (card.regCRTData[Card.CRTC.EGA.PRESCAN] & Card.CRTC.EGA.MAXSCAN.SLMASK) : 0);
        if (card.rowStart !== rowStart) {
            card.rowStart = rowStart;
            this.nShiftUp = 0;
            if (this.fOverBuffer) {
                this.fShifted = true;
                this.nShiftUp = rowStart & Card.CRTC.EGA.MAXSCAN.SLMASK;
            }
        }

    }

    /**
     * updateScreen(fForce)
     *
     * Propagates the video buffer to the cell cache and updates the screen with any changes.  Forced updates
     * are generally internal updates triggered by an I/O operation or other state change, while non-forced updates
     * are the periodic updates coming from the CPU.
     *
     * @this {Video}
     * @param {boolean} [fForce] is used by setMode() to reset the cell cache and force a redraw
     * @return {boolean}
     */
    updateScreen(fForce = false)
    {
        /*
         * The Computer component maintains the fPowered setting on our behalf, so we use it.
         */
        if (!this.flags.powered) return false;

        /*
         * If the card's video signal is disabled (eg, during a mode change), then skip the update,
         * unless fForce is set.
         */
        let card = this.cardActive;
        if (!card) return false;

        let fEnabled = false;
        if (card !== this.cardEGA) {
            if (card.regMode & Card.CGA.MODE.VIDEO_ENABLE) fEnabled = true;
        }
        else {
            if (card.regATCIndx & Card.ATC.INDX_PAL_ENABLE) fEnabled = true;
        }

        if (!fEnabled && !fForce) return false;

        if (fForce) {
            this.initCellCache();
        }
        else {
            /*
             * This should never happen, but since updateScreen() is also called by Computer.updateStatus(),
             * better safe than sorry.
             */
            if (this.aCellCache === undefined) return false;
        }

        /*
         * If cBlinks is "enabled" (ie, >= 0), then advance it once every 10 updateScreen() calls;
         * this assumes an updateScreen() frequency of 60 per second; see Video.UPDATES_PER_SECOND.
         *
         * We assume that the CPU is calling us whenever fForce is undefined.
         */
        let fBlinkUpdate = false;
        if (!fForce && !(++this.cUpdates % 10) && this.cBlinks >= 0) {
            this.cBlinks++;
            fBlinkUpdate = true;
        }

        let iCell = 0;
        let nCells = this.nCells;

        /*
         * Calculate the VISIBLE start of screen memory (addrScreen), not merely the PHYSICAL start,
         * as well as the extent of it (cbScreen) and use those values for all addressing operations to follow.
         * FYI, in these calculations, offScreen does not refer to "off-screen" memory, but rather the "offset"
         * of the start of visible screen memory.
         */
        let addrBuffer = this.addrBuffer;
        let addrScreen = addrBuffer;
        let addrScreenLimit = addrScreen + this.sizeBuffer;

        /*
         * HACK: To deal with the fTextGraphicsHybrid 320x400 mode that Windows 95 uses (ie, when the buffer
         * is mapped to B800:0000 instead of A000:0000 and is configured for text mode access, but graphics are
         * still being displayed from the second half of video memory), we must ignore the programmed address.
         *
         * In that case, the hard-coded address range below isn't actually active either, but it doesn't matter;
         * we just have to get through the rest of this function and make it to the updateScreenGraphicsVGA() call,
         * which will draw from our video buffer (adwMemory) directly; these addresses are only used for bounds
         * checking.
         */
        if (this.nMode >= Video.MODE.VGA_320X200) {
            addrBuffer = addrScreen = 0xA0000;
            addrScreenLimit = addrScreen + 0x10000;
        }

        let cbScreen = this.cbScreen;
        this.nColsLogical = this.nCols;

        if (this.nCard < Video.CARD.EGA) {
            /*
             * Any screen (aka "page") offset must be doubled for text modes, due to the attribute bytes.
             */
            addrScreen += card.offStart << (this.nCardFont? 1 : 0);
        } else {
            /*
             * For the EGA/VGA, we must make offset-doubling dependent on attribute (odd) byte addressibility.
             * For example, Fantasy Land uses a text-mode buffer mapped at 0xA0000 without odd/even addressing.
             *
             * TODO: Setting nPointsPerByte properly would ideally be taken care of in setDimensions(), but there's
             * no guarantee this particular controller tweak will be made BEFORE we detect and initiate a mode change.
             */
            let shiftAddr = 0, shiftCols = 0;
            let bMemMode = this.cardEGA.regSEQData[Card.SEQ.MEMMODE.INDX] & (Card.SEQ.MEMMODE.ALPHA | Card.SEQ.MEMMODE.SEQUENTIAL);
            if (bMemMode == Card.SEQ.MEMMODE.ALPHA) {
                shiftAddr = shiftCols = 1;
                this.nPointsPerByte = 0.5;
            } else if (bMemMode == (Card.SEQ.MEMMODE.ALPHA | Card.SEQ.MEMMODE.SEQUENTIAL)) {
                shiftCols = 1;
                this.nPointsPerByte = 1.0;
            }
            addrScreen += card.offStart << shiftAddr;
            if (card.regCRTData[Card.CRTC.EGA.OFFSET] && (card.regCRTData[Card.CRTC.EGA.OFFSET] << 1) != card.regCRTData[Card.CRTC.EGA.HDEND] + 1) {
                /*
                 * Pre-EGA, the extent of visible screen memory (cbScreen) was derived from nCols * nRows, but since
                 * then, the logical width of screen memory (nColsLogical) can differ from the visible width (nCols).
                 * We now calculate the logical width, and the compute a new cbScreen in much the same way the original
                 * cbScreen was computed (but without any CGA-related padding considerations).
                 */
                this.nColsLogical = card.regCRTData[Card.CRTC.EGA.OFFSET] << (shiftCols || ((card.regCRTData[Card.CRTC.EGA.UNDERLINE.INDX] & Card.CRTC.EGA.UNDERLINE.DWORD)? 3 : 4));
                cbScreen = ((this.nColsLogical * (this.nRowsBuffer - 1) + this.nColsBuffer) / this.nPointsPerByte)|0;
                /*
                 * If nRowsBuffer is larger than nRows (ie, over-buffering is enabled), we run the risk of attempting
                 * to render past the limit of the frame buffer (addrScreenLimit); we're ONLY over-buffering in case the
                 * the app decides to pan vertically, revealing pixels below the last full row, and obviously if there
                 * isn't an additional row of data below that last full row, then we shouldn't over-buffer this time.
                 */
                if (this.nRowsBuffer > this.nRows && addrScreen + cbScreen > addrScreenLimit) {
                    cbScreen = ((this.nColsLogical * (this.nRows - 1) + this.nColsBuffer) / this.nPointsPerByte)|0;
                }
            }
        }

        /*
         * If the amount of data (cbScreen) we need to display goes beyond the end of the screen buffer
         * (addrScreenLimit), then the assumption is that we will have to do a second update operation that
         * wraps around to addrBuffer.
         */
        let addrScreenWrap = 0, cbScreenWrap = 0;
        if (addrScreen + cbScreen > addrScreenLimit) {
            /*
             * There are two possibilities here: addrScreen itself is at or beyond addrScreenLimit, or just a
             * portion of cbScreen goes beyond the limit.  We'll deal with the first case first.
             */
            cbScreenWrap = cbScreen;
            if (addrScreen >= addrScreenLimit) {
                addrScreenWrap = addrBuffer + (addrScreen - addrScreenLimit);
                cbScreen = 0;
            } else {
                addrScreenWrap = addrBuffer;
                cbScreen = addrScreenLimit - addrScreen;
                cbScreenWrap -= cbScreen;
            }
        }
        else if (this.nCard >= Video.CARD.EGA) {
            /*
             * We can leverage our screen wrap support to handle split-screen views as well; we must calculate
             * the number of WHOLE + PARTIAL rows we can draw (which may reduce cbScreen).  TODO: We must also pass
             * along the height of any PARTIAL row, so that pixel-level split-screens can eventually be supported.
             */
            let nRowsHidden = card.getCRTCReg(Card.CRTC.EGA.VDEND) - card.getCRTCReg(Card.CRTC.EGA.LINECOMP);
            if (nRowsHidden > 0) {
                let font = this.aFonts[this.nActiveFont];
                if (font) {
                    nRowsHidden = (nRowsHidden / font.cyChar)|0;
                }
                if (nRowsHidden > 0) {
                    cbScreenWrap = ((this.nColsLogical * (nRowsHidden - 1) + this.nColsBuffer) / this.nPointsPerByte)|0;
                    cbScreen -= ((this.nColsLogical * nRowsHidden) / this.nPointsPerByte)|0;
                    addrScreenWrap = addrBuffer;
                }
            }
        }

        /*
         * updateScreenCells() no longer "scrubs" the screen buffer itself; we call cleanMemory() afterward
         * to take care of that.  This has two benefits: 1) if this was a "forced" updated (or an update to make
         * the cell cache valid), cleaning the screen buffer ourselves reflects the fact that both it and our
         * display are now "in sync"; 2) if screen wrap-around is in effect, we don't want to scrub either subset
         * of the screen until both subsets have been updated, otherwise the second update may erroneously think
         * that nothing changed if it happens to share any blocks with the first.
         */
        let cBlinkOrig = this.cBlinkVisible;
        let cCells = this.updateScreenCells(addrBuffer, addrScreen, cbScreen, iCell, nCells, fForce, fBlinkUpdate);
        if (cbScreenWrap) {
            iCell += cCells;
            let cBlinkNew = this.cBlinkVisible;
            if (cBlinkOrig < 0) this.cBlinkVisible = -1;
            cCells += this.updateScreenCells(addrBuffer, addrScreenWrap, cbScreenWrap, iCell, nCells, fForce, fBlinkUpdate);
            this.cBlinkVisible += cBlinkNew;
            this.bus.cleanMemory(addrScreenWrap, cbScreenWrap, true);
        }
        this.bus.cleanMemory(addrScreen, cbScreen, true);
        if (cCells) this.iCellCacheValid = 2;
        return true;
    }

    /**
     * updateScreenCells(addrBuffer, addrScreen, cbScreen, iCell, nCells, fForce, fBlinkUpdate)
     *
     * @this {Video}
     * @param {number} addrBuffer
     * @param {number} addrScreen
     * @param {number} cbScreen
     * @param {number} iCell
     * @param {number} nCells
     * @param {boolean} fForce
     * @param {boolean} fBlinkUpdate
     * @return {number} (number of cells processed)
     */
    updateScreenCells(addrBuffer, addrScreen, cbScreen, iCell, nCells, fForce, fBlinkUpdate)
    {
        /*
         * When determining the number of cells this update may affect, it is NOT simply cbScreen
         * multiplied by nPointsPerByte, because cbScreen includes any and all off-screen cells, too.
         */
        let cCells = cbScreen * this.nPointsPerByte;
        cCells = Math.trunc(cCells / this.nColsLogical) * this.nColsBuffer + (cCells % this.nColsLogical);
        if (cCells > nCells) cCells = nCells;
        let addrScreenLimit = addrScreen + cbScreen;

        /*
         * This next bit of code can be completely disabled if we discover problems with the dirty
         * memory block tracking feature or we need to remove or disable that feature in the future.
         *
         * We use cleanMemory() to check the video buffer's dirty state.  If the buffer is clean
         * AND there are no visible blinking characters (as of the last updateScreen) AND there is
         * no visible cursor, then we're done; simply return.  Otherwise, if there's only a blinking
         * cursor, then update JUST that one cell.
         */
        if (!fForce && this.iCellCacheValid == 2 && this.bus.cleanMemory(addrScreen, cbScreen)) {
            if (!fBlinkUpdate && this.cBlinkVisible >= 0) {
                if (!this.fShifted) return cCells;
                iCell = nCells;
            }
            else if (!this.cBlinkVisible) {
                /*
                 * iCellCursor may be negative if the cursor is hidden or if it's not on the visible screen.
                 */
                let iCellCursor = this.iCellCursor - iCell;
                if (iCellCursor < 0) {
                    if (!this.fShifted) return cCells;
                    iCell = nCells;
                }
                else {
                    let row = (iCellCursor / this.nColsBuffer)|0;
                    let col = (iCellCursor % this.nColsBuffer);
                    addrScreen += (row * this.nColsLogical + col) << 1;
                    iCell += iCellCursor;
                    nCells = iCell + 1;
                }
            }
            // else if (this.cBlinks & 0x1) return cCells;
        }

        if (this.nActiveFont) {
            /*
             * This is the text-mode update case.
             */
            this.updateScreenText(addrBuffer, addrScreen, addrScreenLimit, iCell, nCells);
        }
        else if (this.cbSplit) {
            /*
             * All CGA graphics modes have the goofy split-buffer layout, hence the simple test above.
             */
            cCells = this.updateScreenGraphicsCGA(addrScreen, addrScreenLimit);
        }
        else if (!this.fColor256) {
            /*
             * All EGA graphics modes are taken care of here, including all 16-color VGA graphics modes.
             */
            cCells = this.updateScreenGraphicsEGA(addrBuffer, addrScreen, addrScreenLimit);
        }
        else {
            /*
             * Finally, all 256-color VGA modes are processed here.
             */
            cCells = this.updateScreenGraphicsVGA(addrBuffer, addrScreen, addrScreenLimit);
        }

        this.fShifted = false;

        return cCells;
    }

    /**
     * updateScreenText(addrBuffer, addrScreen, addrScreenLimit, iCell, nCells)
     *
     * @this {Video}
     * @param {number} addrBuffer
     * @param {number} addrScreen
     * @param {number} addrScreenLimit
     * @param {number} iCell
     * @param {number} nCells
     * @return {number} (number of cells processed)
     */
    updateScreenText(addrBuffer, addrScreen, addrScreenLimit, iCell, nCells)
    {
        let font = this.aFonts[this.nActiveFont];
        if (!font) return 0;

        /*
         * If MDA.MODE.BLINK_ENABLE is set and a cell's blink bit is set, then if (cBlinks & 0x2) != 0,
         * we want the foreground element of the cell to be drawn; otherwise we don't.  So every 16-bit
         * data word we pull from the video buffer will be supplemented with our own special attribute bit
         * (ATTRS.DRAW_FGND = 0x100) accordingly; and to simplify the drawing code, we will also mask the
         * blink bit from the cell's attribute bits.
         *
         * If MDA.MODE.BLINK_ENABLE is clear, then we always set ATTRS.DRAW_FGND and never mask the blink
         * bit in a cell's attributes bits, since it's actually an intensity bit in that case.
         */
        let card = this.cardActive;
        let cCells = 0, cUpdated = 0;
        let dataBlink = 0;
        let dataDraw = (Video.ATTRS.DRAW_FGND << 8);
        let dataMask = 0xfffff;
        let adwMemory = card.adwMemory;

        /*
         * Normally, cbCell will be 2, when attribute bytes are addressible (interleaved) with character bytes,
         * but Fantasy Land is an exception.  Which is another great reason why the loop below needs to get both
         * bytes directly from adwMemory, because reading them with bus.getShortDirect(addrScreen) won't always work.
         */
        let cbCell = (1 / this.nPointsPerByte)|0;
        let nShift = (card.nAccess & Card.ACCESS.WRITE.PAIRS)? 1 : 0;

        let fBlinkEnable = (card.regMode & Card.MDA.MODE.BLINK_ENABLE);
        if (this.nCard >= Video.CARD.EGA) {
            fBlinkEnable = (card.regATCData[Card.ATC.MODE.INDX] & Card.ATC.MODE.BLINK_ENABLE);
        }

        if (fBlinkEnable) {
            dataBlink = (Video.ATTRS.BGND_BLINK << 8);
            dataMask &= ~dataBlink;
            if (!(this.cBlinks & 0x2)) dataMask &= ~dataDraw;
        }

        this.cBlinkVisible = 0;
        let col = iCell % this.nColsBuffer;
        let row = (iCell / this.nColsBuffer) | 0;
        let nbRowExtra = (this.nColsLogical - this.nColsBuffer /* - iCellFirst */) << (cbCell - 1);

        while (addrScreen < addrScreenLimit && iCell < nCells) {

            let idw = (addrScreen - addrBuffer) >>> nShift;


            let data = (adwMemory[idw] & 0xffff);

            data |= dataDraw;
            if (data & dataBlink) {
                this.cBlinkVisible++;
                data &= dataMask;
            }
            if (iCell == this.iCellCursor) {
                data |= ((this.cBlinks & 0x1)? (Video.ATTRS.DRAW_CURSOR << 8) : 0);
            }



            if (!this.iCellCacheValid || data !== this.aCellCache[iCell]) {
                this.updateChar(col, row, data, this.contextBuffer);
                this.aCellCache[iCell] = data;
                cUpdated++;
            }

            cCells++;
            iCell++;
            addrScreen += cbCell;
            if (++col >= this.nColsBuffer) {
                col = 0;
                if (++row >= this.nRowsBuffer) break;
                addrScreen += nbRowExtra;
            }
        }

        if (this.contextBuffer && (cUpdated || this.fShifted)) {
            let xBuffer = 0, yBuffer = 0;
            let cxBuffer = this.cxBuffer;
            let cyBuffer = this.cyBuffer;
            if (this.fOverBuffer) {
                let xShift = this.nShiftLeft;
                let yShift = this.nShiftUp;
                if (this.fDoubleFont) {
                    xShift <<= 1;
                    yShift <<= 1;
                }
                xBuffer += xShift;
                yBuffer += yShift;
                cxBuffer -= font.cxCell;
                cyBuffer -= font.cyCell;
            }
            this.contextScreen.drawImage(this.canvasBuffer, xBuffer, yBuffer, cxBuffer, cyBuffer, this.xScreenOffset, this.yScreenOffset, this.cxScreenOffset, this.cyScreenOffset);
        }

        this.checkBlink();
        return cCells;
    }

    /**
     * updateScreenGraphicsCGA(addrScreen, addrScreenLimit)
     *
     * @this {Video}
     * @param {number} addrScreen
     * @param {number} addrScreenLimit
     * @return {number} (number of cells processed)
     */
    updateScreenGraphicsCGA(addrScreen, addrScreenLimit)
    {
        /*
         * This is the CGA graphics-mode update case, where cells are pixels spread across two halves of the buffer.
         */
        let cCells = (addrScreenLimit - addrScreen) >> 1;
        let iCell = 0, nPixelsPerCell = this.nPointsPerCell;
        let addr = addrScreen;
        let wPixelMask = (nPixelsPerCell == 16? 0x10000 : 0x30000);
        let nPixelShift = (nPixelsPerCell == 16? 1 : 2);
        let aPixelColors = this.getCardColors(nPixelShift);

        let x = 0, y = 0;
        let xDirty = this.nCols, xMaxDirty = 0, yDirty = this.nRows, yMaxDirty = 0;

        this.cBlinkVisible = 0;
        while (addr < addrScreenLimit) {
            let data = this.bus.getShortDirect(addr);

            if (this.iCellCacheValid && data === this.aCellCache[iCell]) {
                x += nPixelsPerCell;
            } else {
                this.aCellCache[iCell] = data;
                let wPixels = (data >> 8) | ((data & 0xff) << 8);
                let wMask = wPixelMask, nShift = 16;
                if (x < xDirty) xDirty = x;
                for (let iPixel = 0; iPixel < nPixelsPerCell; iPixel++) {
                    let bPixel = (wPixels & (wMask >>= nPixelShift)) >> (nShift -= nPixelShift);
                    this.setPixel(this.imageBuffer, x++, y, aPixelColors[bPixel]);
                }
                if (x > xMaxDirty) xMaxDirty = x;
                if (y < yDirty) yDirty = y;
                if (y >= yMaxDirty) yMaxDirty = y + 1;
            }
            addr += 2;
            iCell++;
            if (x >= this.nCols) {
                x = 0;
                y += 2;
                if (y > this.nRows)
                    break;
                if (y == this.nRows) {
                    y = 1;
                    addr = addrScreen + this.cbSplit;
                }
            }
        }

        /*
         * Instead of blasting the ENTIRE imageBuffer into contextBuffer, and then blasting the ENTIRE
         * canvasBuffer onto contextScreen, e{ven for the smallest change, let's try to be a bit smarter about
         * the update (well, to the extent that the canvas APIs permit).
         */
        if (xDirty < this.nCols) {
            let cxDirty = xMaxDirty - xDirty;
            let cyDirty = yMaxDirty - yDirty;
            // this.contextBuffer.putImageData(this.imageBuffer, 0, 0);
            this.contextBuffer.putImageData(this.imageBuffer, 0, 0, xDirty, yDirty, cxDirty, cyDirty);
            /*
             * While ideally I would draw only the dirty portion of canvasBuffer, there usually isn't a 1-1 pixel mapping
             * between canvasBuffer and contextScreen.  In fact, the WHOLE POINT of the canvasBuffer is to leverage
             * drawImage()'s scaling ability; for example, a CGA graphics mode might be 640x200, whereas the canvas representing
             * the screen might be 960x400.  In those situations, if we draw interior rectangles, we often end up with subpixel
             * artifacts along the edges of those rectangles.  So it appears I must continue to redraw the entire canvasBuffer
             * on every change.
             *
            let xScreen = (((xDirty * this.cxScreen) / this.nCols) | 0);
            let yScreen = (((yDirty * this.cyScreen) / this.nRows) | 0);
            let cxScreen = (((cxDirty * this.cxScreen) / this.nCols) | 0);
            let cyScreen = (((cyDirty * this.cyScreen) / this.nRows) | 0);
            this.contextScreen.drawImage(this.canvasBuffer, xDirty, yDirty, cxDirty, cyDirty, xScreen, yScreen, cxScreen, cyScreen);
             */
            this.contextScreen.drawImage(this.canvasBuffer, 0, 0, this.nCols, this.nRows, 0, 0, this.cxScreen, this.cyScreen);
        }
        return cCells;
    }

    /**
     * updateScreenGraphicsEGA(addrBuffer, addrScreen, addrScreenLimit)
     *
     * TODO: Add support for blinking graphics (ATC.MODE.BLINK_ENABLE)
     *
     * @this {Video}
     * @param {number} addrBuffer
     * @param {number} addrScreen
     * @param {number} addrScreenLimit
     * @return {number} (number of cells processed)
     */
    updateScreenGraphicsEGA(addrBuffer, addrScreen, addrScreenLimit)
    {
        let iCell = 0;
        let cCells = addrScreenLimit - addrScreen;
        let aPixelColors = this.getCardColors();
        let adwMemory = this.cardActive.adwMemory;

        let x = 0, y = 0;
        let xDirty = this.nCols, xMaxDirty = 0, yDirty = this.nRows, yMaxDirty = 0;
        let iPixelFirst = this.cardActive.regATCData[Card.ATC.HPAN.INDX] & Card.ATC.HPAN.SHIFT_LEFT;

        /*
         * TODO: What should happen if the card is programmed such that nColsLogical is LESS THAN nCols?
         */
        let nRowAdjust = (this.nColsLogical > this.nCols? ((this.nColsLogical - this.nCols - iPixelFirst) >> 3) : 0);

        this.cBlinkVisible = 0;
        while (addrScreen < addrScreenLimit) {
            let idw = addrScreen++ - addrBuffer;

            let data = adwMemory[idw];

            /*
             * Figure out how many visible pixels this data represents; usually 8, unless panning is being used.
             */
            let iPixel, nPixels = 8;

            if (iPixelFirst) {
                /*
                 * Notice that we're not using the cell cache when panning is active, because the cached cell data no
                 * longer aligns with the data we're pulling out of the video buffer, and it's not clear that the effort
                 * to realign the data and make a valid cache comparison would save enough work to make it worthwhile.
                 */
                if (!x) {
                    data <<= iPixelFirst;
                    nPixels -= iPixelFirst;
                    /*
                     * This is as good a place as any to invalidate the cell cache when panning is active; this ensures
                     * we don't rely on stale cache contents once panning stops.
                     */
                    this.iCellCacheValid = 0;
                } else {
                    iPixel = this.nCols - x;
                    if (nPixels > iPixel) nPixels = iPixel;
                }
            } else {

                if (this.iCellCacheValid && data === this.aCellCache[iCell]) {
                    x += nPixels;
                    nPixels = 0;
                } else {
                    this.aCellCache[iCell] = data;
                }
                iCell++;
            }

            if (nPixels) {
                if (x < xDirty) xDirty = x;
                for (iPixel = 0; iPixel < nPixels; iPixel++) {
                    /*
                     * 0x80808080 may LOOK like a 32-bit value, but it is not, because JavaScript treats it as a POSITIVE
                     * number, and therefore outside the normal 32-bit integer range; however, the AND operator guarantees
                     * that the result will be a 32-bit value, so it doesn't matter.
                     */
                    let dwPixel = data & 0x80808080;

                    /*
                     * We now ensure that bPixel will default to 0 if an undefined value ever slips through again.
                     *
                     * How did an undefined value slip through?  We had (incorrectly) initialized entries in aEGADWToByte;
                     * for example, we used to set aEGADWToByte[0x80808080] instead of aEGADWToByte[0x80808080|0].  The
                     * former is a POSITIVE index that is outside the 32-bit integer range, whereas the latter is a NEGATIVE
                     * index, which is what this code requires.
                     */
                    let bPixel = Video.aEGADWToByte[dwPixel] || 0;
                    this.setPixel(this.imageBuffer, x++, y, aPixelColors[bPixel]);
                    data <<= 1;
                }
                if (x > xMaxDirty) xMaxDirty = x;
                if (y < yDirty) yDirty = y;
                if (y >= yMaxDirty) yMaxDirty = y + 1;
            }



            if (x >= this.nCols) {
                x = 0;
                if (++y >= this.nRows) break;
                addrScreen += nRowAdjust;
            }
        }

        if (iPixelFirst) cCells = 0;    // zero the cell count to inhibit setting iCellCacheValid

        /*
         * For a fascinating discussion of the best way to update the screen canvas at this point, see updateScreenGraphicsCGA().
         */
        if (xDirty < this.nCols) {
            let cxDirty = xMaxDirty - xDirty;
            let cyDirty = yMaxDirty - yDirty;
            this.contextBuffer.putImageData(this.imageBuffer, 0, 0, xDirty, yDirty, cxDirty, cyDirty);
            this.contextScreen.drawImage(this.canvasBuffer, 0, 0, this.nCols, this.nRows, 0, 0, this.cxScreen, this.cyScreen);
        }
        return cCells;
    }

    /**
     * updateScreenGraphicsVGA(addrBuffer, addrScreen, addrScreenLimit)
     *
     * This function name is a slight misnomer: updateScreenGraphicsEGA() takes care of all the 4bpp video modes
     * (first introduced by the EGA and later expanded by the VGA), where each pixel's bits are spread across the 4
     * planes, whereas this function takes care of just the 8bpp video modes introduced by the VGA, such as mode 0x13
     * (320x200x256), where each pixel's bits are contained within a single plane.  This is essentially all 256-color
     * modes (CHAIN4, "Mode X", etc), hence the hard-coded call to getCardColors(8).
     *
     * TODO: Add support for blinking graphics (ATC.MODE.BLINK_ENABLE)
     *
     * @this {Video}
     * @param {number} addrBuffer
     * @param {number} addrScreen
     * @param {number} addrScreenLimit
     * @return {number} (number of cells processed)
     */
    updateScreenGraphicsVGA(addrBuffer, addrScreen, addrScreenLimit)
    {
        let iCell = 0;
        let cCells = addrScreenLimit - addrScreen;
        let addr = addrScreen;
        let aPixelColors = this.getCardColors(8);
        let adwMemory = this.cardActive.adwMemory;

        let x = 0, y = 0;
        let xDirty = this.nCols, xMaxDirty = 0, yDirty = this.nRows, yMaxDirty = 0;
        let cbInc = (this.cardActive.regSEQData[Card.SEQ.MEMMODE.INDX] & Card.SEQ.MEMMODE.CHAIN4)? 4 : 1;
        let iPixelFirst = this.cardActive.regATCData[Card.ATC.HPAN.INDX] & Card.ATC.HPAN.SHIFT_LEFT;

        /*
         * TODO: What should happen if the card is programmed such that nColsLogical is LESS THAN nCols?
         */
        let nRowAdjust = (this.nColsLogical > this.nCols? ((this.nColsLogical - this.nCols - iPixelFirst) >> 3) : 0);

        this.cBlinkVisible = 0;
        while (addr < addrScreenLimit) {
            let idw = addr - addrBuffer;

            let data = adwMemory[idw];

            /*
             * Figure out how many visible pixels this data represents; usually 4, unless panning is being used.
             */
            let iPixel, nPixels = 4;

            if (iPixelFirst) {
                /*
                 * TODO: Implement support for 8bpp panning
                 */
            } else {

                if (this.iCellCacheValid && data === this.aCellCache[iCell]) {
                    x += nPixels;
                    nPixels = 0;
                } else {
                    this.aCellCache[iCell] = data;
                }
                iCell++;
            }

            if (nPixels) {
                if (x < xDirty) xDirty = x;
                for (iPixel = 0; iPixel < nPixels; iPixel++) {
                    this.setPixel(this.imageBuffer, x++, y, aPixelColors[data & 0xff]);
                    data >>>= 8;
                }
                if (x > xMaxDirty) xMaxDirty = x;
                if (y < yDirty) yDirty = y;
                if (y >= yMaxDirty) yMaxDirty = y + 1;
            }



            addr += cbInc;

            if (x >= this.nCols) {
                x = 0;
                if (++y >= this.nRows) break;
                addr += nRowAdjust;
            }
        }

        if (iPixelFirst) cCells = 0;    // zero the cell count to inhibit setting iCellCacheValid

        /*
         * For a fascinating discussion of the best way to update the screen canvas at this point, see updateScreenGraphicsCGA().
         */
        if (xDirty < this.nCols) {
            let cxDirty = xMaxDirty - xDirty;
            let cyDirty = yMaxDirty - yDirty;
            this.contextBuffer.putImageData(this.imageBuffer, 0, 0, xDirty, yDirty, cxDirty, cyDirty);
            this.contextScreen.drawImage(this.canvasBuffer, 0, 0, this.nCols, this.nRows, 0, 0, this.cxScreen, this.cyScreen);
        }
        return cCells;
    }

    /**
     * getRetraceBits(card)
     *
     * This returns a byte value with two bits set or clear as appropriate: RETRACE and VRETRACE.
     *
     * @this {Video}
     * @param {Object} card
     * @return {number}
     */
    getRetraceBits(card)
    {
        /*
         * NOTE: The bits CGA.STATUS.RETRACE (0x01) and CGA.STATUS.VRETRACE (0x08) match the EGA definitions,
         * and they also correspond to the MDA bits MDA.STATUS.HDRIVE (0x01) and MDA.STATUS.BWVIDEO (0x08); it's
         * unclear why the MDA uses different designations, but the bits appear to serve the same purpose.
         */
        let b = 0;
        let nCycles = this.cpu.getCycles();
        let nCyclesElapsed = nCycles - card.nCyclesVertRetrace;
        if (nCyclesElapsed < 0) {       // perhaps the CPU decided to reset its cycle count?
            card.nCyclesVertRetrace = nCycles;
            nCyclesElapsed = 0;
        }
        nCyclesElapsed -= card.nCyclesVertPeriod - card.nCyclesVertActive;
        if (nCyclesElapsed < 0) {
            b |= Card.CGA.STATUS.VRETRACE | Card.CGA.STATUS.RETRACE;
            // this.printf("vertical retrace (%d cycles)\n", nCyclesElapsed);
        } else {
            let nCyclesHorzRemain = nCyclesElapsed % card.nCyclesHorzPeriod;
            if (nCyclesHorzRemain > card.nCyclesHorzActive) {
                b |= Card.CGA.STATUS.RETRACE;
                // this.printf("horizontal retrace (%d cycles)\n", nCyclesElapsed);
            } else {
                // this.printf("no retrace (%d cycles)\n", nCyclesElapsed);
            }
        }
        return b;
    }

    /**
     * inMDAIndx(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3B4)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number|undefined}
     */
    inMDAIndx(port, addrFrom)
    {
        return this.inCRTCIndx(this.cardMono, port, addrFrom);
    }

    /**
     * outMDAIndx(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3B4)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outMDAIndx(port, bOut, addrFrom)
    {
        this.outCRTCIndx(this.cardMono, port, bOut, addrFrom);
    }

    /**
     * inMDAData(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3B5)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number|undefined}
     */
    inMDAData(port, addrFrom)
    {
        return this.inCRTCData(this.cardMono, port, addrFrom);
    }

    /**
     * outMDAData(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3B5)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outMDAData(port, bOut, addrFrom)
    {
        this.outCRTCData(this.cardMono, port, bOut, addrFrom);
    }

    /**
     * inMDAMode(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3B8)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inMDAMode(port, addrFrom)
    {
        return this.inCardMode(this.cardMono, addrFrom);
    }

    /**
     * outMDAMode(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3B8)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outMDAMode(port, bOut, addrFrom)
    {
        this.outCardMode(this.cardMono, bOut, addrFrom);
    }

    /**
     * inMDAStatus(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3BA)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inMDAStatus(port, addrFrom)
    {
        return this.inCardStatus(this.cardMono, addrFrom);
    }

    /**
     * outFeat(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3BA or 0x3DA)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     *
     * NOTE: While this port also existed on the MDA and CGA, it existed only as an INPUT port, not an OUTPUT port.
     */
    outFeat(port, bOut, addrFrom)
    {
        this.cardEGA.regFeat = (this.cardEGA.regFeat & ~Card.FEAT_CTRL.BITS) | (bOut & Card.FEAT_CTRL.BITS);
        this.printMessageIO(port, bOut, addrFrom, "FEAT");
    }

    /**
     * inATCIndx(port, addrFrom)
     *
     * Technically, port 0x3C0 is readable only on a VGA, but we allow reads on an EGA as well,
     * primarily for debugging purposes.  Moreover, ATC port reads do NOT toggle the ATC address/data
     * flip-flop; only writes have that effect.
     *
     * @this {Video}
     * @param {number} port (0x3C0)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inATCIndx(port, addrFrom)
    {
        let b = this.cardEGA.regATCIndx;
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.ATC.PORT, undefined, addrFrom, "ATC.INDX", b);
        }
        return b;
    }

    /**
     * inATCData(port, addrFrom)
     *
     * Technically, port 0x3C0 is readable only on a VGA, but we allow reads on an EGA as well,
     * primarily for debugging purposes.  Moreover, ATC port reads do NOT toggle the ATC address/data
     * flip-flop; only writes have that effect.
     *
     * @this {Video}
     * @param {number} port (0x3C1)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inATCData(port, addrFrom)
    {
        let b = this.cardEGA.regATCData[this.cardEGA.regATCIndx & Card.ATC.INDX_MASK];
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.ATC.PORT, undefined, addrFrom, "ATC." + this.cardEGA.asATCRegs[this.cardEGA.regATCIndx & Card.ATC.INDX_MASK], b);
        }
        return b;
    }

    /**
     * outATC(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C0)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outATC(port, bOut, addrFrom)
    {
        let card = this.cardEGA;
        let fPalEnabled = (card.regATCIndx & Card.ATC.INDX_PAL_ENABLE);
        if (!card.fATCData) {
            card.regATCIndx = bOut;
            this.printMessageIO(port, bOut, addrFrom, "ATC.INDX");
            card.fATCData = true;
            if ((bOut & Card.ATC.INDX_PAL_ENABLE) && !fPalEnabled) {
                /*
                 * TODO: Consider whether it's really necessary (or desirable) to immediately update the screen
                 * on a font change, or if it's sufficient to simply wait until the next normal periodic update.
                 */
                if (this.buildFont(true)) {
                    this.updateScreen(true);
                }
            }
            else {
                /*
                 * TODO: We might want a screen blanking function, suitable for any mode, when INDX_PAL_ENABLE is cleared.
                 * powerDown() might like to use such a function, too.  updateScreen() already disables any further screen
                 * updates while INDX_PAL_ENABLE is clear (except when fForce is true), but that's all we currently do.
                 *
                 *      if (!(bOut & Card.ATC.INDX_PAL_ENABLE) && fPalEnabled) this.blankScreen();
                 *
                 * However, there also needs to be a delay, because when the IBM VGA BIOS changes the mode, it updates
                 * the ATC palette registers in such a way that INDX_PAL_ENABLE is constantly toggled; here's one iteration:
                 *
                 *      C000:2B39 EC              IN       AL,DX
                 *      C000:2B3A B2C0            MOV      DL,C0
                 *      C000:2B3C 8BC3            MOV      AX,BX
                 *      C000:2B3E 86C4            XCHG     AL,AH
                 *      C000:2B40 EE              OUT      DX,AL    <-- this ATC index value does NOT contain 0x20
                 *      C000:2B41 86C4            XCHG     AL,AH
                 *      C000:2B43 EE              OUT      DX,AL
                 *      C000:2B44 B020            MOV      AL,20
                 *      C000:2B46 EE              OUT      DX,AL    <-- this ATC index value obviously DOES contain 0x20
                 *
                 * I'm not sure there are any situations where deliberately flickering the screen is a good thing -- unless
                 * someone REALLY wants to recreate the ugly flickering scroll of a CGA...?
                 */
            }
        }
        else {
            card.fATCData = false;
            let iReg = card.regATCIndx & Card.ATC.INDX_MASK;
            if (iReg >= Card.ATC.PALETTE_REGS || !fPalEnabled) {
                let fModified = (card.regATCData[iReg] !== bOut);
                if (Video.TRAPALL || fModified) {
                    if (!addrFrom || this.messageEnabled()) {
                        this.printMessageIO(port, bOut, addrFrom, "ATC." + card.asATCRegs[iReg]);
                    }
                }
                if (fModified) {
                    card.regATCData[iReg] = bOut;
                    if (iReg == Card.ATC.HPAN.INDX) {
                        if (this.fOverBuffer) {
                            this.fShifted = true;
                            /*
                             * TODO: The SHIFT_LEFT value apparently has a slightly different interpretation in
                             * monochrome mode (ie, when font.cxChar == 9, 8 means no shift and 0-7 means 1-8 shifts).
                             */
                            this.nShiftLeft = bOut & Card.ATC.HPAN.SHIFT_LEFT;
                        }
                    }
                    else if (iReg != Card.ATC.OVERSCAN.INDX) {
                        this.invalidateCellCache(true);
                    }
                }
            }
        }
    }

    /**
     * inStatus0(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C2)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inStatus0(port, addrFrom)
    {
        let bSWBit = 0;
        if (this.nCard == Video.CARD.EGA) {
            let iBit = 3 - ((this.cardEGA.regMisc & Card.MISC.CLOCK_SELECT) >> 2);    // this is the desired SW # (0-3)
            bSWBit = (this.bEGASwitches & (1 << iBit)) << (Card.STATUS0.SWSENSE_SHIFT - iBit);
        } else {
            /*
             * The IBM VGA ROM expects the SWSENSE bit to change according to how the DAC is programmed.
             *
             * At C000:0391, the ROM selects the following array at 0x0454:
             *
             *      db  0x12,0x12,0x12,0x10
             *
             * and writes the first 3 bytes to DAC register #0, and then compares SWSENSE to the 4th byte (0x10).
             *
             * If the 4th byte matches, then the ROM clears the BIOS "monochrome monitor" bit, and does the same
             * thing again with 5 more arrays, expecting the 4th byte in all 5 arrays to match SWSENSE, and being
             * very unhappy if they don't:
             *
             *      db  0x14,0x14,0x14,0x10
             *      db  0x2D,0x14,0x14,0x00
             *      db  0x14,0x2D,0x14,0x00
             *      db  0x14,0x14,0x2D,0x00
             *      db  0x2D,0x2D,0x2D,0x00
             *
             * I ensure much happiness by setting SWSENSE unless any of the three 6-bit DAC values contain 0x2D.
             *
             * This hard-coded behavior assumes a color monitor.  If you really want to simulate a monochrome monitor,
             * then the 1st array (above) must mismatch, and a different set of arrays must all match:
             *
             *      db  0x04,0x12,0x04,0x10
             *      db  0x1E,0x12,0x04,0x00
             *      db  0x04,0x2D,0x04,0x00
             *      db  0x04,0x16,0x15,0x00
             *      db  0x00,0x00,0x00,0x10
             *
             * In other words, for a monochrome monitor, set SWSENSE only when DAC register #0 matches the first and last
             * sets of values.
             */
            let dwDAC = this.cardEGA.regDACData[0];
            if ((dwDAC & 0x3f) != 0x2d && (dwDAC & (0x3f << 6)) != (0x2d << 6) && (dwDAC & (0x3f << 12)) != (0x2d << 12)) {
                bSWBit |= Card.STATUS0.SWSENSE;
            }
        }
        let b = ((this.cardEGA.regStatus0 & ~Card.STATUS0.SWSENSE) | bSWBit);
        /*
         * TODO: Figure out where Card.STATUS0.FEAT bits should come from....
         */
        this.cardEGA.regStatus0 = b;
        this.printMessageIO(Card.STATUS0.PORT, undefined, addrFrom, "STATUS0", b);
        return b;
    }

    /**
     * @this {Video}
     * @param {number} port (0x3C2)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outMisc(port, bOut, addrFrom)
    {
        this.cardEGA.regMisc = bOut;
        this.enableEGA();
        this.printMessageIO(Card.MISC.PORT_WRITE, bOut, addrFrom, "MISC");
    }

    /**
     * inVGAEnable(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C3)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inVGAEnable(port, addrFrom)
    {
        let b = this.cardEGA.regVGAEnable;
        this.printMessageIO(Card.VGA_ENABLE.PORT, undefined, addrFrom, "VGA_ENABLE", b);
        return b;
    }

    /**
     * outVGAEnable(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C3)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outVGAEnable(port, bOut, addrFrom)
    {
        this.cardEGA.regVGAEnable = bOut;
        this.printMessageIO(Card.VGA_ENABLE.PORT, bOut, addrFrom, "VGA_ENABLE");
    }

    /**
     * inSEQIndx(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C4)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inSEQIndx(port, addrFrom)
    {
        let b = this.cardEGA.regSEQIndx;
        this.printMessageIO(Card.SEQ.INDX.PORT, undefined, addrFrom, "SEQ.INDX", b);
        return b;
    }

    /**
     * outSEQIndx(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C4)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outSEQIndx(port, bOut, addrFrom)
    {
        this.cardEGA.regSEQIndx = bOut;
        this.printMessageIO(Card.SEQ.INDX.PORT, bOut, addrFrom, "SEQ.INDX");
    }

    /**
     * inSEQData(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C5)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inSEQData(port, addrFrom)
    {
        let b = this.cardEGA.regSEQData[this.cardEGA.regSEQIndx];
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.SEQ.DATA.PORT, undefined, addrFrom, "SEQ." + this.cardEGA.asSEQRegs[this.cardEGA.regSEQIndx], b);
        }
        return b;
    }

    /**
     * outSEQData(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C5)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outSEQData(port, bOut, addrFrom)
    {
        if (Video.TRAPALL || this.cardEGA.regSEQData[this.cardEGA.regSEQIndx] !== bOut) {
            if (!addrFrom || this.messageEnabled()) {
                this.printMessageIO(Card.SEQ.DATA.PORT, bOut, addrFrom, "SEQ." + this.cardEGA.asSEQRegs[this.cardEGA.regSEQIndx]);
            }
            this.cardEGA.regSEQData[this.cardEGA.regSEQIndx] = bOut;
        }

        switch(this.cardEGA.regSEQIndx) {

        case Card.SEQ.MAPMASK.INDX:
            this.cardEGA.nSeqMapMask = Video.aEGAByteToDW[bOut & Card.SEQ.MAPMASK.MAPS];
            break;

        case Card.SEQ.CHARMAP.INDX:
            let nFontSelect = this.getSelectedFonts();
            if (nFontSelect != this.nFontSelect) {
                if (DEBUG) {
                    if ((nFontSelect & 0xff) == (nFontSelect >> 8)) {
                        if (this.messageEnabled(Messages.VIDEO | Messages.PORT)) {
                            this.printf("outSEQData(0x%02X): font selection changing from 0x%04X to 0x%04X\n", bOut, this.nFontSelect, nFontSelect);
                        }
                    } else {
                        this.printf("outSEQData(0x%02X): low font (0x%02X) differs from high font (0x%02X)\n", bOut, nFontSelect & 0xff, nFontSelect >> 8);
                        this.cpu.stopCPU();
                    }
                }
                let nFontPrev = this.nFontSelect;
                this.buildFont(true);

                this.invalidateCellCache(false, nFontSelect, nFontPrev);
                /*
                 * TODO: Consider whether this code should, like outATC(), immediately update the screen
                 * on a font change, or if it's sufficient to simply wait until the next normal periodic update.
                 */
            }
            break;

        case Card.SEQ.MEMMODE.INDX:
            if (this.setCardAccess(this.getCardAccess())) {
                /*
                 * When switching screens (via SysReq) on early revisions of OS/2 (eg, FOOTBALL), the screen would go
                 * blank; this appeared to be because when the card is reprogrammed, we first think the card is going into
                 * graphics mode, then we reverse course when it becomes clear that the card is going back into text mode,
                 * but unfortunately, at that precise moment, the Sequencer hasn't been fully reprogrammed, so when we're
                 * reading screen memory, we're getting back ZEROS for every odd byte (which are the text attribute bytes),
                 * so the screen is redrawn as black-on-black.
                 *
                 * My solution was to change setCardAccess() to indicate whether it actually altered the video buffer
                 * address and/or format, and if so, then force another screen update.
                 *
                 * UPDATE: This change was NOT sufficient to resolve the OS/2 screen-switching bug described above; in fact,
                 * it's apparently not even necessary, because the REAL problem was caused by PAGED blocks with stale
                 * physical video memory blocks; the solution was for the Bus addMemory() and removeMemory() functions to
                 * call the the CPU flushPageBlocks() function.  With that change in place, the window now stays in sync
                 * with the buffer.
                 *
                 * However, calling updateScreen() here still seems like a good idea, and it shouldn't hurt performance,
                 * since we're doing it only when setCardAccess() indicates a change, so I'm leaving this addition in place.
                 */
                this.updateScreen(true);
            }
            break;

        default:
            break;
        }
    }

    /**
     * inDACMask(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C6)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inDACMask(port, addrFrom)
    {
        let b = this.cardEGA.regDACMask;
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.DAC.MASK.PORT, undefined, addrFrom, "DAC.MASK", b);
        }
        return b;
    }

    /**
     * outDACMask(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C6)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outDACMask(port, bOut, addrFrom)
    {
        if (Video.TRAPALL || this.cardEGA.regDACMask !== bOut) {
            if (!addrFrom || this.messageEnabled()) {
                this.printMessageIO(Card.DAC.MASK.PORT, bOut, addrFrom, "DAC.MASK");
            }
            this.cardEGA.regDACMask = bOut;
        }
    }

    /**
     * inDACState(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C7)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inDACState(port, addrFrom)
    {
        let b = this.cardEGA.regDACState;
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.DAC.STATE.PORT, undefined, addrFrom, "DAC.STATE", b);
        }
        return b;
    }

    /**
     * outDACRead(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C7)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outDACRead(port, bOut, addrFrom)
    {
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.DAC.ADDR.PORT_READ, bOut, addrFrom, "DAC.READ");
        }
        this.cardEGA.regDACAddr = bOut;
        this.cardEGA.regDACState = Card.DAC.STATE.MODE_READ;
        this.cardEGA.regDACShift = 0;
    }

    /**
     * outDACWrite(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C8)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outDACWrite(port, bOut, addrFrom)
    {
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.DAC.ADDR.PORT_WRITE, bOut, addrFrom, "DAC.WRITE");
        }
        this.cardEGA.regDACAddr = bOut;
        this.cardEGA.regDACState = Card.DAC.STATE.MODE_WRITE;
        this.cardEGA.regDACShift = 0;
    }

    /**
     * inDACData(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C9)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inDACData(port, addrFrom)
    {
        let b = (this.cardEGA.regDACData[this.cardEGA.regDACAddr] >> this.cardEGA.regDACShift) & 0x3f;
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.DAC.DATA.PORT, undefined, addrFrom, "DAC.DATA[" + Str.toHexByte(this.cardEGA.regDACAddr) + "][" + Str.toHexByte(this.cardEGA.regDACShift) + "]", b);
        }
        this.cardEGA.regDACShift += 6;
        if (this.cardEGA.regDACShift > 12) {
            this.cardEGA.regDACShift = 0;
            this.cardEGA.regDACAddr = (this.cardEGA.regDACAddr + 1) & (Card.DAC.TOTAL_REGS-1);
        }
        return b;
    }

    /**
     * outDACData(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3C9)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outDACData(port, bOut, addrFrom)
    {
        let dw = this.cardEGA.regDACData[this.cardEGA.regDACAddr];
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.DAC.DATA.PORT, bOut, addrFrom, "DAC.DATA[" + Str.toHexByte(this.cardEGA.regDACAddr) + "][" + Str.toHexByte(this.cardEGA.regDACShift) + "]");
        }
        let dwNew = (dw & ~(0x3f << this.cardEGA.regDACShift)) | ((bOut & 0x3f) << this.cardEGA.regDACShift);
        if (dw !== dwNew) {
            this.cardEGA.regDACData[this.cardEGA.regDACAddr] = dwNew;
            this.invalidateCellCache(true);
        }
        this.cardEGA.regDACShift += 6;
        if (this.cardEGA.regDACShift > 12) {
            this.cardEGA.regDACShift = 0;
            this.cardEGA.regDACAddr = (this.cardEGA.regDACAddr + 1) & (Card.DAC.TOTAL_REGS-1);
        }
    }

    /**
     * inVGAFeat(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3CA)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inVGAFeat(port, addrFrom)
    {
        let b = this.cardEGA.regFeat;
        this.printMessageIO(Card.FEAT_CTRL.PORT_READ, undefined, addrFrom, "FEAT", b);
        return b;
    }

    /**
     * outGRCPos2(port, bOut, addrFrom)
     *
     * "The EGA was originally implemented by IBM using two Graphics Controller Chips. This register is used to program
     * the Graphics #2 chip. See the Graphics #1 Position Register for details."
     *
     * "A one should be loaded into this location to map host data bus bits 2 and 3 to display planes 2 and 3, respectively."
     *
     * @this {Video}
     * @param {number} port (0x3CA)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outGRCPos2(port, bOut, addrFrom)
    {
        this.cardEGA.regGRCPos2 = bOut;
        this.printMessageIO(Card.GRC.POS2_PORT, bOut, addrFrom, "GRC2");
    }

    /**
     * inVGAMisc(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3CC)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inVGAMisc(port, addrFrom)
    {
        let b = this.cardEGA.regMisc;
        this.printMessageIO(Card.MISC.PORT_READ, undefined, addrFrom, "MISC", b);
        return b;
    }

    /**
     * outGRCPos1(port, bOut, addrFrom)
     *
     * "The EGA was originally implemented by IBM using two Graphics Controller Chips. It was necessary to program
     * each to respond to a different set of two consecutive bits of the 8-bit host data bus. In the IBM EGA implementation,
     * a 0 must be loaded into this register. In the VGA, there is no analogous register."
     *
     * "A zero should be loaded into this location to map host data bus bits 0 and 1 to display planes 0 and 1 respectively."
     *
     * Note that this register was not readable on the EGA, and when the VGA came along, reads of this port read the Misc reg.
     *
     * @this {Video}
     * @param {number} port (0x3CC)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outGRCPos1(port, bOut, addrFrom)
    {
        this.cardEGA.regGRCPos1 = bOut;
        this.printMessageIO(Card.GRC.POS1_PORT, bOut, addrFrom, "GRC1");
    }

    /**
     * inGRCIndx(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3CE)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inGRCIndx(port, addrFrom)
    {
        let b = this.cardEGA.regGRCIndx;
        this.printMessageIO(Card.GRC.INDX.PORT, undefined, addrFrom, "GRC.INDX", b);
        return b;
    }

    /**
     * outGRCIndx(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3CE)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outGRCIndx(port, bOut, addrFrom)
    {
        this.cardEGA.regGRCIndx = bOut;
        this.printMessageIO(Card.GRC.INDX.PORT, bOut, addrFrom, "GRC.INDX");
    }

    /**
     * inGRCData(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3CF)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inGRCData(port, addrFrom)
    {
        let b = this.cardEGA.regGRCData[this.cardEGA.regGRCIndx];
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(Card.GRC.DATA.PORT, undefined, addrFrom, "GRC." + this.cardEGA.asGRCRegs[this.cardEGA.regGRCIndx], b);
        }
        return b;
    }

    /**
     * outGRCData(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3CF)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outGRCData(port, bOut, addrFrom)
    {
        if (Video.TRAPALL || this.cardEGA.regGRCData[this.cardEGA.regGRCIndx] !== bOut) {
            if (!addrFrom || this.messageEnabled()) {
                this.printMessageIO(Card.GRC.DATA.PORT, bOut, addrFrom, "GRC." + this.cardEGA.asGRCRegs[this.cardEGA.regGRCIndx]);
            }
            this.cardEGA.regGRCData[this.cardEGA.regGRCIndx] = bOut;
        }
        switch(this.cardEGA.regGRCIndx) {
        case Card.GRC.SRESET.INDX:
            this.cardEGA.nSetMapData = Video.aEGAByteToDW[bOut & 0xf];
            this.cardEGA.nSetMapBits = this.cardEGA.nSetMapData & ~this.cardEGA.nSetMapMask;
            break;
        case Card.GRC.ESRESET.INDX:
            this.cardEGA.nSetMapMask = ~Video.aEGAByteToDW[bOut & 0xf];
            this.cardEGA.nSetMapBits = this.cardEGA.nSetMapData & ~this.cardEGA.nSetMapMask;
            break;
        case Card.GRC.COLORCOMP.INDX:
            this.cardEGA.nColorCompare = Video.aEGAByteToDW[bOut & 0xf] & (0x80808080|0);
            break;
        case Card.GRC.DATAROT.INDX:
        case Card.GRC.MODE.INDX:
            this.setCardAccess(this.getCardAccess());
            break;
        case Card.GRC.READMAP.INDX:
            this.cardEGA.nReadMapShift = (bOut & Card.GRC.READMAP.NUM) << 3;
            break;
        case Card.GRC.MISC.INDX:
            this.checkMode();
            break;
        case Card.GRC.COLORDC.INDX:
            this.cardEGA.nColorDontCare = Video.aEGAByteToDW[bOut & 0xf] & (0x80808080|0);
            break;
        case Card.GRC.BITMASK.INDX:
            this.cardEGA.nBitMapMask = bOut | (bOut << 8) | (bOut << 16) | (bOut << 24);
            break;
        default:
            break;
        }
    }

    /**
     * inCGAIndx(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3D4)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number|undefined}
     */
    inCGAIndx(port, addrFrom)
    {
        return this.inCRTCIndx(this.cardColor, port, addrFrom);
    }

    /**
     * outCGAIndx(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3D4)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCGAIndx(port, bOut, addrFrom)
    {
        this.outCRTCIndx(this.cardColor, port, bOut, addrFrom);
    }

    /**
     * inCGAData(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3D5)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number|undefined}
     */
    inCGAData(port, addrFrom)
    {
        return this.inCRTCData(this.cardColor, port, addrFrom);
    }

    /**
     * outCGAData(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3D5)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCGAData(port, bOut, addrFrom)
    {
        this.outCRTCData(this.cardColor, port, bOut, addrFrom);
    }

    /**
     * inCGAMode(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3D8)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inCGAMode(port, addrFrom)
    {
        return this.inCardMode(this.cardColor, addrFrom);
    }

    /**
     * outCGAMode(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3D8)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCGAMode(port, bOut, addrFrom)
    {
        this.outCardMode(this.cardColor, bOut, addrFrom);
    }

    /**
     * inCGAColor(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3D9)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inCGAColor(port, addrFrom)
    {
        let b = this.cardColor.regColor;
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(port /* this.cardColor.port + 5 */, undefined, addrFrom, this.cardColor.type + ".COLOR", b);
        }
        return b;
    }

    /**
     * outCGAColor(port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3D9)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCGAColor(port, bOut, addrFrom)
    {
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(port /* this.cardColor.port + 5 */, bOut, addrFrom, this.cardColor.type + ".COLOR");
        }
        if (this.cardColor.regColor !== bOut) {
            this.cardColor.regColor = bOut;
            this.invalidateCellCache(true);
        }
    }

    /**
     * inCGAStatus(port, addrFrom)
     *
     * @this {Video}
     * @param {number} port (0x3DA)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inCGAStatus(port, addrFrom)
    {
        return this.inCardStatus(this.cardColor, addrFrom);
    }

    /**
     * inCRTCIndx(card, port, addrFrom)
     *
     * @this {Video}
     * @param {Object} card
     * @param {number} port
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number|undefined}
     */
    inCRTCIndx(card, port, addrFrom)
    {
        let b;
        /*
         * The IBM VGA ROM makes some hardware determinations based on how the CRTC controller responds when
         * the IO_SELECT bit in the Miscellaneous Output Register is cleared; normally, that would mean ports
         * 0x3B? are decoded and ports 0x3D? are ignored.  We didn't used to bother ignoring them, but the
         * VGA ROM's logic requires it, so now we also check fActive.  However, we ignore only CRTC reads;
         * we retain any writes in case that information proves useful later.
         *
         * Note that returning an undefined value now signals the Bus component to return whatever default value
         * it prefers (normally 0xff).
         */
        if (card.fActive) b = card.regCRTIndx;
        this.printMessageIO(port, undefined, addrFrom, "CRTC.INDX", b);
        return b;
    }

    /**
     * outCRTCIndx(card, port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {Object} card
     * @param {number} port
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCRTCIndx(card, port, bOut, addrFrom)
    {
        card.regCRTPrev = card.regCRTIndx;
        card.regCRTIndx = bOut & Card.CGA.CRTC.INDX.MASK;
        this.printMessageIO(port /* card.port */, bOut, addrFrom, "CRTC.INDX");
    }

    /**
     * inCRTCData(card, port, addrFrom)
     *
     * @this {Video}
     * @param {Object} card
     * @param {number} port
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number|undefined}
     */
    inCRTCData(card, port, addrFrom)
    {
        let b;
        /*
         * The IBM VGA ROM makes some hardware determinations based on how the CRTC controller responds when
         * the IO_SELECT bit in the Miscellaneous Output Register is cleared; normally, that would mean ports
         * 0x3B? are decoded and ports 0x3D? are ignored.  We didn't used to bother ignoring them, but the
         * VGA ROM's logic requires it, so now we also check fActive.  However, we ignore only CTRC reads;
         * we retain any writes in case that information proves useful later.
         *
         * Note that returning an undefined value now signals the Bus component to return whatever default value
         * it prefers (normally 0xff).
         */
        if (card.fActive && card.regCRTIndx < card.nCRTCRegs) b = card.regCRTData[card.regCRTIndx];
        if (!addrFrom || this.messageEnabled()) {
            this.printMessageIO(port /* card.port + 1 */, undefined, addrFrom, "CRTC." + card.asCRTCRegs[card.regCRTIndx], b);
        }
        return b;
    }

    /**
     * outCRTCData(card, port, bOut, addrFrom)
     *
     * @this {Video}
     * @param {Object} card
     * @param {number} port
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCRTCData(card, port, bOut, addrFrom)
    {
        if (card.regCRTIndx < card.nCRTCRegs) {

            /*
             * To simulate how the 6845 effectively ignores changes to CURSCAN or CURSCANB whenever one is written
             * while the other is currently > MAXSCAN, we check for those writes now, and ignore the write as appropriate.
             *
             * Since CURSCAN == 0xA and CURSCANB == 0xB, we can get the complementary register by XOR'ing the index with 0x1.
             */
            if (card.regCRTIndx == Card.CRTC.CURSCAN || card.regCRTIndx == Card.CRTC.CURSCANB) {
                let bCur = bOut & Card.CRTCMASKS[Card.CRTC.MAXSCAN];
                let bMax = card.regCRTData[Card.CRTC.MAXSCAN] & Card.CRTCMASKS[Card.CRTC.MAXSCAN];
                if (bCur > bMax) {
                    bCur = card.regCRTData[card.regCRTIndx ^ 0x1] & Card.CRTCMASKS[Card.CRTC.MAXSCAN];
                    if (bCur > bMax) {
                        if (DEBUG) this.printf("outCRTCData(0x%02X): ignoring write to CRTC[0x%02X] since 0x%02X > 0x%02X\n", bOut, card.regCRTIndx, bCur, bMax);
                        return;
                    }
                }
            }

            let fModified = (card.regCRTData[card.regCRTIndx] !== bOut);
            if (fModified || Video.TRAPALL) {
                if (!addrFrom || this.messageEnabled()) {
                    this.printMessageIO(port /* card.port + 1 */, bOut, addrFrom, "CRTC." + card.asCRTCRegs[card.regCRTIndx]);
                }
                card.regCRTData[card.regCRTIndx] = bOut;
            }

            if (card == this.cardEGA) {
                if (card.regCRTIndx == Card.CRTC.EGA.VREND.INDX) {
                    if (this.nIRQ) {
                        if (!(bOut & Card.CRTC.EGA.VREND.UNCLEAR_VRINT)) {
                            if (this.chipset) this.chipset.clearIRR(this.nIRQ);
                        }
                    }
                }
                else if (fModified) {
                    /*
                     * If the split-screen state has been modified, then partially invalidate the cell cache.
                     *
                     * TODO: This register is also used in conjunction with one overflow bit in the OVERFLOW register
                     * and another overflow bit in the MAXSCAN register (VGA only), so technically, if either of those
                     * bits change, then again, the cache should be invalidated.
                     */
                    if (card.regCRTIndx == Card.CRTC.EGA.LINECOMP) {
                        this.invalidateCellCache(false);
                    }
                }
            }

            /*
             * During mode changes on the EGA, all the CRTC regs are typically programmed in sequence,
             * and if that's all that's happening with Card.CRTC.MAXSCAN, then we don't want to treat
             * it special; let the mode change be detected normally (eg, when the GRC regs are written later).
             *
             * On the other hand, if this was an out-of-sequence write to Card.CRTC.MAXSCAN, then
             * yes, we want to force setMode() to call setDimensions(), which is key to setting the proper
             * number of screen rows.
             *
             * The second part of the check is required to promptly detect a switch to "Mode X"; if we assume
             * that anyone switching to "Mode X" will first switch to mode 0x13, then it's a given that they
             * must reprogram the VDEND register, and that they will probably change it from 0x8F to 0xDF.
             *
             * Originally, I wasn't going to check specifically for 0xDF, to help catch other "Mode X" variations,
             * but if I don't, then some spurious mode changes are triggered (eg, when Windows 1.0 switches from
             * CGA graphics mode 0x06 to an EGA graphics mode).
             */
            if (fModified) {
                if (card.regCRTIndx == Card.CRTC.MAXSCAN && card.regCRTPrev != Card.CRTC.MAXSCAN - 1 || card.regCRTIndx == Card.CRTC.EGA.VDEND && bOut == 0xDF) {
                    this.checkMode(true);
                }
                this.checkCursor();
            }
        }
        else if (DEBUG) {
            this.printf("outCRTCData(0x%02X): ignoring unexpected write to CRTC[0x%02X]\n", bOut, card.regCRTIndx);
        }
    }

    /**
     * inCardMode(card, addrFrom)
     *
     * @this {Video}
     * @param {Object} card
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inCardMode(card, addrFrom)
    {
        let b = card.regMode;
        this.printMessageIO(card.port + 4, undefined, addrFrom, "MODE", b);
        return b;
    }

    /**
     * outCardMode(card, bOut, addrFrom)
     *
     * @this {Video}
     * @param {Object} card
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCardMode(card, bOut, addrFrom)
    {
        this.printMessageIO(card.port + 4, bOut, addrFrom, "MODE");
        card.regMode = bOut;
        this.checkMode();
    }

    /**
     * inCardStatus(card, addrFrom)
     *
     * On an EGA, this register is called "Status Register One" (0x3BA/0x3DA aka STATUS1), to distinguish it from
     * "Status Register Zero" (0x3C2 aka STATUS0).  One of the side-effects of reading STATUS1 is that it resets the
     * ATC address/data flip-flop to "address" mode, which we emulate by setting cardEGA.fATCData to false, indicating
     * that the ATC is not in "data" mode.
     *
     * @this {Video}
     * @param {Object} card
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number}
     */
    inCardStatus(card, addrFrom)
    {
        let b = this.getRetraceBits(card);

        if (card === this.cardEGA) {
            /*
             * STATUS1 diagnostic bits 5 and 4 are set according to the Card.ATC.PLANES.MUX bits:
             *
             *      MUX     Bit 5   Bit 4
             *      ---     ----    ----
             *      00:     Red     Blue
             *      01:     SecBlue Green
             *      10:     SecRed  SecGreen
             *      11:     unused  unused
             *
             * Depending on where we are in the horizontal and vertical periods (which can be inferred from the
             * same elapsed cycle count that we used to simulate the retrace bits above), we could extract 4 bits
             * from a corresponding region of the video buffer, "and" them with Card.ATC.PLANES.MASK, use
             * that to index into the palette registers (cardEGA.regATCData), and use the resulting palette register
             * bits to set these diagnostics bits.  However, that's all rather tedious, and the process of extracting
             * 4 appropriate bits from the video buffer varies depending on the video mode.
             *
             * Why are we even considering this?  Because the EGA BIOS diagnostic code draws a bright reverse-video
             * line of text blocks across the top of the screen, writes 0x3F to palette register 0x0f, and then
             * monitors the STATUS1 diagnostic bits, waiting for those palette bits to show up.  It turns out, however,
             * that we can easily fool the EGA BIOS by simply toggling the diagnostic bits.  So we take the easy way out.
             *
             * TODO: Faithful emulation of these bits is certainly doable, so consider doing that at some point.
             */
            b |= ((card.regStatus & Card.STATUS1.DIAGNOSTIC) ^ Card.STATUS1.DIAGNOSTIC);

            /*
             * Last but not least, we must reset the EGA's ATC flip-flop whenever this register is read.
             */
            card.fATCData = false;
        }
        else {
            /*
             * On the MDA/CGA, to satisfy ROM BIOS testing ("TEST.10"), it's sufficient to do a simple toggle of
             * bits 0 and 3 on every read.
             *
             * Also, according to http://www.seasip.info/VintagePC/mda.html, on an MDA, bits 7-4 are always ON and
             * bits 2-1 are always OFF, hence the "OR" of 0xF0.
             *
             * Currently, I use the retrace bits from getRetraceBits() as-is:
             *
             *      b |= 0xF0;
             *
             * but doing so hurts the performance of code like this in the "FlickerFree" utility:
             *
             *      &0600:079A EC              IN       AL,DX
             *      &0600:079B D0E8            SHR      AL,1
             *      &0600:079D 72FB            JC       079A
             *      &0600:079F FA              CLI
             *      &0600:07A0 EC              IN       AL,DX
             *      &0600:07A1 D0E8            SHR      AL,1
             *      &0600:07A3 73FB            JNC      07A0
             *      &0600:07A5 8BC3            MOV      AX,BX
             *      &0600:07A7 AB              STOSW
             *      &0600:07A8 FB              STI
             *      &0600:07A9 E2EF            LOOP     079A
             *
             * which, oddly, appears to want to write only ONE word to video memory per retrace interval.  Sticking
             * with our older, cruder, toggling code, makes that code run faster and reduce the odds that you'll see
             * old data on appear on the screen before the above code has the chance to store new data over it.
             *
             *      b = (card.regStatus ^= (Card.CGA.STATUS.RETRACE | Card.CGA.STATUS.VRETRACE)) | 0xF0;
             */
            b |= 0xF0;
        }

        card.regStatus = b;
        if (MAXDEBUG) this.printMessageIO(card.port + 6, undefined, addrFrom, (card === this.cardEGA? "STATUS1" : "STATUS"), b);
        return b;
    }

    /**
     * dumpVideo(asArgs)
     *
     * @this {Video}
     * @param {Array.<string>} asArgs
     */
    dumpVideo(asArgs)
    {
        if (DEBUGGER) {
            let component = /** @type {Component} */ (this.dbg);
            if (!this.cardActive) {
                component.println("no active video card");
                return;
            }
            if (asArgs[0]) {
                this.cardActive.dumpVideoBuffer(asArgs);
                return;
            }
            component.println("    MODE: " + Str.toHexByte(this.nMode));
            component.println("  BUFFER: " + Str.toHexLong(this.cardActive.addrBuffer));
            this.cardActive.dumpVideoCard();
        }
    }

    /**
     * doBlink()
     *
     * This function is obsolete, now that the checkBlink() function is called on every updateScreen()
     * and checkCursor() call.  updateScreen() is driven by CPU bursts, so piggy-backing on that to drive
     * blink updates seems preferable to having another active timer in the system.
     *
     * @this {Video}
     * @param {boolean} [fStart]
     *
     doBlink(fStart)
     {
        if (this.cBlinks >= 0) {
            this.cBlinks++;
            if (this.cBlinkVisible || this.iCellCursor >= 0) {
                if (!fStart && !this.cpu.isRunning()) {
                    this.updateScreen();
                }
                setTimeout(function(video) { return function onBlinkTimeout() {video.doBlink();}; }(this), 266);
                return;
            }
            this.cBlinks = -1;
        }
    },
     */

    /**
     * Video.init()
     *
     * This function operates on every HTML element of class "video", extracting the
     * JSON-encoded parameters for the Video constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Video component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aElement = Component.getElementsByClass(document, PCX86.APPCLASS, "video");
        for (let iVideo = 0; iVideo < aElement.length; iVideo++) {

            let element = aElement[iVideo];
            let parmsVideo = Component.getComponentParms(element);

            /*
             * We used to create the canvas element ourselves:
             *
             *      let canvas = document.createElement("canvas");
             *
             * and then update its properties to match those specified in parmsVideo:
             *
             *      canvas.setAttribute("class", "pcjs-canvas");
             *      canvas.setAttribute("width", parmsVideo['screenWidth']);
             *      canvas.setAttribute("height", parmsVideo['screenHeight']);
             *
             * but now we prefer to let the XSL template create the canvas element for us, so that the HTML
             * we inject into the page is as fully-formed as possible, keeping disruption of page layout to a
             * minimum.
             */
            let aCanvas = Component.getElementsByClass(element, "pcjs-canvas");
            if (!aCanvas || !aCanvas.length || !aCanvas[0].getContext) {
                element.innerHTML = "<br/>Missing &lt;canvas&gt; support. Please try a newer web browser.";
                return;
            }
            let canvas = aCanvas[0];

            /*
             * The "contenteditable" attribute on a canvas element NOTICEABLY slows down canvas drawing on
             * Safari as soon as you give the canvas focus (ie, click away from the canvas, and drawing speeds
             * up; click on the canvas, and drawing slows down).  So the "transparent textarea hack" that we
             * once employed as only a work-around for Android devices is now our default.
             *
             *      canvas.setAttribute("contenteditable", "true");
             *
             * HACK: A canvas style of "auto" provides for excellent responsive canvas scaling in EVERY browser
             * except IE9/IE10, so I recalculate the appropriate CSS height every time the parent DIV is resized;
             * IE11 works without this hack, so we take advantage of the fact that IE11 doesn't identify as "MSIE".
             *
             * The other reason it's good to keep this particular hack limited to IE9/IE10 is that most other
             * browsers don't actually support an 'onresize' handler on anything but the window object.
             */
            if (Web.getUserAgent().indexOf("MSIE") >= 0) {
                element.onresize = function(eParent, eChild, cx, cy) {
                    return function onResizeVideo() {
                        eChild.style.height = (((eParent.clientWidth * cy) / cx) | 0) + "px";
                    };
                }(element, canvas, parmsVideo['screenWidth'], parmsVideo['screenHeight']);
                element.onresize(null);
            }

            /*
             * The following is a related hack that allows the user to force the screen to use a particular aspect
             * ratio if an 'aspect' attribute or URL parameter is set.  Initially, it's just for testing purposes
             * until we figure out a better UI.  And note that we use our Web.onPageEvent() helper function to make
             * sure we don't trample any other 'onresize' handler(s) attached to the window object.
             */
            let aspect = +(Web.getURLParm('aspect') || parmsVideo['aspect']);

            /*
             * No 'aspect' parameter yields NaN, which is falsey, and anything else must satisfy my arbitrary
             * constraints of 0.3 <= aspect <= 3.33, to prevent any useless (or worse, browser-blowing) results.
             */
            if (aspect && aspect >= 0.3 && aspect <= 3.33) {
                Web.onPageEvent('onresize', function(eParent, eChild, aspectRatio) {
                    return function onResizeWindow() {
                        /*
                         * Since aspectRatio is the target width/height, we have:
                         *
                         *      eParent.clientWidth / eChild.style.height = aspectRatio
                         *
                         * which means that:
                         *
                         *      eChild.style.height = eParent.clientWidth / aspectRatio
                         *
                         * so for example, if aspectRatio is 16:9, or 1.78, and clientWidth = 640,
                         * then the calculated height should approximately 360.
                         */
                        eChild.style.height = ((eParent.clientWidth / aspectRatio)|0) + "px";
                    };
                }(element, canvas, aspect));
                window['onresize']();
            }

            /*
             * HACK: Android-based browsers, like the Silk (Amazon) browser and Chrome for Android, don't honor the
             * "contenteditable" attribute; that is, when the canvas receives focus, they don't activate the on-screen
             * keyboard.  So my fallback is to create a transparent textarea on top of the canvas.
             *
             * The parent DIV must have a style of "position:relative" (alternatively, a class of "pcjs-container"),
             * so that we can position the textarea using absolute coordinates.  Also, we don't want the textarea to be
             * visible, but we must use "opacity:0" instead of "visibility:hidden", because the latter seems to prevent
             * the element from receiving events.  These styling requirements are taken care of in components.css
             * (see references to the "pcjs-video-object" class).
             *
             * UPDATE: Unfortunately, Android keyboards like to compose whole words before transmitting any of the
             * intervening characters; our textarea's keyDown/keyUp event handlers DO receive intervening key events,
             * but their keyCode property is ZERO.  Virtually the only usable key event we receive is the Enter key.
             * Android users will have to use machines that include their own on-screen "soft keyboard", or use an
             * external keyboard.
             *
             * The following attempt to use a password-enabled input field didn't work any better on Android.  You could
             * clearly see the overlaid semi-transparent input field, but none of the input characters were passed along,
             * with the exception of the "Go" (Enter) key.
             *
             *      let input = document.createElement("input");
             *      input.setAttribute("type", "password");
             *      input.setAttribute("style", "position:absolute; left:0; top:0; width:100%; height:100%; opacity:0.5");
             *      element.appendChild(input);
             *
             * See this Chromium issue for more information: https://code.google.com/p/chromium/issues/detail?id=118639
             */
            let textarea = /** @type {HTMLTextAreaElement} */ (document.createElement("textarea"));

            /*
             * As noted in keyboard.js, the keyboard on an iOS device tends to pop up with the SHIFT key depressed,
             * which is not the initial keyboard state that the Keyboard component expects, so hopefully turning off
             * these "auto" attributes will help.
             */
            if (Web.isUserAgent("iOS")) {
                textarea.setAttribute("autocapitalize", "off");
                textarea.setAttribute("autocorrect", "off");
                /*
                 * One of the problems on iOS devices is that after a soft-key control is clicked, we need to give
                 * focus back to the above textarea, usually by calling cmp.updateFocus(), but in doing so, iOS may
                 * also "zoom" the page rather jarringly.  While it's a simple matter to completely disable zooming,
                 * by fiddling with the page's viewport, that prevents the user from intentionally zooming.  A bit of
                 * Googling reveals that another way to prevent those jarring unintentional zooms is to simply set the
                 * font-size of the text control to 16px.  So that's what we do.
                 */
                textarea.style.fontSize = "16px";
            }

            element.appendChild(textarea);

            /*
             * See if there are any "diagnostic" elements we should pass along, too.
             */
            let aDiagElements = /** @type {Array.<HTMLElement>} */ (Component.getElementsByClass(document, PCX86.APPCLASS + "-video-diagnostic"));

            /*
             * Now we can create the Video object, record it, and wire it up to the associated document elements.
             */
            let context = /** @type {CanvasRenderingContext2D} */ (canvas.getContext("2d"));
            let video = new Video(parmsVideo, canvas, context, textarea /* || input */, element, aDiagElements);

            /*
             * Bind any video-specific controls (eg, the Refresh button). There are no essential controls, however;
             * even the "Refresh" button is just a diagnostic tool, to ensure that the screen contents are up-to-date.
             */
            Component.bindComponentControls(video, element, PCX86.APPCLASS);
        }
    }
}

Video.TRAPALL = true;           // monitor all I/O by default (not just deltas)

/*
 * Supported Cards (and associated fonts)
 *
 * These IDs are also used to identify which "slots" in the aFonts[] array contain fonts, which is why
 * there are gaps between the numbers.  The MDA and CGA use a single supplied font, so they will always
 * use font slot 1 or 2, respectively, but the EGA supports up to 4 font "banks", so depending on which
 * bank is being used, font slots 4-7 may be used.  Similarly, the VGA supports up to 8 font "banks",
 * using font slots 8-15.
 *
 * Once we've finished loading the standard 8K font file, aFonts[] should contain at least one of the
 * entries listed below.  For the standard MDA/CGA font ROM, the first (MDA) font resides in the first 4Kb,
 * and the second and third (CGA) fonts reside in the two 2K halves of the second 4Kb.
 *
 * Additional notes from the IBM EGA Manual (p.5):
 *
 *     "In alphanumeric modes, characters are formed from one of two ROM (Read Only Memory) character
 *      generators on the adapter. One character generator defines 7x9 characters in a 9x14 character box.
 *      For Enhanced Color Display support, the 9x14 character set is modified to provide an 8x14 character set.
 *      The second character generator defines 7x7 characters in an 8x8 character box. These generators contain
 *      dot patterns for 256 different characters. The character sets are identical to those provided by the
 *      IBM Monochrome Display Adapter and the IBM Color/Graphics Monitor Adapter."
 */
Video.CARD = {
    MDA:    1,          // uses 9x14 monochrome font
    CGA:    2,          // uses 8x8 color font
    EGA:    4,          // uses 8x14 color font (by default)
    VGA:    8           // uses 9x16 color font (by default)
};

/*
 * Supported Modes
 *
 * Although this component is designed to be a video hardware emulation, not a BIOS simulation, we DO
 * look for changes to the hardware state that correspond to standard BIOS mode settings, so our internal
 * mode setting will normally match the current BIOS mode setting; however, this a debugging convenience,
 * not an attempt to monitor or emulate the BIOS.
 *
 * We do have some BIOS awareness (eg, when loading ROM-based fonts, and some special code to ensure all
 * the BIOS diagnostics pass), but for the most part, we treat the BIOS like any other application code.
 *
 * As we expand support to include more programmable cards like the EGA, it becomes quite easy for the card
 * to enter a "mode" that has no BIOS counterpart (eg, non-standard combinations of video buffer address,
 * memory access modes, fonts, display regions, etc).  Our hardware emulation routines will cope with those
 * situations as best they can (and when they don't, it should be considered a bug if some application is
 * broken as a result), but realistically, our hardware emulation is never likely to be 100% accurate.
 */
Video.MODE = {
    CGA_40X25_BW:       0,
    CGA_40X25:          1,
    CGA_80X25_BW:       2,
    CGA_80X25:          3,
    CGA_320X200:        4,
    CGA_320X200_BW:     5,
    CGA_640X200:        6,
    MDA_80X25:          7,
    EGA_320X200:        0x0D,   // mapped at A000:0000, color, 4bpp, planar
    EGA_640X200:        0x0E,   // mapped at A000:0000, color, 4bpp, planar
    EGA_640X350_MONO:   0x0F,   // mapped at A000:0000, mono,  2bpp, planar
    EGA_640X350:        0x10,   // mapped at A000:0000, color, 4bpp, planar
    VGA_640X480_MONO:   0x11,   // mapped at A000:0000, mono,  2bpp, planar
    VGA_640X480:        0x12,   // mapped at A000:0000, color, 4bpp, planar
    VGA_320X200:        0x13,   // mapped at A000:0000, color, 8bpp, linear
    /*
     * The remaining mode identifiers are for internal use only; there is no correlation with any
     * publicly defined BIOS modes, and overlap with any third-party mode numbers is purely coincidental.
     */
    VGA_320X240:        0x14,   // mapped at A000:0000, color, 8bpp, planar ("Mode X")
    VGA_320X400:        0x15,   // mapped at A000:0000, color, 8bpp, planar
    /*
     * Here's where we might assign additional identifiers to certain unique combinations, like the
     * fTextGraphicsHybrid 320x400 mode that Windows 95 uses (ie, when the buffer is mapped to B800:0000
     * instead of A000:0000 and is configured for text mode access, but graphics are still being displayed
     * from the second half of video memory).
     */
    UNKNOWN:            0xFF
};

Video.UPDATES_PER_SECOND = 60;

/*
 * Supported Models
 *
 * Each model refers to an array where [0] is the card ID, and [1] is the default mode.
 */
Video.MODEL = {
    "mda": [Video.CARD.MDA, Video.MODE.MDA_80X25],
    "cga": [Video.CARD.CGA, Video.MODE.CGA_80X25],
    "ega": [Video.CARD.EGA, Video.MODE.CGA_80X25],
    "vga": [Video.CARD.VGA, Video.MODE.CGA_80X25]
};

/*
 * Supported Monitors
 *
 * The MDA monitor displays 350 lines of vertical resolution, 720 lines of horizontal resolution, and refreshes
 * at ~50Hz.  The CGA monitor displays 200 lines vertically, 640 horizontally, and refreshes at ~60Hz.
 *
 * Based on actual MDA timings (see http://diylab.atwebpages.com/pressureDev.htm), the total horizontal
 * period (drawing a line and retracing) is ~54.25uSec (1000000uSec / 18432) and the horizontal retrace interval
 * is about 15% of that, or ~8.14uSec.  Vertical sync occurs once every 370 horizontal periods.  Of those 370,
 * only 354 represent actively drawn lines (and of those, only 350 are visible); the remaining 16 horizontal
 * periods, or 4% of the 370 total, represent the vertical retrace interval.
 *
 * I don't have similar numbers for the CGA or EGA, so for now, I assume similar percentages; ie, 15% of
 * the horizontal period will represent horizontal retrace, and 4% of the vertical pixel maximum (262) will
 * represent vertical retrace.  However, 24% of the CGA's 262 vertical maximum represents non-visible lines,
 * whereas only 5% of the MDA's 370 maximum represents non-visible lines; is there really that much "overscan"
 * on the CGA?
 *
 * For each monitor type, there's a Video.monitorSpecs object that describes the horizontal and vertical
 * timings, along with my assumptions about the percentage of time that drawing is "active" within those periods,
 * and then based on the selected monitor type, I compute the number of CPU cycles that each period lasts,
 * as well as the number of CPU cycles that drawing lasts within each period, so that the horizontal and vertical
 * retrace status flags can be quickly calculated.
 *
 * For reference, here are some important numbers to know (from https://github.com/reenigne/reenigne/blob/master/8088/cga/register_values.txt):
 *
 *              CGA          MDA
 *  Pixel clock 14.318 MHz   16.257 MHz (aka "maximum video bandwidth", as IBM Tech Refs sometimes call it)
 *  Horizontal  15.700 KHz   18.432 KHz (aka "horizontal drive", as IBM Tech Refs sometimes call it)
 *  Vertical    59.923 Hz    49.816 Hz
 *  Usage       53.69%       77.22%
 *  H pix       912 = 114*8  882 = 98*9
 *  V pix       262          370
 *  Dots        238944       326340
 */

/** @typedef {{ nHorzPeriodsPerSec: number, nHorzPeriodsPerFrame: number, percentHorzActive: number, percentVertActive: number }} */
var MonitorSpecs;

/**
 * @type {Object}
 */
Video.monitorSpecs = {};

/**
 * NOTE: The number of horizontal periods per frame (200) is dictated by the EGA ROM BIOS at C000:03D0.
 *
 * @type {MonitorSpecs}
 */
Video.monitorSpecs[ChipSet.MONITOR.COLOR] = {
    nHorzPeriodsPerSec: 15700,
    nHorzPeriodsPerFrame: 200,
    percentHorzActive: 75,
    percentVertActive: 96
};

/**
 * NOTE: The number of horizontal periods per frame (350) is dictated by the EGA ROM BIOS at C000:03D0.
 *
 * @type {MonitorSpecs}
 */
Video.monitorSpecs[ChipSet.MONITOR.MONO] = {
    nHorzPeriodsPerSec: 18432,
    nHorzPeriodsPerFrame: 350,
    percentHorzActive: 75,
    percentVertActive: 96
};

/**
 * NOTE: The number of horizontal periods per frame (350) is dictated by the EGA ROM BIOS at C000:03D0.
 *
 * @type {MonitorSpecs}
 */
Video.monitorSpecs[ChipSet.MONITOR.EGACOLOR] = {
    nHorzPeriodsPerSec: 21850,
    nHorzPeriodsPerFrame: 350,
    percentHorzActive: 75,
    percentVertActive: 96
};

/**
 * NOTE: The number of horizontal periods per frame (410) is dictated by the IBM VGA ROM code at C000:024A.
 *
 * @type {MonitorSpecs}
 */
Video.monitorSpecs[ChipSet.MONITOR.VGACOLOR] = {
    nHorzPeriodsPerSec: 16700,
    nHorzPeriodsPerFrame: 410,
    percentHorzActive: 85,
    percentVertActive: 83
};

/*
 * EGA Miscellaneous ports and SW1-Sw4
 *
 * The Card.MISC.CLOCK_SELECT bits determine which of the EGA board's 4 configuration switches are
 * returned via Card.STATUS0.SWSENSE (when SWSENSE is zero, the switch is closed):
 *
 *      0xC: return SW1
 *      0x8: return SW2
 *      0x4: return SW3
 *      0x0: return SW4
 *
 * These 4 bits are also copied to the byte at 40:88h by the EGA BIOS, where bit 0 is SW1, bit 1 is SW2,
 * bit 2 is SW3 and bit 3 is SW4.  Our switch settings come from bEGASwitches, which in turn comes from
 * sSwitches, which in turn comes from the "switches" property passed to the Video component, if any.
 *
 * As usual, the switch settings are reversed in both direction and sense from the switch settings; the
 * good news, however, is that we can use the parseSwitches() method in the ChipSet component to parse them.
 *
 * The set of valid EGA switch values, after conversion, is stored in the table below.  For each value,
 * there is an array that defines the corresponding monitor type(s) for the EGA adapter and any secondary
 * adapter.  The third value is a boolean indicating whether the EGA is the primary adapter.
 */
Video.aEGAMonitorSwitches = {
    0x06: [ChipSet.MONITOR.TV,           ChipSet.MONITOR.MONO,  true],  // "1001"
    0x07: [ChipSet.MONITOR.COLOR,        ChipSet.MONITOR.MONO,  true],  // "0001" [used by 5153 monitor configs]
    0x08: [ChipSet.MONITOR.EGAEMULATION, ChipSet.MONITOR.MONO,  true],  // "1110"
    0x09: [ChipSet.MONITOR.EGACOLOR,     ChipSet.MONITOR.MONO,  true],  // "0110" [used by 5154 monitor configs (default; see bEGASwitches below)]
    0x0a: [ChipSet.MONITOR.MONO,         ChipSet.MONITOR.TV,    true],  // "1010"
    0x0b: [ChipSet.MONITOR.MONO,         ChipSet.MONITOR.COLOR, true],  // "0010" [used by 5151 monitor configs]
    0x00: [ChipSet.MONITOR.TV,           ChipSet.MONITOR.MONO,  false], // "1111"
    0x01: [ChipSet.MONITOR.COLOR,        ChipSet.MONITOR.MONO,  false], // "0111"
    0x02: [ChipSet.MONITOR.EGAEMULATION, ChipSet.MONITOR.MONO,  false], // "1011"
    0x03: [ChipSet.MONITOR.EGACOLOR,     ChipSet.MONITOR.MONO,  false], // "0011"
    0x04: [ChipSet.MONITOR.MONO,         ChipSet.MONITOR.TV,    false], // "1101"
    0x05: [ChipSet.MONITOR.MONO,         ChipSet.MONITOR.COLOR, false]  // "0101"
};

/** @typedef {{ cxChar: number, cyChar: number, cxCell: number, cyCell: number, aCSSColors: Array, aRGBColors: Array, aColorMap: Array, aCanvas: Array }} */
var Font;

/*
 * For each video mode, we need to know the following pieces of information:
 *
 *      0: # of columns (nCols)
 *      1: # of rows (nRows)
 *      2: # points per cell (nPointsPerCell: # of points per cell cache entry)
 *      3: # points per byte (nPointsPerByte: # of points per frame buffer byte)
 *      4: # bytes of visible screen padding, if any (used for CGA graphics modes only)
 *      5: font ID (nFont: undefined if graphics mode)
 *
 * The 3rd entry used to be nCellsPerWord, but it is now nPointsPerCell.  nCols * nRows yields total
 * (viewable) points, and dividing that by nPointsPerCell yields the size of the cell cache (nCellCache).
 *
 * For MDA and CGA modes, a "word" of memory is 16 bits of CPU-addressable data, so by calculating
 * ([0] * [1]) / [2], we obtain the number of words that mode actively displays; for example, the
 * amount of visible memory used by mode 0x04 is (320 * 200) / 4, or 16000.
 *
 * However, for EGA and VGA graphics modes, a "word" of memory is a single element in the video buffer
 * containing 32 bits of pixel data.
 */
Video.aModeParms = [];                                                                              // Mode
Video.aModeParms[Video.MODE.CGA_40X25]          = [ 40,  25,  1, 0.5,   0, Video.CARD.CGA];         // 0x01
Video.aModeParms[Video.MODE.CGA_80X25]          = [ 80,  25,  1, 0.5,   0, Video.CARD.CGA];         // 0x03
Video.aModeParms[Video.MODE.CGA_320X200]        = [320, 200,  8,   4, 192];                         // 0x04
Video.aModeParms[Video.MODE.CGA_640X200]        = [640, 200, 16,   8, 192];                         // 0x06
Video.aModeParms[Video.MODE.MDA_80X25]          = [ 80,  25,  1, 0.5,   0, Video.CARD.MDA];         // 0x07
Video.aModeParms[Video.MODE.EGA_320X200]        = [320, 200,  8,   8];                              // 0x0D
Video.aModeParms[Video.MODE.EGA_640X200]        = [640, 200,  8,   8];                              // 0x0E
Video.aModeParms[Video.MODE.EGA_640X350_MONO]   = [640, 350,  8,   8];                              // 0x0F
Video.aModeParms[Video.MODE.EGA_640X350]        = [640, 350,  8,   8];                              // 0x10
Video.aModeParms[Video.MODE.VGA_640X480_MONO]   = [640, 480,  8,   8];                              // 0x11
Video.aModeParms[Video.MODE.VGA_640X480]        = [640, 480,  8,   8];                              // 0x12
Video.aModeParms[Video.MODE.VGA_320X200]        = [320, 200,  4,   1];                              // 0x13
Video.aModeParms[Video.MODE.VGA_320X240]        = [320, 240,  4,   4];                              // 0x14
Video.aModeParms[Video.MODE.VGA_320X400]        = [320, 400,  4,   4];                              // 0x15
Video.aModeParms[Video.MODE.CGA_40X25_BW]       = Video.aModeParms[Video.MODE.CGA_40X25];           // 0x00
Video.aModeParms[Video.MODE.CGA_80X25_BW]       = Video.aModeParms[Video.MODE.CGA_80X25];           // 0x02
Video.aModeParms[Video.MODE.CGA_320X200_BW]     = Video.aModeParms[Video.MODE.CGA_320X200];         // 0x05

/*
 * MDA attribute byte definitions
 *
 * For MDA, only the following group of ATTR definitions are supported; any FGND/BGND value combinations
 * outside this group will be treated as "normal" (ATTR_FGND_WHITE | ATTR_BGND_BLACK).
 *
 * NOTE: Assuming MDA.MODE.BLINK_ENABLE is set (which the ROM BIOS sets by default), ATTR_BGND_BLINK will
 * cause the *foreground* element of the cell to blink, even though it is part of the *background* attribute bits.
 *
 * Regarding blink rate, characters are supposed to blink every 16 vertical frames, which amounts to .26667 blinks
 * per second, assuming a 60Hz vertical refresh rate.  So roughly every 267ms, we need to take care of any blinking
 * characters.  updateScreen() maintains a global count (cBlinkVisible) of blinking characters, to simplify the
 * decision of when to redraw the screen.
 */
Video.ATTRS = {};
Video.ATTRS.FGND_BLACK  = 0x00;
Video.ATTRS.FGND_ULINE  = 0x01;
Video.ATTRS.FGND_WHITE  = 0x07;
Video.ATTRS.FGND_BRIGHT = 0x08;
Video.ATTRS.BGND_BLACK  = 0x00;
Video.ATTRS.BGND_WHITE  = 0x70;
Video.ATTRS.BGND_BLINK  = 0x80;
Video.ATTRS.BGND_BRIGHT = 0x80;
Video.ATTRS.DRAW_FGND   = 0x100;        // this is an internal attribute bit, indicating the foreground should be drawn
Video.ATTRS.DRAW_CURSOR = 0x200;        // this is an internal attribute bit, indicating when the cursor should be drawn

/*
 * Here's a "cheat sheet" for attribute byte combinations that the IBM MDA could have supported.  The original (Aug 1981)
 * IBM Tech Ref is very terse and implies that only those marked with * are actually supported.
 *
 *     *0x00: non-display                       ATTR_FGND_BLACK |                    ATTR_BGND_BLACK
 *     *0x01: underline                         ATTR_FGND_ULINE |                    ATTR_BGND_BLACK
 *     *0x07: normal (white on black)           ATTR_FGND_WHITE |                    ATTR_BGND_BLACK
 *    **0x09: bright underline                  ATTR_FGND_ULINE | ATTR_FGND_BRIGHT | ATTR_BGND_BLACK
 *    **0x0F: bold (bright white on black)      ATTR_FGND_WHITE | ATTR_FGND_BRIGHT | ATTR_BGND_BLACK
 *     *0x70: reverse (black on white)          ATTR_FGND_BLACK |                  | ATTR_BGND_WHITE
 *      0x81: blinking underline                ATTR_FGND_ULINE |                  | ATTR_BGND_BLINK (or dim background if blink disabled)
 *    **0x87: blinking normal                   ATTR_FGND_WHITE |                  | ATTR_BGND_BLINK (or dim background if blink disabled)
 *      0x89: blinking bright underline         ATTR_FGND_ULINE | ATTR_FGND_BRIGHT | ATTR_BGND_BLINK (or dim background if blink disabled)
 *    **0x8F: blinking bold                     ATTR_FGND_WHITE | ATTR_FGND_BRIGHT | ATTR_BGND_BLINK (or dim background if blink disabled)
 *    **0xF0: blinking reverse                  ATTR_FGND_WHITE | ATTR_FGND_BRIGHT | ATTR_BGND_BLINK (or bright background if blink disabled)
 *
 * Unsupported attributes reportedly display as "normal" (ATTR_FGND_WHITE | ATTR_BGND_BLACK).  However, precisely which
 * attributes are unsupported on the MDA varies depending on the source.  Some sources (eg, the IBM Tech Ref) imply that
 * only those marked by * are supported, while others (eg, some--but not all--Peter Norton guides) include those marked
 * by **, and still others include ALL the combinations listed above.
 *
 * Furthermore, according to http://www.seasip.info/VintagePC/mda.html:
 *
 *      Attributes 0x00, 0x08, 0x80 and 0x88 display as black space;
 *      Attribute 0x78 displays as dark green on green; depending on the monitor, there may be a green "halo" where the dark and bright bits meet;
 *      Attribute 0xF0 displays as a blinking version of 0x70 if blink enabled, and black on bright green otherwise;
 *      Attribute 0xF8 displays as a blinking version of 0x78 if blink enabled, and as dark green on bright green otherwise.
 *
 * However, I'm rather skeptical about supporting 0x78 and 0xF8, until I see some evidence that "bright black" actually
 * produced dark green on IBM equipment; it also doesn't sound like a combination many people would have used.  I'll probably
 * treat all of 0x08, 0x80 and 0x88 the same as 0x00, only because it seems logical (they're all "black on black" combinations
 * with only BRIGHT and/or BLINK bits set). Beyond that, I'll likely treat any other combination not listed in the above cheat
 * sheet as "normal".
 *
 * All the discrepancies/disagreements I've found are probably due in part to the proliferation of IBM and non-IBM MDA
 * cards, combined with IBM and non-IBM monochrome monitors, and people assuming that their non-IBM card and/or monitor
 * behaved exactly like the original IBM equipment, which probably wasn't true in all cases.
 *
 * I would like to limit my MDA display support to EXACTLY everything that the IBM MDA supported and nothing more, but
 * since there will be combinations that will logically "fall out" unless I specifically exclude them, it's very likely
 * this implementation will end up being a superset.
 */

/*
 * CGA attribute byte definitions; these simply extend the set of MDA attributes, with the exception of ATTR_FNGD_ULINE,
 * which the CGA can treat only as ATTR_FGND_BLUE.
 */
Video.ATTRS.FGND_BLUE       = 0x01;
Video.ATTRS.FGND_GREEN      = 0x02;
Video.ATTRS.FGND_CYAN       = 0x03;
Video.ATTRS.FGND_RED        = 0x04;
Video.ATTRS.FGND_MAGENTA    = 0x05;
Video.ATTRS.FGND_BROWN      = 0x06;

Video.ATTRS.BGND_BLUE       = 0x10;
Video.ATTRS.BGND_GREEN      = 0x20;
Video.ATTRS.BGND_CYAN       = 0x30;
Video.ATTRS.BGND_RED        = 0x40;
Video.ATTRS.BGND_MAGENTA    = 0x50;
Video.ATTRS.BGND_BROWN      = 0x60;

/*
 * For the MDA, the number of unique "colors" is 5, based on the following supported FGND attribute values:
 *
 *      0x0: black font (attribute value 0x8 is mapped to 0x0)
 *      0x1: green font with underline
 *      0x7: green font without underline (attribute values 0x2-0x6 are mapped to 0x7)
 *      0x9: bright green font with underline
 *      0xf: bright green font without underline (attribute values 0xa-0xe are mapped to 0xf)
 *
 * I'm still not sure about 0x8 (dark green?); for now, I'm mapping it to 0x0, but it may become a 6th supported color.
 *
 * MDA attributes form an index into aMDAColorMap, which in turn provides an index (0-4) into aMDAColors.
 */
Video.aMDAColors = [
    [0x00, 0x00, 0x00, 0xff],
    [0x7f, 0xc0, 0x7f, 0xff],
    [0x7f, 0xc0, 0x7f, 0xff],
    [0x7f, 0xff, 0x7f, 0xff],
    [0x7f, 0xff, 0x7f, 0xff]
];
Video.aMDAColorMap = [0x0, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x0, 0x3, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4];

Video.aCGAColors = [
    [0x00, 0x00, 0x00, 0xff],   // 0x00: ATTR_FGND_BLACK
    [0x00, 0x00, 0xaa, 0xff],   // 0x01: ATTR_FGND_BLUE
    [0x00, 0xaa, 0x00, 0xff],   // 0x02: ATTR_FGND_GREEN
    [0x00, 0xaa, 0xaa, 0xff],   // 0x03: ATTR_FGND_CYAN
    [0xaa, 0x00, 0x00, 0xff],   // 0x04: ATTR_FGND_RED
    [0xaa, 0x00, 0xaa, 0xff],   // 0x05: ATTR_FGND_MAGENTA
    [0xaa, 0x55, 0x00, 0xff],   // 0x06: ATTR_FGND_BROWN
    [0xaa, 0xaa, 0xaa, 0xff],   // 0x07: ATTR_FGND_WHITE                      (aka light gray)
    [0x55, 0x55, 0x55, 0xff],   // 0x08: ATTR_FGND_BLACK   | ATTR_FGND_BRIGHT (aka gray)
    [0x55, 0x55, 0xff, 0xff],   // 0x09: ATTR_FGND_BLUE    | ATTR_FGND_BRIGHT
    [0x55, 0xff, 0x55, 0xff],   // 0x0A: ATTR_FGND_GREEN   | ATTR_FGND_BRIGHT
    [0x55, 0xff, 0xff, 0xff],   // 0x0B: ATTR_FGND_CYAN    | ATTR_FGND_BRIGHT
    [0xff, 0x55, 0x55, 0xff],   // 0x0C: ATTR_FGND_RED     | ATTR_FGND_BRIGHT
    [0xff, 0x55, 0xff, 0xff],   // 0x0D: ATTR_FGND_MAGENTA | ATTR_FGND_BRIGHT
    [0xff, 0xff, 0x55, 0xff],   // 0x0E: ATTR_FGND_BROWN   | ATTR_FGND_BRIGHT (aka yellow)
    [0xff, 0xff, 0xff, 0xff]    // 0x0F: ATTR_FGND_WHITE   | ATTR_FGND_BRIGHT (aka white)
];

Video.aCGAColorSet0 = [Video.ATTRS.FGND_GREEN, Video.ATTRS.FGND_RED,     Video.ATTRS.FGND_BROWN];
Video.aCGAColorSet1 = [Video.ATTRS.FGND_CYAN,  Video.ATTRS.FGND_MAGENTA, Video.ATTRS.FGND_WHITE];

/*
 * Here is the EGA BIOS default ATC palette register set for color text modes, from which getCardColors()
 * builds a default RGB array, similar to aCGAColors above.
 */
Video.aEGAPalDef = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F];

Video.aEGAByteToDW = [
    0x00000000,   0x000000ff,   0x0000ff00,   0x0000ffff,
    0x00ff0000,   0x00ff00ff,   0x00ffff00,   0x00ffffff,
    0xff000000|0, 0xff0000ff|0, 0xff00ff00|0, 0xff00ffff|0,
    0xffff0000|0, 0xffff00ff|0, 0xffffff00|0, 0xffffffff|0
];

Video.aEGADWToByte = [];
Video.aEGADWToByte[0x00000000]   = 0x0;
Video.aEGADWToByte[0x00000080]   = 0x1;
Video.aEGADWToByte[0x00008000]   = 0x2;
Video.aEGADWToByte[0x00008080]   = 0x3;
Video.aEGADWToByte[0x00800000]   = 0x4;
Video.aEGADWToByte[0x00800080]   = 0x5;
Video.aEGADWToByte[0x00808000]   = 0x6;
Video.aEGADWToByte[0x00808080]   = 0x7;
Video.aEGADWToByte[0x80000000|0] = 0x8;
Video.aEGADWToByte[0x80000080|0] = 0x9;
Video.aEGADWToByte[0x80008000|0] = 0xa;
Video.aEGADWToByte[0x80008080|0] = 0xb;
Video.aEGADWToByte[0x80800000|0] = 0xc;
Video.aEGADWToByte[0x80800080|0] = 0xd;
Video.aEGADWToByte[0x80808000|0] = 0xe;
Video.aEGADWToByte[0x80808080|0] = 0xf;

/*
 * Card Specifications
 *
 * We support dynamically switching between MDA and CGA cards by simply flipping switches on
 * the virtual SW1 switch block and resetting the machine.  However, I'm not sure I'll support
 * dynamically switching the EGA card the same way; there's certainly no UI for it at this point.
 *
 * For each supported card, there is a cardSpec array that the Card class uses to initialize the
 * card's defaults:
 *
 *      [0]: card descriptor
 *      [1]: default CRTC port address
 *      [2]: default video buffer address
 *      [3]: default video buffer size
 *      [4]: total on-board memory (if no "memory" parm was specified)
 *      [5]: default monitor type
 *
 * If total on-board memory is zero, then addMemory() will simply add the specified video buffer
 * to the address space; otherwise, we will allocate an internal buffer (adwMemory) and tell addMemory()
 * to map it to the video buffer address.  The latter approach gives us total control over the buffer;
 * refer to getMemoryAccess().
 */
Video.cardSpecs = [];
Video.cardSpecs[Video.CARD.MDA] = ["MDA", Card.MDA.CRTC.INDX.PORT, 0xB0000, 0x01000, 0x01000, ChipSet.MONITOR.MONO];
Video.cardSpecs[Video.CARD.CGA] = ["CGA", Card.CGA.CRTC.INDX.PORT, 0xB8000, 0x04000, 0x04000, ChipSet.MONITOR.COLOR];
Video.cardSpecs[Video.CARD.EGA] = ["EGA", Card.CGA.CRTC.INDX.PORT, 0xB8000, 0x04000, 0x10000, ChipSet.MONITOR.EGACOLOR];
Video.cardSpecs[Video.CARD.VGA] = ["VGA", Card.CGA.CRTC.INDX.PORT, 0xB8000, 0x04000, 0x40000, ChipSet.MONITOR.VGACOLOR];

/*
 * Values for nTouchConfig; a value will be selected based on the sTouchScreen configuration parameter.
 */
Video.TOUCH = {
    NONE:       0,
    DEFAULT:    1,
    KEYGRID:    2,
    MOUSE:      3
};

/*
 * Why simulate a SPACE if the tap is in the middle third (center) of the screen?  Well, apparently
 * I didn't explain earlier that the WHOLE reason I originally added KEYGRID support (before it was
 * even called KEYGRID support) was to make the 1985 game "Rogue" (pcjs.org/apps/pcx86/1985/rogue)
 * more fun to play on an iPad (the space-bar is a commonly required key).
 */
Video.KEYGRID = [
    [Keyboard.SIMCODE.HOME, Keyboard.SIMCODE.UP,    Keyboard.SIMCODE.PGUP],
    [Keyboard.SIMCODE.LEFT, Keyboard.SIMCODE.SPACE, Keyboard.SIMCODE.RIGHT],
    [Keyboard.SIMCODE.END,  Keyboard.SIMCODE.DOWN,  Keyboard.SIMCODE.PGDN],
];

/*
 * Port input/output notification tables
 */
Video.aMDAPortInput = {
    0x3B0: Video.prototype.inMDAIndx,           // duplicate of 0x3B4
    0x3B1: Video.prototype.inMDAData,           // duplicate of 0x3B5
    0x3B2: Video.prototype.inMDAIndx,           // duplicate of 0x3B4
    0x3B3: Video.prototype.inMDAData,           // duplicate of 0x3B5
    0x3B4: Video.prototype.inMDAIndx,           // technically, not actually readable, but I want the Debugger to be able to read this
    0x3B5: Video.prototype.inMDAData,           // technically, the only CRTC Data registers that are readable are R14-R17
    0x3B6: Video.prototype.inMDAIndx,           // duplicate of 0x3B4
    0x3B7: Video.prototype.inMDAData,           // duplicate of 0x3B5
    0x3B8: Video.prototype.inMDAMode,           // technically, not actually readable, but I want the Debugger to be able to read this
    0x3BA: Video.prototype.inMDAStatus
};

Video.aMDAPortOutput = {
    0x3B0: Video.prototype.outMDAIndx,          // duplicate of 0x3B4
    0x3B1: Video.prototype.outMDAData,          // duplicate of 0x3B5
    0x3B2: Video.prototype.outMDAIndx,          // duplicate of 0x3B4
    0x3B3: Video.prototype.outMDAData,          // duplicate of 0x3B5
    0x3B4: Video.prototype.outMDAIndx,
    0x3B5: Video.prototype.outMDAData,
    0x3B6: Video.prototype.outMDAIndx,          // duplicate of 0x3B4
    0x3B7: Video.prototype.outMDAData,          // duplicate of 0x3B5
    0x3B8: Video.prototype.outMDAMode
};

Video.aCGAPortInput = {
    0x3D4: Video.prototype.inCGAIndx,           // technically, not actually readable, but I want the Debugger to be able to read this
    0x3D5: Video.prototype.inCGAData,           // technically, the only CRTC Data registers that are readable are R14-R17
    0x3D8: Video.prototype.inCGAMode,           // technically, not actually readable, but I want the Debugger to be able to read this
    0x3D9: Video.prototype.inCGAColor,          // technically, not actually readable, but I want the Debugger to be able to read this
    0x3DA: Video.prototype.inCGAStatus
};

Video.aCGAPortOutput = {
    0x3D4: Video.prototype.outCGAIndx,
    0x3D5: Video.prototype.outCGAData,
    0x3D8: Video.prototype.outCGAMode,
    0x3D9: Video.prototype.outCGAColor
};

Video.aEGAPortInput = {
    0x3C0: Video.prototype.inATCIndx,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
    0x3C1: Video.prototype.inATCData,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
    0x3C2: Video.prototype.inStatus0,
    0x3C4: Video.prototype.inSEQIndx,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
    0x3C5: Video.prototype.inSEQData,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
    0x3CE: Video.prototype.inGRCIndx,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
    0x3CF: Video.prototype.inGRCData            // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
};

/*
 * WARNING: Unlike the EGA, a standard VGA does not support writes to 0x3C1, but it's easier for me to leave that
 * ability in place, treating the VGA as a superset of the EGA as much as possible; will any code break because word
 * OUTs to port 0x3C0 (and/or byte OUTs to port 0x3C1) actually work?  Possibly, but highly unlikely.
 */
Video.aEGAPortOutput = {
    0x3BA: Video.prototype.outFeat,
    0x3C0: Video.prototype.outATC,
    0x3C1: Video.prototype.outATC,              // the EGA BIOS writes to this port (see C000:0416), implying that 0x3C0 and 0x3C1 both decode the same register
    0x3C2: Video.prototype.outMisc,             // FYI, since this overlaps with STATUS0.PORT, there's currently no way for the Debugger to read the Misc register
    0x3C4: Video.prototype.outSEQIndx,
    0x3C5: Video.prototype.outSEQData,
    0x3CA: Video.prototype.outGRCPos2,
    0x3CC: Video.prototype.outGRCPos1,
    0x3CE: Video.prototype.outGRCIndx,
    0x3CF: Video.prototype.outGRCData,
    0x3DA: Video.prototype.outFeat
};

Video.aVGAPortInput = {
    0x3C3: Video.prototype.inVGAEnable,
    0x3C6: Video.prototype.inDACMask,
    0x3C7: Video.prototype.inDACState,
    0x3C9: Video.prototype.inDACData,
    0x3CA: Video.prototype.inVGAFeat,
    0x3CC: Video.prototype.inVGAMisc
};

Video.aVGAPortOutput = {
    0x3C3: Video.prototype.outVGAEnable,
    0x3C6: Video.prototype.outDACMask,
    0x3C7: Video.prototype.outDACRead,
    0x3C8: Video.prototype.outDACWrite,
    0x3C9: Video.prototype.outDACData
};

/*
 * Initialize every Video module on the page.
 */
Web.onInit(Video.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/parallel.js (C) Jeff Parsons 2012-2018
 */


/*
 * class ParallelPort
 * property {number} iAdapter
 * property {number} portBase
 * property {number} nIRQ
 * property {Object} controlBuffer is a DOM element bound to the port (for rudimentary output; see transmitByte())
 *
 * NOTE: This class declaration started as a way of informing the code inspector of the controlBuffer property,
 * which remained undefined until a setBinding() call set it later, but I've since decided that explicitly
 * initializing such properties in the constructor is a better way to go -- even though it's more code -- because
 * JavaScript compilers are supposed to be happier when the underlying object structures aren't constantly changing.
 *
 * Besides, I'm not sure I want to get into documenting every property this way, for this or any/every other class,
 * let alone getting into which ones should be considered private or protected, because PCjs isn't really a library
 * for third-party apps.
 */

/**
 * class ParallelPort
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class ParallelPort extends Component {
    /**
     * ParallelPort(parmsParallel)
     *
     * The ParallelPort component has the following component-specific (parmsParallel) properties:
     *
     *      adapter: 1 (port 0x3BC), 2 (port 0x378), or 3 (port 0x278); 0 if not defined
     *
     *      binding: name of a control (based on its "binding" attribute) to bind to this port's I/O
     *
     * In the future, we may support 'port' and 'irq' properties that allow the machine to define a
     * non-standard parallel port configuration, instead of only our pre-defined 'adapter' configurations.
     *
     * NOTE: Since the XSL file defines 'adapter' as a number, not a string, there's no need to use
     * parseInt(), and as an added benefit, we don't need to worry about whether a hex or decimal format
     * was used.
     *
     * DOS typically names the Primary adapter "LPT1" and the Secondary adapter "LPT2", but I prefer
     * to stick to adapter numbers, since not all operating systems follow those naming conventions.
     *
     * @this {ParallelPort}
     * @param {Object} parmsParallel
     */
    constructor(parmsParallel)
    {
        super("ParallelPort", parmsParallel, Messages.PARALLEL);

        this.iAdapter = parmsParallel['adapter'];

        switch (this.iAdapter) {
        case 1:
            this.portBase = 0x3BC;
            this.nIRQ = ChipSet.IRQ.LPT1;
            break;
        case 2:
            this.portBase = 0x378;
            this.nIRQ = ChipSet.IRQ.LPT1;
            break;
        case 3:
            this.portBase = 0x278;
            this.nIRQ = ChipSet.IRQ.LPT2;
            break;
        default:
            Component.warning("Unrecognized parallel adapter #" + this.iAdapter);
            return;
        }
        /**
         * consoleBuffer becomes a string that records parallel port output if the 'binding' property is set to the
         * reserved name "console".  Nothing is written to the console, however, until a linefeed (0x0A) is output
         * or the string length reaches a threshold (currently, 1024 characters).
         *
         * @type {string|null}
         */
        this.consoleBuffer = null;

        /**
         * controlBuffer is a DOM element bound to the port (currently used for output only; see transmitByte()).
         *
         * @type {Object}
         */
        this.controlBuffer = null;

        let sBinding = parmsParallel['binding'];
        if (sBinding == "console") {
            this.consoleBuffer = "";
        } else {
            /*
             * If the ParallelPort wants to bind to a control (eg, "print") in a DIFFERENT component (eg, "Panel"),
             * then it specifies the name of that control with the 'binding' property.  The ParallelPort constructor
             * will then call bindExternalControl(), which looks up the control, and then passes it to our own
             * setBinding() handler.
             *
             * For bindExternalControl() to succeed, it also need to know the target component; for now, that's
             * been hard-coded to "Panel", in part because that's one of the few components we can rely upon
             * initializing before we do, but it would be a simple matter to include a component type or ID as part
             * of the 'binding' property as well, if we need more flexibility later.
             *
             * NOTE: If sBinding is not the name of a valid Control Panel DOM element, this call does nothing.
             */
            Component.bindExternalControl(this, sBinding);
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {ParallelPort}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "buffer")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        if (!sHTMLType || sHTMLType == "textarea") {
            this.bindings[sBinding] = this.controlBuffer = control;
            return true;
        }
        return false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {ParallelPort}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.chipset = cmp.getMachineComponent("ChipSet");
        bus.addPortInputTable(this, ParallelPort.aPortInput, this.portBase);
        bus.addPortOutputTable(this, ParallelPort.aPortOutput, this.portBase);
        this.setReady();
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {ParallelPort}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {ParallelPort}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {ParallelPort}
     */
    reset()
    {
        this.initState();
    }

    /**
     * save()
     *
     * This implements save support for the ParallelPort component.
     *
     * @this {ParallelPort}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveRegisters());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the ParallelPort component.
     *
     * @this {ParallelPort}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initState(data[0]);
    }

    /**
     * initState(data)
     *
     * @this {ParallelPort}
     * @param {Array} [data]
     * @return {boolean} true if successful, false if failure
     */
    initState(data)
    {
        let i = 0;
        if (data === undefined) {
            data = [0, ParallelPort.STATUS.NERR | ParallelPort.STATUS.ALWAYS_SET, ParallelPort.CONTROL.ALWAYS_SET];
        }
        this.bData = data[i++];
        this.bStatus = data[i++];
        this.bControl = data[i];
        return true;
    }

    /**
     * saveRegisters()
     *
     * @this {ParallelPort}
     * @return {Array}
     */
    saveRegisters()
    {
        let i = 0;
        let data = [];
        data[i++] = this.bData;
        data[i++] = this.bStatus;
        data[i]   = this.bControl;
        return data;
    }

    /**
     * inData(port, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BC, 0x378, or 0x278)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inData(port, addrFrom)
    {
        let b = this.bData;
        this.printMessageIO(port, undefined, addrFrom, "DATA", b);
        return b;
    }

    /**
     * inStatus(port, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BD, 0x379, or 0x279)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inStatus(port, addrFrom)
    {
        let b = this.bStatus;
        this.bStatus |= (ParallelPort.STATUS.NACK | ParallelPort.STATUS.NBUSY);
        this.printMessageIO(port, undefined, addrFrom, "STAT", b);
        this.updateIRR();
        return b;
    }

    /**
     * inControl(port, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BE, 0x37A, or 0x27A)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inControl(port, addrFrom)
    {
        let b = this.bControl;
        this.printMessageIO(port, undefined, addrFrom, "CTRL", b);
        return b;
    }

    /**
     * outData(port, bOut, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BC, 0x378, or 0x278)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outData(port, bOut, addrFrom)
    {
        let parallel = this;
        this.printMessageIO(port, bOut, addrFrom, "DATA");
        this.bData = bOut;
        this.cpu.nonCPU(function() {
            if (parallel.transmitByte(bOut)) {
                parallel.bStatus |= ParallelPort.STATUS.NERR;
                parallel.bStatus &= ~(ParallelPort.STATUS.NACK | ParallelPort.STATUS.NBUSY);
                return true;
            }
            return false;
        });
        this.updateIRR();
    }

    /**
     * outControl(port, bOut, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BE, 0x37A, or 0x27A)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outControl(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "CTRL");
        this.bControl = bOut | ParallelPort.CONTROL.ALWAYS_SET;
        this.updateIRR();
    }

    /**
     * updateIRR()
     *
     * @this {ParallelPort}
     */
    updateIRR()
    {
        if (this.chipset && this.nIRQ) {
            if ((this.bControl & ParallelPort.CONTROL.IRQ_ENABLE) && !(this.bStatus & ParallelPort.STATUS.NACK)) {
                this.chipset.setIRR(this.nIRQ);
            } else {
                this.chipset.clearIRR(this.nIRQ);
            }
        }
    }

    /**
     * transmitByte(b)
     *
     * @this {ParallelPort}
     * @param {number} b
     * @return {boolean} true if transmitted, false if not
     */
    transmitByte(b)
    {
        let fTransmitted = false;

        this.printMessage("transmitByte(" + Str.toHexByte(b) + ")");

        if (this.controlBuffer) {
            if (b == 0x0D) {
                // this.iLogicalCol = 0;
            }
            else if (b == 0x08) {
                this.controlBuffer.value = this.controlBuffer.value.slice(0, -1);
            }
            else {
                /*
                 * If we assume that the printer being used was the original IBM 80 CPS Matrix Printer,
                 * characters 0x80-0x9F mirror control codes 0x00-0x1F, and characters 0xA0-0xDF are various
                 * block shapes, sort of in the spirit of the line-drawing characters 0xC0-0xDF defined by
                 * IBM Code Page 437, but, no, completely different.  And apparently, characters 0xE0-0xFF
                 * printed nothing at all (see Table 11 on page 2-78 of the original IBM PC 5150 TechRef).
                 *
                 * The only control character we care about is LINE-FEED; for all other control characters,
                 * we'll display the ASCII mnemonic, to make it clear what the software intended.  And as for
                 * any block characters, we'll print an asterisk and call it good, for now.  Beyond that,
                 * we'll just print spaces.
                 */
                if (b >= 0x80) {
                    if (b < 0xA0) {
                        b -= 0x80;
                    } else if (b < 0xE0) {
                        b = 0x2A;       // ASCII code for an asterisk
                    } else {
                        b = 0x20;       // ASCII code for a space
                    }
                }
                this.controlBuffer.value += Str.toASCIICode(b);
                this.controlBuffer.scrollTop = this.controlBuffer.scrollHeight;
            }
            fTransmitted = true;
        }
        else if (this.consoleBuffer != null) {
            if (b == 0x0A || this.consoleBuffer.length >= 1024) {
                this.println(this.consoleBuffer);
                this.consoleBuffer = "";
            }
            if (b != 0x0A) {
                this.consoleBuffer += String.fromCharCode(b);
            }
            fTransmitted = true;
        }

        return fTransmitted;
    }

    /**
     * ParallelPort.init()
     *
     * This function operates on every HTML element of class "parallel", extracting the
     * JSON-encoded parameters for the ParallelPort constructor from the element's "data-value"
     * attribute, invoking the constructor to create a ParallelPort component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeParallel = Component.getElementsByClass(document, PCX86.APPCLASS, "parallel");
        for (let iParallel = 0; iParallel < aeParallel.length; iParallel++) {
            let eParallel = aeParallel[iParallel];
            let parmsParallel = Component.getComponentParms(eParallel);
            let parallel = new ParallelPort(parmsParallel);
            Component.bindComponentControls(parallel, eParallel, PCX86.APPCLASS);
        }
    }
}

/*
 * The "Data Register" is an input/output register at offset 0 from portBase.  The bit-to-pin mappings are:
 *
 *      Bit     Pin
 *      ---     ---
 *       0       2              // 0x01 (DATA 1)
 *       1       3              // 0x02 (DATA 2)
 *       2       4              // 0x04 (DATA 3)
 *       3       5              // 0x08 (DATA 4)
 *       4       6              // 0x10 (DATA 5)
 *       5       7              // 0x20 (DATA 6)
 *       6       8              // 0x40 (DATA 7)
 *       7       9              // 0x80 (DATA 8)
 */
ParallelPort.DATA = {           // (read/write)
    REG:        0
};

/*
 * The "Status Register" is an input register at offset 1 from portBase.  The bit-to-pin mappings are:
 *
 *      Bit     Pin
 *      ---     ---
 *       0       -              // 0x01 (always set on MDA printer port)
 *       1       -              // 0x02 (always set on MDA printer port)
 *       2       -              // 0x04 (always set on MDA printer port)
 *       3       !15            // 0x08 (Error)
 *       4       13             // 0x10 (Select)
 *       5       12             // 0x20 (Out of Paper)
 *       6       !10            // 0x40 (Acknowledged)
 *       7       11             // 0x80 (Busy; eg, printer off-line or operation in progress)
 */
ParallelPort.STATUS = {         // (read)
    REG:        1,
    ALWAYS_SET: 0x07,           // (always set on MDA printer port)
    NERR:       0x08,           // when this bit is clear, I/O error (inverted by the ROM BIOS INT 17h Status function)
    SELECT:     0x10,           // when this bit is set, printer selected
    PAPER:      0x20,           // when this bit is set, out of paper
    NACK:       0x40,           // when this bit is clear, data acknowledged (and optionally, interrupt requested; inverted by the ROM BIOS INT 17h Status function)
    NBUSY:      0x80            // when this bit is clear, printer busy (TODO: Is this really inverted? https://www.seasip.info/VintagePC/mda.htm doesn't show it that way; perhaps it's simply that the signal from the printer is typically inverted)
};

/*
 * The "Control Register" is an input/output register at offset 2 from portBase.  The bit-to-pin mappings are:
 *
 *      Bit     Pin
 *      ---     ---
 *       0       !1             // 0x01 (read input data)
 *       1      !14             // 0x02 (automatically feed paper one line)
 *       2       16             // 0x04
 *       3      !17             // 0x08
 *
 * Additionally, bit 4 is the IRQ ENABLE bit, which allows interrupts when pin 10 transitions high to low.
 */
ParallelPort.CONTROL = {        // (read/write)
    REG:        2,
    NSTROBE:    0x01,           // !Strobe
    NAUTOFEED:  0x02,           // !Auto feed
    INIT:       0x04,           // Initialize printer
    NSELECT:    0x08,           // !Select input
    IRQ_ENABLE: 0x10,           // set to enable interrupts (when printer clears NACK)
    ALWAYS_SET: 0xE0            // (always set on MDA printer port when reading)
};

/*
 * Port input notification table
 */
ParallelPort.aPortInput = {
    0x0: ParallelPort.prototype.inData,
    0x1: ParallelPort.prototype.inStatus,
    0x2: ParallelPort.prototype.inControl
};

/*
 * Port output notification table
 */
ParallelPort.aPortOutput = {
    0x0: ParallelPort.prototype.outData,
    0x2: ParallelPort.prototype.outControl
};

/*
 * Initialize every ParallelPort module on the page.
 */
Web.onInit(ParallelPort.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/serial.js (C) Jeff Parsons 2012-2018
 */


/**
 * SerialPort class
 *
 * The class property declarations below started as a way of informing the code inspector of the controlBuffer
 * property, which remained undefined until a setBinding() call set it later, but I've since decided that explicitly
 * initializing such properties in the constructor is a better way to go -- even though it's more code -- because
 * JavaScript compilers are supposed to be happier when the underlying object structures aren't constantly changing.
 *
 * Besides, I'm not sure I want to get into documenting every property this way, for this or any/every other class,
 * let alone getting into which ones should be considered private or protected, because PCjs isn't really a library
 * for third-party apps.
 *
 * @class SerialPort
 * @property {number} iAdapter
 * @property {number} portBase
 * @property {number} nIRQ
 * @property {string|null} consoleBuffer
 * @property {HTMLTextAreaElement} controlBuffer (DOM element bound to the port for rudimentary output; see transmitByte())
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class SerialPort extends Component {
    /**
     * SerialPort(parms)
     *
     * The SerialPort component has the following component-specific (parms) properties:
     *
     *      adapter: 1 (port 0x3F8) or 2 (port 0x2F8); 0 if not defined
     *
     *      binding: name of a control (based on its "binding" attribute) to bind to this port's I/O;
     *      as a special case, it can be set to "console" to direct all output to the component's default
     *      println() handler (eg, the Control Panel's "print" control, if any, or console.log() if using
     *      a DEBUG or non-COMPILED machine)
     *
     *      tabSize: a non-zero number specifies the tab-stop multiple to use for automatic tab-to-space
     *      conversion; it applies only to the above binding, and the default is 0 (no tab conversion)
     *
     *      charBOL: a non-zero number specifies the ASCII code of a character to display at the beginning
     *      of every line; it applies only to the above binding, and the default is 0 (no BOL character)
     *
     * In the future, we may support 'port' and 'irq' properties that allow the machine to define a non-standard
     * serial port configuration, instead of only our pre-defined 'adapter' configurations.
     *
     * NOTE: Since the XSL file defines 'adapter' as a number, not a string, there's no need to use parseInt(),
     * and as an added benefit, we don't need to worry about whether a hex or decimal format was used.
     *
     * This hard-coded approach mimics the original IBM PC Asynchronous Adapter configuration, which contained
     * a pair of "shunt modules" that allowed the user to select a port address/IRQ combo of either 0x3F8/IRQ4
     * ("Primary") or 0x2F8/IRQ3 ("Secondary").
     *
     * DOS names the first adapter listed by the ROM BIOS as "COM1", even if that adapter is a secondary adapter,
     * so don't assume that COM1 always maps to port 0x3F8/IRQ4.  Internally, I try avoid confusion by always
     * starting with a primary adapter and giving that adapter an ID of "com1".  But different operating systems
     * may follow different device enumeration and naming conventions, so don't make too much of my internally
     * assigned IDs.
     *
     * @this {SerialPort}
     * @param {Object} parms
     */
    constructor(parms)
    {
        super("SerialPort", parms, Messages.SERIAL);

        this.iAdapter = parms['adapter'];

        switch (this.iAdapter) {
        case 1:
            this.portBase = 0x3F8;
            this.nIRQ = ChipSet.IRQ.COM1;
            break;
        case 2:
            this.portBase = 0x2F8;
            this.nIRQ = ChipSet.IRQ.COM2;
            break;
        default:
            if (this.idComponent != "test") {
                Component.warning("Unrecognized serial adapter #" + this.iAdapter);
                return;
            }
            break;
        }

        /*
         * consoleBuffer becomes a string that records serial port output if the 'binding' property is set to the
         * reserved name "console".  Nothing is written to the console, however, until a linefeed (0x0A) is output
         * or the string length reaches a threshold (currently, 1024 characters).
         */
        this.consoleBuffer = null;

        /*
         * controlBuffer is a DOM element bound to the port (currently used for output only; see transmitByte()).
         *
         * Example: CTTY COM2
         *
         * The CTTY DOS command redirects all CON I/O to the specified serial port (eg, COM2), which it assumes is
         * connected to a serial terminal, and therefore anything it *transmits* via COM2 will be displayed by the
         * terminal.  It further assumes that anything typed on such a terminal is NOT displayed, so as DOS *receives*
         * serial input, DOS *transmits* the appropriate characters back to the terminal via COM2.
         *
         * As a result, controlBuffer only needs to be updated by the transmitByte() function.
         */
        this.controlBuffer = null;

        /*
         * If controlBuffer is being used AND 'tabSize' is set, then we make an attempt to monitor the characters
         * being echoed via transmitByte(), maintain a logical column position, and convert any tabs into the appropriate
         * number of spaces.
         *
         * Another controlBuffer feature is charBOL, which, if nonzero, specifies a character to automatically output
         * at the beginning of every line.  This probably isn't generally useful; I use it internally to preformat serial
         * output.
         */
        this.tabSize = parms['tabSize'] || 0;
        this.charBOL = parms['charBOL'] || 0;
        this.charPrev = 0;
        this.iLogicalCol = 0;

        this.bMSRInit = SerialPort.MSR.CTS | SerialPort.MSR.DSR;
        this.fNullModem = true;

        /*
         * Normally, any HTML controls defined within the scope of the component's XML element are *implicitly*
         * bound to us.  For example, in the XML below, the textarea control will automatically trigger a call to
         * setBinding() with sBinding set to "serialWindow" and control set to an HTMLTextAreaElement.
         *
	     *      <serial id="com1">
	     *          <control type="container" class="pcjs-textarea">
	     *      	    <control type="textarea" binding="serialWindow"/>
	     *          </control>
	     *      </serial>
	     *
	     * However, this component also supports an *explicit* binding attribute, which can either be the hard-coded
	     * name "console" (for routing all output to the system console) or the name of a control binding that has
	     * been defined in another component (eg, an HTMLTextAreaElement defined as part of the Control Panel layout).
         */
        let sBinding = parms['binding'];
        if (sBinding == "console") {
            this.consoleBuffer = "";
        } else {
            /*
             * If the SerialPort wants to bind to a control (eg, "print") in a DIFFERENT component (eg, "Panel"),
             * then it specifies the name of that control with the 'binding' property.  The SerialPort constructor
             * will then call bindExternalControl(), which looks up the control, and then passes it to our own
             * setBinding() handler.
             *
             * For bindExternalControl() to succeed, it also need to know the target component; for now, that's
             * been hard-coded to "Panel", in part because that's one of the few components we can rely upon
             * initializing before we do, but it would be a simple matter to include a component type or ID as part
             * of the 'binding' property as well, if we need more flexibility later.
             *
             * NOTE: If sBinding is not the name of a valid Control Panel DOM element, this call does nothing.
             */
            Component.bindExternalControl(this, sBinding);
        }

        /*
         * No connection until initConnection() is called.
         */
        this.sDataReceived = "";
        this.connection = this.sendData = this.updateStatus = null;
        this.fAutoFlow = false;

        /*
         * Export all functions required by bindConnection() or initConnection(), whichever is required.
         */
        this['exports'] = {
            'bind': this.bindConnection,
            'connect': this.initConnection,
            'receiveData': this.receiveData,
            'receiveStatus': this.receiveStatus
        };
    }

    /**
     * bindConnection(connection, receiveData, fAutoFlow)
     *
     * This is basically a lighter-weight version of initConnection(), used by built-in components
     * like TestController, as opposed to components in external machines, which require more work to connect.
     *
     * @this {SerialPort}
     * @param {Component} connection
     * @param {function()} receiveData
     * @param {boolean} [fAutoFlow] (true to enable automatic flow control; default is false)
     * @return {boolean}
     */
    bindConnection(connection, receiveData, fAutoFlow = false)
    {
        if (!this.connection) {
            this.connection = connection;
            this.sendData = receiveData;
            this.fAutoFlow = fAutoFlow;
            return true;
        }
        return false;
    }

    /**
     * bindMouse(id, mouse, fnUpdate)
     *
     * @this {SerialPort}
     * @param {string} id
     * @param {Mouse} mouse
     * @param {function(number)} fnUpdate
     * @return {Component|null}
     */
    bindMouse(id, mouse, fnUpdate)
    {
        let component = null;
        if (id == this.idComponent && !this.connection) {
            this.connection = mouse;
            this.updateStatus = fnUpdate;
            this.fNullModem = false;
            component = this;
        }
        return component;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {SerialPort}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "buffer")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        if (!sHTMLType || sHTMLType == "textarea") {

            let serial = this;
            this.bindings[sBinding] = this.controlBuffer = /** @type {HTMLTextAreaElement} */ (control);

            /*
             * By establishing an onkeypress handler here, we make it possible for DOS commands like
             * "CTTY COM1" to more or less work (use "CTTY CON" to restore control to the DOS console).
             */
            this.controlBuffer.onkeydown = function onKeyDown(event) {
                /*
                 * This is required in addition to onkeypress, because it's the only way to prevent
                 * BACKSPACE (keyCode 8) from being interpreted by the browser as a "Back" operation;
                 * moreover, not all browsers generate an onkeypress notification for BACKSPACE.
                 *
                 * A related problem exists for Ctrl-key combinations in most Windows-based browsers
                 * (eg, IE, Edge, Chrome for Windows, etc), because keys like Ctrl-C and Ctrl-S have
                 * special meanings (eg, Copy, Save).  To the extent the browser will allow it, we
                 * attempt to disable that default behavior when this control receives an onkeydown
                 * event for one of those keys (probably the only event the browser generates for them).
                 */
                event = event || window.event;
                let keyCode = event.keyCode;
                if (keyCode === 0x08 || event.ctrlKey && keyCode >= 0x41 && keyCode <= 0x5A) {
                    if (event.preventDefault) event.preventDefault();
                    if (keyCode > 0x40) keyCode -= 0x40;
                    serial.receiveData(keyCode);
                }
                return true;
            };

            this.controlBuffer.onkeypress = function onKeyPress(event) {
                /*
                 * Browser-independent keyCode extraction; refer to onKeyPress() and the other key event
                 * handlers in keyboard.js.
                 */
                event = event || window.event;
                let keyCode = event.which || event.keyCode;
                serial.receiveData(keyCode);
                /*
                 * Since we're going to remove the "readonly" attribute from the <textarea> control
                 * (so that the soft keyboard activates on iOS), instead of calling preventDefault() for
                 * selected keys (eg, the SPACE key, whose default behavior is to scroll the page), we must
                 * now call it for *all* keys, so that the keyCode isn't added to the control immediately,
                 * on top of whatever the machine is echoing back, resulting in double characters.
                 */
                if (event.preventDefault) event.preventDefault();
                return true;
            };

            /*
             * Now that we've added an onkeypress handler that calls preventDefault() for ALL keys, the control
             * itself no longer needs the "readonly" attribute; we primarily need to remove it for iOS browsers,
             * so that the soft keyboard will activate, but it shouldn't hurt to remove the attribute for all browsers.
             */
            this.controlBuffer.removeAttribute("readonly");
            return true;
        }

        // default:
        //     if (!this.iAdapter) {
        //         control.removeAttribute("readonly");
        //     }
        //     break;
        // }

        return false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {SerialPort}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;

        if (this.iAdapter) {
            this.bus = bus;
            this.cpu = cpu;
            this.dbg = dbg;

            let serial = this;
            this.timerReceiveNext = this.cpu.addTimer(this.id + ".receive", function receiveDataTimer() {
                serial.receiveData();
            });
            this.timerTransmitNext = this.cpu.addTimer(this.id + ".transmit", function transmitDataTimer() {
                serial.transmitData();
            });

            this.chipset = cmp.getMachineComponent("ChipSet");

            bus.addPortInputTable(this, SerialPort.aPortInput, this.portBase);
            bus.addPortOutputTable(this, SerialPort.aPortOutput, this.portBase);
        }
        this.setReady();
    }

    /**
     * initConnection(fNullModem)
     *
     * If a machine 'connection' parameter exists of the form "{sourcePort}->{targetMachine}.{targetPort}",
     * and "{sourcePort}" matches our idComponent, then look for a component with id "{targetMachine}.{targetPort}".
     *
     * If the target component is found, then verify that it has exported functions with the following names:
     *
     *      receiveData(data): called when we have data to transmit; aliased internally to sendData(data)
     *      receiveStatus(pins): called when our control signals have changed; aliased internally to updateStatus(pins)
     *
     * For now, we're not going to worry about communication in the other direction, because when the target component
     * performs its own initConnection(), it will find our receiveData() and receiveStatus() functions, at which point
     * communication in both directions should be established, and the circle of life is complete.
     *
     * For added robustness, if the target machine initializes much more slowly than we do, and our connection attempt
     * fails, that's OK, because when it finally initializes, its initConnection() will call our initConnection();
     * if we've already initialized, no harm done.
     *
     * @this {SerialPort}
     * @param {boolean} [fNullModem] (caller's null-modem setting, to ensure our settings are in agreement)
     */
    initConnection(fNullModem)
    {
        if (!this.connection) {
            let sConnection = this.cmp.getMachineParm('connection');
            if (sConnection) {
                let asParts = sConnection.split('->');
                if (asParts.length == 2) {
                    let sSourceID = Str.trim(asParts[0]);
                    if (sSourceID != this.idComponent) return;  // this connection string is intended for another instance
                    let sTargetID = Str.trim(asParts[1]);
                    this.connection = Component.getComponentByID(sTargetID);
                    if (this.connection) {
                        let exports = this.connection['exports'];
                        if (exports) {
                            let fnConnect = /** @function */ (exports['connect']);
                            if (fnConnect) fnConnect.call(this.connection, this.fNullModem);
                            this.sendData = exports['receiveData'];
                            if (this.sendData) {
                                this.fNullModem = fNullModem;
                                this.updateStatus = exports['receiveStatus'];
                                this.status("Connected " + this.idMachine + '.' + sSourceID + " to " + sTargetID);
                                return;
                            }
                        }
                    }
                }
                /*
                 * Changed from notice() to status() because sometimes a connection fails simply because one of us is a laggard.
                 */
                this.status("Unable to establish connection: " + sConnection);
            }
        }
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {SerialPort}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            /*
             * This is as late as we can currently wait to make our first inter-machine connection attempt;
             * even so, the target machine's initialization process may still be ongoing, so any connection
             * may be not fully resolved until the target machine performs its own initConnection(), which will
             * in turn invoke our initConnection() again.
             */
            this.initConnection(this.fNullModem);

            if (!data || !this.restore) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {SerialPort}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {SerialPort}
     */
    reset()
    {
        this.initState();
    }

    /**
     * save()
     *
     * This implements save support for the SerialPort component.
     *
     * @this {SerialPort}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveRegisters());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the SerialPort component.
     *
     * @this {SerialPort}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initState(data[0]);
    }

    /**
     * initState(data)
     *
     * @this {SerialPort}
     * @param {Array} [data]
     * @return {boolean} true if successful, false if failure
     */
    initState(data)
    {
        /*
         * The NS8250A spec doesn't explicitly say what the RBR and THR are initialized to on a reset,
         * but I think we can safely assume zeros.  Similarly, we reset the baud rate Divisor Latch (wDL)
         * to an arbitrary but consistent default (DL_DEFAULT).
         */
        let i = 0;
        if (data === undefined) {
            data = [
                0,                                          // RBR
                0,                                          // THR
                SerialPort.DL_DEFAULT,                      // DL
                0,                                          // IER
                SerialPort.IIR.NO_INT,                      // IIR
                0,                                          // LCR
                0,                                          // MCR
                SerialPort.LSR.THRE | SerialPort.LSR.TSRE,  // LSR
                this.bMSRInit,                              // MSR
                []
            ];
        }
        this.bRBR = data[i++];
        this.bTHR = data[i++];
        this.wDL =  data[i++];
        this.bIER = data[i++];
        this.bIIR = data[i++];
        this.bLCR = data[i++];
        this.bMCR = data[i++];
        this.bLSR = data[i++];
        this.bMSR = data[i++];
        this.abReceive = data[i];
        return true;
    }

    /**
     * saveRegisters()
     *
     * @this {SerialPort}
     * @return {Array}
     */
    saveRegisters()
    {
        let i = 0;
        let data = [];
        data[i++] = this.bRBR;
        data[i++] = this.bTHR;
        data[i++] = this.wDL;
        data[i++] = this.bIER;
        data[i++] = this.bIIR;
        data[i++] = this.bLCR;
        data[i++] = this.bMCR;
        data[i++] = this.bLSR;
        data[i++] = this.bMSR;
        data[i] = this.abReceive;
        return data;
    }

    /**
     * getBaudTimeout()
     *
     * The 16-bit Divisor Latch is stored in wDL.  If we take the frequency value 1843200 and divide it by wDL*128,
     * we get the maximum number of bytes per second that the SerialPort interface should generate.  For example,
     * if a baud rate of 1200 is being used, the divisor will be 0x60 (96), so we calculate 1843200/(96*128) = 150,
     * which means there should be a 1000ms/150 or 6.667ms delay between bytes delivered.
     *
     * @this {SerialPort}
     * @return {number} (number of milliseconds per byte)
     */
    getBaudTimeout()
    {
        let nBytesPerSecond = 1843200 / ((this.wDL || 1) << 7);
        return (1000 / nBytesPerSecond)|0;
    }

    /**
     * receiveData(data)
     *
     * This replaces the old sendRBR() function, which expected an Array of bytes.  We still support that,
     * but in order to support connections with other SerialPort components (ie, the PC8080 SerialPort), we
     * have added support for numbers and strings as well.  If no data is specified at all, then all we do
     * is "clock" any remaining data into the receiver.
     *
     * @this {SerialPort}
     * @param {number|string|Array} [data]
     * @return {boolean} true if received, false if not
     */
    receiveData(data)
    {
        if (data != null) {
            if (typeof data == "number") {
                this.abReceive.push(data);
            }
            else if (typeof data == "string") {
                for (let i = 0; i < data.length; i++) {
                    this.abReceive.push(data.charCodeAt(i));
                }
            }
            else {
                this.abReceive = this.abReceive.concat(data);
            }
        }
        this.advanceRBR();
        return true;                // for now, return true regardless, since we're buffering everything anyway
    }

    /**
     * receiveStatus(pins)
     *
     * NOTE: Prior to the addition of this interface, the CTS and DSR bits were initialized set and remained set
     * for the life of the machine.  It is entirely appropriate that this is the only way those bits can be changed,
     * because they represent external control signals.
     *
     * @this {SerialPort}
     * @param {number} pins
     */
    receiveStatus(pins)
    {
        let bMSROld = this.bMSR;
        this.bMSR &= ~(SerialPort.MSR.CTS | SerialPort.MSR.DSR);
        if (pins & RS232.CTS.MASK) {
            this.bMSR |= SerialPort.MSR.CTS | SerialPort.MSR.DCTS;
        }
        if (pins & RS232.DSR.MASK) {
            this.bMSR |= SerialPort.MSR.DSR | SerialPort.MSR.DDSR;
        }
        if (bMSROld != this.bMSR) this.updateIIR();
    }

    /**
     * advanceRBR()
     *
     * @this {SerialPort}
     */
    advanceRBR()
    {
        if (this.abReceive.length > 0 && !(this.bLSR & SerialPort.LSR.DR)) {
            if (!this.fAutoFlow || (this.bMCR & SerialPort.MCR.RTS)) {
                this.bRBR = this.abReceive.shift();
                this.bLSR |= SerialPort.LSR.DR;
                if (this.abReceive.length && this.cpu) {
                    this.cpu.setTimer(this.timerReceiveNext, this.getBaudTimeout());
                }
            }
        }
        this.updateIIR();
    }

    /**
     * inRBR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3F8 or 0x2F8)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inRBR(port, addrFrom)
    {
        let b = ((this.bLCR & SerialPort.LCR.DLAB) ? (this.wDL & 0xff) : this.bRBR);
        this.printMessageIO(port, undefined, addrFrom, (this.bLCR & SerialPort.LCR.DLAB) ? "DLL" : "RBR", b);
        this.bLSR &= ~SerialPort.LSR.DR;
        this.advanceRBR();
        return b;
    }

    /**
     * inIER(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3F9 or 0x2F9)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inIER(port, addrFrom)
    {
        let b = ((this.bLCR & SerialPort.LCR.DLAB) ? (this.wDL >> 8) : this.bIER);
        this.printMessageIO(port, undefined, addrFrom, (this.bLCR & SerialPort.LCR.DLAB) ? "DLM" : "IER", b);
        return b;
    }

    /**
     * inIIR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FA or 0x2FA)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inIIR(port, addrFrom)
    {
        let b = this.bIIR;
        /*
         * Reading the IIR is supposed to clear the INT_THR condition (as is another write to the THR).
         */
        if (b == SerialPort.IIR.INT_THR) {
            this.bIIR = SerialPort.IIR.NO_INT;
        }
        this.printMessageIO(port, undefined, addrFrom, "IIR", b);
        return b;
    }

    /**
     * inLCR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FB or 0x2FB)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inLCR(port, addrFrom)
    {
        let b = this.bLCR;
        this.printMessageIO(port, undefined, addrFrom, "LCR", b);
        return b;
    }

    /**
     * inMCR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FC or 0x2FC)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inMCR(port, addrFrom)
    {
        let b = this.bMCR;
        this.printMessageIO(port, undefined, addrFrom, "MCR", b);
        return b;
    }

    /**
     * inLSR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FD or 0x2FD)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inLSR(port, addrFrom)
    {
        let b = this.bLSR;
        this.printMessageIO(port, undefined, addrFrom, "LSR", b);
        return b;
    }

    /**
     * inMSR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FE or 0x2FE)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inMSR(port, addrFrom)
    {
        let b = this.bMSR;
        this.bMSR &= ~(SerialPort.MSR.DCTS | SerialPort.MSR.DDSR);
        this.printMessageIO(port, undefined, addrFrom, "MSR", b);
        return b;
    }

    /**
     * outTHR(port, bOut, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3F8 or 0x2F8)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outTHR(port, bOut, addrFrom)
    {
        let serial = this;
        this.printMessageIO(port, bOut, addrFrom, (this.bLCR & SerialPort.LCR.DLAB) ? "DLL" : "THR");
        if (this.bLCR & SerialPort.LCR.DLAB) {
            this.wDL = (this.wDL & ~0xff) | bOut;
        } else {
            this.bTHR = bOut;
            this.bLSR &= ~(SerialPort.LSR.THRE | SerialPort.LSR.TSRE);
            /*
             * If transmitByte() returned success, we used to immediately re-set the transmitter empty bits:
             *
             *      this.bLSR |= (SerialPort.LSR.THRE | SerialPort.LSR.TSRE);
             *
             * But when we're connected to a virtual device that has no measurable delay, that sets the bits
             * too quickly.  We now arm a timer based on the programmed baud rate, and set the above bits only
             * when that timer fires.
             *
             * Additionally, we no longer care if transmitByte() succeeds, because whether or not a connected
             * device or component received the data is irrelevant to the internal mechanics of the serial port.
             *
             * TODO: Determine if we should also flush/zero bTHR after transmission.
             */
            this.cpu.nonCPU(function() {
                return serial.transmitByte(bOut);
            });
            this.cpu.setTimer(this.timerTransmitNext, this.getBaudTimeout());
            this.updateIIR();
        }
    }

    /**
     * outIER(port, bOut, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3F9 or 0x2F9)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outIER(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, (this.bLCR & SerialPort.LCR.DLAB) ? "DLM" : "IER");
        if (this.bLCR & SerialPort.LCR.DLAB) {
            this.wDL = (this.wDL & 0xff) | (bOut << 8);
        } else {
            this.bIER = bOut;
        }
    }

    /**
     * outLCR(port, bOut, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FB or 0x2FB)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outLCR(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "LCR");
        this.bLCR = bOut;
    }

    /**
     * outMCR(port, bOut, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FC or 0x2FC)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outMCR(port, bOut, addrFrom)
    {
        let delta = (bOut ^ this.bMCR);
        this.printMessageIO(port, bOut, addrFrom, "MCR");
        this.bMCR = bOut;
        /*
         * Whenever DTR or RTS changes, we also need to notify any connected machine or mouse, via updateStatus().
         */
        if (delta & (SerialPort.MCR.DTR | SerialPort.MCR.RTS)) {
            if (this.updateStatus) {
                let pins = 0;
                if (this.fNullModem) {
                    pins |= (bOut & SerialPort.MCR.RTS)? RS232.CTS.MASK : 0;
                    pins |= (bOut & SerialPort.MCR.DTR)? (RS232.DSR.MASK | RS232.CD.MASK): 0;
                } else {
                    pins |= (bOut & SerialPort.MCR.RTS)? RS232.RTS.MASK : 0;
                    pins |= (bOut & SerialPort.MCR.DTR)? RS232.DTR.MASK : 0;
                }
                this.updateStatus.call(this.connection, pins);
            }
            /*
             * Throw in a call to advanceRBR() for good measure, in case fAutoFlow is set and RTS was just enabled.
             */
            this.advanceRBR();
        }
    }

    /**
     * updateIIR()
     *
     * @this {SerialPort}
     */
    updateIIR()
    {
        let bIIR = -1;
        /*
         * We check all the interrupt conditions in priority order.  TODO: Add INT_LSR.
         */
        if ((this.bLSR & SerialPort.LSR.DR) && (this.bIER & SerialPort.IER.RBR_AVAIL)) {
            bIIR = SerialPort.IIR.INT_RBR;
        }
        else if ((this.bLSR & SerialPort.LSR.THRE) && (this.bIER & SerialPort.IER.THR_EMPTY)) {
            bIIR = SerialPort.IIR.INT_THR;
        }
        else if ((this.bMSR & (SerialPort.MSR.DCTS | SerialPort.MSR.DDSR)) && (this.bIER & SerialPort.IER.MSR_DELTA)) {
            bIIR = SerialPort.IIR.INT_MSR;
        }
        if (bIIR >= 0) {
            this.bIIR &= ~(SerialPort.IIR.NO_INT | SerialPort.IIR.INT_BITS);
            this.bIIR |= bIIR;
            /*
             * I still throttle SerialPort interrupts by passing a hard-coded delay of 100 instructions to setIRR(),
             * even though we are now (theoretically) honoring the programmed baud rate.  The setIRR() delay does not
             * ensure any particular baud rate, it simply gives the underlying Interrupt Service Routine (ISR) some
             * breathing room.
             *
             * The Microsoft Windows 1.01 serial mouse driver ISR issues an EOI before it has safely exited, presumably
             * relying on the fact that a 1200 baud serial device would not normally interrupt frequently enough to
             * blow the stack.  However, in PCx86, all you have to do is remove the delay below and enable Debugger
             * messages on every serial interrupt and mouse event, eg:
             *
             *      m serial on;m pic on;m mouse on
             *
             * to slow the machine down to the point where serial mouse interrupts overwhelm the ISR.  The Debugger
             * messages display the current stack pointer, which you can watch drop to zero and then wrap around, no
             * doubt trampling lots of code and data along the way.
             *
             * This problem could also occur without being forced by the Debugger; eg, if your physical machine's mouse
             * was configured for a high interrupt rate, and your browser generated mouse events at a comparable rate.
             */
            if (this.chipset && this.nIRQ) this.chipset.setIRR(this.nIRQ, 100);
        } else {
            this.bIIR = SerialPort.IIR.NO_INT;
            if (this.chipset && this.nIRQ) this.chipset.clearIRR(this.nIRQ);
        }
    }

    /**
     * transmitByte(b)
     *
     * @this {SerialPort}
     * @param {number} b
     * @return {boolean} true if transmitted, false if not
     */
    transmitByte(b)
    {
        let fTransmitted = false;

        this.printMessage("transmitByte(" + Str.toHexByte(b) + ")");

        if (this.sendData) {
            if (this.sendData.call(this.connection, b)) {
                fTransmitted = true;
            }
        }

        if (this.controlBuffer) {
            if (b == 0x0D) {
                this.iLogicalCol = 0;
            }
            else if (b == 0x08) {
                this.controlBuffer.value = this.controlBuffer.value.slice(0, -1);
                /*
                 * TODO: Back up the correct number of columns if the character erased was a tab.
                 */
                if (this.iLogicalCol > 0) this.iLogicalCol--;
            }
            else {
                let s = Str.toASCIICode(b); // formerly: String.fromCharCode(b);
                let nChars = s.length;      // formerly: (b >= 0x20? 1 : 0);
                if (b < 0x20 && nChars == 1) nChars = 0;
                if (b == 0x09) {
                    let tabSize = this.tabSize || 8;
                    nChars = tabSize - (this.iLogicalCol % tabSize);
                    if (this.tabSize) s = Str.pad("", nChars);
                }
                if (!this.iLogicalCol && nChars) {
                    /*
                     * When BASIC.COM outputs a listing to a serial port, it ends every line with a CR (0x0D)
                     * but no LF (0x0A), which seems a bit odd.  We fix that here.
                     */
                    if (this.charPrev != 0x0A) s = "\n" + s;
                    if (this.charBOL) s = String.fromCharCode(this.charBOL) + s;
                }
                this.controlBuffer.value += s;
                this.controlBuffer.scrollTop = this.controlBuffer.scrollHeight;
                this.iLogicalCol += nChars;
            }
            this.charPrev = b;
            fTransmitted = true;
        }
        else if (this.consoleBuffer != null) {
            if (b == 0x0A || this.consoleBuffer.length >= 1024) {
                this.println(this.consoleBuffer);
                this.consoleBuffer = "";
            }
            if (b != 0x0A) {
                this.consoleBuffer += String.fromCharCode(b);
            }
            fTransmitted = true;
        }

        return fTransmitted;
    }

    /**
     * transmitData()
     *
     * Helper for clocking transmitted data at the expected baud rate.
     *
     * @this {SerialPort}
     */
    transmitData()
    {
        this.bLSR |= (SerialPort.LSR.THRE | SerialPort.LSR.TSRE);
        this.updateIIR();
    }

    /**
     * SerialPort.init()
     *
     * This function operates on every HTML element of class "serial", extracting the
     * JSON-encoded parameters for the SerialPort constructor from the element's "data-value"
     * attribute, invoking the constructor to create a SerialPort component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeSerial = Component.getElementsByClass(document, PCX86.APPCLASS, "serial");
        for (let iSerial = 0; iSerial < aeSerial.length; iSerial++) {
            let eSerial = aeSerial[iSerial];
            let parms = Component.getComponentParms(eSerial);
            let serial = new SerialPort(parms);
            Component.bindComponentControls(serial, eSerial, PCX86.APPCLASS);
        }
    }
}

/*
 * 8250 I/O register offsets (add these to a I/O base address to obtain an I/O port address)
 *
 * NOTE: DLL.REG and DLM.REG form a 16-bit divisor into a clock input frequency of 1.8432Mhz.  The following
 * values should be used for the corresponding baud rates.  Rates above 9600 are discouraged by the IBM Tech Ref,
 * but rates as high as 128000 are listed on the NS8250A data sheet.
 *
 *      Divisor     Rate        Percent Error
 *      0x0900      50
 *      0x0600      75
 *      0x0417      110         0.026%
 *      0x0359      134.5       0.058%
 *      0x0300      150
 *      0x0180      300
 *      0x00C0      600
 *      0x0060      1200
 *      0x0040      1800
 *      0x003A      2000        0.69%
 *      0x0030      2400
 *      0x0020      3600
 *      0x0018      4800
 *      0x0010      7200
 *      0x000C      9600
 *      0x0006      19200
 *      0x0003      38400
 *      0x0002      56000       2.86%
 *      0x0001      128000
 */
SerialPort.DLL = {REG: 0};      // Divisor Latch LSB (only when SerialPort.LCR.DLAB is set)
SerialPort.THR = {REG: 0};      // Transmitter Holding Register (write)
SerialPort.DL_DEFAULT = 0x180;  // we select an arbitrary default Divisor Latch equivalent to 300 baud

/*
 * Receiver Buffer Register (RBR.REG, offset 0; eg, 0x3F8 or 0x2F8) on read, Transmitter Holding Register on write
 */
SerialPort.RBR = {REG: 0};      // (read)

/*
 * Interrupt Enable Register (IER.REG, offset 1; eg, 0x3F9 or 0x2F9)
 */
SerialPort.IER = {
    REG:            1,          // Interrupt Enable Register
    RBR_AVAIL:      0x01,
    THR_EMPTY:      0x02,
    LSR_DELTA:      0x04,
    MSR_DELTA:      0x08,
    UNUSED:         0xF0        // always zero
};

SerialPort.DLM = {REG: 1};      // Divisor Latch MSB (only when SerialPort.LCR.DLAB is set)

/*
 * Interrupt ID Register (IIR.REG, offset 2; eg, 0x3FA or 0x2FA)
 *
 * All interrupt conditions cleared by reading the corresponding register (or, in the case of IIR.INT_THR, writing a new value to THR.REG)
 */
SerialPort.IIR = {
    REG:            2,          // Interrupt ID Register (read-only)
    NO_INT:         0x01,
    INT_LSR:        0x06,       // Line Status (highest priority: Overrun error, Parity error, Framing error, or Break Interrupt)
    INT_RBR:        0x04,       // Receiver Data Available
    INT_THR:        0x02,       // Transmitter Holding Register Empty
    INT_MSR:        0x00,       // Modem Status Register (lowest priority: Clear To Send, Data Set Ready, Ring Indicator, or Data Carrier Detect)
    INT_BITS:       0x06,
    UNUSED:         0xF8        // always zero (the ROM BIOS relies on these bits "floating to 1" when no SerialPort is present)
};

/*
 * Line Control Register (LCR.REG, offset 3; eg, 0x3FB or 0x2FB)
 */
SerialPort.LCR = {
    REG:            3,          // Line Control Register
    DATA_5BITS:     0x00,
    DATA_6BITS:     0x01,
    DATA_7BITS:     0x02,
    DATA_8BITS:     0x03,
    STOP_BITS:      0x04,       // clear: 1 stop bit; set: 1.5 stop bits for LCR_DATA_5BITS, 2 stop bits for all other data lengths
    PARITY_BIT:     0x08,       // if set, a parity bit is inserted/expected between the last data bit and the first stop bit; no parity bit if clear
    PARITY_EVEN:    0x10,       // if set, even parity is selected (ie, the parity bit insures an even number of set bits); if clear, odd parity
    PARITY_STICK:   0x20,       // if set, parity bit is transmitted inverted; if clear, parity bit is transmitted normally
    BREAK:          0x40,       // if set, serial output (SOUT) signal is forced to logical 0 for the duration
    DLAB:           0x80        // Divisor Latch Access Bit; if set, DLL.REG and DLM.REG can be read or written
};

/*
 * Modem Control Register (MCR.REG, offset 4; eg, 0x3FC or 0x2FC)
 */
SerialPort.MCR = {
    REG:            4,          // Modem Control Register
    DTR:            0x01,       // when set, DTR goes high, indicating ready to establish link (looped back to DSR in loop-back mode)
    RTS:            0x02,       // when set, RTS goes high, indicating ready to exchange data (looped back to CTS in loop-back mode)
    OUT1:           0x04,       // when set, OUT1 goes high (looped back to RI in loop-back mode)
    OUT2:           0x08,       // when set, OUT2 goes high (looped back to RLSD in loop-back mode); must also be set for most UARTs to enable interrupts (but not ours)
    LOOPBACK:       0x10,       // when set, enables loop-back mode
    UNUSED:         0xE0        // always zero
};

/*
 * Line Status Register (LSR.REG, offset 5; eg, 0x3FD or 0x2FD)
 *
 * NOTE: I've seen different specs for the LSR_TSRE.  I'm following the IBM Tech Ref's lead here, but the data sheet
 * I have calls it TEMT instead of TSRE, and claims that it is set whenever BOTH the THR and TSR are empty, and clear
 * whenever EITHER the THR or TSR contain data.
 */
SerialPort.LSR = {
    REG:            5,          // Line Status Register
    DR:             0x01,       // Data Ready (set when new data in RBR.REG; cleared when RBR.REG read)
    OE:             0x02,       // Overrun Error (set when new data arrives in RBR.REG before previous data read; cleared when LSR.REG read)
    PE:             0x04,       // Parity Error (set when new data has incorrect parity; cleared when LSR.REG read)
    FE:             0x08,       // Framing Error (set when new data has invalid stop bit; cleared when LSR.REG read)
    BI:             0x10,       // Break Interrupt (set when new data exceeded normal transmission time; cleared LSR.REG when read)
    THRE:           0x20,       // Transmitter Holding Register Empty (set when UART ready to accept new data; cleared when THR.REG written)
    TSRE:           0x40,       // Transmitter Shift Register Empty (set when the TSR is empty; cleared when the THR is transferred to the TSR)
    UNUSED:         0x80        // always zero
};

/*
 * Modem Status Register (MSR.REG, offset 6; eg, 0x3FE or 0x2FE)
 */
SerialPort.MSR = {
    REG:            6,          // Modem Status Register
    DCTS:           0x01,       // when set, CTS (Clear To Send) has changed since last read
    DDSR:           0x02,       // when set, DSR (Data Set Ready) has changed since last read
    TERI:           0x04,       // when set, TERI (Trailing Edge Ring Indicator) indicates RI has changed from 1 to 0
    DRLSD:          0x08,       // when set, RLSD (Received Line Signal Detector) has changed
    CTS:            0x10,       // when set, the modem or data set is ready to exchange data (complement of the Clear To Send input signal)
    DSR:            0x20,       // when set, the modem or data set is ready to establish link (complement of the Data Set Ready input signal)
    RI:             0x40,       // complement of the RI (Ring Indicator) input
    RLSD:           0x80        // complement of the RLSD (Received Line Signal Detect) input
};

/*
 * Scratch Register (SCR.REG, offset 7; eg, 0x3FF or 0x2FF)
 */
SerialPort.SCR = {REG: 7};

/*
 * Port input notification table
 */
SerialPort.aPortInput = {
    0x0: SerialPort.prototype.inRBR,    // or DLL if DLAB set
    0x1: SerialPort.prototype.inIER,    // or DLM if DLAB set
    0x2: SerialPort.prototype.inIIR,
    0x3: SerialPort.prototype.inLCR,
    0x4: SerialPort.prototype.inMCR,
    0x5: SerialPort.prototype.inLSR,
    0x6: SerialPort.prototype.inMSR
};

/*
 * Port output notification table
 */
SerialPort.aPortOutput = {
    0x0: SerialPort.prototype.outTHR,   // or DLL if DLAB set
    0x1: SerialPort.prototype.outIER,   // or DLM if DLAB set
    0x3: SerialPort.prototype.outLCR,
    0x4: SerialPort.prototype.outMCR
};

/*
 * Initialize every SerialPort module on the page.
 */
Web.onInit(SerialPort.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/testctl.js (C) Jeff Parsons 2012-2018
 */

/*
 * This module provides connectivity between the TestMonitor component and whichever PCx86 SerialPort
 * our 'binding' property indicates, if any.
 */


/**
 * TestController class
 *
 * @class TestController
 * @property {string|undefined urlTests
 * @property {Object|null} tests
 * @property {string|null} consoleBuffer
 * @property {HTMLTextAreaElement|null} controlBuffer
 * @property {function(...)|null} sendData
 * @property {function(number)|null} deliverData
 * @property {function(number)|null} deliverInput
 * @property {function(Object)|null} deliverTests
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class TestController extends Component {
    /**
     * TestController(parms)
     *
     * @this {TestController}
     * @param {Object} parms
     */
    constructor(parms)
    {
        super("TestController", parms);

        this.tests = null;
        let fLoading = false;
        this.urlTests = parms['tests'];

        this.consoleBuffer = "";
        this.controlBuffer = null;
        this.sendData = null;
        this.deliverData = this.deliverInput = this.deliverTests = null;

        this.sBinding = parms['binding'];
        if (this.sBinding) {
            this.serialPort = Component.getComponentByID(this.sBinding, this.id);
            if (this.serialPort) {
                let exports = this.serialPort['exports'];
                if (exports) {
                    let bind = /** @function */ (exports['bind']);
                    if (bind && bind.call(this.serialPort, this, this.receiveData, true)) {
                        this.sendData = exports['receiveData'].bind(this.serialPort);
                        if (this.urlTests) {
                            this.loadTests(this.urlTests);
                            fLoading = true;
                        }
                    }
                }
            }
            if (!this.sendData) {
                Component.warning(this.id + ": binding '" + this.sBinding + "' unavailable");
            }
        }
        if (!fLoading) this.setReady();
    }

    /**
     * loadTests(sURL)
     *
     * @this {TestController}
     * @param {string} sURL
     */
    loadTests(sURL)
    {
        let controller = this;
        let sProgress = "Loading " + sURL + "...";
        Web.getResource(sURL, null, true, function(sURL, sResponse, nErrorCode) {
            controller.doneLoad(sURL, sResponse, nErrorCode);
        }, function(nState) {
            controller.println(sProgress, Component.PRINT.PROGRESS);
        });

    }

    /**
     * doneLoad(sURL, sTestData, nErrorCode)
     *
     * @this {TestController}
     * @param {string} sURL
     * @param {string} sTestData
     * @param {number} nErrorCode (response from server if anything other than 200)
     */
    doneLoad(sURL, sTestData, nErrorCode)
    {
        if (nErrorCode) {
            this.notice("Unable to load tests (error " + nErrorCode + ": " + sURL + ")", nErrorCode < 0);
        }
        else {
            try {
                this.tests = /** @type {Object} */ (JSON.parse(sTestData));
                if (this.deliverTests) {
                    this.deliverTests(this.tests);
                    this.tests = null;
                }
                Component.addMachineResource(this.idMachine, sURL, sTestData);
            } catch (err) {
                this.notice("Test parsing error: " + err.message);
            }
        }
        this.setReady();
    }

    /**
     * bindMonitor(monitor, deliverData, deliverInput, deliverTests)
     *
     * @this {TestController}
     * @param {TestMonitor} monitor
     * @param {function(number)} deliverData
     * @param {function(number)} deliverInput
     * @param {function(Object)} deliverTests
     */
    bindMonitor(monitor, deliverData, deliverInput, deliverTests)
    {
        this.deliverData = deliverData.bind(monitor);
        this.deliverInput = deliverInput.bind(monitor);
        this.deliverTests = deliverTests.bind(monitor);
        if (this.tests && this.deliverTests) {
            this.deliverTests(this.tests);
            this.tests = null;
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {TestController}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "buffer")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let controller = this;

        if (sHTMLType == "textarea" && !this.controlBuffer) {

            this.bindings[sBinding] = control;
            this.controlBuffer = /** @type {HTMLTextAreaElement} */ (control);
            this.consoleBuffer = null;          // we currently use one or the other: control or console

            /*
             * By establishing an onkeypress handler here, we make it possible for DOS commands like
             * "CTTY COM1" to more or less work (use "CTTY CON" to restore control to the DOS console).
             */
            control.onkeydown = function onKeyDown(event) {
                /*
                 * This is required in addition to onkeypress, because it's the only way to prevent
                 * BACKSPACE (keyCode 8) from being interpreted by the browser as a "Back" operation;
                 * moreover, not all browsers generate an onkeypress notification for BACKSPACE.
                 *
                 * A related problem exists for Ctrl-key combinations in most Windows-based browsers
                 * (eg, IE, Edge, Chrome for Windows, etc), because keys like Ctrl-C and Ctrl-S have
                 * special meanings (eg, Copy, Save).  To the extent the browser will allow it, we
                 * attempt to disable that default behavior when this control receives an onkeydown
                 * event for one of those keys (probably the only event the browser generates for them).
                 */
                event = event || window.event;
                let keyCode = event.keyCode;
                if (keyCode === 0x08 || event.ctrlKey && keyCode >= 0x41 && keyCode <= 0x5A) {
                    if (event.preventDefault) event.preventDefault();
                    if (keyCode > 0x40) keyCode -= 0x40;
                    if (controller.deliverInput) controller.deliverInput(keyCode);
                }
                return true;
            };

            control.onkeypress = function onKeyPress(event) {
                /*
                 * Browser-independent keyCode extraction; refer to onKeyPress() and the other key event
                 * handlers in keyboard.js.
                 */
                event = event || window.event;
                let keyCode = event.which || event.keyCode;
                if (controller.deliverInput) controller.deliverInput(keyCode);
                /*
                 * Since we're going to remove the "readonly" attribute from the <textarea> control
                 * (so that the soft keyboard activates on iOS), instead of calling preventDefault() for
                 * selected keys (eg, the SPACE key, whose default behavior is to scroll the page), we must
                 * now call it for *all* keys, so that the keyCode isn't added to the control immediately,
                 * on top of whatever the machine is echoing back, resulting in double characters.
                 */
                if (event.preventDefault) event.preventDefault();
                return true;
            };

            /*
             * Now that we've added an onkeypress handler that calls preventDefault() for ALL keys, the control
             * itself no longer needs the "readonly" attribute; we primarily need to remove it for iOS browsers,
             * so that the soft keyboard will activate, but it shouldn't hurt to remove the attribute for all browsers.
             */
            control.removeAttribute("readonly");

            if (this.sendData) {
                let monitor = new TestMonitor();
                monitor.bindController(this, this.sendData, this.sendOutput, this.printf, this.sBinding);
            }
            return true;
        }
        return false;
    }

    /**
     * sendOutput(data)
     *
     * @this {TestController}
     * @param {number|string|Array} data
     */
    sendOutput(data)
    {
        if (typeof data == "number") {
            this.printf("%c", data);
        }
        else if (typeof data == "string") {
            this.printf("%s", data);
        }
        else {
            for (let i = 0; i < data.length; i++) this.printf("[0x%02x]", data[i]);
        }
    }

    /**
     * printf(format, ...args)
     *
     * @this {TestController}
     * @param {string} format
     * @param {...} args
     */
    printf(format, ...args)
    {
        let s = Str.sprintf(format, ...args);

        if (this.controlBuffer != null) {
            if (s != '\r') {
                if (s == '\b' || s == "\b \b") {
                    this.controlBuffer.value = this.controlBuffer.value.slice(0, -1);
                } else {
                    this.controlBuffer.value += s;
                }
                /*
                 * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.
                 */
                if (!DEBUG && this.controlBuffer.value.length > 8192) {
                    this.controlBuffer.value = this.controlBuffer.value.substr(this.controlBuffer.value.length - 4096);
                }
                this.controlBuffer.scrollTop = this.controlBuffer.scrollHeight;
            }
        }

        if (this.consoleBuffer != null) {
            let i = s.lastIndexOf('\n');
            if (i >= 0) {
                console.log(this.consoleBuffer + s.substr(0, i));
                this.consoleBuffer = "";
                s = s.substr(i + 1);
            }
            this.consoleBuffer += s;
        }
    }

    /**
     * receiveData(data)
     *
     * @this {TestController}
     * @param {number|string|Array} data
     */
    receiveData(data)
    {
        if (typeof data == "number") {
            this.deliverData(data);
        }
        else if (typeof data == "string") {
            for (let i = 0; i < data.length; i++) this.deliverData(data.charCodeAt(i));
        }
        else {
            for (let i = 0; i < data.length; i++) this.deliverData(data[i]);
        }
    }

    /**
     * TestController.init()
     *
     * This function operates on every HTML element of class "TestController", extracting the
     * JSON-encoded parameters for the TestController constructor from the element's "data-value"
     * attribute, invoking the constructor to create a TestController component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeTest = Component.getElementsByClass(document, PCX86.APPCLASS, "testctl");
        for (let iTest = 0; iTest < aeTest.length; iTest++) {
            let eTest = aeTest[iTest];
            let parms = Component.getComponentParms(eTest);
            let test = new TestController(parms);
            Component.bindComponentControls(test, eTest, PCX86.APPCLASS);
        }
    }
}

/*
 * Initialize every TestController module on the page.
 */
Web.onInit(TestController.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/testmon.js (C) Jeff Parsons 2012-2018
 */

/*
 * Overview
 * --------
 * 
 * TestMonitor monitors activity on the bound SerialPort and a user I/O device (eg, a terminal,
 * a console window, etc).  It operates in several modes:
 * 
 * 1) TERMINAL mode: all data received from the SerialPort is routed the user output device,
 * and all data received from the user input device is routed to the SerialPort.  No special actions
 * are taken, until/unless the ATTENTION key is detected from the user input device (ie, Ctrl-T).
 * 
 * 2) PROMPT mode: data from the SerialPort is monitored for specific prompts (eg, "A>"), and
 * when one of those prompts is detected, we enter COMMAND mode, with category set to the appropriate
 * collection of tests.
 * 
 * 3) COMMAND mode: CR-terminated lines of user input are checked against the current set of test
 * commands, and if a match is found, the corresponding request is sent to the SerialPort.
 */


/**
 * TestMonitor class
 *
 * @class TestMonitor
 * @property {string} mode
 * @property {string} promptActive
 * @property {string} promptBuffer
 * @property {Object|undefined} tests
 * @property {Object|undefined} category (eg, "DOS")
 * @property {string} commandBuffer
 * @property {function(...)} sendData
 * @property {function(...)} sendOutput
 * @property {function(string,...)} printf
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class TestMonitor {
    /**
     * TestMonitor()
     *
     * @this {TestMonitor}
     */
    constructor()
    {
        if (DEBUG) console.log("TestMonitor()");
        /*
         * Operations are added to the following queue by addOperation(), which ensures that as soon as it
         * transitions from empty to non-empty, a timeout handler is established to begin draining the queue.
         * 
         * While this approach is more complicated than simply sending operations (via sendData()) as they
         * arrive, it has at least one important advantage: special operations, such as "wait" (eg, wait for a
         * key to be pressed), are easier to implement, because control of the draining process can be switched
         * from a timeout handler to an appropriate event handler.
         */
        this.aOperations = [];
        this.idTimeout = 0;
        this.fnRemoveOperation = this.removeOperation.bind(this);
        this.fWaitPending = false;
    }

    /**
     * bindController(controller, sendData, sendOutput, printf, sBinding)
     *
     * @this {TestMonitor}
     * @param {Object} controller
     * @param {function(...)} sendData
     * @param {function(...)} sendOutput
     * @param {function(string,...)} printf
     * @param {string} [sBinding]
     */
    bindController(controller, sendData, sendOutput, printf, sBinding)
    {
        this.sendData = sendData.bind(controller);
        this.sendOutput = sendOutput.bind(controller);
        this.printf = printf.bind(controller);
        controller.bindMonitor(this, this.receiveData, this.receiveInput, this.receiveTests);
        this.printf("%s TestMonitor v%s\n", APPNAME, APPVERSION || XMLVERSION);
        this.printf("Use Ctrl-T to toggle terminal mode%s\n", (sBinding? " (" + sBinding.toUpperCase() + ")" : ""));
        this.setMode(TestMonitor.MODE.TERMINAL);
    }

    /**
     * addCommand(commandLine)
     *
     * @this {TestMonitor}
     * @param {string} commandLine
     * @return {boolean} (true if successful, false if error)
     */
    addCommand(commandLine)
    {
        if (!commandLine) return true;
        
        let suite = this.tests[this.category];
        let commands = suite['commands'];
        let commandParts = commandLine.split(' ');
        let command = commandParts[0];
        
        /*
         * Check for a matching command in the current "test suite" category.
         */
        let fExists = false;
        if (commands[command]) {
            fExists = true;
            command = commands[command];
        }
        
        let op, mode;
        if (typeof command == "string") {
            op = command;
            /*
             * If you don't want any special op processing (eg, for-loop), then use an explicit 'op' property.
             */
            if (this.addForLoop(op)) return true;
        } else {
            op = command['op'];
            mode = command['mode'];
        }
        
        if (op) {
            let errorMessage = "";
            op = op.replace(/([$%])([0-9]+)/g, function(match, p1, p2, offset, s) {
                let i = +p2;
                let result = "";
                if (i >= commandParts.length) {
                    result = p1 + p2;
                    errorMessage = "missing value for " + result;
                } else if (!i) {
                    result = commandLine;
                } else if (p1 == '$') {
                    result = commandParts[i];
                } else {        // p1 must be '%', which means convert the value to hex
                    result = Str.sprintf("%x", commandParts[i]);
                }
                return result;
            });
            if (errorMessage) {
                this.printf("%s\n", errorMessage);
            } else {
                let i = op.indexOf('(');
                command = (i > 0? op.substr(0, i) : "");
                if (TestMonitor.COMMANDS.indexOf(command) >= 0) {
                    if (!fExists) op = commandLine;
                    fExists = true;
                    let j = op.lastIndexOf(')');
                    if (j > 0) {
                        mode = op.substr(i+1, j-i-1);
                        op = command;
                    }
                }
                else if (TestMonitor.COMMANDS.indexOf(op) >= 0) {
                    fExists = true;
                    mode = commandParts[1];
                }
                if (fExists) {
                    if (DEBUG) console.log("TestMonitor.addCommand(" + commandLine + "): op '" + op + "'");
                    this.addOperation(op, mode);
                    return true;
                }
                this.printf("unrecognized command: %s\n", commandLine);
            }
        } else {
            this.printf("missing operation for command: %s\n", commandParts[0]);
        }
        return false;
    }

    /**
     * addForLoop(commandLine)
     * 
     * @this {TestMonitor}
     * @param {string} commandLine
     * @return {boolean}
     */
    addForLoop(commandLine)
    {
        let fSuccess = false;
        let match = commandLine.match(/^\s*for\s+([a-z]+)\s*=\s*([0-9]+)\s+to\s+([0-9]+)\s*{\s*([\s\S]*?)\s*}\s*$/i);
        if (match) {
            fSuccess = true;
            let symbol = match[1];
            let initial = +match[2];
            let final = +match[3];
            let commands = match[4].split(';');
            for (let value = initial; value <= final && fSuccess; value++) {
                for (let i = 0; i < commands.length; i++) {
                    let commandLine = commands[i].trim();
                    if (!commandLine) continue;
                    commandLine = commandLine.replace(new RegExp("\\$" + symbol, 'g'), value.toString());
                    if (!this.addCommand(commandLine)) {
                        fSuccess = false;
                        break;
                    }
                }
            }
        }
        return fSuccess;
    }

    /**
     * addOperation(op, mode)
     * 
     * @this {TestMonitor}
     * @param {string} op
     * @param {string} [mode]
     */
    addOperation(op, mode)
    {
        this.aOperations.push(mode? [op, mode] : op);
        this.nextOperation();
    }

    /**
     * flushOperations()
     *
     * @this {TestMonitor}
     */
    flushOperations()
    {
        if (this.idTimeout) {
            clearTimeout(this.idTimeout);
            this.idTimeout = 0;
        }
        this.aOperations = [];
        this.fWaitPending = false;
    }

    /**
     * nextOperation(msDelay)
     *
     * @this {TestMonitor}
     * @param {number} [msDelay]
     * @return {boolean}
     */
    nextOperation(msDelay)
    {
        this.fWaitPending = false;
        if (this.aOperations.length) {
            if (!this.idTimeout) {
                this.idTimeout = setTimeout(this.fnRemoveOperation, msDelay || 0);
            }
            return true;
        }
        this.printf("done\n");
        return false;
    }
    
    /**
     * removeOperation()
     *
     * @this {TestMonitor}
     */
    removeOperation()
    {
        this.idTimeout = 0;
        let op = this.aOperations.shift();
        if (op) {
            let mode;
            if (typeof op != "string") {
                mode = op[1]; op = op[0];
            }
            if (op == TestMonitor.COMMAND.PRINTF) {
                let format = "nothing to print", args = [];
                if (mode) {
                    let parms = mode.match(/^\s*(["'])([\s\S]*?)\1\s*,?\s*([\s\S]*)$/);
                    if (parms) {
                        format = parms[2];
                        args = parms[3].split(',');
                    }
                }
                this.printf(format, ...args);
            }
            else if (op == TestMonitor.COMMAND.WAIT) {
                if (mode) {
                    this.nextOperation(+mode);
                    return;
                }
                this.printf("press a key to continue...");
                this.fWaitPending = true;
                return;
            }
            else {
                this.sendData(op);
                if (mode) {
                    this.flushOperations();
                    this.setMode(mode);
                    return;
                }
            }
            this.nextOperation();
        }
    }
    
    /**
     * setMode(mode, category)
     * 
     * @this {TestMonitor}
     * @param {string} mode
     * @param {string} [category]
     */
    setMode(mode, category)
    {
        if (mode != this.mode) {
            switch (mode) {
            case TestMonitor.MODE.TERMINAL:
                this.category = null;
                break;

            case TestMonitor.MODE.PROMPT:
                this.aCategories = [];
                this.aPrompts = [];
                this.cchPromptLongest = 0;
                for (let category in this.tests) {
                    let suite = this.tests[category];
                    let prompt = suite[TestMonitor.MODE.PROMPT];
                    if (prompt) {
                        /*
                         * The 'prompt' property is allowed to contain a string or array of strings.
                         */
                        if (typeof prompt == "string") {
                            prompt = [prompt];
                        }
                        for (let i = 0; i < prompt.length; i++) {
                            this.aCategories.push(category);
                            this.aPrompts.push(prompt[i]);
                            if (this.cchPromptLongest < prompt[i].length) {
                                this.cchPromptLongest = prompt[i].length;
                            }
                        }
                    }
                }
                this.promptActive = this.promptBuffer = "";
                this.category = null;
                break;

            case TestMonitor.MODE.COMMAND:
                if (category) this.category = category;
                this.commandBuffer = "";
                break;

            default:
                this.printf("unrecognized mode: %s\n", mode);
                return;
            }

            this.mode = mode;
            this.printf("mode: %s\n", this.category || this.mode);
        }
    }
    
    /**
     * receiveTests(tests)
     *
     * @this {TestMonitor}
     * @param {Object} tests
     */
    receiveTests(tests)
    {
        if (DEBUG) console.log("TestMonitor.receiveTests(" + JSON.stringify(tests) + ")");
        this.tests = tests;
        this.setMode(TestMonitor.MODE.PROMPT);
    }

    /**
     * receiveData(data)
     *
     * @this {TestMonitor}
     * @param {number} data
     */
    receiveData(data)
    {
        if (this.mode == TestMonitor.MODE.PROMPT) {
            if (this.promptBuffer.length >= this.cchPromptLongest) {
                this.promptBuffer = this.promptBuffer.slice(-(this.cchPromptLongest - 1));
            }
            if (data == 10) this.promptBuffer = "";
            this.promptBuffer += String.fromCharCode(data);
            if (DEBUG) console.log("TestMonitor.receiveData(" + data + "): checking prompts for '" + this.promptBuffer + "'");
            let i = this.aPrompts.indexOf(this.promptBuffer);
            if (i >= 0) {
                this.setMode(TestMonitor.MODE.COMMAND, this.aCategories[i]);
            }
        } else if (this.mode == TestMonitor.MODE.TERMINAL) {
            this.sendOutput(data);
        } else {
            /*
             * TODO: This is where we need to collect the response to any commands we have issued.
             */
            // this.sendOutput(data);
            if (DEBUG) console.log("TestMonitor.receiveData(" + data + "): ignored while mode is '" + this.mode + "'");
        }
    }

    /**
     * receiveInput(charCode)
     *
     * @this {TestMonitor}
     * @param {number} charCode
     */
    receiveInput(charCode)
    {
        if (DEBUG) console.log("TestMonitor.receiveInput(" + charCode + ")");
        if (charCode == Keys.ASCII.CTRL_T) {
            this.setMode(this.mode == TestMonitor.MODE.TERMINAL? (this.category? TestMonitor.MODE.COMMAND : TestMonitor.MODE.PROMPT) : TestMonitor.MODE.TERMINAL);
            return;
        }
        if (this.mode == TestMonitor.MODE.TERMINAL || this.mode == TestMonitor.MODE.PROMPT) {
            this.sendData(charCode);
        } else if (this.mode == TestMonitor.MODE.COMMAND) {
            if (this.fWaitPending) {
                this.sendOutput(Keys.KEYCODE.LF);
                this.nextOperation();
                return;
            }
            if (charCode == Keys.KEYCODE.CR) {
                this.sendOutput(Keys.KEYCODE.LF);
                this.flushOperations();
                this.addCommand(this.commandBuffer.replace(/\\n/g, "\n"));
                this.commandBuffer = "";
            } else {
                if (charCode == Keys.ASCII.CTRL_H || charCode == Keys.ASCII.DEL) {
                    if (this.commandBuffer.length) {
                        this.commandBuffer = this.commandBuffer.slice(0, -1);
                        this.sendOutput("\b \b");
                    }
                } else if (charCode >= 32 && charCode < 127) {
                    this.commandBuffer += String.fromCharCode(charCode);
                    this.sendOutput(charCode);
                }
            }
        }
    }
}

TestMonitor.MODE = {
    TERMINAL:   "terminal",
    PROMPT:     "prompt",
    COMMAND:    "command"
};

TestMonitor.COMMAND = {
    PRINTF:     "printf",
    WAIT:       "wait"
};

TestMonitor.COMMANDS = [
    TestMonitor.COMMAND.PRINTF,
    TestMonitor.COMMAND.WAIT
];



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/mouse.js (C) Jeff Parsons 2012-2018
 */


/**
 * class Mouse
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Mouse extends Component {
    /**
     * Mouse(parmsMouse)
     *
     * The Mouse component has the following component-specific (parmsMouse) properties:
     *
     *      adapter: 1 (primary) or 2 (secondary); 0 if not defined
     *
     *      binding: name of a corresponding device component (implies type="serial")
     *
     *      scaleMouse: a floating-point number used to scale incoming mouse coordinates; the default is 0.5
     *
     *      serial: the ID of a corresponding serial component (used in lieu of type="serial" and binding="ID")
     *
     *      type: one of "bus", "inport", or "serial"; the default is "serial" if serial or binding properties are set
     *
     * The first version of this component supported ONLY emulation of the original Microsoft serial mouse,
     * so a valid SerialPort component ID using the 'serial' property was required.  Now, using the 'type' property,
     * it's possible to enable support for other types of mouse hardware (eg, 'bus' for the original Microsoft
     * Bus Mouse interface or 'inport' for the Microsoft InPort Mouse interface).  The 'adapter' property is used
     * only when the selected type supports different configurations (eg, primary vs. secondary InPort adapters).
     *
     * If the 'type' property is set to "serial" (or 'type' is not set and either the original 'serial' property
     * or the new 'binding' property is set), then serial communication will be established with the specified
     * SerialPort component, requesting access to the corresponding serial component ID.  If the SerialPort component
     * is not installed and/or the specified serial component ID is not present, a configuration error will be reported.
     *
     * To recap, the following machine XML syntax is still supported:
     *
     *      <mouse serial="com2"/>
     *
     * but going forward, you should stop using the serial attribute and use syntax like this instead:
     *
     *      <mouse type="serial" binding="com2"/>
     *
     * @this {Mouse}
     * @param {Object} parmsMouse
     */
    constructor(parmsMouse)
    {
        super("Mouse", parmsMouse, Messages.MOUSE);

        this.iAdapter = parmsMouse['adapter'] || 0;
        this.idDevice = parmsMouse['serial'] || parmsMouse['binding'];
        this.sType = parmsMouse['type'] || (this.idDevice? Mouse.TYPE.SERIAL : Mouse.TYPE.BUS);
        this.typeDevice = (this.sType == Mouse.TYPE.SERIAL? "SerialPort" : null);
        this.componentDevice = null;

        this.scale = parmsMouse['scaleMouse'];
        this.setActive(false);
        this.fActive = this.fCaptured = this.fLocked = false;

        /*
         * Initially, no video devices, and therefore no screens, are attached.  initBus() will update aVideo,
         * and powerUp() will update aScreens.
         */
        this.aVideo = [];
        this.aScreens = [];
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {Mouse}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.scale = cmp.getMachineParm('scaleMouse') || this.scale;
        /*
         * Enumerate all the Video components that we may need to interact with.
         */
        for (let video = null; (video = cmp.getMachineComponent("Video", video));) {
            this.aVideo.push(video);
        }
        if (this.sType == Mouse.TYPE.BUS) {
            bus.addPortInputTable(this, Mouse.aBusInput, Mouse.BUS.DATA.PORT);
            bus.addPortOutputTable(this, Mouse.aBusOutput, Mouse.BUS.DATA.PORT);
        }
        this.setReady();
    }

    /**
     * isActive()
     *
     * @this {Mouse}
     * @return {boolean} true if active, false if not
     */
    isActive()
    {
        return this.fActive && (this.cpu? this.cpu.isRunning() : false);
    }

    /**
     * setActive(fActive)
     *
     * @this {Mouse}
     * @param {boolean} fActive is true if active, false if not
     */
    setActive(fActive)
    {
        this.fActive = fActive;
        /*
         * It's currently not possible to automatically lock the pointer outside the context of a user action
         * (eg, a button or screen click), so this code is for naught.
         *
         *      if (this.aVideo.length) this.aVideo[0].notifyPointerActive(fActive);
         *
         * We now rely on similar code in clickMouse().
         */
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Mouse}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
            if (this.typeDevice && !this.componentDevice) {
                let componentDevice = null;
                while ((componentDevice = this.cmp.getMachineComponent(this.typeDevice, componentDevice))) {
                    if (componentDevice.bindMouse) {
                        this.componentDevice = componentDevice.bindMouse(this.idDevice, this, this.receiveStatus);
                        if (this.componentDevice) {
                            /*
                             * It's possible that the SerialPort we've just attached to might want to bring us "up to speed"
                             * on the device's state, which is why I envisioned a subsequent syncMouse() call.  And you would
                             * want to do that as a separate call, not as part of bindMouse(), because componentDevice
                             * isn't set until bindMouse() returns.
                             *
                             * However, syncMouse() seems unnecessary, given that SerialPort initializes its MCR to an "inactive"
                             * state, and even when restoring a previous state, if we've done our job properly, both SerialPort
                             * and Mouse should be restored in sync, making any explicit attempt at sync'ing unnecessary (or so I hope).
                             *
                             *      this.componentDevice.syncMouse();
                             */
                            break;
                        }
                    }
                }
                if (this.componentDevice) {
                    this.aScreens = [];     // ensure the screen array is empty before (re)filling it
                    for (let i = 0; i < this.aVideo.length; i++) {
                        let screen = this.aVideo[i].getScreen(this);
                        if (screen) this.aScreens.push(screen);
                    }
                } else {
                    Component.warning(this.id + ": " + this.typeDevice + " " + this.idDevice + " unavailable");
                }
            }
            if (this.fActive) {
                this.captureAll();
            } else {
                this.releaseAll();
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Mouse}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {Mouse}
     */
    reset()
    {
        this.initState();
    }

    /**
     * save()
     *
     * This implements save support for the Mouse component.
     *
     * @this {Mouse}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveState());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the Mouse component.
     *
     * @this {Mouse}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initState(data[0]);
    }

    /**
     * initState(data)
     *
     * @this {Mouse}
     * @param {Array} [data]
     * @return {boolean} true if successful, false if failure
     */
    initState(data)
    {
        let i = 0;
        if (data === undefined) data = [false, -1, -1, 0, 0, false, false, 0];
        this.setActive(data[i++]);
        this.xMouse = data[i++];
        this.yMouse = data[i++];
        this.xDelta = data[i++];
        this.yDelta = data[i++];
        this.fButton1 = data[i++];      // FYI, we consider button1 to be the LEFT button
        this.fButton2 = data[i++];      // FYI, we consider button2 to be the RIGHT button
        this.pins = data[i];
        /*
         * Convert old UART "MCR" data to new RS-232 "pins" data, in case we're loading an old state;
         * detection and conversion relies on the fact that the MCR bits don't overlap with any RS-232 bits.
         */
        if (this.pins & (SerialPort.MCR.DTR | SerialPort.MCR.RTS)) {
            this.pins = ((this.pins & SerialPort.MCR.DTR)? RS232.DTR.MASK : 0) | ((this.pins & SerialPort.MCR.RTS)? RS232.RTS.MASK : 0);
        }
        return true;
    }

    /**
     * saveState()
     *
     * @this {Mouse}
     * @return {Array}
     */
    saveState()
    {
        let i = 0;
        let data = [];
        data[i++] = this.fActive;
        data[i++] = this.xMouse;
        data[i++] = this.yMouse;
        data[i++] = this.xDelta;
        data[i++] = this.yDelta;
        data[i++] = this.fButton1;
        data[i++] = this.fButton2;
        data[i] = this.pins;
        return data;
    }

    /**
     * notifyPointerLocked()
     *
     * @this {Mouse}
     * @param {boolean} fLocked
     */
    notifyPointerLocked(fLocked)
    {
        this.fLocked = fLocked;
    }

    /**
     * captureAll()
     *
     * @this {Mouse}
     */
    captureAll()
    {
        if (!this.fCaptured) {
            for (let i = 0; i < this.aScreens.length; i++) {
                if (this.captureMouse(this.aScreens[i])) this.fCaptured = true;
            }
        }
    }

    /**
     * releaseAll()
     *
     * @this {Mouse}
     */
    releaseAll()
    {
        if (this.fCaptured) {
            for (let i = 0; i < this.aScreens.length; i++) {
                if (this.releaseMouse(this.aScreens[i])) this.fCaptured = false;
            }
        }
    }

    /**
     * captureMouse(control)
     *
     * NOTE: addEventListener() wasn't supported in Internet Explorer until IE9, but that's OK, because
     * IE9 is the oldest IE we support anyway (since versions prior to IE9 lack the necessary HTML5 support).
     *
     * @this {Mouse}
     * @param {HTMLElement} control from the HTML DOM (eg, the control for the simulated screen)
     * @return {boolean} true if event handlers were actually added, false if not
     */
    captureMouse(control)
    {
        if (control) {
            let mouse = this;
            control.addEventListener(
                'mousemove',
                function onMouseMove(event) {
                    mouse.processMouseEvent(event);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            control.addEventListener(
                'mousedown',
                function onMouseDown(event) {
                    mouse.processMouseEvent(event, true);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            control.addEventListener(
                'mouseup',
                function onMouseUp(event) {
                    mouse.processMouseEvent(event, false);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            /*
             * None of these tricks seemed to work for IE10, so I'm giving up hiding the browser's mouse pointer in IE for now.
             *
             *      control['style']['cursor'] = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjbQg61aAAAADUlEQVQYV2P4//8/IwAI/QL/+TZZdwAAAABJRU5ErkJggg=='), url('/versions/images/current/blank.cur'), none";
             *
             * Setting the cursor style to "none" may not be a standard, but it works in Safari, Firefox and Chrome, so that's pretty
             * good for a non-standard!
             *
             * TODO: The reference to '/versions/images/current/blank.cur' is also problematic for anyone who might want
             * to run this app from a different server, so think about that as well.
             */
            control['style']['cursor'] = "none";
            return true;
        }
        return false;
    }

    /**
     * releaseMouse(control)
     *
     * TODO: Use removeEventListener() to clean up our handlers; since I'm currently using anonymous functions,
     * and since I'm not seeing any compelling reason to remove the handlers once they've been established, it's
     * less code to leave them in place.
     *
     * @this {Mouse}
     * @param {HTMLElement} control from the HTML DOM
     * @return {boolean} true if event handlers were actually released, false if not
     */
    releaseMouse(control)
    {
        if (control) {
            control['style']['cursor'] = "auto";
        }
        return false;
    }

    /**
     * processMouseEvent(event, fDown)
     *
     * @this {Mouse}
     * @param {Object} event object from a 'mousemove', 'mousedown' or 'mouseup' event (ie, a MouseEvent object)
     * @param {boolean} [fDown] (undefined if neither a down nor up event)
     */
    processMouseEvent(event, fDown)
    {
        if (fDown !== undefined) {
            if (this.fLocked === false) {
                /*
                 * If there's no support for automatic pointer locking in the Video component, notifyPointerActive()
                 * will return false, and we will set fLocked to null, ensuring that we never attempt this again.
                 */
                if (!this.aVideo.length || !this.aVideo[0].notifyPointerActive(true)) {
                    this.fLocked = null;
                }
            }
            this.clickMouse(event.button, fDown);
        } else {
            /*
             * All we really care about are deltas.  We record screenX and screenY (as xMouse and yMouse)
             * merely to calculate xDelta and yDelta.
             */
            let xDelta, yDelta;
            if (this.xMouse < 0 || this.yMouse < 0) {
                this.xMouse = event.screenX;
                this.yMouse = event.screenY;
            }
            if (this.fLocked) {
                xDelta = event['movementX'] || event['mozMovementX'] || event['webkitMovementX'] || 0;
                yDelta = event['movementY'] || event['mozMovementY'] || event['webkitMovementY'] || 0;
            } else {
                xDelta = event.screenX - this.xMouse;
                yDelta = event.screenY - this.yMouse;
            }
            this.xMouse = event.screenX;
            this.yMouse = event.screenY;
            this.moveMouse(xDelta, yDelta, this.xMouse, this.yMouse);
        }
    }

    /**
     * clickMouse(iButton, fDown)
     *
     * @this {Mouse}
     * @param {number} iButton is Mouse.BUTTON.LEFT (0) for fButton1, Mouse.BUTTON.RIGHT (2) for fButton2
     * @param {boolean} fDown
     */
    clickMouse(iButton, fDown)
    {
        if (this.isActive()) {
            let sDiag = DEBUGGER? ("mouse button" + iButton + ' ' + (fDown? "dn" : "up")) : null;
            switch (iButton) {
            case Mouse.BUTTON.LEFT:
                if (this.fButton1 != fDown) {
                    this.fButton1 = fDown;
                    this.sendPacket(sDiag);
                    return;
                }
                break;
            case Mouse.BUTTON.RIGHT:
                if (this.fButton2 != fDown) {
                    this.fButton2 = fDown;
                    this.sendPacket(sDiag);
                    return;
                }
                break;
            default:
                break;
            }
            this.printMessage(sDiag + ": ignored");
        }
    }

    /**
     * moveMouse(xDelta, yDelta, xDiag, yDiag)
     *
     * @this {Mouse}
     * @param {number} xDelta
     * @param {number} yDelta
     * @param {number} [xDiag]
     * @param {number} [yDiag]
     */
    moveMouse(xDelta, yDelta, xDiag, yDiag)
    {
        if (this.isActive()) {
            /*
             * I would prefer to simply say "Math.round(xDelta * this.scale)", but JavaScript's round() function
             * rounds negative numbers toward +infinity if the fraction is exactly 0.5.  All positive numbers are
             * rounded correctly, so we convert the value to positive and restore its sign afterward.  Additionally,
             * if the scaling factor turns a non-zero value into zero, we restore the value to its smallest legal
             * non-zero value (thanks to Math.sign() again).  This ensures that tiniest movement of the physical
             * mouse always results in at least the tiniest movement of the virtual mouse.
             */
            let xScaled = (Math.round(Math.abs(xDelta) * this.scale) * Math.sign(xDelta)) || Math.sign(xDelta);
            let yScaled = (Math.round(Math.abs(yDelta) * this.scale) * Math.sign(yDelta)) || Math.sign(yDelta);
            if (xScaled || yScaled) {
                if (this.messageEnabled(Messages.MOUSE)) {
                    this.printMessage("moveMouse(" + xScaled + "," + yScaled + ")");
                }
                /*
                 * As sendPacket() indicates, any x and y coordinates we supply are for diagnostic purposes only.
                 * sendPacket() only cares about the xDelta and yDelta properties we provide above, which it then zeroes
                 * on completion.
                 */
                this.xDelta = xScaled;
                this.yDelta = yScaled;
                this.sendPacket(null, xDiag, yDiag);
            }
        }
    }

    /**
     * sendPacket(sDiag, xDiag, yDiag)
     *
     * If we're called, something changed.
     *
     * Let's review the 3-byte packet format:
     *
     *              D7  D6  D5  D4  D3  D2  D1  D0
     *      Byte 1  X   1   LB  RB  Y7  Y6  X7  X6
     *      Byte 2  X   0   X5  X4  X3  X2  X1  X0
     *      Byte 3  X   0   Y5  Y4  Y3  Y2  Y1  Y0
     *
     * @this {Mouse}
     * @param {string|null|*} [sDiag] diagnostic message
     * @param {number} [xDiag] original x-coordinate (optional; for diagnostic use only)
     * @param {number} [yDiag] original y-coordinate (optional; for diagnostic use only)
     */
    sendPacket(sDiag, xDiag, yDiag)
    {
        let b1 = 0x40 | (this.fButton1? 0x20 : 0) | (this.fButton2? 0x10 : 0) | ((this.yDelta & 0xC0) >> 4) | ((this.xDelta & 0xC0) >> 6);
        let b2 = this.xDelta & 0x3F;
        let b3 = this.yDelta & 0x3F;
        if (this.messageEnabled(Messages.SERIAL)) {
            this.printMessage((sDiag? (sDiag + ": ") : "") + (yDiag !== undefined? ("mouse (" + xDiag + "," + yDiag + "): ") : "") + "serial packet [" + Str.toHexByte(b1) + "," + Str.toHexByte(b2) + "," + Str.toHexByte(b3) + "]", 0, true);
        }
        this.componentDevice.receiveData([b1, b2, b3]);
        this.xDelta = this.yDelta = 0;
    }

    /**
     * receiveStatus(pins)
     *
     * The SerialPort notifies us whenever SerialPort.MCR.DTR or SerialPort.MCR.RTS changes.
     *
     * During normal serial mouse operation, both RTS and DTR must be "positive".
     *
     * Setting RTS "negative" for 100ms resets the mouse.  Toggling DTR requests an identification byte (SERIAL.ID).
     *
     * NOTES: The above 3rd-party information notwithstanding, I've observed that Windows v1.01 initially writes 0x01
     * to the MCR (DTR on, RTS off), spins in a loop that reads the RBR (probably to avoid a bogus identification byte
     * sitting in the RBR), and then writes 0x0B to the MCR (DTR on, RTS on).  This last step is consistent with making
     * the mouse "active", but it is NOT consistent with "toggling DTR", so I conclude that a reset is ALSO sufficient
     * for sending the identification byte.  Right or wrong, this gets the ball rolling for Windows v1.01.
     *
     * @this {Mouse}
     * @param {number} pins
     */
    receiveStatus(pins)
    {
        let fActive = ((pins & (RS232.DTR.MASK | RS232.RTS.MASK)) == (RS232.DTR.MASK | RS232.RTS.MASK));
        if (fActive) {
            if (!this.fActive) {
                let fIdentify = false;
                if (!(this.pins & RS232.RTS.MASK)) {
                    this.reset();
                    this.printMessage("serial mouse reset");
                    fIdentify = true;
                }
                if (!(this.pins & RS232.DTR.MASK)) {
                    this.printMessage("serial mouse ID requested");
                    fIdentify = true;
                }
                if (fIdentify) {
                    /*
                     * HEADS UP: Everything I'd read about the (original) Microsoft Serial Mouse "reset" protocol says
                     * that the device sends a single byte (0x4D aka 'M').  It's not surprising to think that newer mice
                     * might send additional bytes, but you would think that newer mouse drivers (eg, MOUSE.COM v8.20)
                     * would always be able to deal with mice that sent only one byte.
                     *
                     * You would be wrong.  On an INT 0x33 reset, the v8.20 driver looks for an 'M', then it waits for
                     * another byte (0x42 aka 'B').  If it doesn't receive a 'B', it will accept another 'M'.  But if it
                     * receives something else (or nothing at all), it will spend a long time waiting for it, and then
                     * return an error.
                     *
                     * It's entirely possible that I've done something wrong and inadvertently "tricked" MOUSE.COM into
                     * using the wrong detection logic.  But given the other problems I've seen in MOUSE.COM v8.20, including
                     * its failure to properly terminate-and-stay-resident when its initial INT 0x33 reset returns an error,
                     * I'm not in the mood to give it the benefit of the doubt.
                     *
                     * So, anyway, I solve the terminate-and-stay-resident bug in MOUSE.COM v8.20 by feeding it *two* SERIAL.ID
                     * bytes on a reset.  This doesn't seem to adversely affect serial mouse emulation for Windows 1.01, so
                     * I'm calling this good enough for now.
                     */
                    this.componentDevice.receiveData([Mouse.SERIAL.ID, Mouse.SERIAL.ID]);
                    this.printMessage("serial mouse ID sent");
                }
                this.captureAll();
                this.setActive(fActive);
            }
        } else {
            if (this.fActive) {
                /*
                 * Although this would seem nice (ie, for the Windows v1.01 mouse driver to turn RTS off when its mouse
                 * driver shuts down and Windows exits, since it DID turn RTS on), that doesn't appear to actually happen.
                 * At the very least, Windows will have (re)masked the serial port's IRQ, so what does it matter?  Not much,
                 * I just would have preferred that fActive properly reflect whether we should continue dispatching mouse
                 * events, displaying MOUSE messages, etc.
                 *
                 * We could ask the ChipSet component to notify the SerialPort component whenever its IRQ is masked/unmasked,
                 * and then have the SerialPort pass that notification on to us, but I'm assuming that in the real world,
                 * a mouse device that's still powered may still send event data to the serial port, and if there was software
                 * polling the serial port, it might expect to see that data.  Unlikely, but not impossible.
                 */
                this.printMessage("serial mouse inactive");
                this.releaseAll();
                this.setActive(fActive);
            }
        }
        this.pins = pins;
    }

    /**
     * inBusData(port, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23C)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inBusData(port, addrFrom)
    {
        let b = 0;
        this.printMessageIO(port, undefined, addrFrom, "DATA", b);
        return b;
    }

    /**
     * inBusTPPI(port, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23D)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inBusTPPI(port, addrFrom)
    {
        let b = 0;
        this.printMessageIO(port, undefined, addrFrom, "TPPI", b);
        return b;
    }

    /**
     * inBusCtrl(port, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23E)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inBusCtrl(port, addrFrom)
    {
        let b = 0;
        this.printMessageIO(port, undefined, addrFrom, "CTRL", b);
        return b;
    }

    /**
     * inBusCPPI(port, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23F)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inBusCPPI(port, addrFrom)
    {
        let b = 0;
        this.printMessageIO(port, undefined, addrFrom, "CPPI", b);
        return b;
    }

    /**
     * outBusData(port, bOut, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23C)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outBusData(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "DATA");
    }

    /**
     * outBusTPPI(port, bOut, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23D)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outBusTPPI(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "TPPI");
    }

    /**
     * outBusCtrl(port, bOut, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23E)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outBusCtrl(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "CTRL");
    }

    /**
     * outBusCPPI(port, bOut, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23F)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outBusCPPI(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "CPPI");
    }

    /**
     * Mouse.init()
     *
     * This function operates on every HTML element of class "mouse", extracting the
     * JSON-encoded parameters for the Mouse constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Mouse component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeMouse = Component.getElementsByClass(document, PCX86.APPCLASS, "mouse");
        for (let iMouse = 0; iMouse < aeMouse.length; iMouse++) {
            let eMouse = aeMouse[iMouse];
            let parmsMouse = Component.getComponentParms(eMouse);
            let mouse = new Mouse(parmsMouse);
            Component.bindComponentControls(mouse, eMouse, PCX86.APPCLASS);
        }
    }
}

Mouse.TYPE = {
    BUS:        "bus",
    INPORT:     "inport",
    SERIAL:     "serial"
};

Mouse.BUTTON = {
    LEFT:   0,
    RIGHT:  2
};

/*
 * The Microsoft Bus Mouse supported only one base address: 0x23C.
 *
 * NOTE: Windows v1.01 probes ports 0x23D and 0x23F immediately prior to probing COM2 (and then COM1)
 * for a serial mouse.
 */
Mouse.BUS = {
    DATA: {                     // Mouse Data Register
        PORT:       0x23C
    },
    TPPI: {                     // 8255 (PPI) Test Register
        PORT:       0x23D
    },
    CTRL: {                     // Mouse Control Register
        PORT:       0x23E
    },
    CPPI: {                     // 8255 (PPI) Control Register
        PORT:       0x23F
    }
};

Mouse.aBusInput = {
    0x0:    Mouse.prototype.inBusData,
    0x1:    Mouse.prototype.inBusTPPI,
    0x2:    Mouse.prototype.inBusCtrl,
    0x3:    Mouse.prototype.inBusCPPI
};

Mouse.aBusOutput = {
    0x0:    Mouse.prototype.outBusData,
    0x1:    Mouse.prototype.outBusTPPI,
    0x2:    Mouse.prototype.outBusCtrl,
    0x3:    Mouse.prototype.outBusCPPI
};

/*
 * The retail Microsoft InPort card supported two base addresses, 0x23C and 0x238, through the primary and
 * secondary jumpers, respectively.  However, OEMs may have had InPorts on other base addresses.
 *
 * Here's a typical InPort Mouse detection sequence:
 *
 *      S = IN(Mouse.INPORT.ID.PORT)
 *      ...
 *      VERIFY THAT S EQUALS Mouse.INPORT.ID.CHIP
 *      T = IN(Mouse.INPORT.ID.PORT)
 *      ...
 *      VERIFY ADDITIONAL PAIRS OF READS RETURN MATCHING S AND T VALUES
 *
 * Here's a typical InPort Mouse interrupt sequence:
 *
 *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.MODE)
 *      OUT(Mouse.INPORT.DATA.PORT, IN(Mouse.INPORT.DATA.PORT) | Mouse.INPORT.DATA.MODE.HOLD)
 *      ...
 *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.X)
 *      X = IN(Mouse.INPORT.DATA.PORT)
 *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.Y)
 *      Y = IN(Mouse.INPORT.DATA.PORT)
 *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.STATUS)
 *      B = IN(Mouse.INPORT.DATA.PORT) & (Mouse.INPORT.DATA.STATUS.B1 | Mouse.INPORT.DATA.STATUS.B2 | Mouse.INPORT.DATA.STATUS.B3)
 *      ...
 *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.MODE)
 *      OUT(Mouse.INPORT.DATA.PORT, IN(Mouse.INPORT.DATA.PORT) & ~Mouse.INPORT.DATA.MODE.HOLD)
 */
Mouse.INPORT = {
    ADDR: {
        PORT:       0x23C,
        STATUS:     0x00,       // InPort Status Register
        X:          0x01,       // InPort X Movement Register
        Y:          0x02,       // InPort Y Movement Register
        ISTAT:      0x05,       // InPort Interface Status Register
        ICTRL:      0x06,       // InPort Interface Control Register
        MODE:       0x07        // InPort Mode Register
    },
    DATA: {
        /*
         * The internal register read or written via this port is determined by the value written to ADDR.PORT
         */
        PORT:       0x23D,
        STATUS:     {           // InPort Status Register (0)
            B3:     0x01,       // Status button 3
            B2:     0x02,       // Status button 2
            B1:     0x04,       // Status button 1
            DB3:    0x08,       // Delta button 3
            DB2:    0x10,       // Delta button 2
            DB1:    0x20,       // Delta button 1
            MOVE:   0x40,       // Movement
            PACKET: 0x80        // Packet complete
        },
        MODE: {                 // InPort Mode Register (7)
            HOLD:   0x20        // hold the status for reading
        }
    },
    ID: {
        /*
         * The initial read returns the Chip ID; alternate reads return a byte containing the InPort revision number
         * in the low nibble and the InPort version number in the high nibble.
         */
        PORT:       0x23E,
        CHIP:       0xDE        // InPort Chip ID
    },
    TEST: {
        PORT:       0x23F
    }
};

/*
 * From http://paulbourke.net/dataformats/serialmouse:
 *
 *      The old MicroSoft serial mouse, while no longer in general use, can be employed to provide a low cost input device,
 *      for example, coupling the internal mechanism to other moving objects. The serial protocol for the mouse is:
 *
 *          1200 baud, 7 bit, 1 stop bit, no parity.
 *
 *      The pinout of the connector follows the standard serial interface, as shown below:
 *
 *          Pin     Abbr    Description
 *          1       DCD     Data Carrier Detect
 *          2       RD      Receive Data            [serial data from mouse to host]
 *          3       TD      Transmit Data
 *          4       DTR     Data Terminal Ready     [used to provide positive voltage to mouse, plus reset/detection]
 *          5       SG      Signal Ground
 *          6       DSR     Data Set Ready
 *          7       RTS     Request To Send         [used to provide positive voltage to mouse]
 *          8       CTS     Clear To Send
 *          9       RI      Ring
 *
 *      Every time the mouse changes state (moved or button pressed) a three byte "packet" is sent to the serial interface.
 *      For reasons known only to the engineers, the data is arranged as follows, most notably the two high order bits for the
 *      x and y coordinates share the first byte with the button status.
 *
 *                      D6  D5  D4  D3  D2  D1  D0
 *          1st byte    1   LB  RB  Y7  Y6  X7  X6
 *          2nd byte    0   X5  X4  X3  X2  X1  X0
 *          3rd byte    0   Y5  Y4  Y3  Y2  Y1  Y0
 *
 *      where:
 *
 *          LB is the state of the left button, 1 = pressed, 0 = released.
 *          RB is the state of the right button, 1 = pressed, 0 = released
 *          X0-7 is movement of the mouse in the X direction since the last packet. Positive movement is toward the right.
 *          Y0-7 is movement of the mouse in the Y direction since the last packet. Positive movement is back, toward the user.
 *
 * From http://www.kryslix.com/nsfaq/Q.12.html:
 *
 *      The Microsoft serial mouse is the most popular 2-button mouse. It is supported by all major operating systems.
 *      The maximum tracking rate for a Microsoft mouse is 40 reports/second * 127 counts per report, in other words, 5080 counts
 *      per second. The most common range for mice is is 100 to 400 CPI (counts per inch) but can be up to 1000 CPI. A 100 CPI mouse
 *      can discriminate motion up to 50.8 inches/second while a 400 CPI mouse can only discriminate motion up to 12.7 inches/second.
 *
 *          9-pin  25-pin    Line    Comments
 *          shell  1         GND
 *          3      2         TD      Serial data from host to mouse (only for power)
 *          2      3         RD      Serial data from mouse to host
 *          7      4         RTS     Positive voltage to mouse
 *          8      5         CTS
 *          6      6         DSR
 *          5      7         SGND
 *          4      20        DTR     Positive voltage to mouse and reset/detection
 *
 *      To function correctly, both the RTS and DTR lines must be positive. DTR/DSR and RTS/CTS must NOT be shorted.
 *      RTS may be toggled negative for at least 100ms to reset the mouse. (After a cold boot, the RTS line is usually negative.
 *      This provides an automatic toggle when RTS is brought positive). When DTR is toggled the mouse should send a single byte
 *      (0x4D, ASCII 'M').
 *
 *      Serial data parameters: 1200bps, 7 data bits, 1 stop bit
 *
 *      Data is sent in 3 byte packets for each event (a button is pressed or released, or the mouse moves):
 *
 *                  D7  D6  D5  D4  D3  D2  D1  D0
 *          Byte 1  X   1   LB  RB  Y7  Y6  X7  X6
 *          Byte 2  X   0   X5  X4  X3  X2  X1  X0
 *          Byte 3  X   0   Y5  Y4  Y3  Y2  Y1  Y0
 *
 *      LB is the state of the left button (1 means down).
 *      RB is the state of the right button (1 means down).
 *      X7-X0 movement in X direction since last packet (signed byte).
 *      Y7-Y0 movement in Y direction since last packet (signed byte).
 *      The high order bit of each byte (D7) is ignored. Bit D6 indicates the start of an event, which allows the software to
 *      synchronize with the mouse.
 */
Mouse.SERIAL = {
    ID:     0x4D
};

/*
 * Initialize every Mouse module on the page.
 */
Web.onInit(Mouse.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/disk.js (C) Jeff Parsons 2012-2018
 */


/*
 *  The Disk component provides methods for:
 *
 *      1) creating an empty disk: create()
 *      2) loading a disk image: load()
 *      3) getting disk information: info()
 *      4) seeking a disk sector: seek()
 *      5) reading data from a sector: read()
 *      6) writing data to a sector: write()
 *      7) save disk deltas: save()
 *      8) restore disk deltas: restore()
 *      9) converting disk contents: convertToJSON()
 *
 *  More functionality may be factored out of the FDC and HDC components later and moved here, to
 *  further reduce some of the duplication between them, but the above functionality is a good start.
 */

/*
 * Client/Server Disk I/O
 *
 * To support large disks without consuming large amounts of client-side memory, and to push
 * client-side disk changes back the server, we need a DiskIO API that can be used in place of
 * the DiskDump API.
 *
 * Use of the DiskIO API and any associated disk images must be tightly coupled to per-user
 * storage and specific machine configurations, to prevent the disk images from being corrupted
 * by inconsistent I/O operations.  Our basic User API (userapi.js) already provides some
 * per-user storage that we can use to get the design rolling.
 *
 * The DiskIO API must also provide the ability to create new (empty) hard disk images in per-user
 * storage and automatically associate them with the machine configurations that requested them.
 */

/*
 * Principles
 *
 * Originally, when the Disk class was given a disk image to load and mount, it would request the
 * ENTIRE disk image from the DiskDump module.  That works well for small (floppy) disk images, but
 * for larger disks -- let's just say anything stored on the server as an "img" file -- we'd prefer
 * to interact with that disk using "On-Demand I/O".  Any "img" file on the same server as the PCjs
 * application should be a candidate for on-demand access.
 *
 * On-Demand I/O means that nothing is initially transferred from the server.  As sectors are
 * requested by the PCx86 machine, PCx86 requests them from the server, and maintains an MRU cache
 * of sectors, periodically discarding the least-used clean sectors above a certain memory limit.
 * Dirty sectors (ie, those that the PCx86 machine has written to) must be periodically sent
 * back to the server and then marked as clean, so that they can be discarded like any other
 * sector.
 *
 * We also support "local" init-only disk images, which means that dirty sectors are never sent
 * back to the server and are instead retained by the client for the lifetime of the app; such
 * images are "read-only" as far as the server is concerned, but "read-write" as far as the client
 * is concerned.  Reloading/restarting an app with an "local" disk will return the disk to its
 * initial state.
 *
 * Practice
 * ---
 * Let's first look at what we *already* do for the HDC component:
 *
 *  1) Creating new (empty) disk images
 *  2) Pre-loading pre-built JSON-encoded disk images (converting them to JSON on the fly as needed)
 *
 * An example of #1 is in /devices/pc/machine/5160/cga/256kb/demo/machine.xml:
 *
 *      <hdc id="hdcXT" drives='[{name:"10Mb Hard Drive",type:3}]'/>
 *
 * and an example of #2 is in /disks/pc/fixed/win101.xml:
 *
 *      <hdc id="hdcXT" drives='[{name:"10Mb Hard Drive",path:"/disks/pc/fixed/win101/10mb.json",type:3}]'/>
 *
 * The HDC component expects an array of drive entries.  Array position determines drive numbering
 * (the first entry is drive 0, the second is drive 1, etc), and each entry contains the following
 * properties:
 *
 *      'name': user-friendly name for the disk, if any
 *      'path': URL of the disk image, if any
 *      'type': a drive type
 *
 * Of those properties, only 'type' is required, which provides an index into an HDC "Drive Type"
 * table that determines disk geometry and therefore disk size.  As we add support for larger disks and
 * newer disk controllers, the 'type' parameter will be superseded by either a user-defined 'geometry'
 * parameter that will define number of heads, cylinders, tracks, sectors per track, and (max) bytes per
 * sector, or perhaps a generic 'size' parameter that leaves geometry choices to the HDC component,
 * which will then pass those decisions on to the Disk component.
 *
 * We will enable on-demand I/O for a disk image with a new 'mode' parameter that looks like:
 *
 *      'mode': one of "local", "preload", "demandrw", "demandro"
 *
 * "preload" means the disk image will be completely preloaded, exactly as before; "demandrw" enables
 * full on-demand I/O support; and "demandro" enables on-demand I/O for reads only (all writes are retained
 * and never written back to the server).
 *
 * "ro" will be the fallback for "rw" unless TWO other important criteria are met: 1) the user has a
 * private user key, and therefore per-user storage; and 2) the disk image 'path' contains an asterisk (*)
 * that the server can internally remap to a directory in the user's storage; eg:
 *
 *      'path': <asterisk>/10mb.img (path components following the asterisk are optional)
 *
 * If the disk image does not already exist, it will be created (but not formatted).
 *
 * This preserves the promise that EVERYTHING a user does within a PCx86 machine is private (ie, not
 * visible to any other PCjs users).  I don't want to be in the business of saving any user machine
 * states or disk changes, but at least those operations are limited to users who have asked for (and
 * received) a private user key.
 *
 * Another important consideration at this stage is dealing with multiple machines writing to the same
 * disk image; even though we're limiting the "demandrw" mode to per-user images, a single user may still
 * inadvertently start up multiple machines that refer to the same disk image.
 *
 * So, every PCx86 machine needs to generate a unique token and include that token with every Disk I/O API
 * operation, so that the server can revoke a previous machine's "rw" access to a disk image when a new
 * machine requests "rw" access to the same disk image.
 *
 * From the client's perspective, revocation can be quietly dealt with by reverting to "demandro" mode;
 * that client becomes stuck with all their dirty sectors until they can reclaim "rw" access, which should
 * only happen if no intervening writes to the disk image on the server have occurred (if I bother allowing
 * reclamation at all).
 *
 * The real challenge here is avoiding revocation of a machine that still has critical changes to commit,
 * but since we can't even solve the problem of a user closing their browser at an inopportune time
 * and potentially leaving a disk image in an inconsistent state, premature revocation is the least of
 * our problems.  Since a real hard drive could suffer the same fate if the machine's power was turned off
 * at the wrong time, you could say that we're simply providing a faithful simulation of reality.
 */

/**
 * class Disk
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Disk extends Component {
    /**
     * Disk(controller, drive, mode)
     *
     * Disk contents are stored as an array (aDiskData) of cylinders, each of which is an array of
     * heads, each of which is an array of sector objects; the latter contain sector numbers and
     * sector data, where sector data is an array of dwords.  The format does not impose any
     * limitations on number of cylinders, number of heads, sectors per track, or bytes per sector.
     *
     * WARNING: All accesses to disk sector properties must be via their string names, not their
     * "dot" names, otherwise code will break after it's been processed by the Closure Compiler,
     * and any dumped disks may be unmountable.  This is a side-effect of how we mount and dump
     * disk images (ie, as JSON-encoded streams).
     *
     * This means, for example, that all references to "track[iSector].data" must actually appear as
     * "track[iSector]['data']".
     *
     * @this {Disk}
     * @param {HDC|FDC} controller
     * @param {Object} drive
     * @param {string} mode
     */
    constructor(controller, drive, mode)
    {
        super("Disk", {'id': controller.idMachine + ".disk" + Str.toHex(++Disk.nDisks, 4)}, Messages.DISK);

        this.controller = controller;

        /*
         * Route all non-Debugger messages (eg, notice() and println() calls) through
         * this.controller (eg, controller.notice() and controller.println()), because
         * the Computer component is unaware of any Disk objects and therefore will not
         * set up the usual overrides when a Control Panel is installed.
         */
        this.notice = controller.notice;
        this.println = controller.println;

        this.cmp = controller.cmp;
        this.dbg = controller.dbg;
        this.drive = drive;

        /*
         * We pull out a number of drive properties that we may or may not need as defaults
         */
        this.sDiskName = drive.name;
        this.fRemovable = drive.fRemovable;
        this.fOnDemand = this.fRemote = false;

        /*
         * Initialize the disk contents
         */
        this.create(mode, drive.nCylinders, drive.nHeads, drive.nSectors, drive.cbSector);

        /*
         * The following dirty sector and timer properties are used only with fOnDemand disks,
         * assuming fRemote was successfully set.
         */
        this.aDirtySectors = [];
        this.aDirtyTimestamps = [];         // this array is parallel to aDirtySectors
        this.timerWrite = null;             // REMOTE_WRITE_DELAY timer in effect, if any
        this.msTimerWrite = 0;              // the time that the write timer, if any, is set to fire
        this.fWriteInProgress = false;

        this.setReady();
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * We have no real interest in this notification, other than to obtain a reference to the Debugger
     * for every disk loaded BEFORE the initBus() phase; any disk loaded AFTER that point will get its Debugger
     * reference, if any, from the disk controller passed to the Disk() constructor.
     *
     * @this {Disk}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.dbg = dbg;
    }

    /**
     * isRemote()
     *
     * @this {Disk}
     * @return {boolean} true if remote disk, false if not
     */
    isRemote()
    {
        /*
         * Ironically, we can't rely on fRemote, because that is cleared and set across disconnect and
         * reconnect operations.  fOnDemand is the next best thing.
         */
        return this.fOnDemand;
    }

    /**
     * powerUp(data, fRepower)
     *
     * As with powerDown(), our sole concern here is for REMOTE disks: if a powerDown() call disconnected an
     * "on-demand" disk, we need to get reconnected.  Calling our own load() function should get the job done.
     *
     * The HDC component could have triggered this as well, but its powerUp() function only calls autoMount()
     * in case of page (ie, application) reload, which is fine for local disks but insufficient for remote disks,
     * which have a server connection that must be re-established.
     *
     * @this {Disk}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (this.fOnDemand && !this.fRemote) {
                this.setReady(false);
                this.load(this.sDiskName, this.sDiskPath, null, this.donePowerUp, this);
            }
        }
        return true;
    }

    /**
     * donePowerUp(drive, disk, sDiskName, sDiskPath)
     *
     * This is a callback issued by the Disk component once the load() from powerUp() has finished.
     *
     * @this {Disk}
     * @param {Object} drive
     * @param {Disk} disk is set if the disk was successfully mounted, null if not
     * @param {string} sDiskName
     * @param {string} sDiskPath
     */
    donePowerUp(drive, disk, sDiskName, sDiskPath)
    {
        this.setReady(true);
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * Our sole concern here is for REMOTE disks, making sure any unwritten changes get flushed to
     * the server during a shutdown.  No local state is ever returned, so fSave is ignored.
     *
     * Local disks are managed by the controller (ie, FDC or HDC) that mounted them; the controller's
     * powerDown() handler will take care of calling save() as needed.
     *
     * TODO: Consider taking responsibility for saving the state of local disks as well; the only reason
     * the controllers still take care of them is historical, because this component originally didn't
     * exist, and even after it was created, it didn't originally receive powerDown() notifications.
     *
     * @this {Disk}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean}
     */
    powerDown(fSave, fShutdown)
    {
        /*
         * If we're connected to a remote disk, take this opportunity to flush any remaining unwritten
         * changes and then close the connection.
         */
        if (this.fRemote) {
            let response;
            let nErrorCode = 0;
            if (this.fWriteInProgress) {
                /*
                 * TODO: Verify that the Computer's powerOff() handler will actually honor a false return value.
                 */
                if (!Component.confirmUser("Disk writes are still in progress, shut down anyway?")) {
                    return false;
                }
            }
            while ((response = this.findDirtySectors(false))) {
                if ((nErrorCode = response[0])) {
                    this.notice('Unable to save "' + this.sDiskName + '" (error ' + nErrorCode + ')');
                    break;
                }
            }
            if (fShutdown) {
                this.disconnectRemoteDisk();
            }
            /*
             * I only report that changes to the disk have been "saved" if fSave is true, to avoid confusing
             * users who might not understand the difference between discarding local changes (which should restore
             * all diskettes to their original state) and discarding remote changes (which could leave the remote disk
             * in a bad state).
             */
            if (!nErrorCode && fSave) this.notice(this.sDiskName + " saved");
        }
        return true;
    }

    /**
     * create()
     *
     * @this {Disk}
     * @param {string} mode
     * @param {number} nCylinders
     * @param {number} nHeads
     * @param {number} nSectors (per track)
     * @param {number} cbSector
     *
     * Initializes the disk contents according to the current drive mode and parameters.
     */
    create(mode, nCylinders, nHeads, nSectors, cbSector)
    {
        this.mode = mode;
        this.nCylinders = nCylinders;
        this.nHeads = nHeads;
        this.nSectors = nSectors;
        this.cbSector = cbSector;
        this.aDiskData = [];
        /*
         * If the drive is using PRELOAD mode, then it will use the load()/mount() process to initialize the disk contents;
         * it wouldn't hurt to let create() do its thing, too, but it's a waste of time.
         */
        if (this.mode != DiskAPI.MODE.PRELOAD) {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage("blank disk for \"" + this.sDiskName + "\": " + this.nCylinders + " cylinders, " + this.nHeads + " head(s)");
            }
            let aCylinders = new Array(this.nCylinders);
            for (let iCylinder = 0; iCylinder < aCylinders.length; iCylinder++) {
                let aHeads = new Array(this.nHeads);
                for (let iHead = 0; iHead < aHeads.length; iHead++) {
                    let aSectors = new Array(this.nSectors);
                    for (let iSector = 1; iSector <= aSectors.length; iSector++) {
                        /*
                         * Now that our read() and write() functions can deal with unallocated data
                         * arrays, and can read/write the specified pattern on-the-fly, we no longer need
                         * to pre-allocate and pre-initialize the 'data' array.
                         *
                         * For "local" disks, we can assume a 'pattern' of 0, but for "demandrw" and "demandro"
                         * disks, 'pattern' is set to null, as yet another indication that I/O is required to load
                         * the sector from the server (or to write it back to the server).
                         */
                        aSectors[iSector - 1] = this.initSector(null, iCylinder, iHead, iSector, this.cbSector, (this.mode == DiskAPI.MODE.LOCAL? 0 : null));
                    }
                    aHeads[iHead] = aSectors;
                }
                aCylinders[iCylinder] = aHeads;
            }
            this.aDiskData = aCylinders;
        }
        this.dwChecksum = null;
    }

    /**
     * load(sDiskName, sDiskPath, file, fnNotify)
     *
     * TODO: Figure out how we can strongly type fnNotify, because the Closure Compiler has issues with:
     *
     *      param {function(Component,Object,Disk,string,string)} fnNotify
     *
     * for:
     *
     *     this.fnNotify.call(this.controller, this.drive, disk, this.sDiskName, this.sDiskPath);
     *
     * Also, while we're at it, learn if there are ways to:
     *
     *      1) declare a function taking NO parameters (ie, generate a warning if any parameters are specified)
     *      2) declare a type for a function's return value
     *
     * @this {Disk}
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {File} [file] is set if there's an associated File object
     * @param {function(...)} [fnNotify]
     * @param {Component} [controller]
     * @return {boolean} true if load completed (successfully or not), false if queued
     */
    load(sDiskName, sDiskPath, file, fnNotify, controller)
    {
        let sDiskURL = sDiskPath;

        /*
         * We could use this.log() as well, but it wouldn't display which component initiated the load.
         */
        if (DEBUG) {
            let sMessage = 'load("' + sDiskName + '","' + sDiskPath + '")';
            this.controller.log(sMessage);
            this.printMessage(sMessage);
        }

        if (this.fnNotify) {
            if (DEBUG) this.controller.log('too many load requests for "' + sDiskName + '" (' + sDiskPath + ')');
            return true;
        }

        this.sDiskName = sDiskName;
        this.sDiskPath = sDiskPath;
        this.sDiskFile = Str.getBaseName(sDiskPath);
        this.sFormat = "json";

        let disk = this;
        this.fnNotify = fnNotify;
        this.controllerNotify = controller || this.controller;

        if (file) {
            let reader = new FileReader();
            reader.onload = function() {
                disk.buildDisk(reader.result, true);
            };
            reader.readAsArrayBuffer(file);
            return true;
        }

        /*
         * If there's an occurrence of API_ENDPOINT anywhere in the path, we assume we can use it as-is;
         * ie, that the user has already formed a URL of the type we use ourselves for unconverted disk images.
         */
        if (sDiskPath.indexOf(DumpAPI.ENDPOINT) < 0) {
            /*
             * If the selected disk image has a "json" extension, then we assume it's a pre-converted
             * JSON-encoded disk image, so we load it as-is; otherwise, we ask our server-side disk image
             * converter to return the corresponding JSON-encoded data.
             */
            let sDiskExt = Str.getExtension(sDiskPath);
            if (sDiskExt == DumpAPI.FORMAT.JSON || sDiskExt == DumpAPI.FORMAT.JSON_GZ) {
                sDiskURL = encodeURI(sDiskPath);
            } else {
                if (this.mode == DiskAPI.MODE.DEMANDRW || this.mode == DiskAPI.MODE.DEMANDRO) {
                    sDiskURL = this.connectRemoteDisk(sDiskPath);
                    this.fOnDemand = true;
                } else {
                    this.sFormat = "arraybuffer";
                }
                // else {
                //     let sDiskParm = DumpAPI.QUERY.PATH;
                //     let sSizeParm = '&' + DumpAPI.QUERY.MBHD + "=10";
                //     /*
                //      * 'mbhd' is a new parm added for hard drive support.  In the case of 'file' or 'dir' requests,
                //      * 'mbhd' informs DumpAPI.ENDPOINT that it should create a hard disk image, and one not larger than
                //      * the specified size (eg, 10mb).  In fact, until DumpAPI.ENDPOINT is changed to create custom hard
                //      * disk BPBs, you'll always get a standard PC XT 10mb disk image, so if the 'file' or 'dir' contains
                //      * more than 10mb of data, the request will fail.  Ultimately, I want to honor the controller's
                //      * driveConfig 'size' parm, or to match the capacity required by the driveConfig 'type' parameter.
                //      *
                //      * If a 'disk' is specified, we pass mbhd=0, because the actual size will depend on the image.
                //      * However, I don't currently have any "dsk" or "img" files containing hard disk images; those formats
                //      * were really intended for floppy disk images.  If I never create any hard disk image files, then
                //      * we can simply eliminate sSizeParm in the 'disk' case.
                //      *
                //      * Added more extensions to the list of paths-treated-as-disk-images, so that URLs to files located here:
                //      *
                //      *      ftp://ftp.oldskool.org/pub/TOPBENCH/dskimage/
                //      *
                //      * can be used as-is.  TODO: There's a TODO in netlib.getFile() regarding remote support that needs
                //      * to be resolved first; DiskDump relies on that function for its remote requests, and it currently
                //      * supports only HTTP.
                //      */
                //     if (!sDiskPath.indexOf("http:") || !sDiskPath.indexOf("ftp:") || ["dsk", "ima", "img", "360", "720", "12", "144"].indexOf(sDiskExt) >= 0) {
                //         sDiskParm = DumpAPI.QUERY.DISK;
                //         sSizeParm = '&' + DumpAPI.QUERY.MBHD + "=0";
                //     } else if (Str.endsWith(sDiskPath, '/')) {
                //         sDiskParm = DumpAPI.QUERY.DIR;
                //     }
                //     sDiskURL = Web.getHostOrigin() + DumpAPI.ENDPOINT + '?' + sDiskParm + '=' + encodeURIComponent(sDiskPath) + (this.fRemovable ? "" : sSizeParm) + "&" + DumpAPI.QUERY.FORMAT + "=" + DumpAPI.FORMAT.JSON;
                // }
            }
        }
        let sProgress = "Loading " + sDiskURL + "...";
        return !!Web.getResource(sDiskURL, this.sFormat, true, function loadDone(sURL, sResponse, nErrorCode) {
            disk.doneLoad(sURL, sResponse, nErrorCode);
        }, function(nState) {
            disk.println(sProgress, Component.PRINT.PROGRESS);
        });
    }

    /**
     * buildDisk(buffer, fModified)
     *
     * Builds a disk image from an ArrayBuffer (eg, from a FileReader object), rather than from JSON-encoded data.
     *
     * @this {Disk}
     * @param {?} buffer (technically, this is always an ArrayBuffer, because we tell FileReader to use readAsArrayBuffer, but the Closure Compiler doesn't realize that)
     * @param {boolean} [fModified] is true if we should mark the entire disk modified (to ensure that we save/restore it)
     */
    buildDisk(buffer, fModified)
    {
        let disk;
        let cbDiskData = buffer? buffer.byteLength : 0;
        let diskFormat = DiskAPI.GEOMETRIES[cbDiskData];

        if (diskFormat) {
            this.nCylinders = diskFormat[0];
            this.nHeads = diskFormat[1];
            this.nSectors = diskFormat[2];
            this.cbSector = (diskFormat[3] || 512);

            let cdw = this.cbSector >> 2, dwPattern = 0, dwChecksum = 0;
            let ib = 0;
            let dv = new DataView(buffer, 0, cbDiskData);

            this.aDiskData = new Array(this.nCylinders);
            for (let iCylinder = 0; iCylinder < this.aDiskData.length; iCylinder++) {
                let cylinder = this.aDiskData[iCylinder] = new Array(this.nHeads);
                for (let iHead = 0; iHead < cylinder.length; iHead++) {
                    let head = cylinder[iHead] = new Array(this.nSectors);
                    for (let iSector = 0; iSector < head.length; iSector++) {
                        let sector = this.initSector(null, iCylinder, iHead, iSector + 1, this.cbSector, dwPattern);
                        let adw = sector['data'];
                        for (let idw = 0; idw < cdw; idw++, ib += 4) {
                            let dw = adw[idw] = dv.getInt32(ib, true);
                            dwChecksum = (dwChecksum + dw) & (0xffffffff|0);
                        }
                        if (fModified) sector.cModify = cdw;
                        head[iSector] = sector;
                    }
                }
            }
            this.dwChecksum = dwChecksum;
            disk = this;
        } else {
            this.notice("Unrecognized disk format (" + cbDiskData + " bytes)");
        }

        if (this.fnNotify) {
            this.fnNotify.call(this.controller, this.drive, disk, this.sDiskName, this.sDiskPath);
            this.fnNotify = null;
        }
    }

    /**
     * doneLoad(sURL, diskData, nErrorCode)
     *
     * This function was originally called mount().  If the mount is successful, we pass the Disk object to the
     * caller's fnNotify handler; otherwise, we pass null.
     *
     * @this {Disk}
     * @param {string} sURL
     * @param {string|ArrayBuffer} diskData
     * @param {number} nErrorCode (response from server if anything other than 200)
     */
    doneLoad(sURL, diskData, nErrorCode)
    {
        let disk = null;
        this.fWriteProtected = false;
        let fPrintOnly = !!(nErrorCode < 0 && this.cmp && !this.cmp.flags.powered);

        if (this.fOnDemand) {
            if (!nErrorCode) {
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage('doneLoad("' + this.sDiskPath + '")');
                }
                this.fRemote = true;
                if (BACKTRACK || SYMBOLS) this.buildFileTable();
                disk = this;
            } else {
                this.notice('Unable to connect to disk "' + this.sDiskPath + '" (error ' + nErrorCode + ': ' + diskData + ')', fPrintOnly);
            }
        }
        else if (nErrorCode) {
            /*
             * This can happen for innocuous reasons, such as the user switching away too quickly, forcing
             * the request to be cancelled.  And unfortunately, the browser cancels XMLHttpRequest requests
             * BEFORE it notifies any page event handlers, so if the Computer's being powered down, we won't know
             * that yet.  For now, we rely on the lack of a specific error (nErrorCode < 0), and suppress the
             * notify() alert if there's no specific error AND the computer is not powered up yet.
             */
            this.notice("Unable to load disk \"" + this.sDiskName + "\" (error " + nErrorCode + ": " + sURL + ")", fPrintOnly);
        } else {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage('doneLoad("' + this.sDiskPath + '")');
            }

            /*
             * If we received binary data instead of JSON, we can use the same buildDisk() function that our FileReader
             * code uses.
             */
            if (typeof diskData != "string") {
                this.buildDisk(diskData);
                return;
            }

            try {
                /*
                 * The following code was a hack to turn on write-protection for a disk image if there was
                 * an initial comment line containing the string "write-protected".  However, since comments
                 * are technically not allowed in JSON, I needed an alternative solution.  So, if the basename
                 * contains the suffix "-readonly", then I'll turn on write-protection for that disk as well.
                 *
                 * TODO: Provide some UI for turning write-protection on/off for disks at will, and provide
                 * an XML-based solution (ie, a per-disk XML configuration option) for controlling it as well.
                 */
                let sBaseName = Str.getBaseName(this.sDiskFile, true).toLowerCase();
                if (sBaseName.indexOf("-readonly") > 0) {
                    this.fWriteProtected = true;
                } else {
                    let iEOL = diskData.indexOf("\n");
                    if (iEOL > 0 && iEOL < 1024) {
                        let sConfig = diskData.substring(0, iEOL);
                        if (sConfig.indexOf("write-protected") > 0) {
                            this.fWriteProtected = true;
                        }
                    }
                }
                /*
                 * The most likely source of any exception will be here, where we're parsing the disk data.
                 */
                let aDiskData;
                if (diskData.substr(0, 1) == "<") {        // if the "data" begins with a "<"...
                    /*
                     * Early server configs reported an error (via the nErrorCode parameter) if a disk URL was invalid,
                     * but more recent server configs now display a somewhat friendlier HTML error page.  The downside,
                     * however, is that the original error has been buried, and we've received "data" that isn't actually
                     * disk data.
                     *
                     * So, if the data we've received appears to be "HTML-like", all we can really do is assume that the
                     * disk image is missing.  And so we pretend we received an error message to that effect.
                     */
                    aDiskData = ["Missing disk image: " + this.sDiskName];
                } else {
                    /*
                     * TODO: IE9 is rather unfriendly and restrictive with regard to how much data it's willing to
                     * eval().  In particular, the 10Mb disk image we use for the Windows 1.01 demo config fails in
                     * IE9 with an "Out of memory" exception.  One work-around would be to chop the data into chunks
                     * (perhaps one track per chunk, using regular expressions) and then manually re-assemble it.
                     *
                     * However, it turns out that using JSON.parse(diskData) instead of eval("(" + diskData + ")")
                     * is a much easier fix. The only drawback is that we must first quote any unquoted property names
                     * and remove any comments, because while eval() was cool with them, JSON.parse() is more particular;
                     * the following RegExp replacements take care of those requirements.
                     *
                     * The use of hex values is something else that eval() was OK with, but JSON.parse() is not, and
                     * while I've stopped using hex values in DumpAPI responses (at least when "format=json" is specified),
                     * I can't guarantee they won't show up in "legacy" images, and there's no simple RegExp replacement
                     * for transforming hex values into decimal values, so I cop out and fall back to eval() if I detect
                     * any hex prefixes ("0x") in the sequence.  Ditto for error messages, which appear like so:
                     *
                     *      ["unrecognized disk path: test.img"]
                     */
                    if (diskData.indexOf("0x") < 0 && diskData.substr(0, 2) != "[\"") {
                        aDiskData = JSON.parse(diskData.replace(/([a-z]+):/gm, "\"$1\":").replace(/\/\/[^\n]*/gm, ""));
                    } else {
                        aDiskData = eval("(" + diskData + ")");
                    }
                }

                if (!aDiskData.length) {
                    Component.error("Empty disk image: " + this.sDiskName);
                }
                else if (aDiskData.length == 1) {
                    Component.error(aDiskData[0]);
                }
                /*
                 * aDiskData is an array of cylinders, each of which is an array of heads, each of which
                 * is an array of sector objects.  The format does not impose any limitations on number of
                 * cylinders, number of heads, or number of bytes in any of the sector object byte-arrays.
                 *
                 * WARNING: All accesses to sector object properties must be via their string names, not their
                 * "dot" names, otherwise code will break after it's been processed by the Closure Compiler.
                 *
                 * Sector object properties include:
                 *
                 *      'sector'    the sector number (1-based, not required to be sequential)
                 *      'length'    the byte-length (ie, formatted length) of the sector
                 *      'data'      the dword-array containing the sector data
                 *      'pattern'   if the dword-array length is less than 'length'/4, this value must be used
                 *                  to pad out the sector; if no 'pattern' is specified, it's assumed to be zero
                 *
                 * We still support the older JSON encoding, where sector data was encoded as an array of 'bytes'
                 * rather than a dword 'data' array.  However, our support is strictly limited to an on-the-fly
                 * conversion to a forward-compatible 'data' array.
                 */
                else {
                    if (DEBUG && this.messageEnabled(Messages.DISK | Messages.DATA)) {
                        let sCylinders = aDiskData.length + " track" + (aDiskData.length > 1 ? "s" : "");
                        let nHeads = aDiskData[0].length;
                        let sHeads = nHeads + " head" + (nHeads > 1 ? "s" : "");
                        let nSectorsPerTrack = aDiskData[0][0].length;
                        let sSectorsPerTrack = nSectorsPerTrack + " sector" + (nSectorsPerTrack > 1 ? "s" : "") + "/track";
                        this.printMessage(sCylinders + ", " + sHeads + ", " + sSectorsPerTrack);
                    }
                    /*
                     * Before the image is usable, we must "normalize" all the sectors.  In the past, this meant
                     * "inflating" them all.  However, that's no longer strictly necessary.  Mainly, it just means
                     * setting 'length', 'data', and 'pattern' properties, so that all the sectors are well-defined.
                     * This includes detecting sector data in older formats (eg, the old array of 'bytes' instead
                     * of the new 'data' array of dwords) and converting them on-the-fly to the current format.
                     */
                    this.nCylinders = aDiskData.length;
                    this.nHeads = aDiskData[0].length;
                    this.nSectors = aDiskData[0][0].length;
                    let sector = aDiskData[0][0][0];
                    this.cbSector = (sector && sector['length']) || 512;

                    let dwChecksum = 0;
                    for (let iCylinder = 0; iCylinder < this.nCylinders; iCylinder++) {
                        for (let iHead = 0; iHead < this.nHeads; iHead++) {
                            for (let iSector = 0; iSector < this.nSectors; iSector++) {
                                sector = aDiskData[iCylinder][iHead][iSector];
                                if (!sector) continue;          // non-standard (eg, XDF) disk images may have "unused" (null) sectors
                                let length = sector['length'];
                                if (length === undefined) {     // provide backward-compatibility with older JSON...
                                    length = sector['length'] = 512;
                                }
                                length >>= 2;                   // convert length from a byte-length to a dword-length
                                let dwPattern = sector['pattern'];
                                if (dwPattern === undefined) {
                                    dwPattern = sector['pattern'] = 0;
                                }
                                let adw = sector['data'];
                                if (adw === undefined) {
                                    let ab = sector['bytes'];
                                    if (ab === undefined || !ab.length) {
                                        /*
                                         * If there is neither a 'bytes' nor 'data' array, then our job is simple:
                                         * create an empty 'data' array; it will be filled in with the dword pattern
                                         * as needed later.
                                         *
                                         * The only wrinkle is if there *is* a 'bytes' array but it's empty, in which
                                         * case we must assume that the pattern was a byte pattern, so convert it to a
                                         * dword pattern.
                                         */
                                        sector['data'] = adw = [];
                                        if (ab) {

                                            sector['pattern'] = (dwPattern | (dwPattern << 8) | (dwPattern << 16) | (dwPattern << 24));
                                        }
                                    }
                                    else {
                                        /*
                                         * To keep the conversion code simple, we'll do any necessary pattern-filling first,
                                         * to fully "inflate" the sector, eliminating the possibility of partial dwords and
                                         * saving any code downstream from dealing with byte-size patterns.
                                         */
                                        let cb = length << 2;

                                        for (let ib = ab.length; ib < cb; ib++) {
                                            ab[ib] = dwPattern;         // the pattern for byte-arrays was only a byte
                                        }
                                        this.fill(sector, ab, 0);
                                    }
                                    delete sector['bytes'];
                                }
                                this.initSector(sector, iCylinder, iHead);
                                /*
                                 * For the disk as a whole, we maintain a checksum of the original unmodified data:
                                 *
                                 *      dwChecksum: summation of all dwords in all non-empty sectors
                                 *
                                 * Pattern-filling of sectors is deferred until absolutely necessary (eg, when a sector is
                                 * being written).  So all we need to do at this point is checksum all the initial sector data.
                                 */
                                for (let idw = 0; idw < adw.length; idw++) {
                                    dwChecksum = (dwChecksum + adw[idw]) & (0xffffffff|0);
                                }
                            }
                        }
                    }
                    this.aDiskData = aDiskData;
                    this.dwChecksum = dwChecksum;
                    if (BACKTRACK || SYMBOLS) this.buildFileTable();
                    disk = this;
                }
            } catch (e) {
                Component.error("Disk image error (" + sURL + "): " + e.message);
                diskData = null;
            }

            if (diskData) {
                Component.addMachineResource(this.controller.idMachine, sURL, diskData);
            }
        }

        if (this.fnNotify) {
            this.fnNotify.call(this.controllerNotify, this.drive, disk, this.sDiskName, this.sDiskPath);
            this.fnNotify = null;
        }
    }

    /**
     * buildFileTable()
     *
     * This function builds (or rebuilds) a complete file table from the (first) FAT volume found on the current
     * disk, and then updates all the sector objects to point back to the corresponding file.  Used for BACKTRACK
     * and SYMBOLS support.  Because this is an expensive operation, in terms of both time and memory, it should
     * only be called when a disk is mounted or has been modified (eg, by applying deltas from a saved machine state).
     *
     * More recently, the FileInfo objects in the table have been enhanced to include debugging information if
     * the file is an EXE or DLL, which we determine merely by checking the file extension.
     *
     * Note that while most of the methods in this module use CHS-style parameters, because our primary clients
     * are old disk controllers that deal exclusively with cylinder/head/sector values, here we use 0-based
     * "logical" sector numbers for volume-relative block addresses (aka LBAs or Logical Block Addresses), and
     * 0-based "physical" sector numbers for disk-relative block addresses (aka PBAs or Physical Block Addresses).
     *
     * Also, our use of the term LBA differs from that of more modern disk controllers; in the pre-modern world
     * of PCx86, what we call PBA numbers are what those controllers would later call LBA numbers.
     *
     * @this {Disk}
     * @return {Array.<FileInfo>|undefined}
     */
    buildFileTable()
    {
        if (BACKTRACK || SYMBOLS) {

            let i, off, dir = {}, iSector;

            if (this.aFileTable && this.aFileTable.length) {
                /*
                 * In order for buildFileTable() to rebuild an existing table (eg, after deltas have been
                 * applied), we need to zap any and all existing file table references in the sector data.
                 */
                let aDiskData = this.aDiskData;
                for (let iCylinder = 0; iCylinder < aDiskData.length; iCylinder++) {
                    for (let iHead = 0; iHead < aDiskData[iCylinder].length; iHead++) {
                        for (iSector = 0; iSector < aDiskData[iCylinder][iHead].length; iSector++) {
                            let sector = aDiskData[iCylinder][iHead][iSector];
                            if (sector) {
                                delete sector['file'];
                                delete sector.offFile;
                            }
                        }
                    }
                }
            }

            this.aFileTable = [];

            dir.pbaVolume = dir.lbaTotal = 0;

            let cbDisk = this.nCylinders * this.nHeads * this.nSectors * this.cbSector;

            /*
             * At this point, if this is a remote disk, you may see some warning messages in your browser's console,
             * like this message from Chrome:
             *
             *      "Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects
             *      to the end user's experience. For more help, check http://xhr.spec.whatwg.org/."
             *
             * This is because I was lazy and made the buildFileTable() worker function getSector() use the synchronous
             * form of seek().  For development purposes, that was fine, but...  TODO: Eventually change buildFileTable()
             * to use async I/O.
             */
            if (this.fRemote) this.log("ignore any synchronous XMLHttpRequest warnings here (for now)");

            let sectorBoot = this.getSector(0);
            if (!sectorBoot) {
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage("buildFileTable(): unable to read boot sector");
                }
                return;
            }

            dir.cbSector = this.getSectorData(sectorBoot, DiskAPI.BPB.SECTOR_BYTES, 2);

            let fValid = true;
            if (dir.cbSector != this.cbSector) {
                /*
                 * When the first sector doesn't appear to contain a valid BPB, the most likely explanations are:
                 *
                 *      1. The image is from a diskette formatted by DOS 1.xx, which didn't use BPBs
                 *      2. The image is a fixed (partitioned) disk and the first sector is actually an MBR
                 *      3. The image is from a diskette that used a non-standard sector size (ie, not 512)
                 *
                 * To start, if this is an 160Kb disk (circa DOS 1.00) or a 320Kb disk (circa DOS 1.10), then we'll
                 * assume it's a 12-bit FAT, set assorted BPB values accordingly, and see if our assumption holds up.
                 */
                fValid = false;
                dir.lbaFAT = 1;
                dir.nFATBits = 12;
                dir.lbaRoot = dir.lbaFAT + 2;   // both 160Kb and 320Kb disks contained 2 FATs, each containing 1 sector
                dir.nClusterSecs = 1;
                dir.cbSector = this.cbSector;

                if (cbDisk == 160 * 1024 && this.getClusterEntry(dir, 0, 0) == DiskAPI.FAT.MEDIA_160KB) {
                    dir.lbaTotal = 320;
                    dir.nEntries = 64;
                    fValid = true;
                }
                else if (cbDisk == 320 * 1024 && this.getClusterEntry(dir, 0, 0) == DiskAPI.FAT.MEDIA_320KB) {
                    dir.lbaTotal = 640;
                    dir.nEntries = 112;

                    dir.nClusterSecs++;         // 320Kb disks use 2 sectors/cluster
                    fValid = true;
                }
                else {
                    /*
                     * So, this is either a fixed (partitioned) disk, or a disk using a non-standard sector size; let's assume
                     * the former and check for an MBR.  For now, we're only going to process the first active partition we find.
                     */
                    off = DiskAPI.MBR.PARTITIONS.OFFSET;
                    for (i = 0; i < 4; i++) {
                        let bStatus = this.getSectorData(sectorBoot, off + DiskAPI.MBR.PARTITIONS.ENTRY.STATUS, 1);
                        if (bStatus == DiskAPI.MBR.PARTITIONS.STATUS.ACTIVE) {
                            dir.pbaVolume = this.getSectorData(sectorBoot, off + DiskAPI.MBR.PARTITIONS.ENTRY.LBA_FIRST, 4);
                            sectorBoot = this.getSector(dir.pbaVolume);
                            if (sectorBoot && this.getSectorData(sectorBoot, DiskAPI.BPB.SECTOR_BYTES, 2) == this.cbSector) {
                                fValid = true;
                            }
                            break;
                        }
                        off += DiskAPI.MBR.PARTITIONS.ENTRY_LENGTH;
                    }
                }
                if (!fValid) {
                    if (DEBUG && this.messageEnabled()) {
                        this.printMessage("buildFileTable(): unrecognized " + cbDisk + "-byte disk image with " + this.cbSector + "-byte sectors");
                    }
                    return;
                }
            }

            if (!dir.lbaTotal) {
                dir.lbaTotal = this.getSectorData(sectorBoot, DiskAPI.BPB.TOTAL_SECS, 2) || this.getSectorData(sectorBoot, DiskAPI.BPB.LARGE_SECS, 4);
                dir.lbaFAT = this.getSectorData(sectorBoot, DiskAPI.BPB.RESERVED_SECS, 2);
                dir.lbaRoot = dir.lbaFAT + this.getSectorData(sectorBoot, DiskAPI.BPB.FAT_SECS, 2) * this.getSectorData(sectorBoot, DiskAPI.BPB.TOTAL_FATS, 1);
                dir.nEntries = this.getSectorData(sectorBoot, DiskAPI.BPB.ROOT_DIRENTS, 2);
                dir.nClusterSecs = this.getSectorData(sectorBoot, DiskAPI.BPB.CLUSTER_SECS, 1);
            }

            dir.lbaData = dir.lbaRoot + (((dir.nEntries * DiskAPI.DIRENT.LENGTH + (dir.cbSector - 1)) / dir.cbSector) | 0);
            dir.nClusters = (((dir.lbaTotal - dir.lbaData) / dir.nClusterSecs) | 0);

            /*
             * In all FATs, the first valid cluster number is 2, as 0 is used to indicate a free cluster and 1 is reserved.
             *
             * In a 12-bit FAT chain, the largest valid cluster number (iClusterMax) is 0xFF6; 0xFF7 is reserved for marking
             * bad clusters and should NEVER appear in a cluster chain, and 0xFF8-0xFFF are used to indicate the end of a chain.
             * Reports that cluster numbers 0xFF0-0xFF6 are "reserved" (eg, http://support.microsoft.com/KB/65541) should be
             * ignored; those numbers may have been considered "reserved" at some early point in FAT's history, but no longer.
             *
             * Since 12 bits yield 4096 possible values, and since 11 of the values (0, 1, and 0xFF7-0xFFF) cannot be used to
             * refer to an actual cluster, that leaves a theoretical maximum of 4085 clusters for a 12-bit FAT.  However, for
             * reasons that only a small (and shrinking -- RIP AAR) number of people know, the actual cut-off is 4084.
             *
             * So, a FAT volume with 4084 or fewer clusters uses a 12-bit FAT, a FAT volume with 4085 to 65524 clusters uses
             * a 16-bit FAT, and a FAT volume with more than 65524 clusters uses a 32-bit FAT.
             *
             * TODO: Eventually add support for FAT32.
             */
            dir.nFATBits = (dir.nClusters <= DiskAPI.FAT12.MAX_CLUSTERS? 12 : 16);
            dir.iClusterMax = (dir.nFATBits == 12? DiskAPI.FAT12.CLUSNUM_MAX : DiskAPI.FAT16.CLUSNUM_MAX);

            if (DEBUG && this.messageEnabled()) {
                this.printMessage("buildFileTable()\n\tlbaFAT: " + dir.lbaFAT + "\n\tlbaRoot: " + dir.lbaRoot + "\n\tlbaData: " + dir.lbaData + "\n\tlbaTotal: " + dir.lbaTotal + "\n\tnClusterSecs: " + dir.nClusterSecs + "\n\tnClusters: " + dir.nClusters);
            }

            /*
             * The following assertion is here only to catch anomalies; it is NOT a requirement that the number of data sectors
             * be a perfect multiple of nClusterSecs, but if it ever happens, it's worth verifying we didn't miscalculate something.
             */
            i = (dir.lbaTotal - dir.lbaData) % dir.nClusterSecs;
            if (i) {
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage("buildFileTable(): " + cbDisk + "-byte disk image wasting " + i + " sectors");
                }
            }

            /*
             * Similarly, it is NOT a requirement that the size of all root directory entries be a perfect multiple of the sector
             * size (cbSector), but it may indicate a problem if it's not.  Note that when it comes time to read the root directory,
             * we treat it exactly like any other directory; that is, we ignore the nEntries value and scan the entire contents of
             * every sector allocated to the directory.  TODO: Determine whether DOS reads all root sector contents or only nEntries
             * (ie, create a test volume where nEntries * 32 is NOT a multiple of cbSector and watch what happens).
             */


            let apba = [];
            for (let lba = dir.lbaRoot; lba < dir.lbaData; lba++) apba.push(dir.pbaVolume + lba);
            this.getDir(dir, this.sDiskFile, "", apba);

            /*
             * Create the sector-to-file mappings now.
             */
            for (i = 0; i < this.aFileTable.length; i++) {
                let file = this.aFileTable[i];
                off = 0;
                for (iSector = 0; iSector < file.apba.length; iSector++) {
                    this.updateSector(file, file.apba[iSector], off);
                    off += this.cbSector;
                }
                file.loadSymbols();
            }
        }
        return this.aFileTable;
    }

    /**
     * getModuleInfo(sModule, nSegment)
     *
     * If the given module and segment number is found, we return an Array of symbol offsets, indexed by symbol name.
     *
     * @this {Disk}
     * @param {string} sModule
     * @param {number} nSegment
     * @return {Object}
     */
    getModuleInfo(sModule, nSegment)
    {
        let aSymbols = {};
        if (SYMBOLS && this.aFileTable) {
            for (let iFile = 0; iFile < this.aFileTable.length; iFile++) {
                let file = this.aFileTable[iFile];
                if (file.sModule != sModule) continue;
                let segment = file.aSegments[nSegment];
                if (!segment) continue;
                for (let iOrdinal in segment.aEntries) {
                    let entry = segment.aEntries[iOrdinal];
                    /*
                     * entry[1] is the symbol name, which becomes the index, and entry[0] is the offset.
                     */
                    aSymbols[entry[1]] = entry[0];
                }
                break;
            }
        }
        return aSymbols;
    }

    /**
     * getSymbolInfo(sSymbol)
     *
     * For all whole or partial symbol matches, return them in an Array of entries:
     *
     *      [symbol, file name, segment number, segment offset, segment size].
     *
     * TODO: This function has many limitations (ie, slow, case-sensitive), but it gets the job done for now.
     *
     * @this {Disk}
     * @param {string} sSymbol
     * @return {Array}
     */
    getSymbolInfo(sSymbol)
    {
        let aInfo = [];
        if (SYMBOLS && this.aFileTable) {
            let sSymbolUpper = sSymbol.toUpperCase();
            for (let iFile = 0; iFile < this.aFileTable.length; iFile++) {
                let file = this.aFileTable[iFile];
                for (let iSegment in file.aSegments) {
                    let segment = file.aSegments[iSegment];
                    for (let iOrdinal in segment.aEntries) {
                        let entry = segment.aEntries[iOrdinal];
                        if (entry[1] && entry[1].indexOf(sSymbolUpper) >= 0) {
                            aInfo.push([entry[1], file.sName, iSegment, entry[0], segment.offEnd - segment.offStart]);
                        }
                    }
                }
            }
        }
        return aInfo;
    }

    /**
     * getDir(dir, sDisk, sDir, apba)
     *
     * @this {Disk}
     * @param {Object} dir
     * @param {string} sDisk
     * @param {string} sDir
     * @param {Array.<number>} apba
     */
    getDir(dir, sDisk, sDir, apba)
    {
        let file;
        let iStart = this.aFileTable.length;
        let nEntriesPerSector = (dir.cbSector / DiskAPI.DIRENT.LENGTH) | 0;

        dir.sDir = sDir + "\\";

        if (DEBUG && this.messageEnabled()) this.printMessage('getDir("' + sDisk + '","' + dir.sDir + '")');

        for (let iSector = 0; iSector < apba.length; iSector++) {
            let pba = apba[iSector];
            for (let iEntry = 0; iEntry < nEntriesPerSector; iEntry++) {
                if (!this.getDirEntry(dir, pba, iEntry)) {
                    iSector = apba.length;
                    break;
                }
                if (dir.sName == null || dir.sName == "." || dir.sName == "..") continue;
                let sPath = dir.sDir + dir.sName;
                if (DEBUG && this.messageEnabled(Messages.DISK | Messages.DATA)) {
                    this.printMessage('"' + sPath + '" size=' + dir.cbSize + ' cluster=' + dir.iCluster + ' sectors=' + JSON.stringify(dir.apba));
                    if (dir.apba.length) this.printMessage(this.dumpSector(this.getSector(dir.apba[0]), dir.apba[0], sPath));
                }
                file = new FileInfo(this, sPath, dir.sName, dir.bAttr, dir.cbSize, dir.apba);
                this.aFileTable.push(file);
            }
        }

        let iEnd = this.aFileTable.length;

        for (let i = iStart; i < iEnd; i++) {
            file = this.aFileTable[i];
            if (file.bAttr & DiskAPI.ATTR.SUBDIR && file.apba.length) this.getDir(dir, sDisk, sDir + "\\" + file.sName, file.apba);
        }
    }

    /**
     * getDirEntry(dir, pba, i)
     *
     * This sets the following properties on the 'dir' object:
     *
     *      sName (null if invalid/deleted entry)
     *      bAttr
     *      cbSize
     *      iCluster
     *      apba (ie, array of physical block addresses)
     *
     * On return, it's the caller's responsibility to copy out any data into a new object
     * if it wants to preserve any of the above information.
     *
     * This function also caches the following properties in the 'dir' object:
     *
     *      pbaDirCache (of the last directory sector read, if any)
     *      sectorDirCache (of the last directory sector read, if any)
     *
     * Also, the caller must also set the following 'dir' helper properties, so that clusters
     * can be located and converted to sectors (see convertClusterToSectors):
     *
     *      lbaFAT
     *      lbaData
     *      cbSector
     *      iClusterMax
     *      nClusterSecs
     *      nFATBits
     *
     * @this {Disk}
     * @param {Object} dir (to be filled in)
     * @param {number} pba (a sector of the directory)
     * @param {number} i (an entry in the directory sector, 0-based)
     * @returns {boolean} true if entry was returned (even if invalid/deleted), false if no more entries
     */
    getDirEntry(dir, pba, i)
    {
        if (!dir.sectorDirCache || !dir.pbaDirCache || dir.pbaDirCache != pba) {
            dir.pbaDirCache = pba;
            dir.sectorDirCache = this.getSector(dir.pbaDirCache);
            if (DEBUG && this.messageEnabled(Messages.DISK | Messages.DATA)) {
                this.printMessage(this.dumpSector(dir.sectorDirCache, dir.pbaDirCache, dir.sDir));
            }
        }
        if (dir.sectorDirCache) {
            let off = i * DiskAPI.DIRENT.LENGTH;
            let b = this.getSectorData(dir.sectorDirCache, off, 1);
            if (b == DiskAPI.DIRENT.UNUSED) {
                return false;
            }
            if (b == DiskAPI.DIRENT.INVALID) {
                dir.sName = null;
                return true;
            }
            dir.sName = Str.trim(this.getSectorString(dir.sectorDirCache, off + DiskAPI.DIRENT.NAME, 8));
            let s = Str.trim(this.getSectorString(dir.sectorDirCache, off + DiskAPI.DIRENT.EXT, 3));
            if (s.length) dir.sName += '.' + s;
            dir.bAttr = this.getSectorData(dir.sectorDirCache, off + DiskAPI.DIRENT.ATTR, 1);
            dir.cbSize = this.getSectorData(dir.sectorDirCache, off + DiskAPI.DIRENT.SIZE, 2);
            dir.iCluster = this.getSectorData(dir.sectorDirCache, off + DiskAPI.DIRENT.CLUSTER, 2);
            dir.apba = this.convertClusterToSectors(dir);
            return true;
        }
        return false;
    }

    /**
     * convertClusterToSectors(dir)
     *
     * @this {Disk}
     * @param {Object} dir
     * @return {Array.<number>} of PBAs (physical block addresses)
     */
    convertClusterToSectors(dir)
    {
        let apba = [];
        let iCluster = dir.iCluster;
        if (iCluster) {
            do {
                if (iCluster < DiskAPI.FAT12.CLUSNUM_MIN) {

                    break;
                }
                let lba = dir.lbaData + ((iCluster - DiskAPI.FAT12.CLUSNUM_MIN) * dir.nClusterSecs);
                for (let i = 0; i < dir.nClusterSecs; i++) {
                    apba.push(dir.pbaVolume + lba++);
                }
                iCluster = this.getClusterEntry(dir, iCluster, 0) | this.getClusterEntry(dir, iCluster, 1);
            } while (iCluster <= dir.iClusterMax);

        }
        return apba;
    }

    /**
     * getClusterEntry(dir, iCluster, iByte)
     *
     * @this {Disk}
     * @param {Object} dir
     * @param {number} iCluster
     * @param {number} iByte (0 for low byte of cluster entry, 1 for high byte)
     * @return {number}
     */
    getClusterEntry(dir, iCluster, iByte)
    {
        let w = 0;
        let cbitsSector = dir.cbSector * 8;
        let offBits = dir.nFATBits * iCluster + (iByte? 8 : 0);
        let iSector = (offBits / cbitsSector) | 0;
        if (!dir.sectorFATCache || !dir.lbaFATCache || dir.lbaFATCache != dir.lbaFAT + iSector) {
            dir.lbaFATCache = dir.lbaFAT + iSector;
            dir.sectorFATCache = this.getSector(dir.pbaVolume + dir.lbaFATCache);
        }
        if (dir.sectorFATCache) {
            offBits = (offBits % cbitsSector) | 0;
            let off = (offBits >> 3);
            w = this.getSectorData(dir.sectorFATCache, off, 1);
            if (!iByte) {
                if (offBits & 0x7) w >>= 4;
            } else {
                if (dir.nFATBits == 16) {
                    w <<= 8;
                } else {

                    if (offBits & 0x7) {
                        w <<= 4;
                    } else {
                        w = (w & 0xf) << 8;
                    }
                }
            }
        }
        return w;
    }

    /**
     * getSector(pba)
     *
     * @this {Disk}
     * @param {number} pba (physical block address)
     * @return {Object|null} sector
     */
    getSector(pba)
    {
        let nSectorsPerCylinder = this.nHeads * this.nSectors;
        let iCylinder = (pba / nSectorsPerCylinder) | 0;
        if (iCylinder < this.nCylinders) {
            let nSectorsRemaining = (pba % nSectorsPerCylinder);
            let iHead = (nSectorsRemaining / this.nSectors) | 0;
            /*
             * PBA numbers are 0-based, but the sector numbers in CHS addressing are 1-based, so add one to iSector
             */
            let iSector = (nSectorsRemaining % this.nSectors) + 1;
            return this.seek(iCylinder, iHead, iSector);
        }
        return null;
    }

    /**
     * getSectorData(sector, off, len)
     *
     * WARNING: This function is restricted to reading data contained ENTIRELY within the specified sector.
     *
     * NOTE: Yes, this function is not the most efficient way to read a byte/word/dword value from within a sector,
     * but given the different states a sector may be in, it's certainly the simplest and safest, and since this is
     * only used by buildFileTable() and its progeny, it's not clear that we need to be superfast anyway.
     *
     * @this {Disk}
     * @param {Object} sector
     * @param {number} off (byte offset)
     * @param {number} len (1 to 4 bytes)
     * @return {number}
     */
    getSectorData(sector, off, len)
    {
        let dw = 0;
        let nShift = 0;

        while (len--) {

            let b = this.read(sector, off++);

            if (b < 0) break;
            dw |= (b << nShift);
            nShift += 8;
        }
        return dw;
    }

    /**
     * getSectorString(sector, off, len)
     *
     * WARNING: This function is restricted to reading a string contained ENTIRELY within the specified sector.
     *
     * @this {Disk}
     * @param {Object} sector
     * @param {number} off (byte offset)
     * @param {number} len (use -1 to read a null-terminated string)
     * @return {string}
     */
    getSectorString(sector, off, len)
    {
        let s = "";
        while (len--) {
            let b = this.read(sector, off++);
            if (b <= 0) break;
            s += String.fromCharCode(b);
        }
        return s;
    }

    /**
     * updateSector(file, pba, off)
     *
     * Like getSector(), this must convert a PBA into CHS values; consider factoring that conversion code out.
     *
     * @this {Disk}
     * @param {FileInfo} file
     * @param {number} pba (physical block address from the file's apba)
     * @param {number} off (file offset corresponding to the given pba of the given file)
     * @return {boolean} true if successfully updated, false if not
     */
    updateSector(file, pba, off)
    {
        let nSectorsPerCylinder = this.nHeads * this.nSectors;
        let iCylinder = (pba / nSectorsPerCylinder) | 0;
        let nSectorsRemaining = (pba % nSectorsPerCylinder);
        let iHead = (nSectorsRemaining / this.nSectors) | 0;
        let iSector = (nSectorsRemaining % this.nSectors);
        let cylinder, head, sector;
        if ((cylinder = this.aDiskData[iCylinder]) && (head = cylinder[iHead]) && (sector = head[iSector])) {

            if (sector['file']) {
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage('"' + sector['file'].sPath + '" cross-linked at offset ' + sector['file'].offFile + ' with "' + file.sPath + '" at offset ' + off);
                }
                return false;
            }
            sector['file'] = file;
            sector.offFile = off;
            return true;
        }
        if (DEBUG && this.messageEnabled()) this.printMessage("unable to map PBA " + pba + " to CHS");
        return false;
    }

    /**
     * initSector(sector, iCylinder, iHead, iSector, cbSector, dwPattern)
     *
     * Ensures every sector has ALL the properties of a proper Sector object; ie:
     *
     *      'sector':   sector number
     *      'length':   size of the sector, in bytes
     *      'data':     array of dwords
     *      'pattern':  dword pattern to use for empty or partial sectors (null for unread remote sectors)
     *
     * In addition, we will maintain the following information on a per-sector basis,
     * as sectors are modified:
     *
     *      iModify:    index of first modified dword in sector
     *      cModify:    number of modified dwords in sector
     *      fDirty:     true if sector is dirty, false if clean (or cleaning in progress)
     *
     * @this {Disk}
     * @param {Object} sector
     * @param {number} iCylinder
     * @param {number} iHead
     * @param {number} [iSector]
     * @param {number} [cbSector]
     * @param {number|null} [dwPattern]
     * @return {Object}
     */
    initSector(sector, iCylinder, iHead, iSector, cbSector, dwPattern)
    {
        if (!sector) {
            sector = {'sector': iSector, 'length': cbSector, 'data': [], 'pattern': dwPattern};
        }
        sector.iCylinder = iCylinder;
        sector.iHead = iHead;
        sector.iModify = sector.cModify = 0;
        sector.fDirty = false;
        return sector;
    }

    /**
     * connectRemoteDisk(sDiskPath)
     *
     * Unlike disconnect(), we don't issue the connect request ourselves; instead, we piggyback on the existing
     * preload code in load() to establish the connection.  That, in turn, will trigger a call to mount(), which
     * will check fOnDemand and set fRemote if the connection was successful.
     *
     * @this {Disk}
     * @param {string} sDiskPath
     * @return {string} is the URL connection string required to connect to sDiskPath
     */
    connectRemoteDisk(sDiskPath)
    {
        let sParms = DiskAPI.QUERY.ACTION + '=' + DiskAPI.ACTION.OPEN;
        sParms += '&' + DiskAPI.QUERY.VOLUME + '=' + sDiskPath;
        sParms += '&' + DiskAPI.QUERY.MODE + '=' + this.mode;
        sParms += '&' + DiskAPI.QUERY.CHS + '=' + this.nCylinders + ':' + this.nHeads + ':' + this.nSectors + ':' + this.cbSector;
        sParms += '&' + DiskAPI.QUERY.MACHINE + '=' + this.controller.getMachineID();
        sParms += '&' + DiskAPI.QUERY.USER + '=' + this.controller.getUserID();
        return Web.getHostOrigin() + DiskAPI.ENDPOINT + '?' + sParms;
    }

    /**
     * readRemoteSectors(iCylinder, iHead, iSector, nSectors, fAsync, done)
     *
     * @this {Disk}
     * @param {number} iCylinder
     * @param {number} iHead
     * @param {number} iSector
     * @param {number} nSectors (to read)
     * @param {boolean} fAsync
     * @param {function(number,boolean)} [done]
     */
    readRemoteSectors(iCylinder, iHead, iSector, nSectors, fAsync, done)
    {
        if (DEBUG && this.messageEnabled()) {
            this.printMessage("readRemoteSectors(CHS=" + iCylinder + ':' + iHead + ':' + iSector + ",N=" + nSectors + ")");
        }

        if (this.fRemote) {
            let sParms = DiskAPI.QUERY.ACTION + '=' + DiskAPI.ACTION.READ;
            sParms += '&' + DiskAPI.QUERY.VOLUME + '=' + this.sDiskPath;
            sParms += '&' + DiskAPI.QUERY.CHS + '=' + this.nCylinders + ':' + this.nHeads + ':' + this.nSectors + ':' + this.cbSector;
            sParms += '&' + DiskAPI.QUERY.ADDR + '=' + iCylinder + ':' + iHead + ':' + iSector + ':' + nSectors;
            sParms += '&' + DiskAPI.QUERY.MACHINE + '=' + this.controller.getMachineID();
            sParms += '&' + DiskAPI.QUERY.USER + '=' + this.controller.getUserID();
            let disk = this;
            let sDiskURL = Web.getHostOrigin() + DiskAPI.ENDPOINT + '?' + sParms;
            Web.getResource(sDiskURL, null, fAsync, function(sURL, sResponse, nErrorCode) {
                disk.doneReadRemoteSectors(sURL, sResponse, nErrorCode, [iCylinder, iHead, iSector, nSectors, fAsync, done]);
            });
            return;
        }
        if (done) done(-1, false);
    }

    /**
     * doneReadRemoteSectors(sURLName, sURLData, nErrorCode, aRequest)
     *
     * @this {Disk}
     * @param {string} sURLName
     * @param {string} sURLData
     * @param {number} nErrorCode
     * @param {Array} aRequest ([iCylinder, iHead, iSector, nSectors, fAsync, done])
     */
    doneReadRemoteSectors(sURLName, sURLData, nErrorCode, aRequest)
    {
        let fAsync = false;

        let iCylinder = aRequest[0];
        let iHead = aRequest[1];
        let iSector = aRequest[2];
        let nSectors = aRequest[3];

        if (!nErrorCode) {
            let abData = JSON.parse(sURLData);
            let offData = 0;
            while (nSectors--) {
                /*
                 * We call seek with fWrite == true to prevent seek() from triggering another call
                 * to readRemoteSectors() and endlessly recursing.  That also forces seek() to:
                 *
                 *  1) zero the sector's 'pattern'
                 *  2) disable warning about reading an uninitialized sector
                 *
                 * We KNOW this is an uninitialized sector, because we're about to initialize it.
                 */
                let sector = this.seek(iCylinder, iHead, iSector, true);
                if (!sector) {
                    if (DEBUG && this.messageEnabled()) {
                        this.printMessage("doneReadRemoteSectors(): seek(CHS=" + iCylinder + ':' + iHead + ':' + iSector + ") failed");
                    }
                    break;
                }
                this.fill(sector, abData, offData);
                offData += sector['length'];
                /*
                 * We happen to know that when seek() calls readRemoteSectors(), it limits the number of sectors
                 * to the current track, so the only variable we need to advance is iSector.
                 */
                iSector++;
            }
            fAsync = aRequest[4];
        } else {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage("doneReadRemoteSectors(CHS=" + iCylinder + ':' + iHead + ':' + iSector + ",N=" + nSectors + ") returned error " + nErrorCode);
            }
        }
        let done = aRequest[5];
        if (done) done(nErrorCode, fAsync);
    }

    /**
     * writeRemoteSectors(iCylinder, iHead, iSector, nSectors, abSectors, fAsync)
     *
     * Writes to a remote disk are performed on a timer-driven basis.  When a sector is modified for the first time,
     * a reference to that sector is "pushed" onto (ie, appended to the end of) aDirtySectors, and if aDirtySectors was
     * originally empty, then a REMOTE_WRITE_DELAY timer is set.
     *
     * When the timer fires, the first batch of contiguous sectors is sent off the server, and when the server responds
     * (ie, when cleanDirtySectors() is called), if the response indicates success, every sector that was sent is marked
     * clean -- unless one or more writes to the sector occurred in the meantime, which we track through a per-sector
     * fDirty flag.
     *
     * @this {Disk}
     * @param {number} iCylinder
     * @param {number} iHead
     * @param {number} iSector
     * @param {number} nSectors (to write)
     * @param {Array.<number>} abSectors
     * @param {boolean} fAsync
     * @return {boolean|Array}
     */
    writeRemoteSectors(iCylinder, iHead, iSector, nSectors, abSectors, fAsync)
    {
        if (DEBUG && this.messageEnabled()) {
            this.printMessage("writeRemoteSectors(CHS=" + iCylinder + ':' + iHead + ':' + iSector + ",N=" + nSectors + ")");
        }

        if (this.fRemote) {
            let dataPost = {};
            this.fWriteInProgress = true;
            dataPost[DiskAPI.QUERY.ACTION] = DiskAPI.ACTION.WRITE;
            dataPost[DiskAPI.QUERY.VOLUME] = this.sDiskPath;
            dataPost[DiskAPI.QUERY.CHS] = this.nCylinders + ':' + this.nHeads + ':' + this.nSectors + ':' + this.cbSector;
            dataPost[DiskAPI.QUERY.ADDR] = iCylinder + ':' + iHead + ':' + iSector + ':' + nSectors;
            dataPost[DiskAPI.QUERY.MACHINE] = this.controller.getMachineID();
            dataPost[DiskAPI.QUERY.USER] = this.controller.getUserID();
            dataPost[DiskAPI.QUERY.DATA] = JSON.stringify(abSectors);
            let disk = this;
            let sDiskURL = Web.getHostOrigin() + DiskAPI.ENDPOINT;
            Web.getResource(sDiskURL, dataPost, fAsync, function(sURL, sResponse, nErrorCode) {
                disk.doneWriteRemoteSectors(sURL, sResponse, nErrorCode, [iCylinder, iHead, iSector, nSectors, fAsync]);
            });
        }
        return false;
    }

    /**
     * doneWriteRemoteSectors(sURLName, sURLData, nErrorCode, aRequest)
     *
     * @this {Disk}
     * @param {string} sURLName
     * @param {string} sURLData
     * @param {number} nErrorCode
     * @param {Array} aRequest ([iCylinder, iHead, iSector, nSectors, fAsync])
     */
    doneWriteRemoteSectors(sURLName, sURLData, nErrorCode, aRequest)
    {
        let iCylinder = aRequest[0];
        let iHead = aRequest[1];
        let iSector = aRequest[2];
        let nSectors = aRequest[3];
        let fAsync = aRequest[4];
        this.fWriteInProgress = false;

        if (iCylinder >= 0 && iCylinder < this.aDiskData.length && iHead >= 0 && iHead < this.aDiskData[iCylinder].length) {
            for (let i = iSector - 1; nSectors-- > 0 && i >= 0 && i < this.aDiskData[iCylinder][iHead].length; i++) {
                let sector = this.aDiskData[iCylinder][iHead][i];

                if (!nErrorCode) {
                    if (!sector.fDirty) {
                        sector.iModify = sector.cModify = 0;
                    }
                } else {
                    if (DEBUG && this.messageEnabled()) {
                        this.printMessage("doneWriteRemoteSectors(CHS=" + iCylinder + ':' + iHead + ':' + sector['sector'] + ") returned error " + nErrorCode);
                    }
                    this.queueDirtySector(sector, false);
                }
            }
        }
        if (fAsync) this.updateWriteTimer();
    }

    /**
     * disconnectRemoteDisk()
     *
     * This is called by our powerDown() notification handler.  If fRemote is true, we issue the disconnect
     * request and then immediately set fRemote to false; we don't wait for (or test) the response.
     *
     * @this {Disk}
     */
    disconnectRemoteDisk()
    {
        if (this.fRemote) {
            let sParms = DiskAPI.QUERY.ACTION + '=' + DiskAPI.ACTION.CLOSE;
            sParms += '&' + DiskAPI.QUERY.VOLUME + '=' + this.sDiskPath;
            sParms += '&' + DiskAPI.QUERY.MACHINE + '=' + this.controller.getMachineID();
            sParms += '&' + DiskAPI.QUERY.USER + '=' + this.controller.getUserID();
            let sDiskURL = Web.getHostOrigin() + DiskAPI.ENDPOINT + '?' + sParms;
            Web.getResource(sDiskURL, null, true);
            this.fRemote = false;
        }
    }

    /**
     * queueDirtySector(sector, fAsync)
     *
     * Mark the specified sector as dirty, add it to the queue (aDirtySectors) if not already added,
     * and establish a timeout handler (findDirtySectors) if not already established.
     *
     * A freshly dirtied sector should sit in the queue for a short period of time (eg, 2 seconds)
     * before we attempt to write it; that is, a REMOTE_WRITE_DELAY timer should start ticking again
     * for any sector that is rewritten.  However, there will be exceptions; for example, when a sector
     * is finally written, we want to take advantage of the write request to write any additional dirty
     * sectors that follow it, even if those additional sectors were written less than 2 seconds ago.
     *
     * @this {Disk}
     * @param {Object} sector
     * @param {boolean} fAsync (true to update write timer, false to not)
     * @return {boolean} true if write timer set, false if not
     */
    queueDirtySector(sector, fAsync)
    {
        sector.fDirty = true;

        let j = this.aDirtySectors.indexOf(sector);
        if (j >= 0) {
            this.aDirtySectors.splice(j, 1);
            this.aDirtyTimestamps.splice(j, 1);
        }
        this.aDirtySectors.push(sector);
        this.aDirtyTimestamps.push(Usr.getTime());

        if (DEBUG && this.messageEnabled()) {
            this.printMessage("queueDirtySector(CHS=" + sector.iCylinder + ':' + sector.iHead + ':' + sector['sector'] + "): " + this.aDirtySectors.length + " dirty");
        }

        return fAsync && this.updateWriteTimer();
    }

    /**
     * updateWriteTimer()
     *
     * If a timer is already active, make sure it's still valid (ie, the time the timer is scheduled to fire is
     * >= the timestamp of the next dirty sector + REMOTE_WRITE_DELAY); if not, cancel the timer and start a new one.
     *
     * @this {Disk}
     * @return {boolean} true if write timer set, false if not
     */
    updateWriteTimer()
    {
        if (this.aDirtySectors.length) {
            let msWrite = this.aDirtyTimestamps[0] + Disk.REMOTE_WRITE_DELAY;
            if (this.timerWrite) {
                if (this.msTimerWrite < msWrite) {
                    clearTimeout(this.timerWrite);
                    this.timerWrite = null;
                }
            }
            if (!this.timerWrite) {
                let obj = this;
                let msNow = Usr.getTime();
                let msDelay = msWrite - msNow;
                if (msDelay < 0) msDelay = 0;
                if (msDelay > Disk.REMOTE_WRITE_DELAY) msDelay = Disk.REMOTE_WRITE_DELAY;
                this.timerWrite = setTimeout(function() {
                    obj.findDirtySectors(true);
                }, msDelay);
                this.msTimerWrite = msNow + msDelay;
            }
        } else {
            if (this.timerWrite) {
                clearTimeout(this.timerWrite);
                this.timerWrite = null;
            }
        }
        return this.timerWrite !== null;
    }

    /**
     * findDirtySectors(fAsync)
     *
     * Starting with the oldest dirty sector in the queue (aDirtySectors), determine the longest contiguous stretch of
     * dirty sectors (currently limited to the same track), mark them all as not dirty, and then call writeRemoteSectors().
     *
     * @this {Disk}
     * @param {boolean} fAsync is true if this function is being called asynchronously, false otherwise
     * @return {boolean|Array} false if no dirty sectors, otherwise true (or a response array if not fAsync)
     */
    findDirtySectors(fAsync)
    {
        if (fAsync) {
            this.timerWrite = null;
        }
        let sector = this.aDirtySectors[0];
        if (sector) {
            let iCylinder = sector.iCylinder;
            let iHead = sector.iHead;
            let iSector = sector['sector'];
            let nSectors = 0;
            let abSectors = [];
            for (let i = iSector - 1; i < this.aDiskData[iCylinder][iHead].length; i++) {
                let sectorNext = this.aDiskData[iCylinder][iHead][i];
                if (!sectorNext.fDirty) break;
                let j = this.aDirtySectors.indexOf(sectorNext);

                if (DEBUG && this.messageEnabled()) {
                    this.printMessage("findDirtySectors(CHS=" + iCylinder + ':' + iHead + ':' + sectorNext['sector'] + ")");
                }
                this.aDirtySectors.splice(j, 1);
                this.aDirtyTimestamps.splice(j, 1);
                abSectors = abSectors.concat(this.toBytes(sectorNext));
                sectorNext.fDirty = false;
                nSectors++;
            }

            let response = this.writeRemoteSectors(iCylinder, iHead, iSector, nSectors, abSectors, fAsync);
            return fAsync || response;
        }
        return false;
    }

    /**
     * info()
     *
     * @this {Disk}
     * @return {Array} containing: [nCylinders, nHeads, nSectorsPerTrack, nBytesPerSector]
     */
    info()
    {
        if (!this.aDiskData.length) {
            return [0, 0, 0, 0];
        }
        return [this.aDiskData.length, this.aDiskData[0].length, this.aDiskData[0][0].length, this.aDiskData[0][0][0]['length']];
    }

    /**
     * seek(iCylinder, iHead, iSector, fWrite, done)
     *
     * TODO: There's some dodgy code in seek() that allows floppy images to be dynamically
     * reconfigured with more heads and/or sectors/track, and it does so by peeking at more drive
     * properties.  That code used to be in the FDC component, where it was perfectly reasonable
     * to access those properties.  We need a cleaner interface back to the drive, similar to the
     * info() interface we provide to the controller.
     *
     * Whether or not the "dynamic reconfiguration" feature itself is perfectly reasonable is,
     * of course, a separate question.
     *
     * @this {Disk}
     * @param {number} iCylinder
     * @param {number} iHead
     * @param {number} iSector
     * @param {boolean} [fWrite]
     * @param {function(Object,boolean)} [done]
     * @return {Object|null} is the requested sector, or null if not found (or not available yet)
     */
    seek(iCylinder, iHead, iSector, fWrite, done)
    {
        let sector = null;
        let drive = this.drive;
        let cylinder = this.aDiskData[iCylinder];
        if (cylinder) {
            let i;
            let track = cylinder[iHead];
            /*
             * The following code allows a single-sided diskette image to be reformatted (ie, "expanded")
             * as a double-sided image, provided the drive has more than one head (see drive.nHeads).
             */
            if (!track && drive.bFormatting && iHead < drive.nHeads) {
                track = cylinder[iHead] = new Array(drive.bSectorEnd);
                for (i = 0; i < track.length; i++) {
                    track[i] = this.initSector(null, iCylinder, iHead, i + 1, drive.nBytes, 0);
                }
                /*
                 * TODO: This is more dodginess, because we can't be certain that every cylinder on the disk
                 * will receive the same "expanded" treatment, but functions like getSector() rely on instance
                 * properties (eg, this.nHeads), on the assumption that the disk's geometry is homogeneous.
                 */
                if (this.nHeads <= iHead) this.nHeads = iHead + 1;
            }
            if (track) {
                for (i = 0; i < track.length; i++) {
                    if (track[i] && track[i]['sector'] == iSector) {
                        /*
                         * If the sector's pattern is null, then this sector's true contents have not yet
                         * been fetched from the server.
                         */
                        sector = track[i];
                        if (sector['pattern'] === null) {
                            if (fWrite) {
                                /*
                                 * Optimization: if the caller has explicitly told us that they're about to WRITE to the
                                 * sector, then we shouldn't need to read it from the server; assume a zero pattern and return.
                                 */
                                sector['pattern'] = 0;
                            } else {
                                let nSectors = 1;
                                /*
                                 * We know we need to read at least 1 sector, but let's count the number of trailing sectors
                                 * on the same track that may also be required.
                                 */
                                while (++i < track.length) {
                                    if (track[i]['pattern'] === null) nSectors++;
                                }
                                this.readRemoteSectors(iCylinder, iHead, iSector, nSectors, done != null, function onReadRemoteComplete(err, fAsync) {
                                    if (err) sector = null;
                                    if (done) { //noinspection JSReferencingMutableVariableFromClosure
                                        done(sector, fAsync);
                                    }
                                });
                                return done? null : sector;
                            }
                        }
                        break;
                    }
                }
                /*
                 * The following code allows an 8-sector track to be reformatted (ie, "expanded") as a 9-sector track.
                 */
                if (!sector && drive.bFormatting && drive.bSector == 9) {
                    sector = track[i] = this.initSector(null, iCylinder, iHead, drive.bSector, drive.nBytes, 0);
                    /*
                     * TODO: This is more dodginess, because we can't be certain that every track on the disk
                     * will receive the same "expanded" treatment, but functions like getSector() rely on instance
                     * properties (eg, this.nSectors), on the assumption that the disk's geometry is homogeneous.
                     */
                    if (this.nSectors < drive.bSector) this.nSectors = drive.bSector;
                }
            }
        }
        if (done) done(sector, false);
        return sector;
    }

    /**
     * fill(sector, ab, off)
     *
     * @this {Disk}
     * @param {Object} sector
     * @param {*} ab (technically, this should be typed as Array.<number> but I'm having trouble coercing JSON.parse() to that)
     * @param {number} off
     */
    fill(sector, ab, off)
    {
        let cdw = sector['length'] >> 2;
        let adw = new Array(cdw);
        for (let idw = 0; idw < cdw; idw++) {
            adw[idw] = ab[off] | (ab[off + 1] << 8) | (ab[off + 2] << 16) | (ab[off + 3] << 24);
            off += 4;
        }
        sector['data'] = adw;
        /*
         * TODO: Consider taking this opportunity to shrink 'data' down by the number of dwords at the end of the buffer that
         * contain the same pattern, and setting 'pattern' accordingly.
         */
    }

    /**
     * toBytes(sector)
     *
     * @this {Disk}
     * @param {Object} sector
     * @return {Array.<number>} is an array of bytes
     */
    toBytes(sector)
    {
        let cb = sector['length'];
        let ab = new Array(cb);
        let ib = 0;
        let cdw = cb >> 2;
        let adw = sector['data'];
        let dwPattern = sector['pattern'];
        for (let idw = 0; idw < cdw; idw++) {
            let dw = (idw < adw.length? adw[idw] : dwPattern);
            ab[ib++] = dw & 0xff;
            ab[ib++] = (dw >> 8) & 0xff;
            ab[ib++] = (dw >> 16) & 0xff;
            ab[ib++] = (dw >> 24) & 0xff;
        }
        return ab;
    }

    /**
     * read(sector, ibSector, fCompare)
     *
     * @this {Disk}
     * @param {Object} sector (returned from a previous seek)
     * @param {number} ibSector a byte index within the given sector
     * @param {boolean} [fCompare] is true if this write-compare read
     * @return {number} the specified (unsigned) byte, or -1 if no more data in the sector
     */
    read(sector, ibSector, fCompare)
    {
        let b = -1;
        if (sector) {
            if (DEBUG && !ibSector && !fCompare && this.messageEnabled()) {
                this.printMessage('read("' + this.sDiskFile + '",CHS=' + sector.iCylinder + ':' + sector.iHead + ':' + sector['sector'] + ')');
            }
            if (ibSector < sector['length']) {
                let adw = sector['data'];
                let idw = ibSector >> 2;
                let dw = (idw < adw.length ? adw[idw] : sector['pattern']);
                b = ((dw >> ((ibSector & 0x3) << 3)) & 0xff);
            }
        }
        return b;
    }

    /**
     * write(sector, ibSector, b)
     *
     * @this {Disk}
     * @param {Object} sector (returned from a previous seek)
     * @param {number} ibSector a byte index within the given sector
     * @param {number} b the byte value to write
     * @return {boolean|null} true if write successful, false if write-protected, null if out of bounds
     */
    write(sector, ibSector, b)
    {
        if (this.fWriteProtected)
            return false;

        if (DEBUG && !ibSector && this.messageEnabled()) {
            this.printMessage('write("' + this.sDiskFile + '",CHS=' + sector.iCylinder + ':' + sector.iHead + ':' + sector['sector'] + ')');
        }

        if (ibSector < sector['length']) {
            if (b != this.read(sector, ibSector, true)) {
                let adw = sector['data'];
                let dwPattern = sector['pattern'];
                let idw = ibSector >> 2;
                let nShift = (ibSector & 0x3) << 3;

                /*
                 * Ensure every byte up to the specified byte is properly initialized.
                 */
                for (let i = adw.length; i <= idw; i++) adw[i] = dwPattern;

                if (!sector.cModify) {
                    sector.iModify = idw;
                    sector.cModify = 1;
                } else if (idw < sector.iModify) {
                    sector.cModify += sector.iModify - idw;
                    sector.iModify = idw;
                } else if (idw >= sector.iModify + sector.cModify) {
                    sector.cModify += idw - (sector.iModify + sector.cModify) + 1;
                }
                adw[idw] = (adw[idw] & ~(0xff << nShift)) | (b << nShift);

                if (this.fRemote) this.queueDirtySector(sector, true);
            }
            return true;
        }
        return null;
    }

    /**
     * encodeAsBase64()
     *
     * @this {Disk}
     * @return {string}
     */
    encodeAsBase64()
    {
        /*
         * Gross, but simple; more importantly, it works -- at least for disks of typical floppy magnitude.
         */
        let s = "", pba = 0, sector;
        while ((sector = this.getSector(pba++))) {
            for (let off = 0, len = sector['length']; off < len; off++) {
                s += String.fromCharCode(this.getSectorData(sector, off, 1));
            }
        }
        return btoa(s);
    }

    /**
     * encodeAsBinary()
     *
     * @this {Disk}
     * @return {Uint8Array}
     */
    encodeAsBinary() {
        let s = [], pba = 0, sector;
        while ((sector = this.getSector(pba++))) {
            for (let off = 0, len = sector['length']; off < len; off++) {
                s.push(this.getSectorData(sector, off, 1));
            }
        }
        return new Uint8Array(s);
    }

    /**
     * save()
     *
     * The first array entry contains some disk information:
     *
     *      [sDiskPath, dwChecksum, nCylinders, nHeads, nSectors, cbSector]
     *
     * Each subsequent entry in the returned array contains the following:
     *
     *      [iCylinder, iHead, iSector, iModify, [...]]
     *
     * where [...] is an array of modified dword(s) in the corresponding sector.
     *
     * @this {Disk}
     * @return {Array} of modified sectors
     */
    save()
    {
        let i = 0;
        let deltas = [];
        deltas[i++] = [this.sDiskPath, this.dwChecksum, this.nCylinders, this.nHeads, this.nSectors, this.cbSector];
        if (!this.fRemote && !this.fWriteProtected) {
            let aDiskData = this.aDiskData;
            for (let iCylinder = 0; iCylinder < aDiskData.length; iCylinder++) {
                for (let iHead = 0; iHead < aDiskData[iCylinder].length; iHead++) {
                    for (let iSector = 0; iSector < aDiskData[iCylinder][iHead].length; iSector++) {
                        let sector = aDiskData[iCylinder][iHead][iSector];
                        if (sector && sector.cModify) {
                            let mods = [], n = 0;
                            let iModify = sector.iModify, iModifyLimit = sector.iModify + sector.cModify;
                            while (iModify < iModifyLimit) {
                                mods[n++] = sector['data'][iModify++];
                            }
                            deltas[i++] = [iCylinder, iHead, iSector, sector.iModify, mods];
                        }
                    }
                }
            }
        }
        if (DEBUG && this.messageEnabled()) {
            this.printMessage('save("' + this.sDiskName + '"): saved ' + (deltas.length - 1) + ' change(s)');
        }
        return deltas;
    }

    /**
     * restore(deltas)
     *
     * The first array entry contains some disk information:
     *
     *      [sDiskPath, dwChecksum, nCylinders, nHeads, nSectors, cbSector]
     *
     * Each subsequent entry in the supplied array contains the following:
     *
     *      [iCylinder, iHead, iSector, iModify, [...]]
     *
     * where [...] is an array of modified dword(s) in the corresponding sector.
     *
     * @this {Disk}
     * @param {Array} deltas
     * @return {number} 0 if no changes applied, -1 if an error occurred, otherwise the number of sectors modified
     */
    restore(deltas)
    {
        /*
         * If deltas is undefined, that's not necessarily an error;  the controller may simply be (re)initializing
         * itself (although neither controller should be calling restore() under those conditions anymore).
         */
        let nChanges = 0;
        let sReason = "unsupported restore format";
        /*
         * I originally added a check for aDiskData here on the assumption that if there was an error loading
         * a disk image, we will have already notified the user, so any additional errors about differing checksums,
         * failure to restore the disk state, etc, would just be annoying.  HOWEVER, HDC will create an empty disk
         * image if its initialization code discovers that no disk was loaded earlier (see verifyDrive).  So while
         * checking aDiskData is still a good idea, be aware that it won't necessarily avoid redundant error messages
         * (at least in the case of HDC).
         */
        if (deltas && deltas.length > 0) {

            let i = 0;
            let aDiskInfo = deltas[i++];

            if (aDiskInfo && aDiskInfo.length >= 2) {
                /*
                 * Before getting to the checksum, we have to deal with a new situation: restoring an uninitialized
                 * disk image from a complete set of deltas.  And that is only possible if the disk was saved with the
                 * original disk geometry.
                 */
                if (!this.aDiskData.length && aDiskInfo.length >= 6) {
                    this.create(DiskAPI.MODE.LOCAL, aDiskInfo[2], aDiskInfo[3], aDiskInfo[4], aDiskInfo[5]);
                    /*
                     * TODO: Consider setting a flag here that we can check at the end of the restore() function
                     * that indicates we should recalculate dwChecksum, because we currently have an inconsistency
                     * between local disks that are mounted via buildDisk() and the same disks that are "remounted"
                     * later by this code; the former has the correct checksum, while the latter has a null checksum.
                     *
                     * As you can see below, we currently deal with this by simply ignoring null checksums....
                     */
                }
                /*
                 * v1.01 failed to indicate an error if either one of these failure conditions occurred.  Although maybe
                 * that's just as well, since v1.01 also failed to properly deal with situations where the user mounted
                 * different diskette(s) prior to exiting (hopefully fixed in v1.02).
                 *
                 * UPDATE: We also check aDiskInfo[0] first, because if it's null, then presumably there was no previous
                 * disk, and I'd like the addition of a disk to a machine to not be fatal to the restoration process.
                 */
                else if (aDiskInfo[0] != null) {
                    if (aDiskInfo[1] != null && this.dwChecksum != null && aDiskInfo[1] != this.dwChecksum) {
                        sReason = "original checksum (" + aDiskInfo[1] + ") differs from current checksum (" + this.dwChecksum + ")";
                        nChanges = -2;
                    }
                    /*
                     * Checksum is more important than disk path, and for now, I want the flexibility to move disk images.
                     *
                     *  else if (aDiskInfo[0] != this.sDiskPath) {
                     *      sReason = "original path '" + aDiskInfo[0] + "' differs from current path '" + this.sDiskPath + "'";
                     *      nChanges = -1;
                     *  }
                     */
                }
            }

            if (!this.aDiskData.length) nChanges = -1;

            while (i < deltas.length && nChanges >= 0) {
                let m = 0;
                let mod = deltas[i++];
                let iCylinder = mod[m++];
                let iHead = mod[m++];
                let iSector = mod[m++];
                /*
                 * Note the buried test for write-protection.  Yes, an invariant condition should be tested
                 * outside the loop, not inside, but (a) it's a trivial test, (b) the test should never fail
                 * because save() should never generate any mods for a write-protected disk, and (c) it
                 * centralizes all the failure conditions we're currently checking (which, admittedly, ain't much).
                 */
                if (iCylinder >= this.aDiskData.length || iHead >= this.aDiskData[iCylinder].length || iSector >= this.aDiskData[iCylinder][iHead].length) {
                    sReason = "sector (CHS=" + iCylinder + ':' + iHead + ':' + iSector + ") out of range (" + nChanges + " changes applied)";
                    nChanges = -1;
                    break;
                }
                if (this.fWriteProtected) {
                    sReason = "unable to modify write-protected disk";
                    nChanges = -1;
                    break;
                }
                let iModify = mod[m++];
                let mods = mod[m++];
                let iModifyLimit = iModify + mods.length;
                let sector = this.aDiskData[iCylinder][iHead][iSector];
                if (!sector) continue;
                /*
                 * Since write() now deals with empty/partial sectors, we no longer need to completely "inflate"
                 * the sector prior to applying modifications.  So let's just make sure that the sector is "inflated"
                 * up to iModify.
                 */
                let idw = sector['data'].length;
                while (idw < iModify) {
                    sector['data'][idw++] = sector['pattern'];
                }
                let n = 0;
                sector.iModify = iModify;
                sector.cModify = mods.length;
                while (iModify < iModifyLimit) {
                    sector['data'][iModify++] = mods[n++];
                }
                nChanges++;
            }
        }

        if (nChanges < 0) {
            /*
             * We're suppressing checksum messages for the general public for now....
             */
            if (DEBUG || nChanges != -2) {
                this.notice("Unable to restore disk '" + this.sDiskName + ": " + sReason);
            }
        } else {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage('restore("' + this.sDiskName + '"): restored ' + nChanges + ' change(s)');
            }
            /*
             * Last but not least, rebuild the disk's file table if BACKTRACK or SYMBOLS support is enabled.
             */
            if (BACKTRACK || SYMBOLS) this.buildFileTable();
        }
        return nChanges;
    }

    /**
     * convertToJSON(fFormatted)
     *
     * We perform some RegExp massaging on the JSON data to eliminate unnecessary properties
     * (eg, 'length' values of 512, 'pattern' values of 0, and empty 'data' arrays, since those
     * are defaults).
     *
     * In addition, we first check every sector to see if it can be "deflated".  Sectors that were
     * initially "deflated" should remain that way unless/until they were modified, so technically,
     * we could call deflateSector() just for modified sectors, but this isn't a common operation,
     * so it doesn't hurt to check every sector.
     *
     * @this {Disk}
     * @param {boolean} [fFormatted]
     * @return {string} containing the entire disk image as JSON-encoded data
     */
    convertToJSON(fFormatted)
    {
        let s, pba = 0, sector, sectorLast;

        while ((sector = this.getSector(pba++))) {
            this.deflateSector(sector);
        }

        s = JSON.stringify(this.aDiskData, function(key, value) {
            /*
             * If BACKTRACK support is enabled, we have to filter out any 'file' properties that may
             * be attached to the sector objects, lest we risk blowing the stack due to circular references.
             */
            if (key == 'file') {
                return undefined;
            }
            return value;
        });

        /*
         * Eliminate unnecessary default properties (eg, 'length' values of 512, 'pattern' values of 0, etc).
         */
        s = s.replace(/,"length":512/g, "").replace(/,"pattern":0/g, "").replace(/,"data":\[]/g, "");

        /*
         * I don't really want to strip quotes from disk image property names, since I would have to put them
         * back again during mount() -- or whenever JSON.parse() is used instead of eval().  But I still remove
         * them temporarily, so that any remaining property names (eg, "iModify", "cModify", "fDirty") can
         * easily be stripped out, by virtue of their being the only quoted properties left.  We then "requote"
         * all the property names that remain.
         */
        s = s.replace(/"(sector|length|data|pattern)":/g, "$1:");

        /*
         * The next line will remove any other numeric or boolean properties that were added at runtime, although
         * they may have completely different ("minified") names if the code has been compiled.
         */
        s = s.replace(/,"[^"]*":([0-9]+|true|false)/g, "");
        s = s.replace(/(sector|length|data|pattern):/g, "\"$1\":");

        /*
         * Last but not least, insert line breaks after every object definition, to improve human readability
         * (but only if the caller asks for it).
         */
        if (fFormatted) s = s.replace(/([\]}]),/g, "$1,\n");
        return s;
    }

    /**
     * deflateSector(sector)
     *
     * This is just the first revision: it currently looks only at fully inflated sectors.
     *
     * @this {Disk}
     * @param {Object} sector
     */
    deflateSector(sector)
    {
        let adw = sector['data'];
        let cdw = adw.length;
        if ((cdw << 2) == sector['length']) {
            let idw = cdw - 1;
            let dwPattern = adw[idw], cDupes = 0;
            while (idw--) {
                if (adw[idw] !== dwPattern) break;
                cDupes++;
            }
            if (cDupes++) {
                adw.length = cdw - cDupes;
                sector['pattern'] = dwPattern;
            }
        }
    }

    /**
     * dumpSector(sector, pba, sDesc)
     *
     * @this {Disk}
     * @param {Object} sector (returned from a previous seek)
     * @param {number} [pba]
     * @param {string} [sDesc]
     * @return {string}
     */
    dumpSector(sector, pba, sDesc)
    {
        let sDump = "";
        if (DEBUG && sector) {
            if (pba != null) sDump += "sector " + pba + (sDesc? (" for " + sDesc) : "") + ':';
            let sBytes = "", sChars = "";
            let cbSector = sector['length'];
            let cdwData = sector['data'].length;
            let dw = 0;
            for (let i = 0; i < cbSector; i++) {
                if ((i % 16) === 0) {
                    if (sDump) sDump += sBytes + ' ' + sChars + '\n';
                    sDump += Str.toHex(i, 4) + ": ";
                    sBytes = sChars = "";
                }
                if ((i % 4) === 0) {
                    let idw = i >> 2;
                    dw = (idw < cdwData? sector['data'][idw] : sector['pattern']);
                }
                let b = dw & 0xff;
                dw >>>= 8;
                sBytes += Str.toHex(b, 2) + (i % 16 == 7? "-" : " ");
                sChars += (b >= 32 && b < 128? String.fromCharCode(b) : ".");
            }
            if (sBytes) sDump += sBytes + ' ' + sChars;
        }
        return sDump;
    }
}

/**
 * The default number of milliseconds to wait before writing a dirty sector back to a remote disk image
 *
 * @const {number}
 */
Disk.REMOTE_WRITE_DELAY = 2000;         // 2-second delay

/*
 * A global disk count, used to form unique Disk component IDs (totally optional; for debugging purposes only)
 */
Disk.nDisks = 0;

/**
 * class FileInfo
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class FileInfo {
    /**
     * FileInfo(disk, sPath, sName, bAttr, cbSize, apba)
     *
     * To the basic file information below, loadSymbols() may also add:
     *
     *      sModule
     *      sDescription
     *      aSegments[]
     *
     * which is indexed by 1-based segment numbers, where each aSegments[] element is an object
     * containing:
     *
     *      offStart (file-relative offset of start of segment data)
     *      offEnd (file-relative offset of end of segment data)
     *      aEntries[]
     *
     * where aEntries is an array indexed by 1-based ordinals, where each aEntries[] element contains:
     *
     *      [offset, symbol]
     *
     * where offset is relative to the segment's offStart value, and symbol is a string describing the
     * entry.
     *
     * NOTE: Although aEntries arrays are similar to the Debugger's aOffsets arrays, they are not
     * interchangeable data structures, because ours is ordered by ordinal, whereas aOffsets is
     * ordered by offset.  We provide an interface, getModuleInfo(), to the Debugger that converts
     * our data into an intermediate array, aSymbols, which the Debugger then uses to build aOffsets.
     * It would be nice to avoid building that intermediate representation, but it's a side-effect of
     * the Debugger's earlier support for JSON-encoded MAP files.
     *
     * There will always be an offset at index 0 of an aEntries[] element, but some error or incomplete
     * symbolic information could result in a missing symbol at index 1, because symbol name processing is
     * separate from entry table processing.
     *
     * @param {Disk} disk
     * @param {string} sPath
     * @param {string} sName
     * @param {number} bAttr
     * @param {number} cbSize
     * @param {Array.<number>} apba
     */
    constructor(disk, sPath, sName, bAttr, cbSize, apba)
    {
        this.disk = disk;
        this.sPath = sPath;
        this.sName = sName;
        this.bAttr = bAttr;
        this.cbSize = cbSize;
        this.apba = apba;
    }

    /**
     * loadValue(offset, length)
     *
     * @this {FileInfo}
     * @param {number} offset
     * @param {number} [length] (1, 2 or 4 bytes; default is 2)
     * @return {number|undefined}
     */
    loadValue(offset, length)
    {
        let l;
        length = length || 2;
        let iSector = offset >> 9;
        let offSector = offset & 0x1ff;
        let sector = this.disk.getSector(this.apba[iSector]);
        if (sector) {
            /*
             * If the read is wholly contained within a sector, read it with one call.
             */
            if (offSector + length <= sector['length']) {
                return this.disk.getSectorData(sector, offSector, length);
            }
            /*
             * The spans a sector boundary, so we just call ourselves one byte at a time.
             */
            l = 0;
            let shift = 0;
            while (length--) {
                l |= this.loadValue(offset++, 1) << shift;
                shift += 8;
            }
        }
        return l;
    }

    /**
     * loadString(offset, length)
     *
     * @this {FileInfo}
     * @param {number} offset
     * @param {number} [length] (if omitted, then string must be zero-terminated)
     * @return {string}
     */
    loadString(offset, length)
    {
        let s = "";
        if (!length) length = -1;
        while (length--) {
            let b = this.loadValue(offset++, 1);
            if (!b) break;
            s += String.fromCharCode(b);
        }
        return s;
    }

    /**
     * loadField(aField, offset)
     *
     * @this {FileInfo}
     * @param {Array.<number>} aField
     * @param {number} [offset] (0 if not specified)
     * @return {number|undefined}
     */
    loadField(aField, offset)
    {
        return this.loadValue(aField[0] + (offset || 0), aField[1]);
    }

    /**
     * loadSegmentTable(offEntries, nEntries, nSegOffShift)
     *
     * @this {FileInfo}
     * @param {number} offEntries
     * @param {number} nEntries
     * @param {number} nSegOffShift
     */
    loadSegmentTable(offEntries, nEntries, nSegOffShift)
    {
        /*
         * Read the Segment Table entries now.
         */
        let iSegment = 1;
        this.aSegments = [];
        this.aOrdinals = [];                // this is an optional array for quick ordinal-to-segment lookup

        if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
            this.disk.printMessage("loadSegmentTable(" + this.sPath + "," + Str.toHexLong(offEntries) + "," + Str.toHexWord(nEntries) + ")");
        }

        while (nEntries--) {
            let offSegment = this.loadValue(offEntries) << nSegOffShift;
            if (offSegment) {
                let lenSegment = this.loadValue(offEntries + 2) || 0x10000;       // 0 means 64K

                if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
                    this.disk.printMessage("segment " + iSegment + ": offStart=" + Str.toHexLong(offSegment) + " offEnd=" + Str.toHexLong(offSegment + lenSegment));
                }

                this.aSegments[iSegment++] = {offStart: offSegment, offEnd: offSegment + lenSegment - 1, aEntries: []};
            }
            offEntries += 8;
        }
        /*
         * Although not documented (at least not in any of the early Windows "New Executable" documents I've seen),
         * the Entry Table may also contain entries whose bSegment field is 0xFE, which doesn't correspond to a valid
         * segment number.  That pseudo-segment number appears to be reserved for constants.  Here are some examples
         * from a 3.1-vintage KRNL386.EXE:
         *
         *      cannot find segment 254 (offset 0xF000) for symbol __ROMBIOS with ordinal 173
         *      cannot find segment 254 (offset 0x0000) for symbol __0000H with ordinal 183
         *      cannot find segment 254 (offset 0x0040) for symbol __0040H with ordinal 193
         *      cannot find segment 254 (offset 0x0008) for symbol __AHINCR with ordinal 114
         *      cannot find segment 254 (offset 0x0003) for symbol __AHSHIFT with ordinal 113
         *      cannot find segment 254 (offset 0xA000) for symbol __A000H with ordinal 174
         *      cannot find segment 254 (offset 0xB000) for symbol __B000H with ordinal 181
         *      cannot find segment 254 (offset 0xC000) for symbol __C000H with ordinal 195
         *      cannot find segment 254 (offset 0xB800) for symbol __B800H with ordinal 182
         *      cannot find segment 254 (offset 0xD000) for symbol __D000H with ordinal 179
         *      cannot find segment 254 (offset 0xE000) for symbol __E000H with ordinal 190
         *      cannot find segment 254 (offset 0xF000) for symbol __F000H with ordinal 194
         *      cannot find segment 254 (offset 0x0001) for symbol __WINFLAGS with ordinal 178
         *
         * The simplest way to handle those Entry Table entries is creating an additional (fake) aSegments table entry.
         */
        this.aSegments[0xFE] = {offStart: 0, offEnd: 0, aEntries: []};
    }

    /**
     * loadEntryTable(offEntries, offEntriesEnd)
     *
     * @this {FileInfo}
     * @param {number} offEntries
     * @param {number} offEntriesEnd
     */
    loadEntryTable(offEntries, offEntriesEnd)
    {
        let iOrdinal = 1;

        if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
            this.disk.printMessage("loadEntryTable(" + Str.toHexLong(offEntries) + "," + Str.toHexLong(offEntriesEnd) + ")");
        }

        while (offEntries < offEntriesEnd) {

            let w = this.loadValue(offEntries);
            let bEntries = w & 0xff;
            if (!bEntries) break;
            let bSegment = w >> 8, iSegment;

            if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
                this.disk.printMessage("bundle for segment " + bSegment + ": " + bEntries + " entries @" + Str.toHex(offEntries));
            }

            offEntries += 2;

            /*
             * bSegment 0x00 means all the entries spanned by bEntries are unused, so move on.
             */
            if (!bSegment) {
                iOrdinal += bEntries;
                continue;
            }
            while (bEntries--) {
                /*
                 * bSegment 0x01-0xFE means the next 3 bytes describe a fixed segment entry; the next
                 * byte contains flags indicating exported (0x1) and/or global/shared (0x2) data, and the
                 * next word is the offset within the segment.
                 */
                let offEntry;
                let offDebug = offEntries;
                let bFlags = this.loadValue(offEntries, 1);

                if (bSegment <= 0xFE) {
                    iSegment = bSegment;
                    offEntry = this.loadValue(offEntries + 1);
                    offEntries += 3;
                } else {
                    /*
                     * bSegment 0xFF means a movable segment entry, which is 6 bytes long: flags byte (which
                     * we've already read), an INT 0x3F (0xCD,0x3F), a 1-byte segment number, and a 2-byte offset.
                     */
                    iSegment = this.loadValue(offEntries + 3, 1);
                    offEntry = this.loadValue(offEntries + 4);
                    offEntries += 6;
                }
                if (!this.aSegments[iSegment]) {
                    if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
                        this.disk.printMessage("invalid segment: " + iSegment);
                    }
                } else {
                    this.aSegments[iSegment].aEntries[iOrdinal] = [offEntry];
                    if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
                        this.disk.printMessage("ordinal " + iOrdinal + ": segment=" + iSegment + " offset=" + Str.toHexLong(offEntry) + " @" + Str.toHex(offDebug));
                    }
                }
                this.aOrdinals[iOrdinal] = [iSegment, offEntry];
                iOrdinal++;
            }
        }
    }

    /**
     * loadNameTable(aField, offset)
     *
     * NOTE: If offset is omitted, we assume we're reading the Resident Name Table, and therefore
     * the first name is the module name; otherwise, we assume it is the Non-Resident Name Table, and
     * that the first name is the module description.
     *
     * @this {FileInfo}
     * @param {number} offEntries
     * @param {number} [offEntriesEnd] (if omitted, then the table must be null-terminated)
     */
    loadNameTable(offEntries, offEntriesEnd)
    {
        let cNames = 0;

        if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
            this.disk.printMessage("loadNameTable(" + Str.toHexLong(offEntries) + (offEntriesEnd? ("," + Str.toHexLong(offEntriesEnd)) : "") + ")");
        }

        while (!offEntriesEnd || offEntries < offEntriesEnd) {

            let offDebug = offEntries;
            let bLength = this.loadValue(offEntries, 1);
            if (!bLength) break;

            let sSymbol = this.loadString(offEntries + 1, bLength);
            if (!sSymbol) break;                    // an error must have occurred (this is not a natural way to end)
            offEntries += 1 + bLength;

            if (!cNames) {
                if (!offEntriesEnd) {
                    this.sModule = sSymbol;
                } else {
                    this.sDescription = sSymbol;
                }
            }
            else {
                let iOrdinal = this.loadValue(offEntries);
                let tuple = this.aOrdinals[iOrdinal];
                if (tuple) {
                    let iSegment = tuple[0];        // tuple[0] is the segment number and tuple[1] is the corresponding offEntry
                    if (this.aSegments[iSegment]) {
                        let aEntries = this.aSegments[iSegment].aEntries[iOrdinal];

                        aEntries.push(sSymbol);
                        if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
                            this.disk.printMessage("segment " + iSegment + " offset " + Str.toHexWord(aEntries[0]) + " ordinal " + iOrdinal + ": " + sSymbol + " @" + Str.toHex(offDebug));
                        }
                    } else {
                        if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
                            this.disk.printMessage(this.sPath + ": cannot find segment " + iSegment + " (offset " + Str.toHexWord(tuple[1]) + ") for symbol " + sSymbol + " with ordinal " + iOrdinal + " @" + Str.toHex(offDebug));
                        }
                    }
                } else {
                    if (DEBUG && this.disk.messageEnabled(Messages.DISK | Messages.DATA)) {
                        this.disk.printMessage(this.sPath + ": cannot find ordinal " + iOrdinal + " for symbol " + sSymbol + " @" + Str.toHex(offDebug));
                    }
                }
            }
            offEntries += 2;
            cNames++;
        }
    }

    /**
     * loadSymbols()
     *
     * For files with NE headers, extract all available symbolic information from the file.
     *
     * @this {FileInfo}
     */
    loadSymbols()
    {
        if (!Str.endsWith(this.sName, ".EXE") && !Str.endsWith(this.sName, ".DLL") && !Str.endsWith(this.sName, ".DRV")) {
            return;
        }

        if (this.loadField(FileInfo.OE.oeSignature) != FileInfo.OE.SIG) {
            return;
        }

        if (this.loadField(FileInfo.OE.oeRelocOffset) != FileInfo.OE.NE_SIG) {
            return;
        }

        let offNEHeader = this.loadField(FileInfo.OE.oeNEHeader);
        if (this.loadField(FileInfo.NE.neSignature, offNEHeader) != FileInfo.NE.SIG) {
            return;
        }

        let nEntries = this.loadField(FileInfo.NE.neSTEntries, offNEHeader);
        let offEntries = this.loadField(FileInfo.NE.neSTOffset, offNEHeader);
        let nSegOffShift = this.loadField(FileInfo.NE.neSegOffShift, offNEHeader);

        if (offEntries && nEntries) {
            this.loadSegmentTable(offEntries + offNEHeader, nEntries, nSegOffShift || 0);
        }

        offEntries = this.loadField(FileInfo.NE.neETOffset, offNEHeader);
        let cbEntries = this.loadField(FileInfo.NE.neETSize, offNEHeader);
        if (offEntries && cbEntries) {
            this.loadEntryTable(offEntries += offNEHeader, offEntries + cbEntries);
        }

        /*
         * Time to walk the Resident Name Table and update the corresponding ordinals.
         */
        offEntries = this.loadField(FileInfo.NE.neRNTOffset, offNEHeader);
        if (offEntries) {
            this.loadNameTable(offEntries + offNEHeader);
        }

        /*
         * Ditto for the Non-Resident Name Table, which for some reason, uses a file-relative offset rather than
         * an NE header-relative offset, and which is both sized AND null-terminated; we check both terminating
         * conditions to be safe.
         */
        offEntries = this.loadField(FileInfo.NE.neNRNTOffset, offNEHeader);
        cbEntries = this.loadField(FileInfo.NE.neNRNTSize, offNEHeader);
        if (offEntries && cbEntries) {
            this.loadNameTable(offEntries, offEntries + cbEntries);
        }
    }

    /**
     * getSymbol(off, fNearest)
     *
     * @this {FileInfo}
     * @param {number} off (offset relative to start of file)
     * @param {boolean} [fNearest] (true to return nearest symbol if a segment with symbols is found)
     * @return {string} symbol corresponding to file offset (of the file name + offset if no symbol found)
     */
    getSymbol(off, fNearest)
    {
        let sSymbol = null;
        if (this.aSegments) {
            for (let iSegment in this.aSegments) {
                let segment = this.aSegments[iSegment];
                if (off >= segment.offStart && off <= segment.offEnd) {
                    /*
                     * This is the one and only segment we need to check, so we can make off segment-relative now.
                     */
                    off -= segment.offStart;
                    /*
                     * To support fNearest, save the entry where (off - entry[0]) yields the smallest positive result.
                     */
                    let cbNearest = off, entryNearest;
                    for (let iOrdinal in segment.aEntries) {
                        let entry = segment.aEntries[iOrdinal];
                        let cb = off - entry[0];
                        if (!cb) {
                            sSymbol = this.sModule + '!' + entry[1];
                            break;
                        }
                        if (fNearest && cb > 0 && cb < cbNearest) {
                            entryNearest = entry;
                            cbNearest = cb;
                        }
                    }
                    if (!sSymbol && entryNearest) {
                        sSymbol = this.sModule + '!' + entryNearest[1] + "+" + Str.toHex(cbNearest, 0, true);
                    }
                    break;
                }
            }
        }
        return sSymbol || this.sName + '+' + Str.toHex(off, 0, true);
    }
}

/*
 * Original (aka "Old") Executable MS-DOS File Format
 *
 * Relocation entries are pairs of 16-bit words:
 *
 *      wOffset
 *      wSegment
 *
 * I've noticed that a "PKLITE" EXE may have a oeRelocOffset of 0x52, where the word at 0x001C is 0x210F and the
 * bytes from 0x001E through 0x0051 are:
 *
 *      "PKLITE Copr. 1990-92 PKWARE Inc. All Rights Reserved"
 *
 * Other EXEs have a oeRelocOffset of 0x1E, which begs the question: what is the word at 0x001C typically used for?
 *
 * It was not uncommon for there to be wasted space in the header; even an EXE with, say, 20 (0x14) entries would
 * likely have a wHeaderParas value of 0x20, which is 512 (0x200) bytes.  The desire, no doubt, was to align the
 * start of the EXE segment(s) to a traditional sector boundary.
 */
FileInfo.OE = {
    SIG:            0x5A4D,
    oeSignature:    [0x0000, 2],        // "MZ" (0x4D,0x5A)
    oeLastBytes:    [0x0002, 2],        // 0-511 (0 means the entire last block is used)
    oeBlocks:       [0x0004, 2],        // number of blocks in the file
    oeRelocEntries: [0x0006, 2],        // number of relocation entries in the header
    oeHeaderParas:  [0x0008, 2],        // number of (16-byte) paragraphs in the header
    oeExtraParas:   [0x000A, 2],        // minimum number of additional paragraphs required at load-time
    oeMaxParas:     [0x000C, 2],        // maximum number of additional paragraphs required at load-time
    oeSSRel:        [0x000E, 2],        // relative value of SS
    oeSPInit:       [0x0010, 2],        // initial value of SP
    oeChecksum:     [0x0012, 2],        // checksum if non-zero (sum of all words, including this, should be zero)
    oeIPInit:       [0x0014, 2],        // initial value of IP
    oeCSRel:        [0x0016, 2],        // relative value of CS
    oeRelocOffset:  [0x0018, 2],        // offset of first relocation item
    oeOverlay:      [0x001A, 2],        // overlay number (normally zero, implying main program)
    /*
     * The following fields are accommodated by the NE format, but they were actually defined by "the DOS 4.0 group"
     * as extensions to the OE format.
     */
    oeDOS40Bits:    [0x0020, 2],        // DOS 4.0 behavior bits
    oeUnusedBits:   [0x0022, 2],        // unused behavior bits
    /*
     * If oeRelocOffset (0x0018) is 0x40, then the file is considered an NE (New Executable) MS-DOS file, and
     * the offset of the NE header (from the start of the file) is a 32-bit value stored at 0x003C.  Note that early
     * versions of Windows (aka "DOS 2.0 Windows") originally defined the NE header offset as a 16-bit value stored
     * at 0x003E.  And before that, it may have been a 16-bit value stored at 0x0024, which would have been immediately
     * after the "behavior bits" fields shown above).
     */
    oeNEHeader:     [0x003C, 4],        // offset from start of file to NE header
    NE_SIG:         0x40
};

/*
 * New Executable MS-DOS File Format
 *
 * Unless otherwise specified, all *Offset fields are relative to the start of the NE header, and all *Size fields
 * are in bytes.
 */
FileInfo.NE = {
    SIG:            0x454E,
    neSignature:    [0x0000, 2],        // "NE" (0x4E,0x45)
    neLinkerVer:    [0x0002, 2],        // (low byte is version, high byte is revision)
    neETOffset:     [0x0004, 2],        // Entry Table offset
    neETSize:       [0x0006, 2],        // Entry Table size
    neChecksum:     [0x0008, 4],        // checksum (sum of all DWORDs in the file, excluding this one)
    neFlags:        [0x000C, 2],
    neDataSeg:      [0x000E, 2],
    neHeapSize:     [0x0010, 2],
    neStackSize:    [0x0012, 2],
    neCSIP:         [0x0014, 4],
    neSSSP:         [0x0018, 4],
    neSTEntries:    [0x001C, 2],        // Segment Table entries
    neMRTEntries:   [0x001E, 2],        // Module Reference Table entries
    neNRNTSize:     [0x0020, 2],        // Non-Resident Name Table size
    neSTOffset:     [0x0022, 2],        // Segment Table offset
    neRTOffset:     [0x0024, 2],        // Resource Table offset
    neRNTOffset:    [0x0026, 2],        // Resident Name Table offset
    neMRTOffset:    [0x0028, 2],        // Module Reference Table offset
    neINTOffset:    [0x002A, 2],        // Imported Names Table offset
    neNRNTOffset:   [0x002C, 4],        // Non-Resident Name Table offset (relative to start of file)
    neETMovable:    [0x0030, 2],        // number of movable entries in the Entry Table
    neSegOffShift:  [0x0032, 2],        // logical sector alignment shift count, log(base 2) of the segment sector size (default 9)
    /*
     * Fields after this point are post "DOS 2.0 Windows"...
     */
    neRTEntries:    [0x0034, 2],        // Resource Table entries
    neEXEType:      [0x0036, 1]         // executable type (0x02 for Windows)
    /*
     * 0x37 through 0x3F is reserved.
     */
};

/**
 * Every Sector object (once loaded, parsed, and "normalized") should have ALL of the following named properties:
 *
 *      'sector':   sector number
 *      'length':   size of the sector, in bytes
 *      'data':     array of dwords
 *      'pattern':  dword pattern to use for empty or partial sectors (or null if sector still needs to be loaded)
 *
 * initSector() also sets the following properties, to help us quickly identify its location within aDiskData:
 *
 *      iCylinder
 *      iHead
 *
 * In addition, we will maintain the following information on a per-sector basis, as sectors are modified:
 *
 *      iModify:    index of first modified dword in sector
 *      cModify:    number of modified dwords in sector
 *      fDirty:     true if sector is dirty, false if clean (or cleaning in progress)
 *
 * fDirty is used in conjunction with "demandrw" disks; it is set to true whenever the sector is modified, and is
 * set to false whenever the sector has been sent to the server.  If the server write succeeds and fDirty is still
 * false, then the sector modifications are removed (cModify is set to zero).  If the write succeeds but fDirty was
 * set to true again in the meantime, then all the sector modifications (even those that were just written) remain
 * in place (since we don't keep track of more than one modification range within a sector).  And if the write failed,
 * then fDirty is set back to true and again all modifications remain in place; the best we can do is schedule another
 * write attempt.
 *
 * TODO: Perhaps we should also maintain a failure count and stop trying to write sectors that reach a certain
 * threshold.  Error-handling, as usual, is the thorniest problem.
 *
 * @typedef {{
 *  sector:     number,
 *  length:     number,
 *  data:       Array.<number>,
 *  pattern:    (number|null),
 *  iCylinder:  number,
 *  iHead:      number,
 *  iModify:    number,
 *  cModify:    number,
 *  file:       FileInfo,
 *  offFile:    number
 * }}
 */
var SectorInfo;



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/fdc.js (C) Jeff Parsons 2012-2018
 */


/*
 * FDC Terms (see FDC.TERMS)
 *
 *      C       Cylinder Number         the current or selected cylinder number
 *
 *      D       Data                    the data pattern to be written to a sector
 *
 *      DS      Drive Select            the selected driver number encoded the same as bits 0 and 1 of the Digital Output
 *                                      Register (DOR); eg, DS0, DS1, DS2, or DS3
 *
 *      DTL     Data Length             when N is 00, DTL is the data length to be read from or written to a sector
 *
 *      EOT     End Of Track            the final sector number on a cylinder
 *
 *      GPL     Gap Length              the length of gap 3 (spacing between sectors excluding the VCO synchronous field)
 *
 *      H       Head Address            the head number, either 0 or 1, as specified in the ID field
 *
 *      HD      Head                    the selected head number, 0 or 1 (H = HD in all command words)
 *
 *      HLT     Head Load Time          the head load time in the selected drive (2 to 256 milliseconds in 2-millisecond
 *                                      increments for the 1.2M-byte drive and 4 to 512 milliseconds in 4 millisecond increments
 *                                      for the 320K-byte drive)
 *
 *      HUT     Head Unload Time        the head unload time after a read or write operation (0 to 240 milliseconds in
 *                                      16-millisecond increments for the 1.2M-byte drive and 0 to 480 milliseconds in
 *                                      32-millisecond increments for the 320K-byte drive)
 *
 *      MF      FM or MFM Mode          0 selects FM mode and 1 selects MFM (MFM is selected only if it is implemented)
 *
 *      MT      Multitrack              1 selects multitrack operation (both HD0 and HD1 will be read or written)
 *
 *      N       Number                  the number of data bytes written in a sector
 *
 *      NCN     New Cylinder Number     the new cylinder number for a SEEK operation
 *
 *      ND      Non-Data Mode           indicates an operation in the non-data mode
 *
 *      PCN     Present Cylinder Number the cylinder number at the completion of a SENSE INTERRUPT STATUS command
 *                                      (present position of the head)
 *
 *      R       Record                  the sector number to be read or written
 *
 *      SC      Sectors Per Cylinder    the number of sectors per cylinder
 *
 *      SK      Skip                    this stands for skip deleted-data address mark
 *
 *      SRT     Stepping Rate           this 4 bit byte indicates the stepping rate for the diskette drive as follows:
 *                                      1.2M-Byte Diskette Drive: 1111=1ms, 1110=2ms, 1101=3ms
 *                                      320K-Byte Diskette Drive: 1111=2ms, 1110=4ms, 1101=6ms
 *
 *      STP     STP Scan Test           if STP is 1, the data in contiguous sectors is compared with the data sent
 *                                      by the processor during a scan operation; if STP is 2, then alternate sections
 *                                      are read and compared
 */

/**
 * class FDC
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class FDC extends Component {
    /**
     * FDC(parmsFDC)
     *
     * The FDC component simulates a NEC ÂµPD765A or Intel 8272A compatible floppy disk controller, and has one
     * component-specific property:
     *
     *      autoMount: one or more JSON-encoded objects, each containing 'name' and 'path' properties
     *
     *      sortBy: "name" to sort disks by name, "path" to sort by path, or "none" to leave as-is (default is "name")
     *
     * Regarding early diskette drives: the IBM PC Model 5150 originally shipped with single-sided drives,
     * and therefore supported only 160Kb diskettes.  That's the only diskette format PC-DOS 1.00 supported, too.
     *
     * At some point, 5150's started shipping with double-sided drives, but I'm not sure whether the ROMs changed;
     * they probably did NOT change, because the original ROM BIOS already supported drives with multiple heads.
     * However, what the ROM BIOS did NOT do was provide any indication of drive type, which as far as I can tell,
     * meant you had to simply read/write/format tracks with the second head and check for errors.
     *
     * Presumably at the same time double-sided drives started shipping, PC-DOS 1.10 shipped, which added
     * support for 320Kb diskettes.  And the FORMAT command changed as well, defaulting to a double-sided format
     * operation UNLESS you specified "FORMAT /1".  If I run PC-DOS 1.10 and try to simulate a single-sided drive
     * (by setting drive.nHeads = 1 in initDrive), FORMAT will balk with "Track 0 bad - disk unusable".  I have to
     * wonder if everyone with single-sided drives who upgraded to PC-DOS 1.10 also got that error, forcing them
     * to always specify "FORMAT /1", or if I'm doing something wrong wrt single-sided drive simulation.
     *
     * I've noticed that if I turn FDC messages on ("m fdc on"), and then run "FORMAT B:/1", the command still
     * tries to format head 1/track 0, followed by head 0/track 0, and then the FDC is reset, and the format operation
     * proceeds with only head 0 for all tracks 0 through 39.  FORMAT successfully creates a 160Kb single-sided diskette,
     * but why it also tries to initially format track 0 using the second head remains a bit of a mystery.
     *
     * @this {FDC}
     * @param {Object} parmsFDC
     */
    constructor(parmsFDC)
    {
        /*
         * TODO: Indicate the type of diskette image being loaded (this might help folks understand what's going
         * on when they try to load a diskette image that's larger than what the selected operating system supports).
         */
        super("FDC", parmsFDC, Messages.FDC);

        this['dmaRead'] = FDC.prototype.doDMARead;
        this['dmaWrite'] = FDC.prototype.doDMAWrite;
        this['dmaFormat'] = FDC.prototype.doDMAFormat;

        /*
         * We record any 'autoMount' object now, but we no longer parse it until initBus(), because the Computer's
         * getMachineParm() service may have an override for us.
         */
        this.configMount = this.parseConfig(parmsFDC['autoMount']);

        /*
         * This establishes "name" as the default; if we decide we'd prefer "none" to be the default (ie, the order
         * to use when no sortBy value is specified), we can just drop the '|| "name"', because an undefined value is
         * just as falsey as null.
         *
         * The code that actually performs the sorting (in setBinding()) first checks that sortBy is not falsey, and
         * then assumes that the non-falsey value must be either "path" or "name", and since it explicitly checks for
         * "path" first, any non-sensical value will be treated as "name" (which is fine, since that's our current default).
         */
        this.sortBy = parmsFDC['sortBy'] || "name";
        if (this.sortBy == "none") this.sortBy = null;

        /*
         * The following array keeps track of every disk image we've ever mounted.  Each entry in the
         * array is another array whose elements are:
         *
         *      [0]: name of disk
         *      [1]: path of disk
         *      [2]: array of deltas, uninitialized until the disk is unmounted and/or all state is saved
         *
         * See functions addDiskHistory() and updateDiskHistory().
         */
        this.aDiskHistory = [];

        /*
         * Support for local disk images is currently limited to desktop browsers with FileReader support;
         * when this flag is set, setBinding() allows local disk bindings and informs initBus() to update the
         * "listDisks" binding accordingly.
         */
        this.fLocalDisks = (!Web.isMobile() && window && 'FileReader' in window);

        /*
         * The remainder of FDC initialization now takes place in our initBus() handler, largely because we
         * want initController() to have access to the ChipSet component, so that it can query switches and/or CMOS
         * settings that determine the number of drives and their characteristics (eg, 40-track vs. 80-track),
         * which it can then pass on to initDrive().
         */
        this.fAutoScroll = false;
        this['exports'] = {
            'loadDisk':     this.loadSelectedDisk,
            'wait':         this.waitDrives
        };
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {FDC}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "listDisks")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let fdc = this;
        /*
         * TODO: Making copies of control that are simply cast to different types seems silly, but it doesn't
         * really cost anything and it's cleaner than doing a lot MORE type overrides inline.  However, it still
         * doesn't solve all my problems: controlForm should really be cast as HTMLFormElement, but JavaScript
         * inspections refuse to believe there's an 'onsubmit' property on an HTMLFormElement that I can override.
         */
        let controlForm = /** @type {Object} */ (control);
        let controlSelect = /** @type {HTMLSelectElement} */ (control);

        switch (sBinding) {

        case "listDisks":
            this.bindings[sBinding] = controlSelect;
            /*
             * Since binding is a one-time initialization operation, it's also the perfect time to
             * perform whatever sorting (if any) is indicated by the FDC component's "sortBy" property.
             *
             * And since setBinding() is called before initBus(), that means any "special" disk entries
             * will be added after the sorting, so we won't be "burying" those entries somewhere in the
             * middle.
             */
            if (this.sortBy) {
                let i, aOptions = [];
                /*
                 * NOTE: All this monkeying around with copying the elements from control.options to aOptions
                 * and then back again is necessary because control.options isn't a *real* Array (at least not
                 * in all browsers); consequently, it may have no sort() method.  It has a length property,
                 * along with numeric properties 0 to length-1, but it's still probably just an Object, not
                 * an Array.
                 *
                 * Also note that changing the order of the control's options would ordinarily mean that the
                 * control's selectedIndex may now be incorrect, but in our case, it doesn't matter, because
                 * we have a special function, displayDiskette(), that will be called at LEAST once during
                 * initialization, ensuring that selectedIndex is set correctly.
                 */
                for (i = 0; i < controlSelect.options.length; i++)  {
                    aOptions.push(controlSelect.options[i]);
                }
                aOptions.sort(function(a, b) {
                    /*
                     * I've switched to localeCompare() because it offers case-insensitivity by default;
                     * I'm still a little concerned that we could somehow end up with list elements whose text
                     * and/or value properties are undefined (because calling a method on an undefined variable
                     * will throw an exception), but maybe I'm being overly paranoid....
                     */
                    if (fdc.sortBy != "path") {
                        return a.text.localeCompare(b.text);
                    } else {
                        return a.value.localeCompare(b.value);
                    }
                });
                for (i = 0; i < aOptions.length; i++)  {
                    try {
                        /*
                         * TODO: Determine why this line blows up in IE8; are the properties of an options object not settable in IE8?
                         */
                        controlSelect.options[i] = aOptions[i];
                    } catch(e) {
                        break;
                    }
                }
            }
            controlSelect.onchange = function onChangeListDisks(event) {
                fdc.updateSelectedDiskette();
            };
            return true;

        case "descDisk":
        case "listDrives":
            this.bindings[sBinding] = controlSelect;
            /*
             * I tried going with onclick instead of onchange, so that if you wanted to confirm what's
             * loaded in a particular drive, you could click the drive control without having to change it.
             * However, that doesn't seem to work for all browsers, so I've reverted to onchange.
             */
            controlSelect.onchange = function onChangeListDrives(event) {
                let iDrive = Str.parseInt(controlSelect.value, 10);
                if (iDrive != null) fdc.displayDiskette(iDrive);
            };
            return true;

        case "loadDisk":
            this.bindings[sBinding] = control;
            control.onclick = function onClickLoadDisk(event) {
                fdc.loadSelectedDisk();
            };
            return true;

        case "saveDisk":
            /*
             * Yes, technically, this feature does not require "Local disk support" (which is really a reference
             * to FileReader support), but since fLocalDisks is also false for all mobile devices, and since there
             * is an "orthogonality" to disabling both features in tandem, let's just let it slide, OK?
             */
            if (!this.fLocalDisks) {
                if (DEBUG) this.log("Local disk support not available");
                /*
                 * We could also simply hide the control; eg:
                 *
                 *      control.style.display = "none";
                 *
                 * but removing the control altogether seems better.
                 */
                control.parentNode.removeChild(/** @type {Node} */ (control));
                return false;
            }
            this.bindings[sBinding] = control;
            control.onclick = function onClickSaveDisk(event) {
                let controlDrives = fdc.bindings["listDrives"];
                if (controlDrives && controlDrives.options && fdc.aDrives) {
                    let iDriveSelected = Str.parseInt(controlDrives.value, 10) || 0;
                    let drive = fdc.aDrives[iDriveSelected];
                    if (drive) {
                        /*
                         * Note the similarity (and hence factoring opportunity) between this code and the HDC's
                         * "saveHD*" binding.
                         */
                        let disk = drive.disk;
                        if (disk) {
                            if (DEBUG) fdc.println("saving diskette " + disk.sDiskPath + "...");
                            let sAlert = Web.downloadFile(disk.encodeAsBinary(), "octet-stream", true, disk.sDiskFile.replace(".json", ".img"));
                            Component.alertUser(sAlert);
                        } else {
                            fdc.notice("No diskette loaded in drive.");
                        }
                    } else {
                        fdc.notice("No diskette drive selected.");
                    }
                }
            };
            return true;

        case "mountDisk":
            if (!this.fLocalDisks) {
                if (DEBUG) this.log("Local disk support not available");
                /*
                 * We could also simply hide the control; eg:
                 *
                 *      controlForm.style.display = "none";
                 *
                 * but removing the control altogether seems better.
                 */
                controlForm.parentNode.removeChild(/** @type {Node} */ (controlForm));
                return false;
            }
            this.bindings[sBinding] = controlForm;
            /*
             * Enable "Mount" button only if a file is actually selected
             */
            controlForm.onchange = function onChangeMountDisk() {
                let fieldset = controlForm.children[0];
                let files = fieldset.children[0].files;
                let submit = fieldset.children[1];
                submit.disabled = !files.length;
            };
            controlForm.onsubmit = function onSubmitMountDisk(event) {
                let file = event.currentTarget[1].files[0];
                if (file) {
                    let sDiskettePath = file.name;
                    let sDisketteName = Str.getBaseName(sDiskettePath, true);
                    fdc.loadSelectedDrive(sDisketteName, sDiskettePath, file);
                }
                /*
                 * Prevent reloading of web page after form submission
                 */
                return false;
            };
            return true;

        default:
            break;
        }
        return false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {FDC}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.cmp = cmp;

        this.chipset = cmp.getMachineComponent("ChipSet");
        this.parseConfig(this.cmp.getMachineParm('autoMount'), this.configMount);

        this.panel = cmp.getMachineComponent("Panel");

        /*
         * If we didn't need auto-mount support, we could defer controller initialization until we received a powerUp() notification,
         * at which point reset() would call initController(), or restore() would restore the controller; in that case, all we'd need
         * to do here is call setReady().
         */
        this.initController();

        bus.addPortInputTable(this, FDC.aPortInput);
        bus.addPortOutputTable(this, FDC.aPortOutput);

        this.addDiskette("None", "", true);
        if (this.fLocalDisks) this.addDiskette("Local Disk", "?");
        this.addDiskette("Remote Disk", "??");

        if (!this.autoMount()) this.setReady();
    }

    /**
     * setLED(color)
     *
     * @this {FDC}
     * @param {string} [color]
     */
    setLED(color)
    {
        if (this.panel) {
            this.panel.setLED("fdcState", color);
        }
    }

    /**
     * parseConfig(config, configMerge)
     *
     * @this {FDC}
     * @param {Object|string|undefined} config
     * @param {Object} [configMerge]
     * @return {Object}
     */
    parseConfig(config, configMerge)
    {
        if (config) {
            if (typeof config == "string") {
                try {
                    /*
                     * We must take care when parsing user-supplied JSON-encoded diskette data.
                     */
                    config = /** @type {Object} */ (eval("(" + config + ")"));
                } catch (e) {
                    Component.error("FDC auto-mount error: " + e.message + " (" + config + ")");
                    config = {};
                }
            }
        } else {
            config = {};
        }
        for (let sDrive in config) {
            if (configMerge) configMerge[sDrive] = config[sDrive];
        }
        return config;
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {FDC}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data) {
                this.reset();
                if (this.cmp.fReload) {
                    /*
                     * If the computer's fReload flag is set, we're required to toss all currently
                     * loaded disks and remount all disks specified in the auto-mount configuration.
                     */
                    this.unloadAllDrives(true);
                    this.autoMount(true);
                }
            } else {
                if (!this.restore(data)) return false;
            }
            /*
             * Populate the HTML controls to match the actual (well, um, specified) number of floppy drives.
             */
            let controlDrives;
            if ((controlDrives = this.bindings['listDrives'])) {
                while (controlDrives.firstChild) {
                    controlDrives.removeChild(controlDrives.firstChild);
                }
                controlDrives.value = "";
                for (let iDrive = 0; iDrive < this.nDrives; iDrive++) {
                    let controlOption = document.createElement("option");
                    controlOption.value = iDrive.toString();
                    /*
                     * TODO: This conversion of drive number to drive letter, starting with A:, is very simplistic
                     * and will NOT match the drive mappings that DOS ultimately uses.  We'll need to spiff this up at
                     * some point.
                     */
                    controlOption.text = String.fromCharCode(0x41 + iDrive) + ":";
                    controlDrives.appendChild(controlOption);
                }
                if (this.nDrives > 0) {
                    controlDrives.value = "0";
                    this.displayDiskette(0);
                }
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {FDC}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * NOTE: initController() establishes the maximum possible number of drives, but it's not until
     * we interrogate the current SW1 settings that we will have an ACTUAL number of drives (nDrives),
     * at which point we can also update the contents of the "listDrives" HTML control, if any.
     *
     * @this {FDC}
     */
    reset()
    {
        /*
         * NOTE: The controller is also initialized by the constructor, to assist with auto-mount support,
         * so think about whether we can skip powerUp initialization.
         */
        this.initController();
    }

    /**
     * save()
     *
     * This implements save support for the FDC component.
     *
     * @this {FDC}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveController());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the FDC component.
     *
     * @this {FDC}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initController(data[0]);
    }

    /**
     * initController(data)
     *
     * @this {FDC}
     * @param {Array} [data]
     * @return {boolean} true if successful, false if failure
     */
    initController(data)
    {
        let i = 0, iDrive;
        let fSuccess = true;

        if (!data) {
            data = [0, 0, FDC.REG_STATUS.RQM, new Array(9), 0, 0, 0, []];
        }

        /*
         * Selected drive (from regOutput), which can only be selected if its motor is on (see regOutput).
         */
        this.iDrive = data[i++];
        i++;                        // unused slot (if reused, bias by +4, since it was formerly a unit #)

        /*
         * Defaults to FDC.REG_STATUS.RQM set (ready for command) and FDC.REG_STATUS.READ_DATA clear (data direction
         * is from processor to the FDC Data Register).
         */
        this.regStatus = data[i++];

        /*
         * There can be up to 9 command bytes, and 7 result bytes, so 9 data registers are sufficient for communicating
         * in both directions (hence, the new Array(9) default above).
         */
        this.regDataArray = data[i++];

        /*
         * Determines the next data byte to be received.
         */
        this.regDataIndex = data[i++];

        /*
         * Determines the next data byte to be sent (internally, we use regDataIndex to read data bytes, up to this total).
         */
        this.regDataTotal = data[i++];
        this.regOutput = data[i++];
        let dataDrives = data[i++];

        /*
         * Initialize the disk history (if available) before initializing the drives, so that any disk deltas can be
         * applied to disk images that are already loaded.
         */
        let aDiskHistory = data[i++];
        if (aDiskHistory != null) this.aDiskHistory = aDiskHistory;

        if (this.aDrives === undefined) {
            this.nDrives = 4;                       // default to the maximum number of drives
            if (this.chipset) this.nDrives = this.chipset.getDIPFloppyDrives();
            /*
             * I would prefer to allocate only nDrives, but as discussed in the handling of the FDC.REG_DATA.CMD.SENSE_INT
             * command, we're faced with situations where the controller must respond to any drive in the range 0-3, regardless
             * how many drives are actually installed.  We still rely upon nDrives to determine the number of drives displayed
             * to the user, however.
             */
            this.aDrives = new Array(4);
        }

        for (iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let drive = this.aDrives[iDrive];
            if (drive === undefined) {
                /*
                 * The first time each drive is initialized, we query its capacity (based on switches or CMOS) and set
                 * the drive's physical limits accordingly (ie, max tracks, max heads, and max sectors/track).
                 */
                drive = this.aDrives[iDrive] = {};
                let nKb = (this.chipset? this.chipset.getDIPFloppyDriveSize(iDrive) : 0);
                switch(nKb) {
                case 160:
                case 180:
                    drive.nHeads = 1;       // required for single-sided drives only (all others default to double-sided)
                    /* falls through */
                case 320:
                case 360:
                    /* falls through */
                default:                    // drives that don't have a recognized capacity default to 360
                    drive.nCylinders = 40;
                    drive.nSectors = 9;     // drives capable of writing 8 sectors/track can also write 9 sectors/track
                    break;
                case 720:
                    drive.nCylinders = 80;
                    drive.nSectors = 9;
                    break;
                case 1200:
                    drive.nCylinders = 80;
                    drive.nSectors = 15;
                    break;
                case 1440:
                    drive.nCylinders = 80;
                    drive.nSectors = 18;
                    break;
                }
            }
            if (!this.initDrive(drive, iDrive, dataDrives[iDrive])) {
                fSuccess = false;
            }
        }

        /*
         * regInput and regControl (port 0x3F7) were not present on controllers prior to MODEL_5170, which is why
         * we don't include initializers for them in the default data array; we could eliminate them on older models,
         * but we don't have access to the model info right now, and there's no real cost to always including them
         * in the FDC state.
         *
         * The bigger compatibility question is whether to always include hooks for them (see aPortInput and aPortOutput).
         */
        this.regInput = data[i++] || 0;                             // TODO: Determine if we should default to FDC.REG_INPUT.DISK_CHANGE instead of 0
        this.regControl = data[i] || FDC.REG_CONTROL.RATE500K;      // default to maximum data rate

        if (DEBUG && this.messageEnabled()) {
            this.printMessage("FDC initialized for " + this.aDrives.length + " drive(s)");
        }
        return fSuccess;
    }

    /**
     * saveController()
     *
     * @this {FDC}
     * @return {Array}
     */
    saveController()
    {
        let i = 0;
        let data = [];
        data[i++] = this.iDrive;
        data[i++] = 0;
        data[i++] = this.regStatus;
        data[i++] = this.regDataArray;
        data[i++] = this.regDataIndex;
        data[i++] = this.regDataTotal;
        data[i++] = this.regOutput;
        data[i++] = this.saveDrives();
        data[i++] = this.saveDeltas();
        data[i++] = this.regInput;
        data[i] = this.regControl;
        return data;
    }

    /**
     * initDrive(drive, iDrive, data)
     *
     * TODO: Consider a separate Drive class that both FDC and HDC can use, since there's a lot of commonality
     * between the drive objects created by both controllers.  This will clean up overall drive management and allow
     * us to factor out some common Drive methods (eg, advanceSector()).
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} iDrive
     * @param {Array|undefined} data
     * @return {boolean} true if successful, false if failure
     */
    initDrive(drive, iDrive, data)
    {
        let i = 0;
        let fSuccess = true;

        drive.iDrive = iDrive;
        drive.fBusy = drive.fLocal = false;
        drive.fnCallReady = null;

        if (data === undefined) {
            /*
             * We set a default of two heads (MODEL_5150 PCs originally shipped with single-sided drives,
             * but the ROM BIOS appears to have always supported both drive types).
             */
            data = [FDC.REG_DATA.RES.RESET, true, 0, 2, 0];
        }

        if (typeof data[1] == "boolean") {
            /*
             * Note that when no data is provided (eg, when the controller is being reinitialized), we now take
             * care to preserve any drive defaults that initController() already obtained for us, falling back to
             * bare minimums only when all else fails.
             */
            data[1] = [
                FDC.DEFAULT_DRIVE_NAME, // a[0]
                drive.nCylinders || 40, // a[1]
                drive.nHeads || data[3],// a[2]
                drive.nSectors || 9,    // a[3]
                drive.cbSector || 512,  // a[4]
                data[1],                // a[5]
                drive.nDiskCylinders,   // a[6]
                drive.nDiskHeads,       // a[7]
                drive.nDiskSectors      // a[8]
            ];
        }

        /*
         * resCode used to be an FDC global, but in order to insulate FDC state from the operation of various functions
         * that operate on drive objects (eg, readData and writeData), I've made it a per-drive variable.  This choice,
         * similar to my choice for handling PCN, may be contrary to how the actual hardware works, but I prefer this
         * approach, as long as it doesn't expose any incompatibilities that any software actually cares about.
         */
        drive.resCode = data[i++];

        /*
         * Some additional drive properties/defaults that are largely for the Disk component's benefit.
         */
        let a = data[i++];
        drive.name = a[0];
        drive.nCylinders = a[1];          // cylinders
        drive.nHeads = a[2];              // heads/cylinders
        drive.nSectors = a[3];            // sectors/track
        drive.cbSector = a[4];            // bytes/sector
        drive.fRemovable = a[5];
        /*
         * If we have current media parameters, restore them; otherwise, default to the drive's physical parameters.
         */
        if (drive.nDiskCylinders = a[6]) {
            drive.nDiskHeads = a[7];
            drive.nDiskSectors = a[8];
        } else {
            drive.nDiskCylinders = drive.nCylinders;
            drive.nDiskHeads = drive.nHeads;
            drive.nDiskSectors = drive.nSectors;
        }

        /*
         * The next group of properties are set by various FDC command sequences.
         *
         * We initialize this.iDrive (above) and drive.bHead and drive.bCylinder (below) to zero, but leave the rest undefined,
         * awaiting their first FDC command.  We do this because the initial SENSE_INT command returns a PCN, which will also
         * be undefined unless we have at least zeroed both the current drive and the "present" cylinder on that drive.
         *
         * Alternatively, I could make PCN a global FDC variable.  That may be closer to how the actual hardware operates,
         * but I'm using per-drive variables so that the FDC component can be a good client to both the CPU and other components.
         *
         * COMPATIBILITY ALERT: The MODEL_5170 BIOS ("DSKETTE_SETUP") attempts to discern the drive type (double-density vs.
         * high-capacity) by "slapping" the heads around -- "litrally" (it uses a constant named "TRK_SLAP" equal to 48).
         * After seeking to "TRK_SLAP", the BIOS performs a series of seeks, looking for the precise point where the heads
         * return to track 0.
         *
         * Here's how it works: the BIOS seeks to track 48 (which is fine on an 80-track 1.2Mb high-capacity drive, but 9 tracks
         * too far on a 40-track 360Kb double-density drive), then seeks to track 10, and then seeks in single-track increments
         * up to 10 more times until the SENSE_DRIVE command returns ST3 with the TRACK0 bit set.
         *
         * This implies that SEEK isn't really seeking to a specified cylinder, but rather it is calculating a delta from
         * the previous cylinder to the specified cylinder, and stepping over that number of tracks.  Which means that SEEK
         * is updating a "logical" cylinder number, not the "physical" (actual) cylinder number.  Presumably a RECALIBRATE
         * command will bring the logical and physical values into sync, but once an out-of-bounds cylinder is requested, they
         * will be out of sync.
         *
         * To simulate this, bCylinder is now treated as the "physical" cylinder (since that's how it's ALWAYS been used here),
         * and bCylinderSeek will now track (pun intended) the "logical" cylinder that's programmed via SEEK commands.
         */
        drive.bHead = data[i++];
        drive.bCylinderSeek = data[i++];        // the data[] slot where we used to store drive.nHeads (or -1)
        drive.bCylinder = data[i++];
        if (drive.bCylinderSeek >= 100) {       // verify that the saved bCylinderSeek is valid, otherwise sync it with bCylinder
            drive.bCylinderSeek -= 100;
        } else {
            drive.bCylinderSeek -= drive.bCylinder;
        }
        drive.bSector = data[i++];
        drive.bSectorEnd = data[i++];           // aka EOT
        drive.nBytes = data[i++];

        /*
         * We no longer reinitialize drive.disk, in order to retain previously mounted diskette across resets.
         */

        /*
         * The next group of properties are managed by worker functions (eg, doRead()) to maintain state across DMA requests.
         */
        drive.ibSector = data[i++];             // location of the next byte to be accessed in the current sector
        drive.sector = null;

        if (!drive.disk) {
            drive.sDiskettePath = "";           // ensure this is initialized to a default that displayDiskette() can deal with
        }

        let deltas = data[i++];
        if (deltas == 102) deltas = false;      // v1.02 backward-compatibility

        if (typeof deltas == "boolean") {
            let fLocal = deltas;
            let sDisketteName = data[i++];
            let sDiskettePath = data[i];
            /*
             * If we're restoring a local disk image, then the entire disk contents should be captured in aDiskHistory,
             * so all we have to do is mount a blank diskette and let disk.restore() do the rest; ie, there's nothing to
             * "load" (it's a purely synchronous operation).
             *
             * Otherwise, we must call loadDrive(); in the common case, loadDrive() will have already "auto-mounted"
             * the diskette, so it will return true, and then we restore any deltas to the current image.
             *
             * However, if loadDrive() returns false, then it has initiated the load for a *different* disk image,
             * so we must mark ourselves as "not ready" again, and add another "wait for ready" test in Computer before
             * finally powering the CPU.
             */
            if (fLocal) {
                this.mountDrive(iDrive, sDisketteName, sDiskettePath);
            }
            else if (this.loadDrive(iDrive, sDisketteName, sDiskettePath, true)) {
                if (drive.disk) {
                    if (sDiskettePath) {
                        this.addDiskHistory(sDisketteName, sDiskettePath, drive.disk);
                    } else {
                        if (MAXDEBUG) Component.warning("Disk '" + (drive.disk.sDiskName || sDisketteName) + "' not recorded properly in drive " + iDrive);
                    }
                }
            } else {
                this.setReady(false);
            }
        } else if (deltas !== undefined) {
            /*
             * If there's any data at all (ie, if this is a restore and not a reset), then it must be in the
             * pre-v1.02 save/restore format, so we'll restore as best we can, but be aware that if disk.restore()
             * notices that the currently mounted disk image differs from the disk image that these deltas belong to,
             * it will return false, and the restore operation will be aborted.
             */
            if (drive.disk && drive.disk.restore(deltas) < 0) {
                fSuccess = false;
            }
        }

        /*
         * TODO: If loadDrive() returned true, then this can happen immediately.  Otherwise, loadDrive()
         * will have merely "queued up" the load request and drive.disk won't be ready yet, so figure out how/when
         * we can properly restore drive.sector in that case.
         */
        if (fSuccess && drive.disk && drive.ibSector !== undefined) {
            drive.sector = drive.disk.seek(drive.bCylinder, drive.bHead, drive.bSector);
        }
        return fSuccess;
    }

    /**
     * saveDrives()
     *
     * @this {FDC}
     * @return {Array}
     */
    saveDrives()
    {
        let i = 0;
        let data = [];
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            data[i++] = this.saveDrive(this.aDrives[iDrive]);
        }
        return data;
    }

    /**
     * saveDrive(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     * @return {Array}
     */
    saveDrive(drive)
    {
        let i = 0;
        let data = [];
        data[i++] = drive.resCode;
        data[i++] = [drive.name, drive.nCylinders, drive.nHeads, drive.nSectors, drive.cbSector, drive.fRemovable, drive.nDiskCylinders, drive.nDiskHeads, drive.nDiskSectors];
        data[i++] = drive.bHead;
        /*
         * We used to store drive.nHeads in the next slot, but now we store bCylinderSeek,
         * and we bias it by +100 so that initDrive() can distinguish it from older values.
         */
        data[i++] = drive.bCylinderSeek + 100;
        data[i++] = drive.bCylinder;
        data[i++] = drive.bSector;
        data[i++] = drive.bSectorEnd;
        data[i++] = drive.nBytes;
        data[i++] = drive.ibSector;
        /*
         * Now we deviate from the 1.01a save format: instead of next storing all the deltas for the
         * currently mounted disk (if any), we store only the name and path of the currently mounted disk
         * (if any).  Deltas for ALL disks, both currently mounted and previously mounted, are stored later.
         *
         *      data[i++] = drive.disk? drive.disk.save() : null;
         *
         * To indicate this deviation, we store neither a null nor a delta array, but a boolean (fLocal);
         * if that boolean is not present, then the restore code will know it's dealing with a pre-v1.02 state.
         */
        data[i++] = drive.fLocal;
        data[i++] = drive.sDisketteName;
        data[i] = drive.sDiskettePath;
        if (DEBUG && !drive.sDiskettePath && drive.disk && drive.disk.sDiskPath) {
            Component.warning("Disk '" + drive.disk.sDiskName + "' not saved properly in drive " + drive.iDrive);
        }
        return data;
    }

    /**
     * saveDeltas()
     *
     * This returns an array of entries, one for each disk image we've ever mounted, including any deltas; ie:
     *
     *      [name, path, deltas]
     *
     * aDiskHistory contains exactly that, except that deltas may not be up-to-date for any currently mounted
     * disk image(s), so we call updateHistory() for all those disks, and then aDiskHistory is ready to be saved.
     *
     * @this {FDC}
     * @return {Array}
     */
    saveDeltas()
    {
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let drive = this.aDrives[iDrive];
            if (drive.disk) {
                this.updateDiskHistory(drive.sDisketteName, drive.sDiskettePath, drive.disk);
            }
        }
        return this.aDiskHistory;
    }

    /**
     * copyDrive(iDrive)
     *
     * @this {FDC}
     * @param {number} iDrive
     * @return {Object|undefined} drive (which may be undefined if the requested drive does not exist)
     */
    copyDrive(iDrive)
    {
        let driveNew;
        let driveOld = this.aDrives[iDrive];
        if (driveOld !== undefined) {
            driveNew = {};
            for (let p in driveOld) {
                driveNew[p] = driveOld[p];
            }
        }
        return driveNew;
    }

    /**
     * seekDrive(drive, iSector, nSectors)
     *
     * The FDC doesn't need this function, since all FDC requests from the CPU are handled by doCmd().  This function
     * is used by other components (eg, Debugger) to mimic an FDC request, using a drive object obtained from copyDrive(),
     * to avoid disturbing the internal state of the FDC's drive objects.
     *
     * Also note that in an actual FDC request, drive.nBytes is initialized to the size of a single sector; the extent
     * of the entire transfer is actually determined by a count that has been pre-loaded into the DMA controller.  The FDC
     * isn't even aware of the extent of the transfer, so in the case of a read request, all readData() can do is return
     * bytes until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * Since seekDrive() is for use with non-DMA requests, we use nBytes to specify the length of the entire transfer.
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} iSector (a "logical" sector number, relative to the entire disk, NOT a physical sector number)
     * @param {number} nSectors
     * @return {boolean} true if successful, false if invalid position request
     */
    seekDrive(drive, iSector, nSectors)
    {
        if (drive.disk) {
            let aDiskInfo = drive.disk.info();
            let nCylinders = aDiskInfo[0];
            let nHeads = aDiskInfo[1];
            let nSectorsPerTrack = aDiskInfo[2];
            let nSectorsPerCylinder = nHeads * nSectorsPerTrack;
            let nSectorsPerDisk = nCylinders * nSectorsPerCylinder;
            if (iSector + nSectors <= nSectorsPerDisk) {
                drive.bCylinder = Math.floor(iSector / nSectorsPerCylinder);
                iSector %= nSectorsPerCylinder;
                drive.bHead = Math.floor(iSector / nSectorsPerTrack);
                drive.bSector = (iSector % nSectorsPerTrack) + 1;
                drive.nBytes = nSectors * aDiskInfo[3];
                /*
                 * NOTE: We don't set bSectorEnd, as an FDC command would, but it's irrelevant, because we don't actually
                 * do anything with bSectorEnd at this point.  Perhaps someday, when we faithfully honor/restrict requests
                 * to a single track (or a single cylinder, in the case of multi-track requests).
                 */
                drive.resCode = FDC.REG_DATA.RES.NONE;
                /*
                 * At this point, we've finished simulating what an FDC.REG_DATA.CMD.READ_DATA command would have performed,
                 * up through doRead().  Now it's the caller responsibility to call readData(), just like the DMA Controller would.
                 */
                return true;
            }
        }
        return false;
    }

    /**
     * autoMount(fRemount)
     *
     * @this {FDC}
     * @param {boolean} [fRemount] is true if we're remounting all auto-mounted diskettes
     * @return {boolean} true if one or more diskette images are being auto-mounted, false if none
     */
    autoMount(fRemount)
    {
        if (!fRemount) this.cAutoMount = 0;
        for (let sDrive in this.configMount) {
            let configDrive = this.configMount[sDrive];
            let sDiskettePath = configDrive['path'] || this.findDisketteByName(configDrive['name']);
            if (sDiskettePath) {
                /*
                 * WARNING: This conversion of drive letter to drive number, starting with A:, is very simplistic
                 * and is not guaranteed to match the drive mapping that DOS ultimately uses.
                 */
                let iDrive = sDrive.charCodeAt(0) - 0x41;
                if (iDrive >= 0 && iDrive < this.aDrives.length) {
                    let sDisketteName = configDrive['name'] || this.findDisketteByPath(sDiskettePath) || Str.getBaseName(sDiskettePath, true);
                    if (!this.loadDrive(iDrive, sDisketteName, sDiskettePath, true) && fRemount) {
                        this.setReady(false);
                    }
                    continue;
                }
                this.notice("Incorrect auto-mount settings for drive " + sDrive + " (" + JSON.stringify(configDrive) + ")");
            }
        }
        return !!this.cAutoMount;
    }

    /**
     * loadSelectedDisk(...args)
     *
     * NOTE: Since this can be called via script command (eg, 'loadDisk FDC'), additional parameters can be
     * passed; use the args array to access them if necessary.
     *
     * @this {FDC}
     * @param {...} args
     * @return {boolean}
     */
    loadSelectedDisk(...args)
    {
        let controlDisks = this.bindings["listDisks"];
        if (controlDisks) {
            let sDisketteName = controlDisks.options[controlDisks.selectedIndex].text;
            let sDiskettePath = controlDisks.value;
            this.fAutoScroll = (args[0] == "scroll");
            return this.loadSelectedDrive(sDisketteName, sDiskettePath);
        }
        return false;
    }

    /**
     * loadSelectedDrive(sDisketteName, sDiskettePath, file)
     *
     * @this {FDC}
     * @param {string} sDisketteName
     * @param {string} sDiskettePath
     * @param {File} [file] is set if there's an associated File object
     * @return {boolean}
     */
    loadSelectedDrive(sDisketteName, sDiskettePath, file)
    {
        let iDrive;
        let controlDrives = this.bindings["listDrives"];
        if (controlDrives && !isNaN(iDrive = Str.parseInt(controlDrives.value, 10)) && iDrive >= 0 && iDrive < this.aDrives.length) {

            if (!sDiskettePath) {
                this.unloadDrive(iDrive);
                return true;
            }

            if (sDiskettePath == "?") {
                this.notice('Use "Choose File" and "Mount" to select and load a local disk.');
                return false;
            }

            /*
             * If the special path of "??" is selected, then we want to prompt the user for a URL.  Oh, and
             * make sure we pass an empty string as the 2nd parameter to prompt(), so that IE won't display
             * "undefined" -- because after all, undefined and "undefined" are EXACTLY the same thing, right?
             *
             * TODO: This is literally all I've done to support remote disk images. There's probably more
             * I should do, like dynamically updating "listDisks" to include new entries, and adding new entries
             * to the save/restore data.
             */
            if (sDiskettePath == "??") {
                sDiskettePath = window.prompt("Enter the URL of a remote disk image.", "") || "";
                if (!sDiskettePath) return false;
                sDisketteName = Str.getBaseName(sDiskettePath);
                if (DEBUG) this.println("Attempting to load " + sDiskettePath + " as \"" + sDisketteName + "\"");
            }

            while (this.loadDrive(iDrive, sDisketteName, sDiskettePath, false, file) < 0) {
                if (!window.confirm("Click OK to reload the original disk and discard any changes.")) {
                    if (DEBUG) this.println("load cancelled");
                    return false;
                }
                /*
                 * So here's the story: loadDrive() returned true, which it does ONLY if the specified disk is already
                 * mounted, AND the user clicked OK to reload the original disk image.  So we must toss any history we have
                 * for the disk, unload it, and then loop back around to loadDrive().
                 *
                 * loadDrive() should NEVER return true the second time, since no disk is loaded. In other words,
                 * this isn't really a loop so much as a one-time retry operation.
                 */
                this.removeDiskHistory(sDisketteName, sDiskettePath);
                this.unloadDrive(iDrive, false, true);
            }
            return true;
        }
        this.notice("Unable to load the selected drive");
        return false;
    }

    /**
     * mountDrive(iDrive, sDisketteName, sDiskettePath)
     *
     * @this {FDC}
     * @param {number} iDrive
     * @param {string} sDisketteName
     * @param {string} sDiskettePath
     */
    mountDrive(iDrive, sDisketteName, sDiskettePath)
    {
        let drive = this.aDrives[iDrive];
        this.unloadDrive(iDrive, true, true);
        drive.fLocal = true;
        let disk = new Disk(this, drive, DiskAPI.MODE.PRELOAD);
        this.doneLoadDrive(drive, disk, sDisketteName, sDiskettePath, true);
    }

    /**
     * loadDrive(iDrive, sDisketteName, sDiskettePath, fAutoMount, file)
     *
     * NOTE: If sDiskettePath is already loaded in the drive, nothing needs to be done.
     *
     * @this {FDC}
     * @param {number} iDrive
     * @param {string} sDisketteName
     * @param {string} sDiskettePath
     * @param {boolean} [fAutoMount]
     * @param {File} [file] is set if there's an associated File object
     * @return {number} 1 if diskette loaded, 0 if queued up (or busy), -1 if already loaded
     */
    loadDrive(iDrive, sDisketteName, sDiskettePath, fAutoMount, file)
    {
        let drive = this.aDrives[iDrive];
        if (sDiskettePath) {
            /*
             * The following hacks should only be necessary for (old) saved states, since all our disk manifests
             * should no longer be using any of these old paths.
             */
            sDiskettePath = sDiskettePath.replace("/disks/pc/", "/disks/pcx86/");
            sDiskettePath = sDiskettePath.replace("/disks/pcx86/private/", "/private-disks/pcx86/");
            if (sDiskettePath.indexOf("archive.pcjs.org") < 0 || DEBUG) {
                sDiskettePath = sDiskettePath.replace("/disks/pcx86/", "/pcjs-disks/pcx86/");
            }
            sDiskettePath = sDiskettePath.replace("/pcjs-disks/pcx86/games/", "/pcjs-games/pcx86/");
            /*
             * TODO: Machines with saved states may be using lower-case disk image names, whereas we now use
             * UPPER-CASE names for disk images, so we lower-case both before comparing.  The only problem with
             * removing these hacks is that we can never be sure when all saved states in the wild have been updated.
             */
            if (drive.sDiskettePath.toLowerCase() != sDiskettePath.toLowerCase()) {
                this.unloadDrive(iDrive, fAutoMount, true);
                if (drive.fBusy) {
                    this.notice("Drive " + iDrive + " busy");
                    return 0;
                }
                drive.fBusy = true;
                if (fAutoMount) {
                    drive.fAutoMount = true;
                    this.cAutoMount++;
                    if (this.messageEnabled()) this.printMessage("loading diskette '" + sDisketteName + "'");
                }
                drive.fLocal = !!file;
                let disk = new Disk(this, drive, DiskAPI.MODE.PRELOAD);
                if (!disk.load(sDisketteName, sDiskettePath, file, this.doneLoadDrive)) {
                    return 0;
                }
                return 1;
            }
        }
        return -1;
    }

    /**
     * doneLoadDrive(drive, disk, sDisketteName, sDiskettePath, fAutoMount)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {Disk} disk is set if the disk was successfully loaded, null if not
     * @param {string} sDisketteName
     * @param {string} sDiskettePath
     * @param {boolean} [fAutoMount]
     */
    doneLoadDrive(drive, disk, sDisketteName, sDiskettePath, fAutoMount)
    {
        let aDiskInfo;

        drive.fBusy = false;

        if (disk) {
            /*
             * We shouldn't mount the diskette unless the drive is able to handle it; for example, FD360 (40-track)
             * drives cannot read FD1200 (80-track) diskettes.  However, I no longer require that the diskette's
             * sectors/track fall within the drive's standard maximum, because XDF diskettes use 19 physical sectors/track
             * on the first cylinder (1 more than the typical 18 sectors/track found on 1.44Mb diskettes) but declare
             * a larger logical size (23 512-byte sectors/track) to reflect the actual capacity of XDF tracks beyond the
             * first cylinder (ie, one 8Kb sector, one 2Kb sector, one 1Kb sector, and one 512-byte sector).
             */
            aDiskInfo = disk.info();
            if (disk && aDiskInfo[0] > drive.nCylinders || aDiskInfo[1] > drive.nHeads /* || aDiskInfo[2] > drive.nSectors */) {
                this.notice("Diskette \"" + sDisketteName + "\" too large for drive " + String.fromCharCode(0x41 + drive.iDrive));
                disk = null;
            }
        }

        if (disk) {
            drive.disk = disk;
            drive.sDisketteName = sDisketteName;
            drive.sDiskettePath = sDiskettePath;

            /*
             * Since we allow a diskette image to be auto-mounted even if it isn't in the machine's list of disks,
             * let's add it to the list now, since the disk apparently exists.
             */
            if (!this.findDisketteByPath(sDiskettePath)) {
                this.addDiskette(sDisketteName, sDiskettePath);
            }

            /*
             * Adding local disk image names to the disk list seems like a nice idea, but it's too confusing,
             * because then it looks like the "Mount" button should be able to (re)load them, and that can NEVER
             * happen, for security reasons; local disk images can ONLY be loaded via the "Mount" button after
             * the user has selected them via the "Choose File" button.
             *
             *      this.addDiskette(sDisketteName, sDiskettePath);
             *
             * So we're going to take a different approach: when displayDiskette() is asked to display the name
             * of a local disk image, it will map all such disks to "Local Disk", and any attempt to "Mount" such
             * a disk, will essentially result in a "Disk not found" error.
             */
            this.addDiskHistory(sDisketteName, sDiskettePath, disk);

            /*
             * For a local disk (ie, one loaded via mountDrive()), the disk.restore() performed by addDiskHistory()
             * may have altered the disk geometry, so refresh the disk info.
             */
            aDiskInfo = disk.info();

            /*
             * Clearly, a successful mount implies a disk change, and I suppose that, technically, an *unsuccessful*
             * mount should imply the same, but what would the real-world analog be?  Inserting a piece of cardboard
             * instead of an actual diskette?  In any case, if we can do the user a favor by pretending (as far as the
             * disk change line is concerned) that an unsuccessful mount never happened, let's do it.
             *
             * Successful unmounts are a different story, however; those *do* trigger a change. See unloadDrive().
             */
            this.regInput |= FDC.REG_INPUT.DISK_CHANGE;

            /*
             * With the addition of notify(), users are now "alerted" whenever a diskette has finished loading;
             * notify() is selective about its output, using print() if a print window is open, alert() otherwise.
             *
             * WARNING: This conversion of drive number to drive letter, starting with A:, is very simplistic
             * and will not match the drive mappings that DOS ultimately uses (ie, for drives beyond B:).
             *
             * TODO: Consider adding support for non-modal notices that appear briefly over the machine and then fade,
             * because these modal alerts quickly become annoying.  In the meantime, I now set fPrintOnly to true, on the
             * theory no message is a good sign, while load errors in disk.js should continue to trigger notifications.
             */
            if (!drive.fnCallReady) {
                this.notice("Mounted diskette \"" + sDisketteName + "\" in drive " + String.fromCharCode(0x41 + drive.iDrive), true /* drive.fAutoMount || fAutoMount */);
            }

            /*
             * Update the drive's current media parameters to match the disk's.
             */
            drive.nDiskCylinders = aDiskInfo[0];
            drive.nDiskHeads = aDiskInfo[1];
            drive.nDiskSectors = aDiskInfo[2];

            /*
             * Since you usually want the Computer to have focus again after loading a new diskette, let's try automatically
             * updating the focus after a successful load.
             */
            if (this.cmp) this.cmp.updateFocus(this.fAutoScroll);
        }
        else {
            drive.fLocal = false;
        }

        if (drive.fAutoMount) {
            drive.fAutoMount = false;
            if (!--this.cAutoMount) this.setReady();
        }

        this.displayDiskette(drive.iDrive);

        if (drive.fnCallReady) {
            drive.fnCallReady();
            drive.fnCallReady = null;
        }

        this.fAutoScroll = false;
    }

    /**
     * addDiskette(sName, sPath, fTop)
     *
     * @this {FDC}
     * @param {string} sName
     * @param {string} sPath
     * @param {boolean} [fTop] (default is bottom)
     */
    addDiskette(sName, sPath, fTop)
    {
        let controlDisks = this.bindings["listDisks"];
        if (controlDisks && controlDisks.options) {
            for (let i = 0; i < controlDisks.options.length; i++) {
                if (controlDisks.options[i].value == sPath) return;
            }
            let controlOption = document.createElement("option");
            controlOption.text = sName;
            controlOption.value = sPath;
            if (fTop && controlDisks.childNodes[0]) {
                controlDisks.insertBefore(controlOption, controlDisks.childNodes[0]);
            } else {
                controlDisks.appendChild(controlOption);
            }
        }
    }

    /**
     * findDisketteByPath(sPath)
     *
     * This is used to deal with mount requests (eg, autoMount) that supply a path without a name;
     * if we can find the path in the "listDisks" control, then we return the associated disk name.
     *
     * @this {FDC}
     * @param {string} sPath
     * @return {string|null}
     */
    findDisketteByPath(sPath)
    {
        let controlDisks = this.bindings["listDisks"];
        if (controlDisks && controlDisks.options) {
            for (let i = 0; i < controlDisks.options.length; i++) {
                let control = controlDisks.options[i];
                if (control.value == sPath) return control.text;
            }
        }
        return null;
    }

    /**
     * findDisketteByName(sName)
     *
     * This is used to deal with mount requests (eg, autoMount) that supply a name without a path;
     * if we can find the name in the "listDisks" control, then we return the associated disk path.
     *
     * @this {FDC}
     * @param {string|undefined} sName
     * @return {string}
     */
    findDisketteByName(sName)
    {
        if (sName) {
            let controlDisks = this.bindings["listDisks"];
            if (controlDisks && controlDisks.options) {
                for (let i = 0; i < controlDisks.options.length; i++) {
                    let control = controlDisks.options[i];
                    if (control.text == sName) return control.value;
                }
            }
        }
        return "";
    }

    /**
     * displayDiskette(iDrive, fUpdateDrive)
     *
     * @this {FDC}
     * @param {number} iDrive (unvalidated)
     * @param {boolean} [fUpdateDrive] is true to update the drive list to match the specified drive (eg, the auto-mount case)
     */
    displayDiskette(iDrive, fUpdateDrive)
    {
        /*
         * First things first: validate iDrive.
         */
        if (iDrive >= 0 && iDrive < this.aDrives.length) {
            let drive = this.aDrives[iDrive];
            let controlDisks = this.bindings["listDisks"];
            let controlDrives = this.bindings["listDrives"];
            /*
             * Next, make sure controls for both drives and disks exist.
             */
            if (controlDisks && controlDrives && controlDisks.options && controlDrives.options) {
                /*
                 * Next, make sure the drive whose disk we're updating is the currently selected drive.
                 */
                let i;
                let iDriveSelected = Str.parseInt(controlDrives.value, 10);
                let sTargetPath = (drive.fLocal? "?" : drive.sDiskettePath);
                if (!isNaN(iDriveSelected) && iDriveSelected == iDrive) {
                    for (i = 0; i < controlDisks.options.length; i++) {
                        if (controlDisks.options[i].value == sTargetPath) {
                            if (controlDisks.selectedIndex != i) {
                                controlDisks.selectedIndex = i;
                            }
                            break;
                        }
                    }
                    if (i == controlDisks.options.length) controlDisks.selectedIndex = 0;
                }
                if (fUpdateDrive) {
                    for (i = 0; i < controlDrives.options.length; i++) {
                        if (Str.parseInt(controlDrives.options[i].value, 10) == drive.iDrive) {
                            if (controlDrives.selectedIndex != i) {
                                controlDrives.selectedIndex = i;
                            }
                            break;
                        }
                    }
                }
            }
        }
    }

    /**
     * updateSelectedDiskette()
     *
     * @this {FDC}
     */
    updateSelectedDiskette()
    {
        let control = this.bindings["listDisks"];
        let controlDesc = this.bindings["descDisk"];
        let controlOption = control.options[control.selectedIndex];
        if (controlDesc && controlOption) {
            let dataValue = {};
            let sValue = controlOption.getAttribute("data-value");
            if (sValue) {
                try {
                    dataValue = eval("(" + sValue + ")");
                } catch (e) {
                    Component.error(this.type + " option error: " + e.message);
                }
            }
            let sHTML = dataValue['desc'];
            if (sHTML === undefined) sHTML = "";
            let sHRef = dataValue['href'];
            if (sHRef !== undefined) sHTML = "<a href=\"" + sHRef + "\" target=\"_blank\">" + sHTML + "</a>";
            controlDesc.innerHTML = sHTML;
        }
    }

    /**
     * waitDrives(fnCallReady)
     *
     * @this {FDC}
     * @param {function()|null} fnCallReady
     * @return {boolean} false if wait required, true otherwise
     */
    waitDrives(fnCallReady)
    {
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let drive = this.aDrives[iDrive];
            if (drive && drive.fBusy) {
                if (!drive.fnCallReady) drive.fnCallReady = fnCallReady;
                return false;
            }
        }
        return true;
    }

    /**
     * unloadDrive(iDrive, fAutoUnload, fQuiet)
     *
     * @this {FDC}
     * @param {number} iDrive (pre-validated)
     * @param {boolean} [fAutoUnload] is true if this unload is being forced as part of an automount and/or restored mount
     * @param {boolean} [fQuiet]
     */
    unloadDrive(iDrive, fAutoUnload, fQuiet)
    {
        let drive = this.aDrives[iDrive];
        if (drive.disk) {
            /*
             * Before we toss the disk's information, capture any deltas that may have occurred.
             */
            this.updateDiskHistory(drive.sDisketteName, drive.sDiskettePath, drive.disk);
            drive.sDisketteName = "";
            drive.sDiskettePath = "";
            drive.disk = null;
            drive.fLocal = false;

            this.regInput |= FDC.REG_INPUT.DISK_CHANGE;

            /*
             * WARNING: This conversion of drive number to drive letter, starting with A:, is very simplistic
             * and is not guaranteed to match the drive mapping that DOS ultimately uses.
             *
             * TODO: Consider adding support for non-modal notices that appear briefly over the machine and then fade,
             * because these modal alerts quickly become annoying.  In the meantime, I now set fPrintOnly to true, on the
             * theory no message is a good sign, while load errors in disk.js should continue to trigger notifications.
             */
            if (!fQuiet) {
                this.notice("Drive " + String.fromCharCode(0x41 + iDrive) + " unloaded", true /* fAutoUnload */);
            }
            /*
             * Try to avoid any unnecessary hysteresis regarding the diskette display if this unload is merely
             * a prelude to another load.
             */
            if (!fAutoUnload && !fQuiet) {
                this.displayDiskette(iDrive);
            }
        }
    }

    /**
     * unloadAllDrives(fDiscard)
     *
     * @this {FDC}
     * @param {boolean} fDiscard to discard all disk history before unloading
     */
    unloadAllDrives(fDiscard)
    {
        if (fDiscard) {
            this.aDiskHistory = [];
        }
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            this.unloadDrive(iDrive, true);
        }
    }

    /**
     * addDiskHistory(sDisketteName, sDiskettePath, disk)
     *
     * @this {FDC}
     * @param {string} sDisketteName
     * @param {string} sDiskettePath
     * @param {Disk} disk containing corresponding disk image
     */
    addDiskHistory(sDisketteName, sDiskettePath, disk)
    {
        let i;
        //
        for (i = 0; i < this.aDiskHistory.length; i++) {
            if (this.aDiskHistory[i][1] == sDiskettePath) {
                let nChanges = disk.restore(this.aDiskHistory[i][2]);
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage("disk '" + sDisketteName + "' restored from history (" + nChanges + " changes)");
                }
                return;
            }
        }
        if (DEBUG && this.messageEnabled()) {
            this.printMessage("disk '" + sDisketteName + "' added to history (nothing to restore)");
        }
        this.aDiskHistory[i] = [sDisketteName, sDiskettePath, []];
    }

    /**
     * removeDiskHistory(sDisketteName, sDiskettePath)
     *
     * @this {FDC}
     * @param {string} sDisketteName
     * @param {string} sDiskettePath
     */
    removeDiskHistory(sDisketteName, sDiskettePath)
    {
        let i;
        for (i = 0; i < this.aDiskHistory.length; i++) {
            if (this.aDiskHistory[i][1] == sDiskettePath) {
                this.aDiskHistory.splice(i, 1);
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage("disk '" + sDisketteName + "' removed from history");
                }
                return;
            }
        }
        if (DEBUG && this.messageEnabled()) {
            this.printMessage("unable to remove disk '" + sDisketteName + "' from history (" + sDiskettePath + ")");
        }
    }

    /**
     * updateDiskHistory(sDisketteName, sDiskettePath, disk)
     *
     * @this {FDC}
     * @param {string} sDisketteName
     * @param {string} sDiskettePath
     * @param {Disk} disk containing corresponding disk image, with possible deltas
     */
    updateDiskHistory(sDisketteName, sDiskettePath, disk)
    {
        let i;
        for (i = 0; i < this.aDiskHistory.length; i++) {
            if (this.aDiskHistory[i][1] == sDiskettePath) {
                this.aDiskHistory[i][2] = disk.save();
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage("disk '" + sDisketteName + "' updated in history");
                }
                return;
            }
        }
        /*
         * I used to report this as an error (at least in the DEBUG release), but it's no longer really
         * an error, because if we're trying to re-mount a clean copy of a disk, we toss its history, then
         * unload, and then reload/remount.  And since unloadDrive's normal behavior is to call updateDiskHistory()
         * before unloading, the fact that the disk is no longer listed here can't be treated as an error.
         */
        if (DEBUG && this.messageEnabled()) {
            this.printMessage("unable to update disk '" + sDisketteName + "' in history (" + sDiskettePath + ")");
        }
    }

    /**
     * outFDCOutput(port, bOut, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F2, output only)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outFDCOutput(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "OUTPUT");
        if (!(bOut & FDC.REG_OUTPUT.ENABLE)) {
            this.initController();
            /*
             * initController() resets, among other things, the selected drive (this.iDrive), so if we were
             * still updating this.iDrive below based on the "drive select" bits in regOutput, we would want
             * to make sure those bits now match what initController() set.  But since we no longer do that
             * (see below), this is no longer needed either.
             *
             *      bOut = (bOut & ~FDC.REG_OUTPUT.DS) | this.iDrive;
             */
        }
        else if (!(this.regOutput & FDC.REG_OUTPUT.ENABLE)) {
            /*
             * When FDC.REG_OUTPUT.ENABLE transitions from 0 to 1, generate an interrupt (assuming INT_ENABLE is set).
             */
            this.requestInterrupt();
        }
        /*
         * This no longer updates the internally selected drive (this.iDrive) based on regOutput, because (a) there seems
         * to be no point, as all drive-related commands include their own "drive select" bits, and (b) it breaks the
         * MODEL_5170 boot code.  Here's why:
         *
         * Unlike previous models, the MODEL_5170 BIOS probes all installed diskette drives to determine drive type;
         * ie, FD360 (40-track) or FD1200 (80-track).  So if there are two drives, the last selected drive will be drive 1.
         * Immediately before booting, the BIOS issues an INT 0x13/AH=0 reset, which writes regOutput two times: first
         * with FDC.REG_OUTPUT.ENABLE clear, and then with it set.  However, both times, it ALSO loads the last selected
         * drive number into regOutput's "drive select" bits.
         *
         * If we switched our selected drive to match regOutput, then the ST0 value we returned on an SENSE_INT command
         * following the regOutput reset operation would indicate drive 1 instead of drive 0.  But the BIOS requires
         * the ST0 result from the SENSE_INT command ALWAYS be 0xC0 (not 0xC1), so the controller must not be propagating
         * regOutput's "drive select" bits in the way I originally assumed.
         *
         *      let iDrive = bOut & FDC.REG_OUTPUT.DS;
         *      if (bOut & (FDC.REG_OUTPUT.MOTOR_D0 << iDrive)) this.iDrive = iDrive;
         */
        this.regOutput = bOut;
    }

    /**
     * inFDCDiagnostic(port, addrFrom)
     *
     * It turns out that any 5170 configuration without an HDC component that attempts to use either the REV2 or REV3
     * PC AT ROM BIOS will fail with error "601-Diskette Error", unless we also provide this "D/S/P DIAGNOSTIC REGISTER".
     * The original 5170 REV1 BIOS didn't have this requirement.
     *
     * I'm unable to find any documentation on this so-called "D/S/P DIAGNOSTIC REGISTER" (port 0x3F1) or the "D/S/P CARD"
     * to which the ROM BIOS refers.  But it seems clear that if we don't provide the expected response from the DIAGNOSTIC
     * REGISTER, and there's no HDC to respond to the MULTIPLE DATA RATE CAPABLE test that follows, then an error is
     * inevitable.  Clearly, there is a very intimate relationship between the FDC and HDC portions of this card.
     *
     * Here's the relevant code from the REV3 PC AT ROM BIOS (TEST2.ASM):
     *
     *      ;-----  CHECK FOR MULTIPLE DATA RATE CAPABILITY
     *
     *      J_OK:
     *              MOV     DX,03F1H                ; D/S/P DIAGNOSTIC REGISTER
     *              IN      AL,DX                   ; READ D/S/P TYPE CODE
     *              AND     AL,11111000B            ; KEEP ONLY UNIQUE CODE FOR D/S/P
     *              CMP     AL,01010000B            ; D/S/P CARD - MULTIPLE DATA RATE?
     *              JZ      J_OK3                   ; IF SO JUMP
     *
     *              MOV     DX,05F7H                ; FIXED DISK DIAGNOSTIC REGISTER
     *              IN      AL,DX                   ; READ FIXED DISK TYPE CODE
     *              AND     AL,11110000B            ; KEEP ONLY UNIQUE CODE FOR F/D
     *              CMP     AL,10100000B            ; FIXED DISK ADAPTER ?
     *              JZ      J_FAIL                  ; MUST BE COMBO ELSE ERROR
     *
     *              MOV     BL,0FH                  ; OUTER LOOP COUNT WAIT FOR BUSY OFF
     *              SUB     CX,CX
     *              MOV     DX,01F7H                ; HARD FILE STATUS PORT
     *      J_OK1:
     *              IN      AL,DX                   ; GET THE STATUS
     *              TEST    AL,080H                 ; IS THE CONTROLLER BUSY?
     *              JZ      J_OK2                   ; CONTINUE IF NOT
     *              LOOP    J_OK1                   ; TRY AGAIN
     *              DEC     BL                      ; DECREMENT OUTER LOOP
     *              JNZ     J_OK1                   ; TRY AGAIN IF NOT ZERO
     *              AND     AL,0CH                  ; BITS 2 & 3 = 0 IF MULTI DATA CAPABLE
     *              JZ      J_OK3                   ; GO IF YES
     *              JMP     SHORT J_FAIL            ; NO MULTIPLE DATA RATE CAPABILITY
     *      J_OK2:
     *              MOV     DX,1F4H                 ; VERIFY MULTIPLE DATA RATE CAPABLE
     *              MOV     AL,055H                 ; WRITE TO THE CYLINDER BYTE
     *              OUT     DX,AL
     *              JMP     $+2                     ; I/O DELAY
     *              IN      AL,DX                   ; CHECK DATA WRITTEN = DATA READ
     *              CMP     AL,055H
     *              JNZ     J_FAIL                  ; GO IF NOT
     *              MOV     AL,0AAH                 ; WRITE ANOTHER PATTERN
     *              OUT     DX,AL
     *              JMP     $+2                     ; I/O DELAY
     *              IN      AL,DX
     *              CMP     AL,0AAH                 ; IS DATA PATTERN THE SAME?
     *              JZ      J_OK3                   ; GO IF SO
     *
     *      J_FAIL:
     *              OR      @MFG_ERR_FLAG+1,DSK_FAIL;       <><><><><><><><><><><><><>
     *                                              ;       <><> DISKETTE FAILED  <><>
     *              MOV     SI,OFFSET E601          ; GET ADDRESS OF MESSAGE
     *              CALL    E_MSG                   ; GO PRINT ERROR MESSAGE
     *              JMP     SHORT F15C              ; SKIP SETUP IF ERROR
     *
     *      J_OK3:
     *              OR      @LASTRATE,DUAL          ; TURN ON DSP/COMBO FLAG
     *
     * @this {FDC}
     * @param {number} port (0x3F1, input only)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inFDCDiagnostic(port, addrFrom)
    {
        let b = 0x50;       // we simply return the expected pattern (01010000B); see code excerpt above
        this.printMessageIO(port, undefined, addrFrom, "DIAG", b);
        return b;
    }

    /**
     * inFDCStatus(port, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F4, input only)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inFDCStatus(port, addrFrom)
    {
        this.printMessageIO(port, undefined, addrFrom, "STATUS", this.regStatus);
        return this.regStatus;
    }

    /**
     * inFDCData(port, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F5, input/output)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inFDCData(port, addrFrom)
    {
        let bIn = 0;
        if (this.regDataIndex < this.regDataTotal) {
            bIn = this.regDataArray[this.regDataIndex];
        }
        /*
         * As per the discussion in doCmd(), once the first byte of the Result Phase has been read, the interrupt must be cleared.
         */
        if (this.regOutput & FDC.REG_OUTPUT.INT_ENABLE) {
            if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.FDC);
        }
        if (this.messageEnabled()) {
            this.printMessageIO(port, undefined, addrFrom, "DATA[" + this.regDataIndex + "]", bIn);
        }
        if (++this.regDataIndex >= this.regDataTotal) {
            this.regStatus &= ~(FDC.REG_STATUS.READ_DATA | FDC.REG_STATUS.BUSY);
            this.regDataIndex = this.regDataTotal = 0;
        }
        return bIn;
    }

    /**
     * outFDCData(port, bOut, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F5, input/output)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outFDCData(port, bOut, addrFrom)
    {
        if (this.messageEnabled()) {
            this.printMessageIO(port, bOut, addrFrom, "DATA[" + this.regDataTotal + "]");
        }

        if (this.regDataTotal < this.regDataArray.length) {
            this.regDataArray[this.regDataTotal++] = bOut;
        }
        let bCmd = this.regDataArray[0];
        let bCmdMasked = bCmd & FDC.REG_DATA.CMD.MASK;
        if (FDC.aCmdInfo[bCmdMasked] !== undefined) {
            if (this.regDataTotal >= FDC.aCmdInfo[bCmdMasked].cbReq) {
                this.doCmd();
            }
            return;
        }
        if (DEBUG && this.messageEnabled()) {
            this.printMessage("unsupported FDC command: " + Str.toHexByte(bCmd));
            if (MAXDEBUG) this.dbg.stopCPU();
        }
    }

    /**
     * inFDCInput(port, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F7, input only, MODEL_5170 only)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inFDCInput(port, addrFrom)
    {
        let bIn = this.regInput;
        /*
         * TODO: Determine when the DISK_CHANGE bit is *really* cleared (this is just a guess)
         */
        this.regInput &= ~FDC.REG_INPUT.DISK_CHANGE;
        this.printMessageIO(port, undefined, addrFrom, "INPUT", bIn);
        return bIn;
    }

    /**
     * outFDCControl(port, bOut, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F7, output only, MODEL_5170 only)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outFDCControl(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "CONTROL");
        this.regControl  = bOut;
    }

    /**
     * doCmd()
     *
     * @this {FDC}
     */
    doCmd()
    {
        let fIRQ = false;
        this.regDataIndex = 0;
        let bCmd = this.popCmd();
        let drive, bDrive, bHead, c, h, r, n;

        /*
         * NOTE: We currently ignore the FDC.REG_DATA.CMD.SK, FDC.REG_DATA.CMD.MF and FDC.REG_DATA.CMD.MT bits of every command.
         * The only command bit of possible interest down the road might be the FDC.REG_DATA.CMD.MT (Multi-Track); the rest relate
         * to storage format details that we cannot emulate as long as our diskette images contain nothing more than sector
         * data without any formatting data.
         *
         * Similarly, we ignore parameters like SRT, HUT, HLT and the like, since our "motors" don't require physical delays;
         * however, if timing issues become compatibility issues, we'll have to revisit those delays.  In any case, the maximum
         * speed of the simulation will still be limited by various spin-loops in the ROM BIOS that wait prescribed times, so even
         * with infinitely fast hardware, the simulation will never run as fast as it theoretically could, unless we opt to identify
         * those spin-loops and either patch them or skip over them.
         */
        let ledState;
        let bCmdMasked = bCmd & FDC.REG_DATA.CMD.MASK;

        switch (bCmdMasked) {
        case FDC.REG_DATA.CMD.SPECIFY:                      // 0x03
            this.popSRT();                                  // SRT and HUT (encodings?)
            this.popHLT();                                  // HLT and ND (encodings?)
            this.beginResult();
            /*
             * No results are provided by this command, and fIRQ should remain false
             */
            break;

        case FDC.REG_DATA.CMD.SENSE_DRIVE:                  // 0x04
            bDrive = this.popCmd(FDC.TERMS.DS);
            bHead = (bDrive >> 2) & 0x1;
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            this.beginResult();
            this.pushST3(drive);
            break;

        case FDC.REG_DATA.CMD.WRITE_DATA:                   // 0x05
            ledState = Panel.STATE.WRITE;
            /* fall through */

        case FDC.REG_DATA.CMD.READ_DATA:                    // 0x06
            if (!ledState) ledState = Panel.STATE.READ;
            bDrive = this.popCmd(FDC.TERMS.DS);             // Drive Select
            bHead = (bDrive >> 2) & 0x1;                    // isolate HD (Head Select) bits
            this.iDrive = (bDrive & 0x3);                   // isolate DS (Drive Select, aka Unit Select) bits
            drive = this.aDrives[this.iDrive];
            drive.bHead = bHead;
            c = drive.bCylinder = this.popCmd(FDC.TERMS.C); // C
            h = this.popCmd(FDC.TERMS.H);                   // H
            /*
             * Controller docs say that H should always match HD, so I assert that, but what if someone
             * made a mistake and didn't program them identically -- what would happen?  Which should we honor?
             */

            r = drive.bSector = this.popCmd(FDC.TERMS.R);   // R
            n = this.popCmd(FDC.TERMS.N);                   // N
            drive.nBytes = 128 << n;                        // 0 => 128, 1 => 256, 2 => 512, 3 => 1024
            drive.bSectorEnd = this.popCmd(FDC.TERMS.EOT);  // EOT (final sector number on a cylinder)
            this.popCmd(FDC.TERMS.GPL);                     // GPL (spacing between sectors, excluding VCO Sync Field; 3)
            this.popCmd(FDC.TERMS.DTL);                     // DTL (when N is 0, DTL stands for the data length to read out or write into the sector)
            this.setLED(ledState);
            if (bCmdMasked == FDC.REG_DATA.CMD.READ_DATA)
                this.doRead(drive);
            else
                this.doWrite(drive);
            this.pushResults(drive, bCmd, bHead, c, h, r, n);
            fIRQ = true;
            break;

        case FDC.REG_DATA.CMD.RECALIBRATE:                  // 0x07
            bDrive = this.popCmd(FDC.TERMS.DS);
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            drive.bCylinder = drive.bCylinderSeek = 0;
            drive.resCode = FDC.REG_DATA.RES.SEEK_END | FDC.REG_DATA.RES.TRACK0;
            this.beginResult();                             // no results provided; this command is typically followed by FDC.REG_DATA.CMD.SENSE_INT
            fIRQ = true;
            break;

        case FDC.REG_DATA.CMD.SENSE_INT:                    // 0x08
            drive = this.aDrives[this.iDrive];
            drive.bHead = 0;                                // this command is documented as ALWAYS returning a head address of 0 in ST0; see pushST0()
            this.beginResult();
            this.pushST0(drive);
            this.pushResult(drive.bCylinder, FDC.TERMS.PCN);
            /*
             * For some strange reason, the "DISK_RESET" function in the MODEL_5170_REV3 BIOS resets the
             * adapter and then issues FOUR -- that's right, not ONE but FOUR -- SENSE INTERRUPT STATUS commands
             * in a row, and expects ST0 to contain a different drive number after each command (first 0, then 1,
             * then 2, and finally 3).  What makes this doubly weird is SENSE INTERRUPT STATUS (unlike SENSE
             * DRIVE STATUS) is a drive-agnostic command.
             *
             * Didn't the original PC AT "HFCOMBO" controller limit support to TWO diskette drives max?
             * And even if the PC AT supported other FDC controllers that DID support up to FOUR diskette drives,
             * why should "DISK_RESET" hard-code a 4-drive loop?
             *
             * Well, whatever.  All this head-scratching doesn't change the fact that I apparently have to
             * "auto-increment" the internal drive number (this.iDrive) after each SENSE INTERRUPT STATUS command.
             */
            this.iDrive = (this.iDrive + 1) & 0x3;
            /*
             * No interrupt is generated by this command, so fIRQ should remain false.
             */
            break;

        case FDC.REG_DATA.CMD.READ_ID:                      // 0x0A
            /*
             * This command is used by "SETUP_DBL" in the MODEL_5170_REV3 BIOS to determine if a double-density
             * (40-track) diskette has been inserted in a high-density (80-track) drive; ie, whether "double stepping"
             * is required, since only 40 of the 80 possible "steps" are valid for a double-density diskette.
             *
             * To start, we'll focus on making this work in the normal case (80-track diskette in 80-track drive).
             */
            bDrive = this.popCmd(FDC.TERMS.DS);
            bHead = (bDrive >> 2) & 0x1;
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            c = drive.bCylinder;
            h = drive.bHead = bHead;
            r = drive.bSector = 1;
            n = 0;
            drive.resCode = FDC.REG_DATA.RES.NONE;
            if (drive.disk && (drive.sector = drive.disk.seek(drive.bCylinder, drive.bHead, drive.bSector))) {
                n = (drive.sector['length'] >> 8);
            } else {
                /*
                 * TODO: Determine the appropriate response code(s) for the possible errors that can occur here.
                 */
                drive.resCode = FDC.REG_DATA.RES.NOT_READY | FDC.REG_DATA.RES.INCOMPLETE;
            }
            this.pushResults(drive, bCmd, bHead, c, h, r, n);
            fIRQ = true;
            break;

        case FDC.REG_DATA.CMD.FORMAT_TRACK:                 // 0x0D
            bDrive = this.popCmd(FDC.TERMS.DS);
            bHead = (bDrive >> 2) & 0x1;
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            c = drive.bCylinder;
            h = drive.bHead = bHead;
            r = 1;
            n = this.popCmd(FDC.TERMS.N);                   // N
            drive.nBytes = 128 << n;                        // 0 => 128, 1 => 256, 2 => 512, 3 => 1024 (bytes/sector)
            drive.bSectorEnd = this.popCmd(FDC.TERMS.SC);   // SC (sectors/track)
            this.popCmd(FDC.TERMS.GPL);                     // GPL (spacing between sectors, excluding VCO Sync Field; 3)
            drive.bFiller = this.popCmd(FDC.TERMS.D);       // D (filler byte)
            this.doFormat(drive);
            this.pushResults(drive, bCmd, bHead, c, h, r, n);
            fIRQ = true;
            break;

        case FDC.REG_DATA.CMD.SEEK:                         // 0x0F
            bDrive = this.popCmd(FDC.TERMS.DS);
            bHead = (bDrive >> 2) & 0x1;
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            drive.bHead = bHead;
            /*
             * As discussed in initDrive(), we can no longer simply set bCylinder to the specified NCN;
             * instead, we must calculate the delta between bCylinderSeek and the NCN, and adjust bCylinder
             * by that amount.  Then we simply move the NCN into bCylinderSeek without any range checking.
             *
             * Since bCylinder is now expressly defined as the "physical" cylinder number, it must never
             * be allowed to exceed the physical boundaries of the drive (ie, never lower than 0, and never
             * greater than or equal to nCylinders).
             */
            c = this.popCmd(FDC.TERMS.NCN);
            drive.bCylinder += c - drive.bCylinderSeek;
            if (drive.bCylinder < 0) drive.bCylinder = 0;
            if (drive.bCylinder >= drive.nCylinders) drive.bCylinder = drive.nCylinders - 1;
            drive.bCylinderSeek = c;
            drive.resCode = FDC.REG_DATA.RES.SEEK_END;
            /*
             * TODO: To properly support ALL the ST3 result bits (not just TRACK0), we need a resCode
             * update() function that all FDC commands can use.  This code is merely sufficient to get us
             * through the "DSKETTE_SETUP" gauntlet in the MODEL_5170 BIOS.
             */
            if (!drive.bCylinder) {
                drive.resCode |= FDC.REG_DATA.RES.TRACK0;
            }
            this.beginResult();                             // like FDC.REG_DATA.CMD.RECALIBRATE, no results are provided
            fIRQ = true;
            break;

        default:
            if (DEBUG && this.messageEnabled()) {
                this.printMessage("unsupported FDC operation: " + Str.toHexByte(bCmd));
                if (MAXDEBUG) this.dbg.stopCPU();
            }
            break;
        }

        if (this.regDataTotal > 0) {
            this.regStatus |= (FDC.REG_STATUS.READ_DATA | FDC.REG_STATUS.BUSY);
        }

        /*
         * After the Execution Phase (eg, DMA Terminal Count has occurred, or the EOT sector has been read/written),
         * an interrupt is supposed to occur, signaling the beginning of the Result Phase.  Once the first byte of the
         * result has been read, the interrupt is cleared (see inFDCData).
         *
         * TODO: Technically, interrupt request status should be cleared by the FDC.REG_DATA.CMD.SENSE_INT command; in fact,
         * if that command is issued and no interrupt was pending, then FDC.REG_DATA.RES.INVALID should be returned (via ST0).
         */

        /*
         * When the Windows 95 HSFLOP ("High-Speed Floppy") VxD performs its diskette change-line detection logic
         * ("determine_changeline"), it sets a special callback ("dcl_callback_int_entry") for its interrupt handler
         * to invoke, then issues a READ_ID command, and then sets a bit telling its interrupt handler to expect an
         * interrupt ("FLP_NEC_INT_EXPECTED").
         *
         * Technically, it should have set *both* "dcl_callback_int_entry" *and* "FLP_NEC_INT_EXPECTED" *before*
         * issuing the READ_ID command, but I imagine the author assumed all was fine, since interrupts had been
         * disabled with a "cli" beforehand and had not been re-enabled with an "sti" yet.  But alas, the function
         * used to the issue the READ_ID command ("NecOut") immediately re-enabled interrupts.
         *
         * So, if we request an interrupt immediately after the READ_ID command, the interrupt handler will think
         * our interrupt is spurious (ie, not EXPECTED).  In this particular case, there are only about 10 instructions
         * executed from the time READ_ID is issued until the "FLP_NEC_INT_EXPECTED" bit is set, but I'm going to
         * add a little padding to that, in part because I wouldn't be surprised if there are other places where a
         * similar assumption exists (ie, either that "NecOut" leaves interrupts disabled, or simply that the floppy
         * controller is an inherently slow device).
         *
         * TODO: Determine why the Football prototype disk fails to boot if we specify a larger delay (eg, 32) and
         * why TopView 1.10 hangs when the delay is set to 16.  I've worked around those questions for now, by simply
         * limiting the delay to the READ_ID command.
         *
         * UPDATE: Those aforementioned issues with Football and TopView may have been entirely due to a problem
         * with the initial version of requestInterrupt(), which had an additional fCondition parameter into which I
         * was passing the entire "drive && fIRQ && !(drive.resCode & FDC.REG_DATA.RES.NOT_READY)" expression.  Note
         * that if "drive" was undefined, the entire expression would be "undefined", which I assumed would translate
         * to a "falsey" fCondition, but the fCondition parameter was also declared with a default value of true,
         * and default values are used not only when NO value is supplied but ALSO when an "undefined" value is supplied.
         *
         * Oops.
         */
        if (drive && fIRQ && !(drive.resCode & FDC.REG_DATA.RES.NOT_READY)) {
            this.requestInterrupt(bCmdMasked == FDC.REG_DATA.CMD.READ_ID? 16 : 0);
        }
    }

    /**
     * pushResults(drive, bCmd, bHead, c, h, r, n)
     *
     * @param {Object} drive
     * @param {number} bCmd
     * @param {number} bHead
     * @param {number} c
     * @param {number} h
     * @param {number} r
     * @param {number} n
     */
    pushResults(drive, bCmd, bHead, c, h, r, n)
    {
        this.beginResult();
        this.pushST0(drive);
        this.pushST1(drive);
        this.pushST2(drive);
        /*
         * NOTE: I used to set the following C/H/R/N results using the values that advanceSector() had "advanced"
         * them to, which seemed logical but was technically incorrect.  For non-multi-track reads, they should match
         * the programmed C/H/R/N values, except when EOT has been reached, in which case C = C + 1 and R = 1.
         *
         * For multi-track, the LSB of H should be complemented whenever EOT has been reached, which I "informally"
         * detect by testing if the drive's current bCylinder and/or bHead positions advanced to a new cylinder or head,
         * and apparently, C should never be advanced if H was initially 0.
         *
         * I don't do strict EOT comparisons here or elsewhere, because it allows the controller to work with a wider
         * range of disks (eg, "fake" XDF disk images that contain 23 512-byte sectors/track).
         */
        let i = 0;
        if (c != drive.bCylinder || h != drive.bHead) {
            i = r = 1;
        }
        if (bCmd & FDC.REG_DATA.CMD.MT) {
            h ^= i;
            if (!bHead) i = 0;
        }
        c += i;
        this.pushResult(c, FDC.TERMS.C);                // formerly drive.bCylinder
        this.pushResult(h, FDC.TERMS.H);                // formerly drive.bHead
        this.pushResult(r, FDC.TERMS.R);                // formerly drive.bSector
        this.pushResult(n, FDC.TERMS.N);
    }

    /**
     * popCmd(name)
     *
     * @this {FDC}
     * @param {string|undefined} [name]
     * @return {number}
     */
    popCmd(name)
    {

        let bCmd = this.regDataArray[this.regDataIndex];
        if (DEBUG && this.messageEnabled(Messages.PORT | Messages.FDC)) {
            let bCmdMasked = bCmd & FDC.REG_DATA.CMD.MASK;
            if (!name && !this.regDataIndex && FDC.aCmdInfo[bCmdMasked]) name = FDC.aCmdInfo[bCmdMasked].name;
            this.printMessage(this.idComponent + ".popCmd(" + (name || this.regDataIndex) + "): " + Str.toHexByte(bCmd), true);
        }
        this.regDataIndex++;
        return bCmd;
    }

    /**
     * popHLT()
     *
     * NOTE: This byte is actually a combination of HLT (Head Load Time) and ND (Non-DMA Mode)
     *
     * @this {FDC}
     */
    popHLT()
    {
        this.popCmd(FDC.TERMS.HLT);
     // this.nHLT = this.popCmd(FDC.TERMS.HLT);
    }

    /**
     * popSRT()
     *
     * NOTE: This byte is actually a combination of SRT (Step Rate Time) and HUT (Head Unload Time)
     *
     * @this {FDC}
     */
    popSRT()
    {
        this.popCmd(FDC.TERMS.SRT);
     // this.nSRT = this.popCmd(FDC.TERMS.SRT);
    }

    /**
     * requestInterrupt(nDelay)
     *
     * Request an FDC interrupt, as long as INT_ENABLE is set (and the optional supplied condition, if any, is true).
     *
     * @this {FDC}
     * @param {number} [nDelay]
     */
    requestInterrupt(nDelay)
    {
        if (this.regOutput & FDC.REG_OUTPUT.INT_ENABLE) {
            if (this.chipset) this.chipset.setIRR(ChipSet.IRQ.FDC, nDelay);
        }
    }

    /**
     * beginResult()
     *
     * @this {FDC}
     */
    beginResult()
    {
        this.setLED();
        this.regDataIndex = this.regDataTotal = 0;
    }

    /**
     * pushResult(bResult, name)
     *
     * @this {FDC}
     * @param {number} bResult
     * @param {string|undefined} [name]
     */
    pushResult(bResult, name)
    {
        if (DEBUG && this.messageEnabled(Messages.PORT | Messages.FDC)) {
            this.printMessage(this.idComponent + ".pushResult(" + (name || this.regDataTotal) + "): " + Str.toHexByte(bResult), true);
        }

        this.regDataArray[this.regDataTotal++] = bResult;
    }

    /**
     * pushST0(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    pushST0(drive)
    {
        this.pushResult(drive.iDrive | (drive.bHead << 2) | (drive.resCode & FDC.REG_DATA.RES.ST0), FDC.TERMS.ST0);
    }

    /**
     * pushST1(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    pushST1(drive)
    {
        this.pushResult((drive.resCode & FDC.REG_DATA.RES.ST1) >>> 8, FDC.TERMS.ST1);
    }

    /**
     * pushST2(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    pushST2(drive)
    {
        this.pushResult((drive.resCode & FDC.REG_DATA.RES.ST2) >>> 16, FDC.TERMS.ST2);
    }

    /**
     * pushST3(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    pushST3(drive)
    {
        this.pushResult((drive.resCode & FDC.REG_DATA.RES.ST3) >>> 24, FDC.TERMS.ST3);
    }

    /**
     * doDMARead(drive, b, done)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b
     * @param {function(number,boolean)} done
     */
    doDMARead(drive, b, done)
    {
        if (b === undefined || b < 0) {
            this.readData(drive, done);
            return;
        }
        /*
         * The DMA controller should be ASKING for data, not GIVING us data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printMessage(this.idComponent + ".doDMARead(): invalid DMA acknowledgement");
        done(-1, false);
    }

    /**
     * doDMAWrite(drive, b)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b
     * @return {number}
     */
    doDMAWrite(drive, b)
    {
        if (b !== undefined && b >= 0)
            return this.writeData(drive, b);
        /*
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printMessage(this.idComponent + ".doDMAWrite(): invalid DMA acknowledgement");
        return -1;
    }

    /**
     * doDMAFormat(drive, b)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b
     * @returns {number}
     */
    doDMAFormat(drive, b)
    {
        if (b !== undefined && b >= 0)
            return this.writeFormat(drive, b);
        /*
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printMessage(this.idComponent + ".doDMAFormat(): invalid DMA acknowledgement");
        return -1;
    }

    /**
     * doRead(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    doRead(drive)
    {
        /*
         * With only NOT_READY and INCOMPLETE set, an empty drive causes DOS to report "General Failure";
         * with the addition of NO_DATA, DOS reports "Sector not found".  The traditional "Drive not ready"
         * error message is not triggered by anything we return here, but simply by BIOS commands timing out.
         */
        drive.resCode = FDC.REG_DATA.RES.NOT_READY | FDC.REG_DATA.RES.INCOMPLETE;

        if (drive.disk) {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage(this.idComponent + ".doRead(CHS=" + drive.bCylinder + ':' + drive.bHead + ':' + drive.bSector + ",PBA=" + (drive.bCylinder * (drive.disk.nHeads * drive.disk.nSectors) + drive.bHead * drive.disk.nSectors + drive.bSector-1) + ')');
            }
            drive.sector = null;
            drive.resCode = FDC.REG_DATA.RES.NONE;
            if (this.chipset) {
                this.chipset.connectDMA(ChipSet.DMA_FDC, this, 'dmaRead', drive);
                this.chipset.requestDMA(ChipSet.DMA_FDC);
            }
        }
    }

    /**
     * doWrite(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    doWrite(drive)
    {
        drive.resCode = FDC.REG_DATA.RES.NOT_READY | FDC.REG_DATA.RES.INCOMPLETE;

        if (drive.disk) {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage(this.idComponent + ".doWrite(CHS=" + drive.bCylinder + ':' + drive.bHead + ':' + drive.bSector + ",PBA=" + (drive.bCylinder * (drive.disk.nHeads * drive.disk.nSectors) + drive.bHead * drive.disk.nSectors + drive.bSector-1) + ')');
            }
            if (drive.disk.fWriteProtected) {
                drive.resCode = FDC.REG_DATA.RES.NOT_WRITABLE | FDC.REG_DATA.RES.INCOMPLETE;
                return;
            }
            drive.sector = null;
            drive.resCode = FDC.REG_DATA.RES.NONE;
            if (this.chipset) {
                this.chipset.connectDMA(ChipSet.DMA_FDC, this, 'dmaWrite', drive);
                this.chipset.requestDMA(ChipSet.DMA_FDC);
            }
        }
    }

    /**
     * doFormat(drive)
     *
     * drive is initialized by doCmd() to the following extent:
     *
     *      drive.bHead (ignored)
     *      drive.nBytes (bytes/sector)
     *      drive.bSectorEnd (sectors/track)
     *      drive.bFiller (fill byte)
     *
     * and we expect the DMA controller to provide C, H, R and N (ie, 4 bytes) for each sector to be formatted.
     *
     * @this {FDC}
     * @param {Object} drive
     */
    doFormat(drive)
    {
        drive.resCode = FDC.REG_DATA.RES.NOT_READY | FDC.REG_DATA.RES.INCOMPLETE;

        if (drive.disk) {
            drive.sector = null;
            drive.resCode = FDC.REG_DATA.RES.NONE;
            if (this.chipset) {
                drive.cbFormat = 0;
                drive.abFormat = new Array(4);
                drive.bFormatting = true;
                drive.cSectorsFormatted = 0;
                this.chipset.connectDMA(ChipSet.DMA_FDC, this, 'dmaFormat', drive);
                this.chipset.requestDMA(ChipSet.DMA_FDC);
                drive.bFormatting = false;
            }
        }
    }

    /**
     * readData(drive, done)
     *
     * The following drive properties must have been setup prior to our first call:
     *
     *      drive.bHead
     *      drive.bCylinder
     *      drive.bSector
     *      drive.sector (initialized to null)
     *
     * On the first readData() request, since drive.sector will be null, we ask the Disk object to look
     * up the first sector of the request.  We then ask the Disk for bytes from that sector until the sector
     * is exhausted, and then we look up the next sector and continue the process.
     *
     * NOTE: Since the FDC isn't aware of the extent of the transfer, all readData() can do is return bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * TODO: Research the requirements, if any, for multi-track I/O and determine what else needs to be done.
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {function(number,boolean,Object,number)} done (number is next available byte from drive, or -1 if no more bytes available)
     */
    readData(drive, done)
    {
        let b = -1;
        let obj = null, off = 0;    // these variables are purely for BACKTRACK purposes

        if (!drive.resCode && drive.disk) {
            do {
                if (drive.sector) {
                    off = drive.ibSector;
                    if ((b = drive.disk.read(drive.sector, drive.ibSector++)) >= 0) {
                        obj = drive.sector;
                        break;
                    }
                }
                /*
                 * Locate the next sector, and then try reading again.
                 */
                drive.sector = drive.disk.seek(drive.bCylinder, drive.bHead, drive.bSector);
                if (!drive.sector) {
                    drive.resCode = FDC.REG_DATA.RES.NO_DATA | FDC.REG_DATA.RES.INCOMPLETE;
                    break;
                }
                drive.ibSector = 0;
                /*
                 * We "pre-advance" bSector et al now, instead of waiting to advance it right before the seek().
                 * This allows the initial call to readData() to perform a seek without triggering an unwanted advance.
                 */
                this.advanceSector(drive);
            } while (true);
        }
        done(b, false, obj, off);
    }

    /**
     * writeData(drive, b)
     *
     * The following drive properties must have been setup prior to our first call:
     *
     *      drive.bHead
     *      drive.bCylinder
     *      drive.bSector
     *      drive.sector (initialized to null)
     *
     * On the first writeData() request, since drive.sector will be null, we ask the Disk object to look
     * up the first sector of the request.  We then send the Disk bytes for that sector until the sector
     * is full, and then we look up the next sector and continue the process.
     *
     * NOTE: Since the FDC isn't aware of the extent of the transfer, all writeData() can do is accept bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * TODO: Research the requirements, if any, for multi-track I/O and determine what else needs to be done.
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b containing next byte to write
     * @return {number} (b unchanged; return -1 if command should be terminated)
     */
    writeData(drive, b)
    {
        if (drive.resCode || !drive.disk) return -1;
        do {
            if (drive.sector) {
                if (drive.disk.write(drive.sector, drive.ibSector++, b))
                    break;
            }
            /*
             * Locate the next sector, and then try writing again.
             */
            drive.sector = drive.disk.seek(drive.bCylinder, drive.bHead, drive.bSector);
            if (!drive.sector) {
                /*
                 * TODO: Determine whether this should be FDC.REG_DATA.RES.CRC_ERROR or FDC.REG_DATA.RES.DATA_FIELD
                 */
                drive.resCode = FDC.REG_DATA.RES.CRC_ERROR | FDC.REG_DATA.RES.INCOMPLETE;
                b = -1;
                break;
            }
            drive.ibSector = 0;
            /*
             * We "pre-advance" bSector et al now, instead of waiting to advance it right before the seek().
             * This allows the initial call to writeData() to perform a seek without triggering an unwanted advance.
             */
            this.advanceSector(drive);
        } while (true);
        return b;
    }

    /**
     * advanceSector(drive)
     *
     * This increments the sector number; when the sector number reaches drive.nDiskSectors on the current track, we
     * increment drive.bHead and reset drive.bSector, and when drive.bHead reaches drive.nDiskHeads, we reset drive.bHead
     * and increment drive.bCylinder.
     *
     * @this {FDC}
     * @param {Object} drive
     */
    advanceSector(drive)
    {

        drive.bSector++;
        let bSectorStart = 1;
        if (drive.bSector >= drive.nDiskSectors + bSectorStart) {
            drive.bSector = bSectorStart;
            drive.bHead++;
            if (drive.bHead >= drive.nDiskHeads) {
                drive.bHead = 0;
                drive.bCylinder++;
            }
        }
    }

    /**
     * writeFormat(drive, b)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b containing a format command byte
     * @return {number} (b if successful, -1 if command should be terminated)
     */
    writeFormat(drive, b)
    {
        if (drive.resCode) return -1;
        drive.abFormat[drive.cbFormat++] = b;
        if (drive.cbFormat == drive.abFormat.length) {
            drive.bCylinder = drive.abFormat[0];    // C
            drive.bHead = drive.abFormat[1];        // H
            drive.bSector = drive.abFormat[2];      // R
            drive.nBytes = 128 << drive.abFormat[3];// N (0 => 128, 1 => 256, 2 => 512, 3 => 1024)
            drive.cbFormat = 0;
            if (DEBUG && this.messageEnabled()) {
                this.printMessage(this.idComponent + ".writeFormat(head=" + Str.toHexByte(drive.bHead) + ",cyl=" + Str.toHexByte(drive.bCylinder) + ",sec=" + Str.toHexByte(drive.bSector) + ",len=" + Str.toHexWord(drive.nBytes) + ")");
            }
            for (let i = 0; i < drive.nBytes; i++) {
                if (this.writeData(drive, drive.bFiller) < 0) {
                    return -1;
                }
            }
            drive.cSectorsFormatted++;
        }
        if (drive.cSectorsFormatted >= drive.bSectorEnd) b = -1;
        return b;
    }

    /**
     * FDC.init()
     *
     * This function operates on every HTML element of class "fdc", extracting the
     * JSON-encoded parameters for the FDC constructor from the element's "data-value"
     * attribute, invoking the constructor to create a FDC component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeFDC = Component.getElementsByClass(document, PCX86.APPCLASS, "fdc");
        for (let iFDC = 0; iFDC < aeFDC.length; iFDC++) {
            let eFDC = aeFDC[iFDC];
            let parmsFDC = Component.getComponentParms(eFDC);
            let fdc = new FDC(parmsFDC);
            Component.bindComponentControls(fdc, eFDC, PCX86.APPCLASS);
        }
    }
}

FDC.DEFAULT_DRIVE_NAME = "Floppy Drive";

if (DEBUG) {
    FDC.TERMS = {
        C:   "C",       // Cylinder Number
        D:   "D",       // Data (eg, pattern to be written to a sector)
        H:   "H",       // Head Address
        R:   "R",       // Record (ie, sector number to be read or written)
        N:   "N",       // Number (ie, number of data bytes to write)
        DS:  "DS",      // Drive Select
        SC:  "SC",      // Sectors per Cylinder
        DTL: "DTL",     // Data Length
        EOT: "EOT",     // End of Track
        GPL: "GPL",     // Gap Length
        HLT: "HLT",     // Head Load Time
        NCN: "NCN",     // New Cylinder Number
        PCN: "PCN",     // Present Cylinder Number
        SRT: "SRT",     // Stepping Rate
        ST0: "ST0",     // Status Register 0
        ST1: "ST1",     // Status Register 1
        ST2: "ST2",     // Status Register 2
        ST3: "ST3"      // Status Register 3
    };
} else {
    FDC.TERMS = {};
}

/*
 * FDC Digital Output Register (DOR) (0x3F2, write-only)
 *
 * NOTE: Reportedly, a drive's MOTOR had to be ON before the drive could be selected; however, outFDCOutput() no
 * longer verifies that.  Also, motor start time for original drives was 500ms, but we make no attempt to simulate that.
 *
 * On the MODEL_5170 "PC AT Fixed Disk and Diskette Drive Adapter", this port is called the Digital Output Register
 * or DOR.  It uses the same bit definitions as the original FDC Output Register, except that only two diskette drives
 * are supported, hence bit 1 is always 0 (ie, FDC.REG_OUTPUT.DS2 and FDC.REG_OUTPUT.DS3 are not supported) and bits
 * 6 and 7 are unused (FDC.REG_OUTPUT.MOTOR_D2 and FDC.REG_OUTPUT.MOTOR_D3 are not supported).
 */
FDC.REG_OUTPUT = {
    PORT:      0x3F2,
    DS:         0x03,   // drive select bits
    DS0:        0x00,
    DS1:        0x01,
    DS2:        0x02,   // reserved on the MODEL_5170
    DS3:        0x03,   // reserved on the MODEL_5170
    ENABLE:     0x04,   // clearing this bit resets the FDC
    INT_ENABLE: 0x08,   // enables both FDC and DMA (Channel 2) interrupt requests (IRQ 6)
    MOTOR_D0:   0x10,
    MOTOR_D1:   0x20,
    MOTOR_D2:   0x40,   // reserved on the MODEL_5170
    MOTOR_D3:   0x80    // reserved on the MODEL_5170
};

/*
 * FDC Main Status Register (0x3F4, read-only)
 *
 * On the MODEL_5170 "PC AT Fixed Disk and Diskette Drive Adapter", bits 2 and 3 are reserved, since that adapter
 * supported a maximum of two diskette drives.
 */
FDC.REG_STATUS = {
    PORT:      0x3F4,
    BUSY_A:     0x01,
    BUSY_B:     0x02,
    BUSY_C:     0x04,   // reserved on the MODEL_5170
    BUSY_D:     0x08,   // reserved on the MODEL_5170
    BUSY:       0x10,   // a read or write command is in progress
    NON_DMA:    0x20,   // FDC is in non-DMA mode
    READ_DATA:  0x40,   // transfer is from FDC Data Register to processor (if clear, then transfer is from processor to the FDC Data Register)
    RQM:        0x80    // indicates FDC Data Register is ready to send or receive data to or from the processor (Request for Master)
};

/*
 * FDC Data Register (0x3F5, read-write)
 */
FDC.REG_DATA = {
    PORT:      0x3F5,
    /*
     * FDC Commands
     *
     * NOTE: FDC command bytes need to be masked with FDC.REG_DATA.CMD.MASK before comparing to the values below, since a
     * number of commands use the following additional bits as follows:
     *
     *      SK (0x20): Skip Deleted Data Address Mark
     *      MF (0x40): Modified Frequency Modulation (as opposed to FM or Frequency Modulation)
     *      MT (0x80): multi-track operation (ie, data processed under both head 0 and head 1)
     *
     * We don't support MT (Multi-Track) operations at this time, and the MF and SK designations cannot be supported as long
     * as our diskette images contain only the original data bytes without any formatting information.
     */
    CMD: {
        READ_TRACK:     0x02,
        SPECIFY:        0x03,
        SENSE_DRIVE:    0x04,
        WRITE_DATA:     0x05,
        READ_DATA:      0x06,
        RECALIBRATE:    0x07,
        SENSE_INT:      0x08,           // this command is used to clear the FDC interrupt following the clearing/setting of FDC.REG_OUTPUT.ENABLE
        WRITE_DEL_DATA: 0x09,
        READ_ID:        0x0A,
        READ_DEL_DATA:  0x0C,
        FORMAT_TRACK:   0x0D,
        SEEK:           0x0F,
        SCAN_EQUAL:     0x11,
        SCAN_LO_EQUAL:  0x19,
        SCAN_HI_EQUAL:  0x1D,
        MASK:           0x1F,
        SK:             0x20,           // SK (Skip Deleted Data Address Mark)
        MF:             0x40,           // MF (Modified Frequency Modulation)
        MT:             0x80            // MT (Multi-Track; ie, data under both heads will be processed)
    },
    /*
     * FDC status/error results, generally assigned according to the corresponding ST0, ST1, ST2 or ST3 status bit.
     *
     * TODO: Determine when EQUIP_CHECK is *really* set; also, "77 step pulses" sounds suspiciously like a typo (it's not 79?)
     */
    RES: {
        NONE:           0x00000000,     // ST0 (IC): Normal termination of command (NT)
        NOT_READY:      0x00000008,     // ST0 (NR): When the FDD is in the not-ready state and a read or write command is issued, this flag is set; if a read or write command is issued to side 1 of a single sided drive, then this flag is set
        EQUIP_CHECK:    0x00000010,     // ST0 (EC): If a fault signal is received from the FDD, or if the track 0 signal fails to occur after 77 step pulses (recalibrate command), then this flag is set
        SEEK_END:       0x00000020,     // ST0 (SE): When the FDC completes the Seek command, this flag is set to 1 (high)
        INCOMPLETE:     0x00000040,     // ST0 (IC): Abnormal termination of command (AT); execution of command was started, but was not successfully completed
        RESET:          0x000000C0,     // ST0 (IC): Abnormal termination because during command execution the ready signal from the drive changed state
        INVALID:        0x00000080,     // ST0 (IC): Invalid command issue (IC); command which was issued was never started
        ST0:            0x000000FF,
        NO_ID_MARK:     0x00000100,     // ST1 (MA): If the FDC cannot detect the ID Address Mark, this flag is set; at the same time, the MD (Missing Address Mark in Data Field) of Status Register 2 is set
        NOT_WRITABLE:   0x00000200,     // ST1 (NW): During Execution of a Write Data, Write Deleted Data, or Format a Cylinder command, if the FDC detects a write protect signal from the FDD, then this flag is set
        NO_DATA:        0x00000400,     // ST1 (ND): FDC cannot find specified sector (or specified ID if READ_ID command)
        DMA_OVERRUN:    0x00001000,     // ST1 (OR): If the FDC is not serviced by the main systems during data transfers within a certain time interval, this flag is set
        CRC_ERROR:      0x00002000,     // ST1 (DE): When the FDC detects a CRC error in either the ID field or the data field, this flag is set
        END_OF_CYL:     0x00008000,     // ST1 (EN): When the FDC tries to access a sector beyond the final sector of a cylinder, this flag is set
        ST1:            0x0000FF00,
        NO_DATA_MARK:   0x00010000,     // ST2 (MD): When data is read from the medium, if the FDC cannot find a Data Address Mark or Deleted Data Address Mark, then this flag is set
        BAD_CYL:        0x00020000,     // ST2 (BC): This bit is related to the ND bit, and when the contents of C on the medium are different from that stored in the ID Register, and the content of C is FF, then this flag is set
        SCAN_FAILED:    0x00040000,     // ST2 (SN): During execution of the Scan command, if the FDC cannot find a sector on the cylinder which meets the condition, then this flag is set
        SCAN_EQUAL:     0x00080000,     // ST2 (SH): During execution of the Scan command, if the condition of "equal" is satisfied, this flag is set
        WRONG_CYL:      0x00100000,     // ST2 (WC): This bit is related to the ND bit, and when the contents of C on the medium are different from that stored in the ID Register, this flag is set
        DATA_FIELD:     0x00200000,     // ST2 (DD): If the FDC detects a CRC error in the data, then this flag is set
        STRL_MARK:      0x00400000,     // ST2 (CM): During execution of the Read Data or Scan command, if the FDC encounters a sector which contains a Deleted Data Address Mark, this flag is set
        ST2:            0x00FF0000,
        DRIVE:          0x03000000,     // ST3 (Ux): Status of the "Drive Select" signals from the diskette drive
        HEAD:           0x04000000,     // ST3 (HD): Status of the "Side Select" signal from the diskette drive
        TWOSIDE:        0x08000000,     // ST3 (TS): Status of the "Two Side" signal from the diskette drive
        TRACK0:         0x10000000,     // ST3 (T0): Status of the "Track 0" signal from the diskette drive
        READY:          0x20000000,     // ST3 (RY): Status of the "Ready" signal from the diskette drive
        WRITEPROT:      0x40000000,     // ST3 (WP): Status of the "Write Protect" signal from the diskette drive
        FAULT:          0x80000000|0,   // ST3 (FT): Status of the "Fault" signal from the diskette drive
        ST3:            0xFF000000|0
    }
};

/*
 * FDC "Fixed Disk" Register (0x3F6, write-only)
 *
 * Since this register's functions are all specific to the Hard Drive Controller, see the HDC component for details.
 * The fact that this HDC register is in the middle of the FDC I/O port range is an oddity of the "HFCOMBO" controller.
 */

/*
 * FDC Digital Input Register (0x3F7, read-only, MODEL_5170 only)
 *
 * Bit 7 indicates a diskette change (the MODEL_5170 introduced change-line support).  Bits 0-6 are for the selected
 * hard drive, so this port must be shared with the HDC; bits 0-6 are valid for 50 microseconds after a write to the
 * Drive Head Register.
 */
FDC.REG_INPUT = {
    PORT:      0x3F7,
    DS0:        0x01,   // Drive Select 0
    DS1:        0x02,   // Drive Select 1
    HS0:        0x04,   // Head Select 0
    HS1:        0x08,   // Head Select 1
    HS2:        0x10,   // Head Select 2
    HS3:        0x20,   // Head Select 3
    WRITE_GATE: 0x40,   // Write Gate
    DISK_CHANGE:0x80    // Diskette Change
};

/*
 * FDC Diskette Control Register (0x3F7, write-only, MODEL_5170 only)
 *
 * Only bits 0-1 are used; bits 2-7 are reserved.
 */
FDC.REG_CONTROL = {
    PORT:      0x3F7,
    RATE500K:   0x00,   // 500,000 bps
    RATE300K:   0x02,   // 300,000 bps
    RATE250K:   0x01,   // 250,000 bps
    RATEUNUSED: 0x03
};

/*
 * FDC Command Sequences
 *
 * For each command, cbReq indicates the total number of bytes in the command request sequence,
 * including the first (command) byte; cbRes indicates total number of bytes in the response sequence.
 */
if (DEBUG) {
    FDC.CMDS = {
        SPECIFY:      "SPECIFY",
        SENSE_DRIVE:  "SENSE DRIVE",
        WRITE_DATA:   "WRITE DATA",
        READ_DATA:    "READ DATA",
        RECALIBRATE:  "RECALIBRATE",
        SENSE_INT:    "SENSE INTERRUPT",
        READ_ID:      "READ ID",
        FORMAT:       "FORMAT",
        SEEK:         "SEEK"
    };
} else {
    FDC.CMDS = {};
}

FDC.aCmdInfo = {
    0x03: {cbReq: 3, cbRes: 0, name: FDC.CMDS.SPECIFY},
    0x04: {cbReq: 2, cbRes: 1, name: FDC.CMDS.SENSE_DRIVE},
    0x05: {cbReq: 9, cbRes: 7, name: FDC.CMDS.WRITE_DATA},
    0x06: {cbReq: 9, cbRes: 7, name: FDC.CMDS.READ_DATA},
    0x07: {cbReq: 2, cbRes: 0, name: FDC.CMDS.RECALIBRATE},
    0x08: {cbReq: 1, cbRes: 2, name: FDC.CMDS.SENSE_INT},
    0x0A: {cbReq: 2, cbRes: 7, name: FDC.CMDS.READ_ID},
    0x0D: {cbReq: 6, cbRes: 7, name: FDC.CMDS.FORMAT},
    0x0F: {cbReq: 3, cbRes: 0, name: FDC.CMDS.SEEK}
};

/*
 * Port input notification table
 *
 * TODO: Even though port 0x3F7 was not present on controllers prior to MODEL_5170, I'm taking the easy
 * way out and always emulating it.  So, consider an FDC parameter to disable that feature for stricter compatibility.
 */
FDC.aPortInput = {
    0x3F1: FDC.prototype.inFDCDiagnostic,
    0x3F4: FDC.prototype.inFDCStatus,
    0x3F5: FDC.prototype.inFDCData,
    0x3F7: FDC.prototype.inFDCInput
};

/*
 * Port output notification table
 *
 * TODO: Even though port 0x3F7 was not present on controllers prior to MODEL_5170, I'm taking the easy
 * way out and always emulating it.  So, consider an FDC parameter to disable that feature for stricter compatibility.
 */
FDC.aPortOutput = {
    0x3F2: FDC.prototype.outFDCOutput,
    0x3F5: FDC.prototype.outFDCData,
    0x3F7: FDC.prototype.outFDCControl
};

/*
 * Initialize every Floppy Drive Controller (FDC) module on the page.
 */
Web.onInit(FDC.init);



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/hdc.js (C) Jeff Parsons 2012-2018
 */


/**
 * class HDC
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class HDC extends Component {
    /**
     * HDC(parmsHDC)
     *
     * The HDC component simulates an STC-506/412 interface to an IBM-compatible fixed disk drive. The first
     * such drive was a 10Mb 5.25-inch drive containing two platters and 4 heads. Data spanned 306 cylinders
     * for a total of 1224 tracks, with 17 sectors/track and 512 bytes/sector.  Support has since been expanded
     * to include the original PC AT Western Digital controller.
     *
     * HDC supports the following component-specific properties:
     *
     *      drives: an array of driveConfig objects, each containing 'name', 'path', 'size' and 'type' properties
     *      type:   either 'XT' (for the PC XT Xebec controller) or 'AT' (for the PC AT Western Digital controller)
     *
     * The 'type' parameter defaults to 'XT'.  All ports for the PC XT controller are referred to as XTC ports,
     * and similarly, all PC AT controller ports are referred to as ATC ports.
     *
     * If 'path' is empty, a scratch disk image is created; otherwise, we make a note of the path, but we will NOT
     * pre-load it like we do for floppy disk images.
     *
     * My current plan is to read all disk data on-demand, keeping a cache of what we've read, and possibly adding
     * some read-ahead as well. Any portions of the disk image that are written before being read will never be read.
     *
     * TRIVIA: On p.1-179 of the PC XT Technical Reference Manual (revised APR83), it reads:
     *
     *      "WARNING: The last cylinder on the fixed disk drive is reserved for diagnostic use.
     *      Diagnostic write tests will destroy any data on this cylinder."
     *
     * Does FDISK insure that the last cylinder is reserved?  I'm sure we'll eventually find out.
     *
     * @this {HDC}
     * @param {Object} parmsHDC
     */
    constructor(parmsHDC)
    {
        super("HDC", parmsHDC, Messages.HDC);

        this['dmaRead'] = HDC.prototype.doDMARead;
        this['dmaWrite'] = HDC.prototype.doDMAWrite;
        this['dmaWriteBuffer'] = HDC.prototype.doDMAWriteBuffer;
        this['dmaWriteFormat'] = HDC.prototype.doDMAWriteFormat;

        this.aDriveConfigs = [];

        /*
         * We used to eval() sDriveConfigs immediately, but now we wait until initBus() is called, so that
         * we can check for any machine overrides.
         */
        this.sDriveConfigs = parmsHDC['drives'];

        /*
         * Set fATC (AT Controller flag) according to the 'type' parameter.  This in turn determines other
         * defaults.  For example, the default XT drive type is 3 (for a 10Mb disk drive), whereas the default
         * AT drive type is 2 (for a 20Mb disk drive).
         */
        let sType = parmsHDC['type'];
        this.fATC = sType && sType.toUpperCase() == "AT" || false;

        /*
         * Support for local disk images is currently limited to desktop browsers with FileReader support;
         * when this flag is set, setBinding() allows local disk bindings and informs initBus() to update the
         * "listDisks" binding accordingly.
         */
        this.fLocalDisks = (!Web.isMobile() && window && 'FileReader' in window);

        /*
         * The remainder of HDC initialization now takes place in our initBus() handler.
         */
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {HDC}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "listDisks")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let hdc = this;

        switch (sBinding) {

        case "saveHD0":
        case "saveHD1":
            /*
             * Yes, technically, this feature does not require "Local disk support" (which is really a reference
             * to FileReader support), but since fLocalDisks is also false for all mobile devices, and since there
             * is an "orthogonality" to disabling both features in tandem, let's just let it slide, OK?
             */
            if (!this.fLocalDisks) {
                if (DEBUG) this.log("Local disk support not available");
                /*
                 * We could also simply hide the control; eg:
                 *
                 *      control.style.display = "none";
                 *
                 * but removing the control altogether seems better.
                 */
                control.parentNode.removeChild(/** @type {Node} */ (control));
                return false;
            }
            this.bindings[sBinding] = control;
            control.onclick = function(iDrive) {
                return function onClickSaveDrive(event) {
                    let drive = hdc.aDrives && hdc.aDrives[iDrive];
                    if (drive && drive.disk) {
                        /*
                         * Note the similarity (and hence factoring opportunity) between this code and the FDC's
                         * "saveDisk" binding.
                         *
                         * One important difference between the FDC and the HDC is that an FDC may or may not contain
                         * a disk, whereas an HDC always contains a disk.  However, the contents of an HDC's disk may
                         * never have been initialized with the contents of an external disk image, and therefore the
                         * disk's sDiskFile/sDiskPath properties may be undefined.  sDiskName should always be defined
                         * though, defaulting to the name of the drive (eg, "10Mb Hard Disk").
                         */
                        let disk = drive.disk;
                        let sDiskName = disk.sDiskFile || disk.sDiskName;
                        let i = sDiskName.lastIndexOf('.');
                        if (i >= 0) sDiskName = sDiskName.substr(0, i);
                        sDiskName += ".img";
                        if (DEBUG) hdc.println("saving disk " + sDiskName + "...");
                        let sAlert = Web.downloadFile(disk.encodeAsBinary(), "octet-stream", true, sDiskName);
                        Component.alertUser(sAlert);
                    } else {
                        hdc.notice("Hard drive " + iDrive + " is not available.");
                    }
                };
            }(+sBinding.slice(-1));
            return true;
        }
        return false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {HDC}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.cmp = cmp;

        let aDriveConfigs = cmp.getMachineParm('drives');
        if (aDriveConfigs) {
            if (typeof aDriveConfigs == "string") {
                this.sDriveConfigs = aDriveConfigs;
            } else {
                this.aDriveConfigs = aDriveConfigs;
                this.sDriveConfigs = "";
            }
        }

        if (this.sDriveConfigs) {
            try {
                /*
                 * We must take care when parsing user-supplied JSON-encoded drive data.
                 */
                this.aDriveConfigs = eval("(" + this.sDriveConfigs + ")");
                /*
                 * Nothing more to do with aDriveConfigs now. initController() and autoMount() (if there are
                 * any disk image "path" properties to process) will take care of the rest.
                 */
                this.sDriveConfigs = "";
            } catch (e) {
                Component.error("HDC drive configuration error: " + e.message + " (" + this.sDriveConfigs + ")");
            }
        }

        /*
         * We need access to the ChipSet component, because we need to communicate with
         * the PIC and DMA controller.
         */
        this.chipset = cmp.getMachineComponent("ChipSet");

        this.iDriveTable = 0;
        this.iDriveTypeDefault = 3;

        bus.addPortInputTable(this, this.fATC? HDC.aATCPortInput : HDC.aXTCPortInput);
        bus.addPortOutputTable(this, this.fATC? HDC.aATCPortOutput : HDC.aXTCPortOutput);

        if (this.fATC) {
            this.iDriveTable++;
            if (this.chipset && this.chipset.model == ChipSet.MODEL_COMPAQ_DESKPRO386) this.iDriveTable++;
            this.iDriveTypeDefault = 2;
            bus.addPortInputWidth(HDC.ATC.DATA.PORT, 2);
            bus.addPortOutputWidth(HDC.ATC.DATA.PORT, 2);
        }

        cpu.addIntNotify(Interrupts.DISK, this.intBIOSDisk.bind(this));
        cpu.addIntNotify(Interrupts.ALT_DISK, this.intBIOSDiskette.bind(this));

        /*
         * The following code used to be performed in the HDC constructor, but now we need to wait for information
         * about the Computer to be available (eg, getMachineID() and getUserID()) before we start loading and/or
         * connecting to disk images.
         *
         * If we didn't need auto-mount support, we could defer controller initialization until we received a powerUp()
         * notification, at which point reset() would call initController(), or restore() would restore the controller;
         * in that case, all we'd need to do here is call setReady().
         */
        this.reset();

        if (!this.autoMount()) this.setReady();
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {HDC}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data) {
                this.initController();
                if (this.cmp.fReload) {
                    /*
                     * If the computer's fReload flag is set, we're required to toss all currently
                     * loaded disks and remount all disks specified in the auto-mount configuration.
                     */
                    this.autoMount(true);
                }
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {HDC}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean}
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * getMachineID()
     *
     * @return {string}
     */
    getMachineID()
    {
        return this.cmp? this.cmp.getMachineID() : "";
    }

    /**
     * getUserID()
     *
     * @return {string}
     */
    getUserID()
    {
        return this.cmp? this.cmp.getUserID() : "";
    }

    /**
     * reset()
     *
     * @this {HDC}
     */
    reset()
    {
        /*
         * TODO: The controller is also initialized by the constructor, to assist with auto-mount support,
         * so think about whether we can skip powerUp initialization.
         */
        this.initController(null, true);
    }

    /**
     * save()
     *
     * This implements save support for the HDC component.
     *
     * @this {HDC}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveController());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the HDC component.
     *
     * @this {HDC}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initController(data[0]);
    }

    /**
     * initController(data, fHard)
     *
     * @this {HDC}
     * @param {Array} [data]
     * @param {boolean} [fHard] true if a machine reset (not just a controller reset)
     * @return {boolean} true if successful, false if failure
     */
    initController(data, fHard)
    {
        let i = 0;
        let fSuccess = true;

        /*
         * TODO: This is used to re-select the controller's active drive whenever the machine is restored, but alas,
         * we currently only update it and save it for the ATC, not the XTC.
         */
        this.iDrive = -1;

        /*
         * At this point, it's worth calling into question my decision to NOT split the HDC component into separate XTC
         * and ATC components, given all the differences, and given that I'm about to write some "if (ATC) else (XTC) ..."
         * code.  And all I can say in my defense is, yes, it's definitely worth calling that into question.
         *
         * However, there's also some common code, mostly in the area of disk management rather than controller management,
         * and if the components were split, then I'd have to create a third component for that common code (although again,
         * disk management probably belongs in its own component anyway).
         *
         * However, let's not forget that since my overall plan is to have only one PCx86 "binary", everything's going to end
         * up in the same bucket anyway, so let's not be too obsessive about organizational details.  As long as the number
         * of these conditionals is small and they're not performance-critical, this seems much ado about nothing.
         */
        if (this.fATC) {
            /*
             * Since there's no way (and never will be a way) for an HDC to change its "personality" (from 'xt' to 'at'
             * or vice versa), we're under no obligation to use the same number of registers, or save/restore format, etc,
             * as the original XT controller.
             */
            if (data == null) data = [0, 0, 0, 0, 0, 0, 0, HDC.ATC.STATUS.READY, 0, [0, -1]];
            this.regError   = data[i++];
            this.regWPreC   = data[i++];
            this.regSecCnt  = data[i++];
            this.regSecNum  = data[i++];
            this.regCylLo   = data[i++];
            this.regCylHi   = data[i++];
            this.regDrvHd   = data[i++];
            this.regStatus  = data[i++];
            this.regCommand = data[i++];
            this.regFDR     = data[i++];
            if (typeof this.regFDR == "object") {
                let a = this.regFDR;
                this.regFDR = a[0];
                this.iDrive = a[1];
            }
            /*
             * Additional state is maintained by the Drive object (eg, abSector, ibSector)
             */
        } else {
            if (data == null) data = [0, HDC.XTC.STATUS.NONE, new Array(14), 0, 0];
            this.regConfig    = data[i++];
            this.regStatus    = data[i++];
            this.regDataArray = data[i++];  // there can be up to 14 command bytes (6 for normal commands, plus 8 more for HDC.XTC.DATA.CMD.INIT_DRIVE)
            this.regDataIndex = data[i++];  // used to control the next data byte to be received
            this.regDataTotal = data[i++];  // used to control the next data byte to be sent (internally, we use regDataIndex to read data bytes, up to this total)
            this.regReset     = data[i++];
            this.regPulse     = data[i++];
            this.regPattern   = data[i++];
            /*
             * Initialize iDriveAllowFail only if it's never been initialized, otherwise its entire purpose will be defeated.
             * See the related HACK in intBIOSDisk() for more details.
             */
            let iDriveAllowFail = data[i++];
            if (iDriveAllowFail !== undefined) {
                this.iDriveAllowFail = iDriveAllowFail;
            } else {
                if (this.iDriveAllowFail === undefined) this.iDriveAllowFail = -1;
            }
        }

        if (this.aDrives === undefined) {
            this.aDrives = new Array(this.aDriveConfigs.length);
        }

        let dataDrives = data[i];
        if (dataDrives === undefined) dataDrives = [];

        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            if (this.aDrives[iDrive] === undefined) {
                this.aDrives[iDrive] = {};
            }
            let drive = this.aDrives[iDrive];
            let driveConfig = this.aDriveConfigs[iDrive];
            if (!this.initDrive(iDrive, drive, driveConfig, dataDrives[iDrive], fHard)) {
                fSuccess = false;
            }
            /*
             * XTC only: the original STC-506/412 controller had two pairs of DIP switches to indicate a drive
             * type (0, 1, 2 or 3) for drives 0 and 1.  Those switch settings are recorded in regConfig, now that
             * drive.type has been validated by initDrive().
             */
            if (this.regConfig != null && iDrive <= 1) {
                this.regConfig |= (drive.type & 0x3) << ((1 - iDrive) << 1);
            }
        }

        if (this.iDrive >= 0) {
            this.drive = this.aDrives[this.iDrive];
        }

        if (DEBUG && this.messageEnabled()) {
            this.printMessage("HDC initialized for " + this.aDrives.length + " drive(s)");
        }
        return fSuccess;
    }

    /**
     * saveController()
     *
     * @this {HDC}
     * @return {Array}
     */
    saveController()
    {
        let i = 0;
        let data = [];
        if (this.fATC) {
            data[i++] = this.regError;
            data[i++] = this.regWPreC;
            data[i++] = this.regSecCnt;
            data[i++] = this.regSecNum;
            data[i++] = this.regCylLo;
            data[i++] = this.regCylHi;
            data[i++] = this.regDrvHd;
            data[i++] = this.regStatus;
            data[i++] = this.regCommand;
            data[i++] = [this.regFDR, this.iDrive];
        } else {
            data[i++] = this.regConfig;
            data[i++] = this.regStatus;
            data[i++] = this.regDataArray;
            data[i++] = this.regDataIndex;
            data[i++] = this.regDataTotal;
            data[i++] = this.regReset;
            data[i++] = this.regPulse;
            data[i++] = this.regPattern;
            data[i++] = this.iDriveAllowFail;
        }
        data[i] = this.saveDrives();
        return data;
    }

    /**
     * initDrive(iDrive, drive, driveConfig, data, fHard)
     *
     * TODO: Consider a separate Drive class that both FDC and HDC can use, since there's a lot of commonality
     * between the drive objects created by both controllers.  This will clean up overall drive management and allow
     * us to factor out some common Drive methods (eg, advanceSector()).
     *
     * @this {HDC}
     * @param {number} iDrive
     * @param {Object} drive
     * @param {Object} driveConfig (contains one or more of the following properties: 'name', 'path', 'size', 'type')
     * @param {Array} [data]
     * @param {boolean} [fHard] true if a machine reset (not just a controller reset)
     * @return {boolean} true if successful, false if failure
     */
    initDrive(iDrive, drive, driveConfig, data, fHard)
    {
        let i = 0;
        let fSuccess = true;
        if (data === undefined) data = [HDC.XTC.DATA.ERR.NONE, 0, false, new Array(8)];

        drive.iDrive = iDrive;

        /*
         * errorCode could be an HDC global, but in order to insulate HDC state from the operation of various functions
         * that operate on drive objects (eg, readData and writeData), I've made it a per-drive variable.  This choice may
         * be contrary to how the actual hardware works, but I prefer this approach, as long as it doesn't expose any
         * incompatibilities that any software actually cares about.
         */
        drive.errorCode = data[i++];
        drive.senseCode = data[i++];
        drive.fRemovable = data[i++];
        drive.abDriveParms = data[i++];         // captures drive parameters programmed via HDC.XTC.DATA.CMD.INIT_DRIVE

        /*
         * TODO: Make abSector a DWORD array rather than a BYTE array (we could even allocate a Memory block for it);
         * alternatively, eliminate the buffer entirely and re-establish a reference to the appropriate Disk sector object.
         */
        drive.abSector = data[i++];

        /*
         * The next group of properties are set by various HDC command sequences.
         */
        drive.bHead = data[i++];
        drive.nHeads = data[i++];
        drive.wCylinder = data[i++];
        drive.bSector = data[i++];
        drive.bSectorEnd = data[i++];           // aka EOT
        drive.nBytes = data[i++];
        drive.bSectorBias = (this.fATC? 0: 1);

        drive.name = driveConfig['name'];
        if (drive.name === undefined) drive.name = HDC.DEFAULT_DRIVE_NAME;
        drive.path = driveConfig['path'];

        /*
         * If no 'mode' is specified, we fall back to the original behavior, which is to completely preload
         * any specific disk image, or create an empty (purely local) disk image.
         */
        drive.mode = driveConfig['mode'] || (drive.path? DiskAPI.MODE.PRELOAD : DiskAPI.MODE.LOCAL);

        /*
         * On-demand I/O of raw disk images is supported only if there's a valid user ID; fall back to an empty
         * local disk image if there's not.
         */
        if (drive.mode == DiskAPI.MODE.DEMANDRO || drive.mode == DiskAPI.MODE.DEMANDRW) {
            if (!this.getUserID()) drive.mode = DiskAPI.MODE.LOCAL;
        }

        drive.type = driveConfig['type'];
        if (drive.type === undefined || HDC.aDriveTypes[this.iDriveTable][drive.type] === undefined) drive.type = this.iDriveTypeDefault;

        let driveType = HDC.aDriveTypes[this.iDriveTable][drive.type];
        drive.nSectors = driveType[2] || 17;    // sectors/track
        drive.cbSector = driveType[3] || 512;   // bytes/sector (default is 512 if unspecified in the table)

        /*
         * On a full machine reset, pass the current drive type to setCMOSDriveType() (a no-op on pre-CMOS machines)
         */
        if (fHard && this.chipset) {
            this.chipset.setCMOSDriveType(iDrive, drive.type);
        }

        /*
         * The next group of properties are set by user requests to load/unload disk images.
         *
         * We no longer reinitialize drive.disk, in order to retain previously mounted disk across resets.
         */
        if (drive.disk === undefined) {
            drive.disk = null;
            this.notice("Type " + drive.type + " \"" + drive.name + "\" is fixed disk " + iDrive, true);
        }

        /*
         * With the advent of save/restore, we need to verify every drive at initialization, not just whenever
         * drive characteristics are initialized.  Thus, if we've restored a sensible set of drive characteristics,
         * then verifyDrive will create an empty disk if none has been provided, insuring we are ready for
         * disk.restore().
         */
        this.verifyDrive(drive);

        /*
         * The next group of properties are managed by worker functions (eg, doRead()) to maintain state across DMA requests.
         */
        drive.ibSector = data[i++];             // location of the next byte to be accessed in the above sector
        drive.sector = null;                    // initialized to null by worker, and then set to the next sector satisfying the request

        if (drive.disk) {
            let deltas = data[i];
            if (deltas !== undefined && drive.disk.restore(deltas) < 0) {
                fSuccess = false;
            }
            if (fSuccess && drive.ibSector !== undefined) {
                drive.sector = drive.disk.seek(drive.wCylinder, drive.bHead, drive.bSector + drive.bSectorBias);
            }
        }
        return fSuccess;
    }

    /**
     * saveDrives()
     *
     * @this {HDC}
     * @return {Array}
     */
    saveDrives()
    {
        let i = 0;
        let data = [];
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            data[i++] = this.saveDrive(this.aDrives[iDrive]);
        }
        return data;
    }

    /**
     * saveDrive(drive)
     *
     * @this {HDC}
     * @return {Array}
     */
    saveDrive(drive)
    {
        let i = 0;
        let data = [];
        data[i++] = drive.errorCode;
        data[i++] = drive.senseCode;
        data[i++] = drive.fRemovable;
        data[i++] = drive.abDriveParms;
        data[i++] = drive.abSector;
        data[i++] = drive.bHead;
        data[i++] = drive.nHeads;
        data[i++] = drive.wCylinder;
        data[i++] = drive.bSector;
        data[i++] = drive.bSectorEnd;
        data[i++] = drive.nBytes;
        data[i++] = drive.ibSector;
        data[i] = drive.disk? drive.disk.save() : null;
        return data;
    }

    /**
     * copyDrive(iDrive)
     *
     * @this {HDC}
     * @param {number} iDrive
     * @return {Object|undefined} (undefined if the requested drive does not exist)
     */
    copyDrive(iDrive)
    {
        let driveNew;
        let driveOld = this.aDrives[iDrive];
        if (driveOld !== undefined) {
            driveNew = {};
            for (let p in driveOld) {
                driveNew[p] = driveOld[p];
            }
        }
        return driveNew;
    }

    /**
     * verifyDrive(drive, type)
     *
     * If no disk image is attached, create an empty disk with the specified drive characteristics.
     * Normally, we'd rely on the drive characteristics programmed via the HDC.XTC.DATA.CMD.INIT_DRIVE
     * command, but if an explicit drive type is specified, then we use the characteristics (geometry)
     * associated with that type.
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} [type] to create a disk of the specified type, if no disk exists yet
     */
    verifyDrive(drive, type)
    {
        if (drive) {
            let nHeads = 0, nCylinders = 0;
            if (type == null) {
                /*
                 * If the caller wants us to use the programmed drive parameters, we use those,
                 * but if there aren't any drive parameters (yet), then use default parameters based
                 * on drive.type.
                 *
                 * We used to do the last step ONLY if there was no drive.path -- otherwise, we'd waste
                 * time creating an empty disk if autoMount() was going to load an image from drive.path;
                 * but hopefully the Disk component is smarter now.
                 */
                nHeads = drive.abDriveParms[2];
                if (nHeads) {
                    nCylinders = (drive.abDriveParms[0] << 8) | drive.abDriveParms[1];
                } else {
                    type = drive.type;
                }
            }
            if (type != null && !nHeads) {
                nHeads = HDC.aDriveTypes[this.iDriveTable][type][1];
                nCylinders = HDC.aDriveTypes[this.iDriveTable][type][0];
            }
            if (nHeads) {
                /*
                 * The assumption here is that if the 3rd drive parameter byte (abDriveParms[2]) has been set
                 * (ie, if nHeads is valid) then the first two bytes (ie, the low and high cylinder byte values)
                 * must have been set as well.
                 *
                 * Do these values agree with those for the given drive type?  Even if they don't, all we do is warn.
                 */
                let driveType = HDC.aDriveTypes[this.iDriveTable][drive.type];
                if (driveType) {
                    if (nCylinders != driveType[0] && nHeads != driveType[1]) {
                        this.notice("Warning: drive parameters (" + nCylinders + "," + nHeads + ") do not match drive type " + drive.type + " (" + driveType[0] + "," + driveType[1] + ")");
                    }
                }
                drive.nCylinders = nCylinders;
                drive.nHeads = nHeads;
                if (drive.disk == null) {
                    drive.disk = new Disk(this, drive, drive.mode);
                }
            }
        }
    }

    /**
     * seekDrive(drive, iSector, nSectors)
     *
     * The HDC doesn't need this function, since all HDC requests from the CPU are handled by doXTCmd().  This function
     * is used by other components (eg, Debugger) to mimic an HDC request, using a drive object obtained from copyDrive(),
     * to avoid disturbing the internal state of the HDC's drive objects.
     *
     * Also note that in an actual HDC request, drive.nBytes is initialized to the size of a single sector; the extent
     * of the entire transfer is actually determined by a count that has been pre-loaded into the DMA controller.  The HDC
     * isn't aware of the extent of the transfer, so in the case of a read request, all readData() can do is return bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * Since seekDrive() is for use with non-DMA requests, we use nBytes to specify the length of the entire transfer.
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} iSector (a "logical" sector number, relative to the entire disk, NOT a physical sector number)
     * @param {number} nSectors
     * @return {boolean} true if successful, false if invalid position request
     */
    seekDrive(drive, iSector, nSectors)
    {
        if (drive.disk) {
            let aDiskInfo = drive.disk.info();
            let nCylinders = aDiskInfo[0];
            /*
             * If nCylinders is zero, we probably have an empty disk image, awaiting initialization (see verifyDrive())
             */
            if (nCylinders) {
                let nHeads = aDiskInfo[1];
                let nSectorsPerTrack = aDiskInfo[2];
                let nSectorsPerCylinder = nHeads * nSectorsPerTrack;
                let nSectorsPerDisk = nCylinders * nSectorsPerCylinder;
                if (iSector + nSectors <= nSectorsPerDisk) {
                    drive.wCylinder = Math.floor(iSector / nSectorsPerCylinder);
                    iSector %= nSectorsPerCylinder;
                    drive.bHead = Math.floor(iSector / nSectorsPerTrack);
                    /*
                     * Important difference between the FDC and the XTC: the XTC uses 0-based sector numbers, so unlike
                     * FDC.seekDrive(), we must NOT add 1 to bSector below.  I could change how sector numbers are stored in
                     * hard drive images, but it seems preferable to keep the image format consistent and controller-independent.
                     */
                    drive.bSector = (iSector % nSectorsPerTrack);
                    drive.nBytes = nSectors * aDiskInfo[3];
                    /*
                     * NOTE: We don't set nSectorEnd, as an HDC command would, but it's irrelevant, because we don't actually
                     * do anything with nSectorEnd at this point.  Perhaps someday, when we faithfully honor/restrict requests
                     * to a single track (or a single cylinder, in the case of multi-track requests).
                     */
                    drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                    /*
                     * At this point, we've finished simulating what an HDC.XTC.DATA.CMD.READ_DATA command would have performed,
                     * up through doRead().  Now it's the caller responsibility to call readData(), like the DMA Controller would.
                     */
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * autoMount(fRemount)
     *
     * @this {HDC}
     * @param {boolean} [fRemount] is true if we're remounting all auto-mounted disks
     * @return {boolean} true if one or more disk images are being auto-mounted, false if none
     */
    autoMount(fRemount)
    {
        if (!fRemount) this.cAutoMount = 0;

        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let drive = this.aDrives[iDrive];
            if (drive.name && drive.path) {

                if (fRemount && drive.disk && drive.disk.isRemote()) {
                    /*
                     * The Disk component has its own logic for remounting remote disks, so skip this disk.
                     *
                     * TODO: Consider rewriting how ALL disks are automounted/remounted, now that the Disk component
                     * is receiving its own powerDown() and powerUp() notifications (originally, it didn't receive them).
                     */
                    continue;
                }

                if (!this.loadDisk(iDrive, drive.name, drive.path, true) && fRemount)
                    this.setReady(false);
                continue;
            }
            if (fRemount && drive.type !== undefined) {
                drive.disk = null;
                this.verifyDrive(drive, drive.type);
            }
        }
        return !!this.cAutoMount;
    }

    /**
     * loadDisk(iDrive, sDiskName, sDiskPath, fAutoMount)
     *
     * @this {HDC}
     * @param {number} iDrive
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {boolean} fAutoMount
     * @return {boolean} true if disk (already) loaded, false if queued up (or busy)
     */
    loadDisk(iDrive, sDiskName, sDiskPath, fAutoMount)
    {
        let drive = this.aDrives[iDrive];
        if (drive.fBusy) {
            this.notice("Drive " + iDrive + " busy");
            return true;
        }
        drive.fBusy = true;
        if (fAutoMount) {
            drive.fAutoMount = true;
            this.cAutoMount++;
            if (this.messageEnabled()) this.printMessage("loading " + sDiskName);
        }
        let disk = drive.disk || new Disk(this, drive, drive.mode);
        /*
         * The following hacks should only be necessary for (old) saved states, since all our disk manifests
         * should no longer be using any of these old paths.
         */
        sDiskPath = sDiskPath.replace("/disks/pc/", "/disks/pcx86/");
        sDiskPath = sDiskPath.replace("/disks/pcx86/private/", "/private-disks/pcx86/");
        sDiskPath = sDiskPath.replace("/disks/pcx86/", "/pcjs-disks/pcx86/");
        sDiskPath = sDiskPath.replace("/fixed/", "/drives/");
        disk.load(sDiskName, sDiskPath, null, this.doneLoadDisk);
        return false;
    }

    /**
     * doneLoadDisk(drive, disk, sDiskName, sDiskPath)
     *
     * This is a callback issued by the Disk component once the load() operation has finished.
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {Disk} disk is set if the disk was successfully mounted, null if not
     * @param {string} sDiskName
     * @param {string} sDiskPath
     */
    doneLoadDisk(drive, disk, sDiskName, sDiskPath)
    {
        drive.fBusy = false;
        if ((drive.disk = disk)) {
            /*
             * With the addition of notice(), users are now "alerted" whenever a diskette has finished loading;
             * notice() is selective about its output, using print() if a print window is open, otherwise alert().
             *
             * WARNING: This conversion of drive number to drive letter, starting with "C:" (0x43), is very simplistic
             * and is not guaranteed to match the drive mapping that DOS ultimately uses.
             */
            this.notice("Mounted disk \"" + sDiskName + "\" in drive " + String.fromCharCode(0x43 + drive.iDrive), drive.fAutoMount);

            let aDiskInfo = disk.info();
            if (aDiskInfo[0] != drive.nCylinders || aDiskInfo[1] != drive.nHeads || aDiskInfo[2] != drive.nSectors || aDiskInfo[3] != drive.cbSector) {
                /*
                 * TODO: Decide how to deal with this problem; ie, either disallow disk access altogether, or automatically
                 * map the controller's I/O requests to the disk's geometry.  Also, we should provide a way to reformat such a
                 * disk so that its geometry matches the controller requirements.
                 */
                this.notice("Warning: disk geometry (" + aDiskInfo[0] + ':' + aDiskInfo[1] + ':' + aDiskInfo[2] + ") does not match " + HDC.aDriveTables[this.iDriveTable] + " drive type " + drive.type + " (" + drive.nCylinders + ':' + drive.nHeads + ':' + drive.nSectors + ")");
            }
        }
        if (drive.fAutoMount) {
            drive.fAutoMount = false;
            if (!--this.cAutoMount) this.setReady();
        }
    }

    /**
     * intXTCData(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x320)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inXTCData(port, addrFrom)
    {
        let bIn = 0;
        if (this.regDataIndex < this.regDataTotal) {
            bIn = this.regDataArray[this.regDataIndex];
        }
        if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.XTC);
        this.regStatus &= ~HDC.XTC.STATUS.INTERRUPT;

        this.printMessageIO(port, undefined, addrFrom, "DATA[" + this.regDataIndex + "]", bIn);
        if (++this.regDataIndex >= this.regDataTotal) {
            this.regDataIndex = this.regDataTotal = 0;
            this.regStatus &= ~(HDC.XTC.STATUS.IOMODE | HDC.XTC.STATUS.BUS | HDC.XTC.STATUS.BUSY);
        }
        return bIn;
    }

    /**
     * outXTCData(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x320)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCData(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "DATA[" + this.regDataTotal + "]");
        if (this.regDataTotal < this.regDataArray.length) {
            this.regDataArray[this.regDataTotal++] = bOut;
        }
        let bCmd = this.regDataArray[0];
        let cbCmd = (bCmd != HDC.XTC.DATA.CMD.INIT_DRIVE? 6 : this.regDataArray.length);
        if (this.regDataTotal == 6) {
            /*
             * XTC.STATUS.REQ must be CLEAR following any 6-byte command sequence that the HDC BIOS "COMMAND" function outputs,
             * yet it must also be SET before the HDC BIOS will proceed with the remaining the 8-byte sequence that's part of
             * HDC.XTC.DATA.CMD.INIT_DRIVE command. See inXTCStatus() for HACK details.
             */
            this.regStatus &= ~HDC.XTC.STATUS.REQ;
        }
        if (this.regDataTotal >= cbCmd) {
            /*
             * It's essential that XTC.STATUS.IOMODE be set here, at least after the final 8-byte HDC.XTC.DATA.CMD.INIT_DRIVE sequence.
             */
            this.regStatus |= HDC.XTC.STATUS.IOMODE;
            this.regStatus &= ~HDC.XTC.STATUS.REQ;
            this.doXTC();
        }
    }

    /**
     * inXTCStatus(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x321)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inXTCStatus(port, addrFrom)
    {
        let b = this.regStatus;
        this.printMessageIO(port, undefined, addrFrom, "STATUS", b);
        /*
         * HACK: The HDC BIOS will not finish the HDC.XTC.DATA.CMD.INIT_DRIVE sequence unless it sees XTC.STATUS.REQ set again, nor will
         * it read any of the XTC.DATA bytes returned from a HDC.XTC.DATA.CMD.REQUEST_SENSE command unless XTC.STATUS.REQ is set again, so
         * we turn it back on if there are unprocessed data bytes.
         */
        if (this.regDataIndex < this.regDataTotal) {
            this.regStatus |= HDC.XTC.STATUS.REQ;
        }
        return b;
    }

    /**
     * outXTCReset(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x321)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCReset(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "RESET");
        /*
         * Not sure what to do with this value, and the value itself may be "don't care", but we'll save it anyway.
         */
        this.regReset = bOut;
        if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.XTC);
        this.initController();
    }

    /**
     * inXTCConfig(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x322)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inXTCConfig(port, addrFrom)
    {
        this.printMessageIO(port, undefined, addrFrom, "CONFIG", this.regConfig);
        return this.regConfig;
    }

    /**
     * outXTCPulse(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x322)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCPulse(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "PULSE");
        /*
         * Not sure what to do with this value, and the value itself may be "don't care", but we'll save it anyway.
         */
        this.regPulse = bOut;
        /*
         * The HDC BIOS "COMMAND" function (@C800:0562) waits for these ALL status bits after writing to both regPulse
         * and regPattern, so we must oblige it.
         *
         * TODO: Figure out exactly when either XTC.STATUS.BUS or XTC.STATUS.BUSY are supposed to be cleared.
         * The HDC BIOS doesn't care much about them, except for the one location mentioned above. However, MS-DOS 4.0
         * (aka the unreleased "multitasking" version of MS-DOS) cares, so I'm going to start by clearing them at the
         * same point I clear XTC.STATUS.IOMODE.
         */
        this.regStatus = HDC.XTC.STATUS.REQ | HDC.XTC.STATUS.BUS | HDC.XTC.STATUS.BUSY;
    }

    /**
     * outXTCPattern(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x323)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCPattern(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "PATTERN");
        this.regPattern = bOut;
    }

    /**
     * outXTCNoise(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x327, 0x32B or 0x32F)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCNoise(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "NOISE");
    }

    /**
     * inATCByte(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F0)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inATCByte(port, addrFrom)
    {
        let bIn = -1;

        if (this.drive) {
            /*
             * We use the synchronous form of readData() at this point because we have no choice; an I/O instruction
             * has just occurred and cannot be delayed.  The good news is that doATCommand() should have already primed
             * the pump; all we can do is assert that the pump has something in it.  If bIn is inexplicably negative,
             * well, then the caller will get 0xff.
             */
            let hdc = this;
            bIn = this.readData(this.drive, function onATCReadData(b, fAsync, obj, off) {

                if (BACKTRACK) {
                    if (!off && obj.file && hdc.messageEnabled(Messages.DISK)) {
                        hdc.printMessage("loading " + obj.file.sPath + '[' + obj.offFile + "] via port " + Str.toHexWord(port), true);
                    }
                    /*
                     * TODO: We could define a cached BTO that's reset prior to a new ATC command, and then pass that
                     * to addBackTrackObject() here instead of null; but for now, we're going to rely on that function's
                     * simplistic MRU logic.  If that fails, the worst that will (or should) happen is we'll burn through
                     * more BackTrack wrapper objects than necessary, and risk running out.
                     */
                    let bto = hdc.bus.addBackTrackObject(obj, /** @type BackTrack */ (null), off);
                    hdc.cpu.backTrack.btiIO = hdc.bus.getBackTrackIndex(bto, off);
                }
            });


            if (this.drive.ibSector == 1 || this.drive.ibSector == this.drive.cbSector) {
                /*
                 * printMessageIO() calls, if enabled, can be overwhelming for this port, so limit them to the first
                 * and last bytes of each sector.
                 */
                if (this.messageEnabled(Messages.PORT | Messages.HDC)) {
                    this.printMessageIO(port, undefined, addrFrom, "DATA[" + this.drive.ibSector + "]", bIn);
                }
                if (this.drive.ibSector > 1) {      // in other words, if this.drive.ibSector == this.drive.cbSector...
                    if (this.messageEnabled(Messages.DATA | Messages.HDC)) {
                        let sDump = this.drive.disk.dumpSector(this.drive.sector);
                        if (sDump) this.dbg.message(sDump);
                    }
                    /*
                     * Now that we've supplied a full sector of data, see if the caller's expecting additional sectors;
                     * if so, prime the pump again.  The caller should not poll us again until another interrupt's delivered.
                     */
                    this.drive.nBytes -= this.drive.cbSector;
                    this.regSecCnt = (this.regSecCnt - 1) & 0xff;
                    /*
                     * TODO: If the WITH_ECC bit is set in the READ_DATA command, then we need to support "stuffing" 4
                     * additional bytes into the inATCByte() stream.  And we must first set DATA_REQ in the STATUS register.
                     */
                    if (this.drive.nBytes >= this.drive.cbSector) {
                        /*
                         * FYI, with regard to regStatus, I'm simply aping what the ATC.COMMAND.READ_DATA setup code does
                         * for the first sector, which may not strictly be necessary for subsequent sectors....
                         */
                        hdc.regStatus = HDC.ATC.STATUS.BUSY;
                        this.readData(this.drive, function onATCReadDataNext(b, fAsync) {
                            if (b >= 0) {
                                hdc.setATCIRR();
                                /*
                                 * Due to the way I'm immediately triggering an interrupt whenever more data is available,
                                 * I must take a "shotgun approach' to regStatus bits in order to make the MODEL_5170_REV1,
                                 * MODEL_5170_REV3, and MODEL_COMPAQ_DESKPRO386 all happy.
                                 *
                                 * In general, it's fine for all of STATUS.READY, STATUS.SEEK_OK and STATUS.DATA_REQ to be
                                 * set now; the MODEL_5170_REV3 requires at least the first two, and the MODEL_COMPAQ_DESKPRO386
                                 * requires the third.  Unfortunately, the outlier is the MODEL_5170_REV1, which also needs
                                 * the STATUS.BUSY to be set on the first regStatus read after it finishes reading a sector;
                                 * otherwise, the MODEL_5170_REV1 BIOS will never read any remaining sectors.
                                 *
                                 * Technically, it doesn't make sense for both BUSY and READY to be set at the same time,
                                 * so we fix that in inATCStatus() by clearing BUSY whenever READY is detected *after* that
                                 * first read.  In addition, since this hack is really only needed for the MODEL_5170_REV1,
                                 * we clear BUSY immediately on the MODEL_COMPAQ_DESKPRO386 (which makes the Windows 95
                                 * protected-mode disk driver much happier).
                                 */
                                if (hdc.chipset && hdc.chipset.model == ChipSet.MODEL_COMPAQ_DESKPRO386) hdc.regStatus = 0;
                                hdc.regStatus |= HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK | HDC.ATC.STATUS.DATA_REQ;
                            } else {
                                /*
                                 * TODO: It would be nice to be a bit more specific about the error (if any) that just occurred.
                                 * Consult drive.errorCode (it uses older XTC error codes, but mapping those codes should be trivial).
                                 */
                                hdc.regStatus = HDC.ATC.STATUS.ERROR;
                                hdc.regError = HDC.ATC.ERROR.NO_CHS;
                                if (DEBUG) hdc.printMessage(this.idComponent + ".inATCByte(): read failed");
                            }
                        }, false);
                    } else {

                        this.regStatus = HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK;
                    }
                }
            }
        }
        return bIn;
    }

    /**
     * inATCData(port, addrFrom)
     *
     * Wrapper around inATCByte() to treat this as a 16-bit port; see addPortInputWidth(HDC.ATC.DATA.PORT, 2).
     *
     * @this {HDC}
     * @param {number} port (0x1F0)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port data
     */
    inATCData(port, addrFrom)
    {
        return this.inATCByte(port, addrFrom) | (this.inATCByte(port, addrFrom) << 8);
    }

    /**
     * outATCByte(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F0)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCByte(port, bOut, addrFrom)
    {
        if (this.drive) {
            if (this.drive.nBytes >= this.drive.cbSector) {
                if (this.writeData(this.drive, bOut) < 0) {
                    /*
                     * TODO: It would be nice to be a bit more specific about the error (if any) that just occurred.
                     * Consult drive.errorCode (it uses older XTC error codes, but mapping those codes should be trivial).
                     */
                    this.regStatus = HDC.ATC.STATUS.ERROR;
                    this.regError = HDC.ATC.ERROR.NO_CHS;
                    if (DEBUG && this.messageEnabled()) {
                        this.printMessage(this.idComponent + ".outATCByte(" + Str.toHexByte(bOut) + "): write failed");
                    }
                }
                else if (this.drive.ibSector == 1 || this.drive.ibSector == this.drive.cbSector) {
                    /*
                     * printMessageIO() calls, if enabled, can be overwhelming for this port, so limit them to the first
                     * and last bytes of each sector.
                     */
                    if (this.messageEnabled(Messages.PORT | Messages.HDC)) {
                        this.printMessageIO(port, bOut, addrFrom, "DATA[" + this.drive.ibSector + "]");
                    }
                    if (this.drive.ibSector > 1) {      // in other words, if this.drive.ibSector == this.drive.cbSector...
                        if (this.messageEnabled(Messages.DATA | Messages.HDC)) {
                            let sDump = this.drive.disk.dumpSector(this.drive.sector);
                            if (sDump) this.dbg.message(sDump);
                        }
                        this.drive.nBytes -= this.drive.cbSector;
                        this.regSecCnt = (this.regSecCnt - 1) & 0xff;
                        this.setATCIRR(true);
                        this.regStatus = HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK;
                        if (this.drive.nBytes >= this.drive.cbSector) {
                            this.regStatus |= HDC.ATC.STATUS.DATA_REQ;
                        } else {

                        }
                    }
                }
            } else {
                /*
                 * TODO: What to do about unexpected writes? The number of bytes has exceeded what the command specified.
                 */
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage(this.idComponent + ".outATCByte(" + Str.toHexByte(bOut) + "): write exceeds count (" + this.drive.nBytes + ")");
                }
            }
        } else {
            /*
             * TODO: What to do about unexpected writes? No command was specified.
             */
            if (DEBUG && this.messageEnabled()) {
                this.printMessage(this.idComponent + ".outATCByte(" + Str.toHexByte(bOut) + "): write without command");
            }
        }
    }

    /**
     * outATCData(port, data, addrFrom)
     *
     * Wrapper around outATCByte() to treat this as a 16-bit port; see addPortOutputWidth(HDC.ATC.DATA.PORT, 2)
     *
     * @this {HDC}
     * @param {number} port (0x1F0)
     * @param {number} data
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCData(port, data, addrFrom)
    {
        this.outATCByte(port, data & 0xff, addrFrom);
        this.outATCByte(port, (data >> 8) & 0xff, addrFrom);
    }

    /**
     * inATCError(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F1)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inATCError(port, addrFrom)
    {
        let bIn = this.regError;
        this.printMessageIO(port, undefined, addrFrom, "ERROR", bIn);
        return bIn;
    }

    /**
     * outATCWPreC(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCWPreC(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "WPREC");
        this.regWPreC = bOut;
    }

    /**
     * inATCSecCnt(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F2)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inATCSecCnt(port, addrFrom)
    {
        let bIn = this.regSecCnt;
        this.printMessageIO(port, undefined, addrFrom, "SECCNT", bIn);
        return bIn;
    }

    /**
     * outATCSecCnt(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F2)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCSecCnt(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "SECCNT");
        this.regSecCnt = bOut;
    }

    /**
     * inATCSecNum(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F3)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inATCSecNum(port, addrFrom)
    {
        let bIn = this.regSecNum;
        this.printMessageIO(port, undefined, addrFrom, "SECNUM", bIn);
        return bIn;
    }

    /**
     * outATCSecNum(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F3)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCSecNum(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "SECNUM");
        this.regSecNum = bOut;
    }

    /**
     * inATCCylLo(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F4)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inATCCylLo(port, addrFrom)
    {
        let bIn = this.regCylLo;
        this.printMessageIO(port, undefined, addrFrom, "CYLLO", bIn);
        return bIn;
    }

    /**
     * outATCCylLo(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F4)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCCylLo(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "CYLLO");
        this.regCylLo = bOut;
    }

    /**
     * inATCCylHi(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F5)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inATCCylHi(port, addrFrom)
    {
        let bIn = this.regCylHi;
        this.printMessageIO(port, undefined, addrFrom, "CYLHI", bIn);
        return bIn;
    }

    /**
     * outATCCylHi(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F5)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCCylHi(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "CYLHI");
        this.regCylHi = bOut;
    }

    /**
     * inATCDrvHd(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F6)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inATCDrvHd(port, addrFrom)
    {
        let bIn = this.regDrvHd;
        this.printMessageIO(port, undefined, addrFrom, "DRVHD", bIn);
        return bIn;
    }

    /**
     * outATCDrvHd(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F6)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCDrvHd(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "DRVHD");
        this.regDrvHd = bOut;
        /*
         * The MODEL_5170_REV3 BIOS (see "POST2_CHK_HF2" @F000:14FC) probes for a 2nd hard drive when the number
         * of configured hard drives is something other than 2, using INT 0x13/AH=0x10.  This in turn calls the
         * BIOS "TST_RDY" function, which selects the drive in this register (see DRIVE_MASK), and then immediately
         * expects regStatus to reflect success or failure.
         *
         * We were always returning success, because no ATC command was actually issued, and so the user would
         * always get a spurious CMOS configuration error: "System Options Not Set-(Run SETUP)".
         *
         * So now we update regStatus here.  I'm not sure which status bits are normally set to indicate failure,
         * but it should be sufficient to set or clear the READY bit according to whether the drive exists or not.
         *
         * TODO: Dig into the ATC documentation some more, and determine what other situations, if any, regStatus
         * needs to be updated.
         *
         * UPDATE: The COMPAQ DeskPro 386 ROM BIOS requires setting STATUS.SEEK_OK in addition to STATUS.READY;
         * a quick retest of the MODEL_5170_REV3 BIOS suggests that it's happy with that change, so it's quite likely
         * that was the appropriate change all along.
         */
        let iDrive = (this.regDrvHd & HDC.ATC.DRVHD.DRIVE_MASK? 1 : 0);
        if (this.aDrives[iDrive]) {
            this.regStatus |= HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK;
        } else {
            this.regStatus &= ~HDC.ATC.STATUS.READY;
        }
    }

    /**
     * inATCStatus(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F7)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @return {number} simulated port value
     */
    inATCStatus(port, addrFrom)
    {
        let bIn = this.regStatus;
        this.printMessageIO(port, undefined, addrFrom, "STATUS", bIn);
        /*
         * Despite what IBM's documentation for the "Personal Computer AT Fixed Disk and Diskette Drive Adapter"
         * (August 31, 1984) says (ie, "A read of the status register clears interrupt request 14"), we cannot
         * unilaterally clear the IRQ on any read of STATUS.  For starters, that would completely break the PC AT
         * ROM BIOS; here's what it does for multi-sector reads:
         *
         *      (1) read sector (REP INSW)
         *      (2) check STATUS
         *      (3) check sector count, exit if done
         *      (4) wait for interrupt
         *      (5) repeat
         *
         * Since we set the IRR immediately after (1), we cannot immediately clear the IRR at (2), otherwise the
         * interrupt at (4) never happens.  So, maybe there are SOME situations where IRR should be cleared on
         * a read, but I don't know what they are.
         *
         *      if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.ATC);
         */
        if (this.regStatus & HDC.ATC.STATUS.READY) this.regStatus &= ~HDC.ATC.STATUS.BUSY;
        return bIn;
    }

    /**
     * outATCCommand(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F7)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCCommand(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "COMMAND");
        this.regCommand = bOut;
        if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.ATC);
        this.doATC();
    }

    /**
     * outATCFDR(port, bOut, addrFrom)
     *
     * This is referred to in IBM's docs as the "Fixed Disk Register" (write-only)
     *
     * @this {HDC}
     * @param {number} port (0x3F6)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCFDR(port, bOut, addrFrom)
    {
        this.printMessageIO(port, bOut, addrFrom, "FDR");
        /*
         * I'm not really sure if I should set HDC.ATC.DIAG.NO_ERROR in regError after *every* write where
         * HDC.ATC.FDR.RESET is clear, or only after it has transitioned from set to clear; since the BIOS only
         * requires the latter, I'm going to be conservative and restrict regError updates to the latter.
         */
        if ((this.regFDR & HDC.ATC.FDR.RESET) && !(bOut & HDC.ATC.FDR.RESET)) this.regError = HDC.ATC.DIAG.NO_ERROR;
        this.regFDR = bOut;
    }

    /**
     * doATC()
     *
     * Handles ATC (AT Controller) commands
     *
     * @this {HDC}
     */
    doATC()
    {
        let hdc = this;
        let fInterrupt = false;
        let bCmd = this.regCommand;
        let iDrive = (this.regDrvHd & HDC.ATC.DRVHD.DRIVE_MASK? 1 : 0);
        let nHead = this.regDrvHd & HDC.ATC.DRVHD.HEAD_MASK;
        let nCylinder = this.regCylLo | ((this.regCylHi & HDC.ATC.CYLHI.MASK) << 8);
        let nSector = this.regSecNum;
        let nSectors = this.regSecCnt || 256;

        this.iDrive = -1;
        this.drive = null;
        this.regError = HDC.ATC.ERROR.NONE;
        this.regStatus = HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK;

        let drive = this.aDrives[iDrive];
        if (!drive) {
            bCmd = -1;
        } else {
            /*
             * Update the Drive object with the new positional information associated with this command.
             */
            drive.wCylinder = nCylinder;
            drive.bHead = nHead;
            drive.bSector = nSector;
            drive.nBytes = nSectors * drive.cbSector;
            bCmd = (bCmd >= HDC.ATC.COMMAND.DIAGNOSE? bCmd : (bCmd & HDC.ATC.COMMAND.MASK));
            /*
             * Since the ATC doesn't use DMA, we must now set some additional Drive state for the benefit of any
             * follow-up I/O instructions.  For example, any subsequent inATCByte() and outATCByte() calls need to
             * know which drive to talk to ("this.drive"), to issue their own readData() and writeData() calls.
             *
             * The XTC didn't need this, because it used doRead(), doWrite(), doFormat() helper functions,
             * which reset the current drive's "sector" and "errorCode" properties themselves and then used DMA
             * functions that delivered drive data with direct calls to readData() and writeData().
             */
            drive.sector = null;
            drive.ibSector = 0;
            drive.errorCode = 0;
            this.iDrive = iDrive;
            this.drive = drive;
        }

        if (DEBUG && this.messageEnabled(Messages.HDC)) {
            this.printMessage(this.idComponent + ".doATC(" + Str.toHexByte(bCmd) + "): " + HDC.aATCCommands[bCmd], true);
        }

        switch (bCmd & HDC.ATC.COMMAND.MASK) {

        case HDC.ATC.COMMAND.RESTORE:               // 0x10
            /*
             * Physically, this retracts the heads to cylinder 0, but logically, there isn't anything to do.
             */
            fInterrupt = true;
            break;

        case HDC.ATC.COMMAND.READ_DATA:             // 0x20
            if (DEBUG && this.messageEnabled(Messages.HDC)) {
                this.printMessage(this.idComponent + ".doATCRead(" + iDrive + ',' + drive.wCylinder + ':' + drive.bHead + ':' + drive.bSector + ',' + nSectors + ")", true);
            }
            /*
             * We're using a call to readData() that disables auto-increment, so that once we've got the first
             * byte of the next sector, we can signal an interrupt without also consuming the first byte, allowing
             * inATCByte() to begin with that byte.
             */
            hdc.regStatus = HDC.ATC.STATUS.BUSY;
            this.readData(drive, function onATCReadDataFirst(b, fAsync) {
                if (b >= 0 && hdc.chipset) {
                    hdc.setATCIRR();
                    /*
                     * Bytes from the requested sector(s) will now be delivered via inATCByte().
                     *
                     * FYI, I'm taking a shotgun approach to these status bits: I need to clear STATUS.BUSY and
                     * set STATUS.DATA_REQ, because otherwise COMPAQ DeskPro 386 reads will fail, and I need to set
                     * the STATUS.READY and STATUS.SEEK_OK bits, because otherwise MODEL_5170_REV3 reads will fail.
                     */
                    hdc.regStatus = HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK | HDC.ATC.STATUS.DATA_REQ;
                } else {
                    /*
                     * TODO: It would be nice to be a bit more specific about the error (if any) that just occurred.
                     * Consult drive.errorCode (it uses older XTC error codes, but mapping those codes should be trivial).
                     */
                    hdc.regStatus = HDC.ATC.STATUS.ERROR;
                    hdc.regError = HDC.ATC.ERROR.NO_CHS;
                }
            }, false);
            break;

        case HDC.ATC.COMMAND.WRITE_DATA:            // 0x30
            if (DEBUG && this.messageEnabled(Messages.HDC)) {
                this.printMessage(this.idComponent + ".doATCWrite(" + iDrive + ',' + drive.wCylinder + ':' + drive.bHead + ':' + drive.bSector + ',' + nSectors + ")", true);
            }
            this.regStatus = HDC.ATC.STATUS.DATA_REQ;
            break;

        case HDC.ATC.COMMAND.READ_VERF:             // 0x40
            /*
             * Since the READ VERIFY command returns no data, once again, logically, there isn't much we HAVE to
             * to do, but... TODO: Verify that all the disk parameters are valid, and return an error if they're not.
             */
            fInterrupt = true;
            break;

        case HDC.ATC.COMMAND.SEEK:                  // 0x70
            /*
             * Physically, this moves the head(s) to the requested cylinder, but logically, there isn't anything to do;
             * in fact, we didn't even need this command for the MODEL_5170 ROM BIOS (the COMPAQ DeskPro 386 ROM BIOS was
             * another story).
             */
            fInterrupt = true;
            break;

        case HDC.ATC.COMMAND.DIAGNOSE:              // 0x90
            this.regError = HDC.ATC.DIAG.NO_ERROR;
            fInterrupt = true;
            break;

        case HDC.ATC.COMMAND.SETPARMS:              // 0x91
            /*
             * The documentation implies that the only parameters this command really affects are the number
             * of heads (from regDrvHd) and sectors/track (from regSecCnt) -- this despite the fact that the BIOS
             * programs all the other registers.  For a type 2 drive, that includes:
             *
             *      WPREC:   0x4B
             *      SECCNT:  0x11 (for 17 sectors per track)
             *      CYL:    0x100 (256 -- huh?)
             *      SECNUM:  0x0C (12 -- huh?)
             *      DRVHD:   0xA3 (max head of 0x03, for 4 total heads)
             *
             * The importance of SECCNT (nSectors) and DRVHD (nHeads) is controlling how multi-sector operations
             * advance to the next sector; see advanceSector().
             */


            drive.nHeads = nHead + 1;
            drive.nSectors = nSectors;
            fInterrupt = true;
            break;

        default:
            if (DEBUG && this.messageEnabled()) {
                this.printMessage(this.idComponent + ".doATC(" + Str.toHexByte(this.regCommand) + "): " + (bCmd < 0? ("invalid drive (" + iDrive + ")") : "unsupported operation"));
                if (MAXDEBUG && bCmd >= 0) this.dbg.stopCPU();
            }
            break;
        }

        if (fInterrupt) this.setATCIRR();
    }

    /**
     * setATCIRR(fWrite)
     *
     * Raise the ATC's IRQ, provided ATC interrupts are enabled.
     *
     * @this {HDC}
     * @param {boolean} [fWrite] is true on completion of a write to the sector buffer
     */
    setATCIRR(fWrite)
    {
        if (this.chipset) {
            if (!(this.regFDR & HDC.ATC.FDR.INT_DISABLE)) {
                /*
                 * TODO: Determine what the "correct" instruction delay should be here.  When the OS/2 1.0 Install Disk
                 * begins copying files to the hard drive, at one point it performs the following 125-sector write (use the
                 * Debugger's "m hdc on" and "m pic on" commands to enable HDC and PIC messages, along with "m data on"
                 * if you also want to see the actual sector data being written):
                 *
                 *      HDC.doATC(0x30): Write
                 *      HDC.doATCWrite(0,2:0:5,125)
                 *
                 * As the write progresses, you'll notice that the HDC interrupt after each sector occurs at decreasingly
                 * lower points in the stack, until we eventually start overwriting non-stack data:
                 *
                 *      getIRRVector(): IRQ 14 interrupting @0090:52A6 stack=0050:1906
                 *      getIRRVector(): IRQ 14 interrupting @0318:196B stack=0050:18D6
                 *      getIRRVector(): IRQ 14 interrupting @0318:196B stack=0050:18A6
                 *      ...
                 *      getIRRVector(): IRQ 14 interrupting @0318:196B stack=0050:1156
                 *
                 * At roughly this point, very bad things start happening.  I decided to try an arbitrarily large delay
                 * on the setIRR() call here (120), and the problem vanished, so it seems likely that the OS/2 disk driver
                 * has a low tolerance for fast controller interrupts during multi-sector operations.
                 */
                this.chipset.setIRR(ChipSet.IRQ.ATC, 120);
                if (DEBUG) this.printMessage(this.idComponent + ".setATCIRR(): enabled", Messages.PIC | Messages.HDC);
            } else {
                if (DEBUG) this.printMessage(this.idComponent + ".setATCIRR(): disabled", Messages.PIC | Messages.HDC);
            }
        }
    }

    /**
     * doXTC()
     *
     * Handles XTC (XT Controller) commands
     *
     * @this {HDC}
     */
    doXTC()
    {
        let hdc = this;
        this.regDataIndex = 0;

        let bCmd = this.popCmd();
        let bCmdOrig = bCmd;
        let b1 = this.popCmd();
        let bDrive = b1 & 0x20;
        let iDrive = (bDrive >> 5);

        let bHead = b1 & 0x1f;
        let b2 = this.popCmd();
        let b3 = this.popCmd();
        let wCylinder = ((b2 << 2) & 0x300) | b3;
        let bSector = b2 & 0x3f;
        let bCount = this.popCmd();             // block count or interleave count, depending on the command
        let bControl = this.popCmd();
        let bParm, bDataStatus;

        let drive = this.aDrives[iDrive];
        if (drive) {
            drive.wCylinder = wCylinder;
            drive.bHead = bHead;
            drive.bSector = bSector;
            drive.nBytes = bCount * drive.cbSector;
        }

        /*
         * I tried to save normal command processing from having to deal with invalid drives,
         * but the HDC BIOS initializes both drive 0 AND drive 1 on a HDC.XTC.DATA.CMD.INIT_DRIVE command,
         * and apparently that particular command has no problem with non-existent drives.
         *
         * So I've separated the commands into two groups: drive-ambivalent commands should be
         * processed in the first group, and all the rest should be processed in the second group.
         */
        switch (bCmd) {

        case HDC.XTC.DATA.CMD.REQUEST_SENSE:        // 0x03
            this.beginResult(drive? drive.errorCode : HDC.XTC.DATA.ERR.NOT_READY);
            this.pushResult(b1);
            this.pushResult(b2);
            this.pushResult(b3);
            /*
             * Although not terribly clear from IBM's "Fixed Disk Adapter" documentation, a data "status byte"
             * also follows the 4 "sense bytes".  Interestingly, The HDC BIOS checks that data status byte for
             * XTC.DATA.STATUS.ERROR, but I have to wonder if it would have ever been set for this command....
             *
             * The whole point of the HDC.XTC.DATA.CMD.REQUEST_SENSE command is to obtain details about a
             * previous error, so if HDC.XTC.DATA.CMD.REQUEST_SENSE itself reports an error, what would that mean?
             */
            this.pushResult(HDC.XTC.DATA.STATUS.OK | bDrive);
            bCmd = -1;                              // mark the command as complete
            break;

        case HDC.XTC.DATA.CMD.INIT_DRIVE:           // 0x0C
            /*
             * Pop off all the extra "Initialize Drive Characteristics" bytes and store them, for the benefit of
             * other functions, like verifyDrive().
             */
            let i = 0;
            while ((bParm = this.popCmd()) >= 0) {
                if (drive && i < drive.abDriveParms.length) {
                    drive.abDriveParms[i++] = bParm;
                }
            }
            if (drive) this.verifyDrive(drive);
            bDataStatus = HDC.XTC.DATA.STATUS.OK;
            if (!drive && this.iDriveAllowFail == iDrive) {
                this.iDriveAllowFail = -1;
                if (DEBUG) this.printMessage(this.idComponent + ".doXTC(): fake failure triggered");
                bDataStatus = HDC.XTC.DATA.STATUS.ERROR;
            }
            this.beginResult(bDataStatus | bDrive);
            bCmd = -1;                              // mark the command as complete
            break;

        case HDC.XTC.DATA.CMD.RAM_DIAGNOSTIC:       // 0xE0
        case HDC.XTC.DATA.CMD.CTL_DIAGNOSTIC:       // 0xE4
            this.beginResult(HDC.XTC.DATA.STATUS.OK | bDrive);
            bCmd = -1;                              // mark the command as complete
            break;

        default:
            break;
        }

        if (bCmd >= 0) {
            if (drive === undefined) {
                bCmd = -1;
            } else {
                /*
                 * In preparation for this command, zero out the drive's errorCode and senseCode.
                 * Commands that require a disk address should update senseCode with HDC.XTC.DATA.SENSE_ADDR_VALID.
                 * And of course, any command that encounters an error should set the appropriate error code.
                 */
                drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                drive.senseCode = 0;
            }
            switch (bCmd) {
            case HDC.XTC.DATA.CMD.TEST_READY:       // 0x00
                this.beginResult(HDC.XTC.DATA.STATUS.OK | bDrive);
                break;

            case HDC.XTC.DATA.CMD.RECALIBRATE:      // 0x01
                drive.bControl = bControl;
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage(this.idComponent + ".doXTC(): drive " + iDrive + " control byte: " + Str.toHexByte(bControl));
                }
                this.beginResult(HDC.XTC.DATA.STATUS.OK | bDrive);
                break;

            case HDC.XTC.DATA.CMD.READ_VERF:        // 0x05
                /*
                 * This is a non-DMA operation, so we simply pretend everything is OK for now.  TODO: Revisit.
                 */
                this.beginResult(HDC.XTC.DATA.STATUS.OK | bDrive);
                break;

            case HDC.XTC.DATA.CMD.READ_DATA:        // 0x08
                this.doRead(drive, function onXTCReadDataCommand(bStatus) {
                    hdc.beginResult(bStatus | bDrive);
                });
                break;

            case HDC.XTC.DATA.CMD.WRITE_DATA:       // 0x0A
                /*
                 * QUESTION: The IBM TechRef (p.1-188) implies that bCount is used as part of HDC.XTC.DATA.CMD.WRITE_DATA command,
                 * but it is omitted from the HDC.XTC.DATA.CMD.READ_DATA command.  Is that correct?  Note that, as far as the length
                 * of the transfer is concerned, we rely exclusively on the DMA controller being programmed with the appropriate byte count.
                 */
                this.doWrite(drive, function onXTCWriteDataCommand(bStatus) {
                    hdc.beginResult(bStatus | bDrive);
                });
                break;

            case HDC.XTC.DATA.CMD.WRITE_BUFFER:     // 0x0F
                this.doWriteBuffer(drive, function onXTCWriteBufferCommand(bStatus) {
                    hdc.beginResult(bStatus | bDrive);
                });
                break;

            default:
                this.beginResult(HDC.XTC.DATA.STATUS.ERROR | bDrive);
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage(this.idComponent + ".doXTC(" + Str.toHexByte(bCmdOrig) + "): " + (bCmd < 0? ("invalid drive (" + iDrive + ")") : "unsupported operation"));
                    if (MAXDEBUG && bCmd >= 0) this.dbg.stopCPU();
                }
                break;
            }
        }
    }

    /**
     * popCmd()
     *
     * @this {HDC}
     * @return {number}
     */
    popCmd()
    {
        let bCmd = -1;
        let bCmdIndex = this.regDataIndex;
        if (bCmdIndex < this.regDataTotal) {
            bCmd = this.regDataArray[this.regDataIndex++];
            if (DEBUG && this.messageEnabled((bCmdIndex > 0? Messages.PORT : 0) | Messages.HDC)) {
                this.printMessage(this.idComponent + ".popCmd(" + bCmdIndex + "): " + Str.toHexByte(bCmd) + (!bCmdIndex && HDC.aXTCCommands[bCmd]? (" (" + HDC.aXTCCommands[bCmd] + ")") : ""), true);
            }
        }
        return bCmd;
    }

    /**
     * beginResult(bResult)
     *
     * @this {HDC}
     * @param {number} [bResult]
     */
    beginResult(bResult)
    {
        this.regDataIndex = this.regDataTotal = 0;
        if (bResult !== undefined) this.pushResult(bResult);
        /*
         * After the Execution phase (eg, DMA Terminal Count has occurred, or the EOT sector has been read/written),
         * an interrupt is supposed to occur, signaling the beginning of the Result Phase.  Once the data "status byte"
         * has been read from XTC.DATA, the interrupt is cleared (see inXTCData).
         */
        if (this.chipset) this.chipset.setIRR(ChipSet.IRQ.XTC);
        this.regStatus |= HDC.XTC.STATUS.INTERRUPT;
    }

    /**
     * pushResult(bResult)
     *
     * @this {HDC}
     * @param {number} bResult
     */
    pushResult(bResult)
    {
        if (DEBUG && this.messageEnabled((this.regDataTotal > 0? Messages.PORT : 0) | Messages.HDC)) {
            this.printMessage(this.idComponent + ".pushResult(" + this.regDataTotal + "): " + Str.toHexByte(bResult), true);
        }
        this.regDataArray[this.regDataTotal++] = bResult;
    }

    /**
     * doDMARead(drive, b, done)
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} b
     * @param {function(number,boolean)} done
     */
    doDMARead(drive, b, done)
    {
        if (b === undefined || b < 0) {
            this.readData(drive, done);
            return;
        }
        /*
         * The DMA controller should be ASKING for data, not GIVING us data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printMessage(this.idComponent + ".doDMARead(): invalid DMA acknowledgement");
        done(-1, false);
    }

    /**
     * doDMAWrite(drive, b)
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} b
     * @return {number}
     */
    doDMAWrite(drive, b)
    {
        if (b !== undefined && b >= 0)
            return this.writeData(drive, b);
        /*
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printMessage(this.idComponent + ".doDMAWrite(): invalid DMA acknowledgement");
        return -1;
    }

    /**
     * doDMAWriteBuffer(drive, b)
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} b
     * @return {number}
     */
    doDMAWriteBuffer(drive, b)
    {
        if (b !== undefined && b >= 0)
            return this.writeBuffer(drive, b);
        /*
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printMessage(this.idComponent + ".doDMAWriteBuffer(): invalid DMA acknowledgement");
        return -1;
    }

    /**
     * doDMAWriteFormat(drive, b)
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} b
     * @returns {number}
     */
    doDMAWriteFormat(drive, b)
    {
        if (b !== undefined && b >= 0)
            return this.writeFormat(drive, b);
        /*
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printMessage(this.idComponent + ".doDMAWriteFormat(): invalid DMA acknowledgement");
        return -1;
    }

    /**
     * doRead(drive, done)
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {function(number)} done (dataStatus is XTC.DATA.STATUS.OK or XTC.DATA.STATUS.ERROR; if error, then drive.errorCode should be set as well)
     */
    doRead(drive, done)
    {
        drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;

        if (DEBUG && this.messageEnabled()) {
            this.printMessage(this.idComponent + ".doRead(" + drive.iDrive + ',' + drive.wCylinder + ':' + drive.bHead + ':' + drive.bSector + ',' + ((drive.nBytes / drive.cbSector)|0) + ")");
        }

        if (drive.disk) {
            drive.sector = null;
            if (this.chipset) {
                /*
                 * We need to reverse the original logic, and default to success unless/until an actual error occurs;
                 * otherwise doDMARead()/readData() will bail on us.  The original approach used to work because requestDMA()
                 * would immediately call us back with fComplete set to true EVEN if the DMA channel was not yet unmasked;
                 * now the callback is deferred until the DMA channel has been unmasked and the DMA request has finished.
                 */
                drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                this.chipset.connectDMA(ChipSet.DMA_HDC, this, 'dmaRead', drive);
                this.chipset.requestDMA(ChipSet.DMA_HDC, function onDMAReadRequest(fComplete) {
                    if (!fComplete) {
                        /*
                         * If an incomplete request wasn't triggered by an explicit error, then let's make explicit
                         * (ie, revert to the default failure code that we originally set above).
                         */
                        if (drive.errorCode == HDC.XTC.DATA.ERR.NONE) {
                            drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
                        }
                    }
                    done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
                });
                return;
            }
        }
        done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
    }

    /**
     * doWrite(drive, done)
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {function(number)} done (dataStatus is XTC.DATA.STATUS.OK or XTC.DATA.STATUS.ERROR; if error, then drive.errorCode should be set as well)
     */
    doWrite(drive, done)
    {
        drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;

        if (DEBUG && this.messageEnabled()) {
            this.printMessage(this.idComponent + ".doWrite(" + drive.iDrive + ',' + drive.wCylinder + ':' + drive.bHead + ':' + drive.bSector + ',' + ((drive.nBytes / drive.cbSector)|0) + ")");
        }

        if (drive.disk) {
            drive.sector = null;
            if (this.chipset) {
                /*
                 * We need to reverse the original logic, and default to success unless/until an actual error occurs;
                 * otherwise doDMAWrite()/writeData() will bail on us.  The original approach would work because requestDMA()
                 * would immediately call us back with fComplete set to true EVEN if the DMA channel was not yet unmasked;
                 * now the callback is deferred until the DMA channel has been unmasked and the DMA request has finished.
                 */
                drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                this.chipset.connectDMA(ChipSet.DMA_HDC, this, 'dmaWrite', drive);
                this.chipset.requestDMA(ChipSet.DMA_HDC, function onDMAWriteRequest(fComplete) {
                    if (!fComplete) {
                        /*
                         * If an incomplete request wasn't triggered by an explicit error, then let's make explicit
                         * (ie, revert to the default failure code that we originally set above).
                         */
                        if (drive.errorCode == HDC.XTC.DATA.ERR.NONE) {
                            drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
                        }
                        /*
                         * Mask any error that's the result of an attempt to write beyond the end of the track (which is
                         * something the MS-DOS 4.0M's FORMAT utility seems to like to do).
                         */
                        if (drive.errorCode == HDC.XTC.DATA.ERR.NO_SECTOR) {
                            drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                        }
                    }
                    done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
                });
                return;
            }
        }
        done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
    }

    /**
     * doWriteBuffer(drive, done)
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {function(number)} done (dataStatus is XTC.DATA.STATUS.OK or XTC.DATA.STATUS.ERROR; if error, then drive.errorCode should be set as well)
     */
    doWriteBuffer(drive, done)
    {
        drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;

        if (DEBUG) this.printMessage(this.idComponent + ".doWriteBuffer()");

        if (!drive.abSector || drive.abSector.length != drive.nBytes) {
            drive.abSector = new Array(drive.nBytes);
        }
        drive.ibSector = 0;
        if (this.chipset) {
            /*
             * We need to reverse the original logic, and default to success unless/until an actual error occurs;
             * otherwise doDMAWriteBuffer() will bail on us.  The original approach would work because requestDMA()
             * would immediately call us back with fComplete set to true EVEN if the DMA channel was not yet unmasked;
             * now the callback is deferred until the DMA channel has been unmasked and the DMA request has finished.
             */
            drive.errorCode = HDC.XTC.DATA.ERR.NONE;
            this.chipset.connectDMA(ChipSet.DMA_HDC, this, 'dmaWriteBuffer', drive);
            this.chipset.requestDMA(ChipSet.DMA_HDC, function onDMAWriteBufferRequest(fComplete) {
                if (!fComplete) {
                    /*
                     * If an incomplete request wasn't triggered by an explicit error, then let's make explicit
                     * (ie, revert to the default failure code that we originally set above).
                     */
                    if (drive.errorCode == HDC.XTC.DATA.ERR.NONE) {
                        drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
                    }
                }
                done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
            });
            return;
        }
        done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
    }

    /**
     * readData(drive, done)
     *
     * The following drive variable properties must have been setup prior to our first call:
     *
     *      drive.wCylinder
     *      drive.bHead
     *      drive.bSector
     *      drive.sector (initialized to null)
     *
     * On the first readData() request, since drive.sector will be null, we ask the Disk object to look
     * up the first sector of the request.  We then ask the Disk for bytes from that sector until the sector
     * is exhausted, and then we look up the next sector and continue the process.
     *
     * NOTE: Since the HDC isn't aware of the extent of the transfer, all readData() can do is return bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {function(number,boolean,Object,number)} [done] (number is next available byte from drive, or -1 if no more bytes available)
     * @param {boolean} [fAutoInc] (default is true to auto-increment)
     * @return {number} the requested byte, or -1 if unavailable
     */
    readData(drive, done, fAutoInc)
    {
        let b = -1;
        let obj = null, off = 0;    // these variables are purely for BACKTRACK purposes

        if (drive.errorCode) {
            if (done) done(b, false, obj, off);
            return b;
        }

        let inc = (fAutoInc !== false? 1 : 0);

        if (drive.sector) {
            off = drive.ibSector;
            b = drive.disk.read(drive.sector, drive.ibSector);
            drive.ibSector += inc;
            if (b >= 0) {
                obj = drive.sector;
                if (done) done(b, false, obj, off);
                return b;
            }
        }

        /*
         * Locate the next sector, and then try reading again.
         *
         * Important difference between the FDC and the XTC: the XTC uses 0-based sector numbers,
         * hence the bSectorBias below.  I could change how sector numbers are stored in the image,
         * but it seems preferable to keep the image format consistent and controller-independent.
         */
        if (done) {
            let hdc = this;
            if (drive.disk) {
                drive.disk.seek(drive.wCylinder, drive.bHead, drive.bSector + drive.bSectorBias, false, function onReadDataSeek(sector, fAsync) {
                    if ((drive.sector = sector)) {
                        obj = sector;
                        off = drive.ibSector = 0;
                        /*
                         * We "pre-advance" bSector et al now, instead of waiting to advance it right before the seek().
                         * This allows the initial call to readData() to perform a seek without triggering an unwanted advance.
                         */
                        hdc.advanceSector(drive);
                        b = drive.disk.read(drive.sector, drive.ibSector);
                        drive.ibSector += inc;
                    } else {
                        drive.errorCode = HDC.XTC.DATA.ERR.NO_SECTOR;
                    }
                    done(b, fAsync, obj, off);
                });
                return b;
            }
            drive.errorCode = HDC.XTC.DATA.ERR.NO_SECTOR;
            done(b, false, obj, off);
        }
        return b;
    }

    /**
     * writeData(drive, b)
     *
     * The following drive variable properties must have been setup prior to our first call:
     *
     *      drive.wCylinder
     *      drive.bHead
     *      drive.bSector
     *      drive.sector (initialized to null)
     *
     * On the first writeData() request, since drive.sector will be null, we ask the Disk object to look
     * up the first sector of the request.  We then send the Disk bytes for that sector until the sector
     * is full, and then we look up the next sector and continue the process.
     *
     * NOTE: Since the HDC isn't aware of the extent of the transfer, all writeData() can do is accept bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} b containing next byte to write
     * @return {number} (b unchanged; return -1 if command should be terminated)
     */
    writeData(drive, b)
    {
        if (drive.errorCode) return -1;
        do {
            if (drive.sector) {
                if (drive.disk.write(drive.sector, drive.ibSector++, b))
                    break;
            }
            /*
             * Locate the next sector, and then try writing again.
             *
             * Important difference between the FDC and the XTC: the XTC uses 0-based sector numbers,
             * hence the bSectorBias below.  I could change how sector numbers are stored in the image,
             * but it seems preferable to keep the image format consistent and controller-independent.
             */
            if (drive.disk) {
                drive.disk.seek(drive.wCylinder, drive.bHead, drive.bSector + drive.bSectorBias, true, function onWriteDataSeek(sector, fAsync) {
                    drive.sector = sector;
                });
            }
            if (!drive.sector) {
                drive.errorCode = HDC.XTC.DATA.ERR.NO_SECTOR;
                b = -1;
                break;
            }
            drive.ibSector = 0;
            /*
             * We "pre-advance" bSector et al now, instead of waiting to advance it right before the seek().
             * This allows the initial call to writeData() to perform a seek without triggering an unwanted advance.
             */
            this.advanceSector(drive);
        } while (true);
        return b;
    }

    /**
     * advanceSector(drive)
     *
     * This increments the sector number; when the sector number reaches drive.nSectors on the current track, we
     * increment drive.bHead and reset drive.bSector, and when drive.bHead reaches drive.nHeads, we reset drive.bHead
     * and increment drive.wCylinder.
     *
     * One wrinkle is that the ATC uses 1-based sector numbers (bSectorBias is 0), whereas the XTC uses 0-based sector
     * numbers (bSectorBias is 1).  Thus, the correct "reset" value for bSector is (1 - bSectorBias), and the correct
     * limit for bSector is (nSectors + bSectorStart).
     *
     * @this {HDC}
     * @param {Object} drive
     */
    advanceSector(drive)
    {

        drive.bSector++;
        let bSectorStart = (1 - drive.bSectorBias);
        if (drive.bSector >= drive.nSectors + bSectorStart) {
            drive.bSector = bSectorStart;
            drive.bHead++;
            if (drive.bHead >= drive.nHeads) {
                drive.bHead = 0;
                drive.wCylinder++;
            }
        }
    }

    /**
     * writeBuffer(drive, b)
     *
     * NOTE: Since the HDC isn't aware of the extent of the transfer, all writeBuffer() can do is accept bytes
     * until the buffer is full.
     *
     * TODO: Support for HDC.XTC.DATA.CMD.READ_BUFFER is missing, and support for HDC.XTC.DATA.CMD.WRITE_BUFFER may not be complete;
     * tests required.
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} b containing next byte to write
     * @return {number} (b unchanged; return -1 if command should be terminated)
     */
    writeBuffer(drive, b)
    {
        if (drive.ibSector < drive.abSector.length) {
            drive.abSector[drive.ibSector++] = b;
        } else {
            /*
             * TODO: Determine the proper error code to return here.
             */
            drive.errorCode = HDC.XTC.DATA.ERR.NO_SECTOR;
            b = -1;
        }
        return b;
    }

    /**
     * writeFormat(drive, b)
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {number} b containing a format command byte
     * @return {number} (b if successful, -1 if command should be terminated)
     */
    writeFormat(drive, b)
    {
        if (drive.errorCode) return -1;
        drive.abFormat[drive.cbFormat++] = b;
        if (drive.cbFormat == drive.abFormat.length) {
            drive.wCylinder = drive.abFormat[0];    // C
            drive.bHead = drive.abFormat[1];        // H
            drive.bSector = drive.abFormat[2];      // R
            drive.nBytes = 128 << drive.abFormat[3];// N (0 => 128, 1 => 256, 2 => 512, 3 => 1024)
            drive.cbFormat = 0;

            if (DEBUG && this.messageEnabled()) {
                this.printMessage(this.idComponent + ".writeFormat(" + drive.wCylinder + ":" + drive.bHead + ":" + drive.bSector + ":" + drive.nBytes + ")");
            }

            for (let i = 0; i < drive.nBytes; i++) {
                if (this.writeData(drive, drive.bFiller) < 0) {
                    return -1;
                }
            }
            drive.cSectorsFormatted++;
        }
        if (drive.cSectorsFormatted >= drive.bSectorEnd) b = -1;
        return b;
    }

    /**
     * intBIOSDisk(addr)
     *
     * NOTE: This function differentiates HDC requests from FDC requests, based on whether the INT 0x13 drive number
     * in DL is >= 0x80.
     *
     * HACK: The HDC BIOS code for both INT 0x13/AH=0x00 and INT 0x13/AH=0x09 calls "INIT_DRV" @C800:0427, which is
     * hard-coded to issue the HDC.XTC.DATA.CMD.INIT_DRIVE command for BOTH drives 0 and 1 (aka drive numbers 0x80 and
     * 0x81), regardless of the drive number specified in DL; this means that the HDC.XTC.DATA.CMD.INIT_DRIVE command
     * must always succeed for drive 1 if it also succeeds for drive 0 -- even if there is no drive 1.  Bizarre, but OK,
     * whatever.
     *
     * So assuming we a have drive 0, when the power-on diagnostics in "DISK_SETUP" @C800:0003 call INT 0x13/AH=0x09
     * (@C800:00DB) for drive 0, it must succeed.  No problem.  But when "DISK_SETUP" starts probing for additional drives,
     * it first issues INT 0x13/AH=0x00, followed by INT 0x13/AH=0x11, and finally INT 0x13/AH=0x09.  If the first
     * (AH=0x00) or third (AH=0x09) INT 0x13 fails, it quickly moves on (ie, it jumps to "POD_DONE").  But as we just
     * discussed, both those operations call "INIT_DRV", which can't return an error.  This means the only function that
     * can return an error in this context is the recalibrate function (AH=0x11).  That sucks, because the way the HDC
     * BIOS is written, it will loop for anywhere from 1.5 seconds to 25 seconds (depending on whether the controller
     * is part of the "System Unit" or not; see port 0x213), attempting to recalibrate drive 1 until it finally times out.
     *
     * Normally, you'll only experience the 1.5 second delay, but even so, it's a ridiculous waste of time and a lot of
     * useless INT 0x13 calls.  So I monitor INT 0x13/AH=0x00 for DL >= 0x80 and set a special HDC.XTC.DATA.CMD.INIT_DRIVE
     * override flag (iDriveAllowFail) that will allow that command to fail, and in theory, make the the HDC BIOS
     * "DISK_SETUP" code much more efficient.
     *
     * @this {HDC}
     * @param {number} addr
     * @return {boolean} true to proceed with the INT 0x13 software interrupt, false to skip
     */
    intBIOSDisk(addr)
    {
        let AH = this.cpu.regEAX >> 8;
        let DL = this.cpu.regEDX & 0xff;
        if (!AH && DL > 0x80) this.iDriveAllowFail = DL - 0x80;
        return true;
    }

    /**
     * intBIOSDiskette(addr)
     *
     * When the HDC BIOS overwrites the ROM BIOS INT 0x13 address, it saves the original INT 0x13 address
     * in the INT 0x40 vector.  This function intercepts calls to that vector to work around a minor nuisance.
     *
     * The HDC BIOS's plan was simple, albeit slightly flawed: assign fixed disks drive numbers >= 0x80,
     * and whenever someone calls INT 0x13 with a drive number < 0x80, invoke the original INT 0x13 diskette
     * code via INT 0x40 and return via RET 2.
     *
     * Unfortunately, not all original INT 0x13 functions required a drive number in DL (eg, the "reset"
     * function, where AH=0).  And the HDC BIOS knew this, which is why, in the case of the "reset" function,
     * the HDC BIOS performs BOTH an INT 0x40 diskette reset AND an HDC reset -- it can't be sure which
     * controller the caller really wants to reset.
     *
     * An unfortunate side-effect of this behavior: when the HDC BIOS is initialized for the first time, it may
     * issue several resets internally, depending on whether there are 0, 1 or 2 hard drives installed, and each
     * of those resets also triggers completely useless diskette resets, each wasting up to two seconds waiting
     * for the FDC to interrupt.  The FDC tries to interrupt, but it can't, because at this early stage of
     * ROM BIOS initialization, IRQ.FDC hasn't been unmasked yet.
     *
     * My work-around: have the HDC component hook INT 0x40, and every time an INT 0x40 is issued with AH=0 and
     * IRQ.FDC masked, bypass the INT 0x40 interrupt.  This is as close as PCx86 has come to patching any BIOS code
     * (something I've refused to do), and even here, I'm not doing it out of necessity, just annoyance.
     *
     * @this {HDC}
     * @param {number} addr
     * @return {boolean} true to proceed with the INT 0x40 software interrupt, false to skip
     */
    intBIOSDiskette(addr)
    {
        let AH = this.cpu.regEAX >> 8;
        if ((!AH && this.chipset && this.chipset.checkIMR(ChipSet.IRQ.FDC))) {
            if (DEBUG) this.printMessage(this.idComponent + ".intBIOSDiskette(): skipping useless INT 0x40 diskette reset");
            return false;
        }
        return true;
    }

    /**
     * unloadDrive(iDrive)
     *
     * NOTE: At the moment, we support only auto-mounts; there is no user interface for selecting hard drive
     * images, let alone unloading them, so there is currently no need for the following function.
     *
     * @this {HDC}
     * @param {number} iDrive
     *
     unloadDrive(iDrive)
     {
        this.aDrives[iDrive].disk = null;
        //
        // WARNING: This conversion of drive number to drive letter, starting with "C:" (0x43), is very simplistic
        // and is not guaranteed to match the drive mapping that DOS ultimately uses.
        //
        this.notice("Drive " + String.fromCharCode(0x43 + iDrive) + " unloaded");
    }
     */

    /**
     * doFormat(drive, done)
     *
     * The drive variable is initialized by doXTC() to the following extent:
     *
     *      drive.bHead (ignored)
     *      drive.nBytes (bytes/sector)
     *      drive.bSectorEnd (sectors/track)
     *      drive.bFiller (fill byte)
     *
     * and we expect the DMA controller to provide C, H, R and N (ie, 4 bytes) for each sector to be formatted.
     *
     * NOTE: This function is not currently used.
     *
     * @this {HDC}
     * @param {Object} drive
     * @param {function(number)} done (dataStatus is XTC.DATA.STATUS.OK or XTC.DATA.STATUS.ERROR; if error, then drive.errorCode should be set as well)
     *
     doFormat(drive, done)
     {
         drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;

         if (drive.disk) {
             drive.sector = null;
             if (this.chipset) {
                 drive.cbFormat = 0;
                 drive.abFormat = new Array(4);
                 drive.bFormatting = true;
                 drive.cSectorsFormatted = 0;
                 //
                 // We need to reverse the original logic, and default to success unless/until an actual error occurs;
                 // otherwise doDMAWriteFormat() will bail on us.  The original approach would work because requestDMA()
                 // would immediately call us back with fComplete set to true EVEN if the DMA channel was not yet unmasked;
                 // now the callback is deferred until the DMA channel has been unmasked and the DMA request has finished.
                 //
                 drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                 this.chipset.connectDMA(ChipSet.DMA_HDC, this, 'dmaWriteFormat', drive);
                 this.chipset.requestDMA(ChipSet.DMA_HDC, function onDMAFormat(fComplete) {
                     if (!fComplete) {
                         //
                         // If an incomplete request wasn't triggered by an explicit error, then let's make explicit
                         // (ie, revert to the default failure code that we originally set above).
                         //
                         if (drive.errorCode == HDC.XTC.DATA.ERR.NONE) {
                             drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
                         }
                     }
                     drive.bFormatting = false;
                     done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
                 });
                 return;
             }
         }
         done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
     }
     */

    /**
     * HDC.init()
     *
     * This function operates on every HTML element of class "hdc", extracting the
     * JSON-encoded parameters for the HDC constructor from the element's "data-value"
     * attribute, invoking the constructor to create a HDC component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeHDC = Component.getElementsByClass(document, PCX86.APPCLASS, "hdc");
        for (let iHDC = 0; iHDC < aeHDC.length; iHDC++) {
            let eHDC = aeHDC[iHDC];
            let parmsHDC = Component.getComponentParms(eHDC);
            let hdc = new HDC(parmsHDC);
            Component.bindComponentControls(hdc, eHDC, PCX86.APPCLASS);
        }
    }
}

/*
 * HDC defaults, in case drive parameters weren't specified
 */
HDC.DEFAULT_DRIVE_NAME = "Hard Drive";

/*
 * Starting with the IBM PC XT, the ROM defined a "Fixed Disk Parameter Table" (FD_TBL) that contained 16 bytes
 * at the following offsets for each of 4 drive types (see IBM 5160 Tech Ref, April 1983, p. A-94):
 *
 *      0: maximum number of cylinders (word)
 *      2: maximum number of heads
 *      3: starting reduced write current cylinder (word)
 *      5: starting write precompensation cylinder (word)
 *      7: maximum ECC data burst length
 *      8: control byte (drive step option)
 *          bit 7: disable disk-access retries
 *          bit 6: disable ECC retries
 *          bits 5-3: zero
 *          bits 2-0: drive option
 *      9: standard time-out value
 *      A: time-out value for format drive
 *      B: time-out value for check drive
 *      C: reserved
 *      D: reserved
 *      E: reserved
 *      F: reserved
 *
 * Starting with the IBM PC AT, the ROM defined a "Fixed Disk Parameter Table" (FD_TBL) that contained 16 bytes
 * at the following offsets for each of 47 drive types (see IBM 5170 Tech Ref, March 1986, p. 5-185):
 *
 *      0: maximum number of cylinders (word)
 *      2: maximum number of heads
 *      3: not used
 *      5: starting write precompensation cylinder (word)
 *      7: not used
 *      8: control byte (drive step option)
 *          bit 7: disable retries -OR-
 *          bit 6: disable retries
 *          bit 3: more than 8 heads
 *      9: not used
 *      A: not used
 *      B: not used
 *      C: landing zone (word)
 *      E: number of sectors/track (NOTE: all PC AT drive types specified 17 sectors/track)
 *      F: reserved
 *
 * NOTE: While drive type 0 was a valid type in the PC XT, it was NOT a valid drive type in the PC AT; zero was used
 * to indicate that no hard drive was installed.
 *
 * Of the 47 PC AT drive types, the first 14 (1-E) could be selected by 4 bits in CMOS byte 0x12.  Drive type 15 was not
 * a valid type but rather an indicator that CMOS byte 0x19 (or 0x1A) contained the actual drive type, which technically
 * could contain any value from 0-255, but was documented as being limited to values 16-255.  And in fact, the ROM only
 * contained entries for drive types 1-47, and of those, only drive types 1-14 and 16-23 were valid; the rest (15 and 24-47)
 * were marked "RESERVED" and contained zeros.
 *
 * If a system needed a drive type that wasn't defined by the ROM, it could be placed in RAM, as the ROM explained:
 *
 *      To dynamically define a set of parameters, build a table for up to 15 types and place
 *      the corresponding vector into interrupt 0x41 for drive 0 and interrupt 0x46 for drive 1.
 *
 * To make PCjs easier to configure, we have three drive tables (for XT, AT, and COMPAQ machines), each of which
 * contains DriveArrays for the various DriveTypes supported by each machine.  Each DriveArray contains the following
 * subset of "Fixed Disk Parameter Table" information:
 *
 *      [0]: total cylinders
 *      [1]: total heads
 *      [2]: total sectors/tracks (optional; default is 17)
 *      [3]: total bytes/sector (optional; default is 512)
 *
 * verifyDrive() attempts to confirm that these values agree with the programmed drive characteristics.
 *
 * NOTE: For the record, PCjs considers 1Kb to be 1 kilobyte (1,024 bytes, not 1,000 bytes) and 1Mb to be 1 megabyte
 * (1024*1024 or 1,048,576 bytes, not 1,000,000 bytes).
 *
 * Apparently, in 1998, it was decided that a kilobyte should be 1,000 bytes and a megabyte should be 1,000,000 bytes,
 * and that if you really meant 2^10 (1,024) or 2^20 (1,048,576), you should use "kibibyte" (KiB) or "mebibyte" (MiB)
 * instead.  But since PCjs simulates machines that pre-date 1998, I have chosen to retain the more "traditional"
 * understanding of Kb and Mb; I never use KiB or MiB.
 */

/*
 * Drive type tables differed across IBM controller models (XTC drive types don't match ATC drive types) and across OEMs
 * (eg, COMPAQ drive types only match a few IBM drive types), so you must use iDriveTable to index the correct table type
 * inside both aDriveTables and aDriveTypes.
 */
HDC.aDriveTables = ["XTC", "ATC", "COMPAQ"];

HDC.aDriveTypes = [
    /*
     * aDriveTypes[0] is for the IBM PC XT (XTC) controller.
     */
    {
         0: [306, 2],
         1: [375, 8],
         2: [306, 6],
         3: [306, 4]            // 10Mb (10.16Mb: 306*4*17*512 or 10,653,696 bytes) (default XTC drive type: 3)
    },
    /*
     * aDriveTypes[1] is for the IBM PC AT (ATC) controller.
     *
     * The following is a more complete description of the drive types supported by the MODEL_5170, where C is
     * Cylinders, H is Heads, WP is Write Pre-Comp, and LZ is Landing Zone (in practice, we don't need WP or LZ).
     *
     * Type    C    H   WP   LZ
     * ----  ---   --  ---  ---
     *   1   306    4  128  305
     *   2   615    4  300  615
     *   3   615    6  300  615
     *   4   940    8  512  940
     *   5   940    6  512  940
     *   6   615    4   no  615
     *   7   462    8  256  511
     *   8   733    5   no  733
     *   9   900   15   no  901
     *  10   820    3   no  820
     *  11   855    5   no  855
     *  12   855    7   no  855
     *  13   306    8  128  319
     *  14   733    7   no  733
     *  15  (reserved--all zeros)
     *  16   612    4  all  663
     *  17   977    5  300  977
     *  18   977    7   no  977
     *  19  1024    7  512 1023
     *  20   733    5  300  732
     *  21   733    7  300  732
     *  22   733    5  300  733
     *  23   306    4   no  336
     */
    {
         1: [306,  4],          // 10Mb (10.16Mb:  306*4*17*512 or 10,653,696 bytes)
         2: [615,  4],          // 20Mb (20.42Mb:  615*4*17*512 or 21,411,840 bytes) (default ATC drive type)
         3: [615,  6],          // 31Mb (30.63Mb:  615*6*17*512 or 32,117,760 bytes)
         4: [940,  8],          // 62Mb (62.42Mb:  940*8*17*512 or 65,454,080 bytes)
         5: [940,  6],          // 47Mb (46.82Mb:  940*6*17*512 or 49,090,560 bytes)
         6: [615,  4],
         7: [462,  8],
         8: [733,  5],
         9: [900, 15],
        10: [820,  3],
        11: [855,  5],
        12: [855,  7],
        13: [306,  8],
        14: [733,  7],
        /*
         * Since the remaining drive types are > 14, they must be stored in either EXTHDRIVE0 or EXTHDRIVE1 CMOS bytes (0x19 or 0x1A)
         */
        16: [612,  4],
        17: [977,  5],
        18: [977,  7],
        19: [1024, 7],
        20: [733,  5],
        21: [733,  7],
        22: [733,  5],
        23: [306,  4]
    },
    /*
     * aDriveTypes[2] is for the COMPAQ DeskPro (ATC) controller.
     *
     * NOTE: According to COMPAQ, drive type 25 (0x19) must be used with their 130Mb drive when using MS-DOS 3.1
     * or earlier, or when using any [unspecified] application software that supports only 17 sectors per track;
     * otherwise, use drive type 35 (0x23), which uses the drive's full capacity of 34 sectors per track.
     */
    {
         1: [306,  4],          // 10Mb (10.16Mb:  306*4*17*512 or 10,653,696 bytes) (same as IBM)
         2: [615,  4],          // 20Mb (20.42Mb:  615*4*17*512 or 21,411,840 bytes) (same as IBM)
         3: [615,  6],          // 31Mb (30.63Mb:  615*6*17*512 or 32,117,760 bytes) (same as IBM)
         4: [1023, 8],          // 68Mb (67.93Mb: 1023*8*17*512 or 71,233,536 bytes) (TODO: Cylinders is listed as 1024 in the COMPAQ TechRef; confirm)
         5: [940,  6],          // 47Mb (46.82Mb:  940*6*17*512 or 49,090,560 bytes) (same as IBM)
         6: [697,  5],
         7: [462,  8],          // same as IBM
         8: [925,  5],
         9: [900, 15],          // same as IBM
        10: [980,  5],
        11: [925,  7],
        12: [925,  9],          // 70Mb (69.10Mb: 925*9*17*512 or 72,460,800 bytes)
        13: [612,  8],
        14: [980,  4],
        /*
         * Since the remaining drive types are > 14, they must be stored in either EXTHDRIVE0 or EXTHDRIVE1 CMOS bytes (0x19 or 0x1A)
         */
        16: [612,  4],          // same as IBM
        17: [980,  5],          // 40Mb (40.67Mb: 980*5*17*512 or 42,649,600 bytes)
        18: [966,  6],
        19: [1023, 8],
        20: [733,  5],          // same as IBM
        21: [733,  7],          // same as IBM
        22: [524,  4, 40],
        23: [924,  8],
        24: [966, 14],
        25: [966, 16],          // 130Mb (128.30Mb: 966*16*17*512 or 134,529,024 bytes)
        26: [1023,14],
        27: [832,  6, 33],
        28: [1222,15, 34],
        29: [1240, 7, 34],
        30: [615,  4, 25],
        31: [615,  8, 25],
        32: [905,  9, 25],
        33: [832,  8, 33],      // 110Mb (107.25Mb: 832*8*33*512 or 112,459,776 bytes)
        34: [966,  7, 34],
        35: [966,  8, 34],      // 130Mb (128.30Mb: 966*8*34*512 or 134,529,024 bytes)
        36: [966,  9, 34],
        37: [966,  5, 34],
        38: [612, 16, 63],      // 300Mb (301.22Mb: 612*16*63*512 or 315,850,752 bytes) (TODO: Cylinders is listed as 611 in the COMPAQ TechRef; confirm)
        39: [1023,11, 33],
        40: [1023,15, 34],
        41: [1630,15, 52],
        42: [1023,16, 63],
        43: [805,  4, 26],
        44: [805,  2, 26],
        45: [748,  8, 33],
        46: [748,  6, 33],
        47: [966,  5, 25]
    }
];

/*
 * ATC (AT Controller) Registers
 *
 * The "IBM Personal Computer AT Fixed Disk and Diskette Drive Adapter", aka the HFCOMBO card, contains what we refer
 * to here as the ATC (AT Controller).  Even though that card contains both Fixed Disk and Diskette Drive controllers,
 * this component (HDC) still deals only with the "Fixed Disk" portion.  Fortunately, the "Diskette Drive Adapter"
 * portion of the card is compatible with the existing FDC component, so that component continues to be responsible
 * for all diskette operations.
 *
 * ATC ports default to their primary addresses; secondary port addresses are 0x80 lower (eg, 0x170 instead of 0x1F0).
 *
 * It's important to know that the MODEL_5170 BIOS has a special relationship with the "Combo Hard File/Diskette
 * (HFCOMBO) Card" (see @F000:144C).  Initially, the ChipSet component intercepted reads for HFCOMBO's STATUS port
 * and returned the BUSY bit clear to reduce boot time; however, it turned out that was also a prerequisite for the
 * BIOS to write test patterns to the CYLLO port (0x1F4) and set the "DUAL" bit (bit 0) of the "HFCNTRL" byte at 40:8Fh
 * if those CYLLO operations succeeded (now that the HDC is "ATC-aware", the ChipSet port intercepts have been removed).
 *
 * Without the "DUAL" bit set, when it came time later to report the diskette drive type, the "DISK_TYPE" function
 * (@F000:273D) would branch to one of two almost-identical blocks of code -- specifically, a block that disallowed
 * diskette drive types >= 2 (ChipSet.CMOS.FDRIVE.FD360) instead of >= 3 (ChipSet.CMOS.FDRIVE.FD1200).
 *
 * In other words, the "Fixed Disk" portion of the HFCOMBO controller has to be present and operational if the user
 * wants to use high-capacity (80-track) diskettes with "Diskette Drive" portion of the controller.  This may not be
 * immediately obvious to anyone creating a 5170 machine configuration with the FDC component but no HDC component.
 *
 * TODO: Investigate what a MODEL_5170 can do, if anything, with diskettes if an "HFCOMBO card" was NOT installed;
 * eg, was there Diskette-only Controller that could be installed, and if so, did it support high-capacity diskette
 * drives?  Also, consider making the FDC component able to detect when the HDC is missing and provide the same minimal
 * HFCOMBO port intercepts that ChipSet once provided (this is not a requirement, just a usability improvement).
 *
 * UPDATE: I later discovered that newer (ie, REV2 and REV3) 5170 ROMs are even less happy when no HDC is installed,
 * *unless* an undocumented FDC "DIAGNOSTIC" register (port 0x3F1) provides a "MULTIPLE DATA RATE" response, bypassing
 * the HDC port tests described above.  This may also imply that those newer 5170 revisions are incompatible with FD360
 * diskette drives, because if none of the "MULTIPLE DATA RATE" tests succeed, a "601-Diskette Error" always occurs.
 */
HDC.ATC = {
    DATA:   { PORT: 0x1F0},     // no register (read-write)
    DIAG:   {                   // this.regError (read-only)
        PORT:       0x1F1,
        NO_ERROR:    0x01,
        CTRL_ERROR:  0x02,
        SEC_ERROR:   0x03,
        ECC_ERROR:   0x04,
        PROC_ERROR:  0x05
    },
    ERROR: {                    // this.regError (read-only)
        PORT:       0x1F1,
        NONE:        0x00,
        NO_DAM:      0x01,      // Data Address Mark (DAM) not found
        NO_TRK0:     0x02,      // Track 0 not detected
        CMD_ABORT:   0x04,      // Aborted Command
        NO_CHS:      0x10,      // ID field with the specified C:H:S not found
        ECC_ERR:     0x40,      // Data ECC Error
        BAD_BLOCK:   0x80       // Bad Block Detect
    },
    WPREC:  { PORT: 0x1F1},     // this.regWPreC (write-only)
    SECCNT: { PORT: 0x1F2},     // this.regSecCnt (read-write; 0 implies a 256-sector request)
    SECNUM: { PORT: 0x1F3},     // this.regSecNum (read-write)
    CYLLO:  { PORT: 0x1F4},     // this.regCylLo (read-write; all 8 bits are used)
    CYLHI:  {                   // this.regCylHi (read-write; only bits 0-1 are used, for a total of 10 bits, or 1024 max cylinders)
        PORT:       0x1F5,
        MASK:        0x03
    },
    DRVHD:  {                   // this.regDrvHd (read-write)
        PORT:       0x1F6,
        HEAD_MASK:   0x0F,      // set this to the max number of heads before issuing a SET PARAMETERS command
        DRIVE_MASK:  0x10,
        SET_MASK:    0xE0,
        SET_BITS:    0xA0       // for whatever reason, these bits must always be set
    },
    STATUS: {                   // this.regStatus (read-only; reading clears IRQ.ATC)
        PORT:       0x1F7,
        ERROR:       0x01,      // set when the previous command ended in an error; one or more bits are set in the ERROR register (the next command to the controller resets the ERROR bit)
        INDEX:       0x02,      // set once for every revolution of the disk
        CORRECTED:   0x04,
        DATA_REQ:    0x08,      // indicates that "the sector buffer requires servicing during a Read or Write command. If either bit 7 (BUSY) or this bit is active, a command is being executed. Upon receipt of any command, this bit is reset."
        SEEK_OK:     0x10,      // seek operation complete
        WFAULT:      0x20,      // write fault
        READY:       0x40,      // if this is set (along with the SEEK_OK bit), the drive is ready to read/write/seek again
        BUSY:        0x80       // if this is set, no other STATUS bits are valid
    },
    COMMAND: {                  // this.regCommand (write-only)
        PORT:       0x1F7,
        RESTORE:     0x10,      // low nibble x 500us equal stepping rate (except for 0, which corresponds to 35us) (aka RECALIBRATE)
        READ_DATA:   0x20,      // also supports NO_RETRIES and WITH_ECC
        WRITE_DATA:  0x30,      // also supports NO_RETRIES and WITH_ECC
        READ_VERF:   0x40,      // also supports NO_RETRIES
        FORMAT_TRK:  0x50,      // TODO
        SEEK:        0x70,      // low nibble x 500us equal stepping rate (except for 0, which corresponds to 35us)
        DIAGNOSE:    0x90,
        SETPARMS:    0x91,
        NO_RETRIES:  0x01,
        WITH_ECC:    0x02,
        MASK:        0xF0
    },
    FDR: {                      // this.regFDR
        PORT:       0x3F6,
        INT_DISABLE: 0x02,      // a logical 0 enables fixed disk interrupts
        RESET:       0x04,      // a logical 1 enables reset fixed disk function
        HS3:         0x08,      // a logical 1 enables head select 3 (a logical 0 enables reduced write current)
        RESERVED:    0xF1
    }
};

/*
 * XTC (XT Controller) Registers
 */
HDC.XTC = {
    /*
     * XTC Data Register (0x320, read-write)
     *
     * Writes to this register are discussed below; see HDC Commands.
     *
     * Reads from this register after a command has been executed retrieve a "status byte",
     * which must NOT be confused with the Status Register (see below).  This data "status byte"
     * contains only two bits of interest: XTC.DATA.STATUS.ERROR and XTC.DATA.STATUS.UNIT.
     */
    DATA: {
        PORT:          0x320,   // port address
        STATUS: {
            OK:         0x00,   // no error
            ERROR:      0x02,   // error occurred during command execution
            UNIT:       0x20    // logical unit number of the drive
        },
        /*
         * XTC Commands, as issued to XTC_DATA
         *
         * Commands are multi-byte sequences sent to XTC_DATA, starting with a XTC_DATA.CMD byte,
         * and followed by 5 more bytes, for a total of 6 bytes, which collectively are called a
         * Device Control Block (DCB).  Not all commands use all 6 bytes, but all 6 bytes must be present;
         * unused bytes are simply ignored.
         *
         *      XTC_DATA.CMD    (3-bit class code, 5-bit operation code)
         *      XTC_DATA.HEAD   (1-bit drive number, 5-bit head number)
         *      XTC_DATA.CLSEC  (upper bits of 10-bit cylinder number, 6-bit sector number)
         *      XTC_DATA.CH     (lower bits of 10-bit cylinder number)
         *      XTC_DATA.COUNT  (8-bit interleave or block count)
         *      XTC_DATA.CTRL   (8-bit control field)
         *
         * One command, HDC.XTC.DATA.CMD.INIT_DRIVE, must include 8 additional bytes following the DCB:
         *
         *      maximum number of cylinders (high)
         *      maximum number of cylinders (low)
         *      maximum number of heads
         *      start reduced write current cylinder (high)
         *      start reduced write current cylinder (low)
         *      start write precompensation cylinder (high)
         *      start write precompensation cylinder (low)
         *      maximum ECC data burst length
         *
         * Note that the 3 word values above are stored in "big-endian" format (high byte followed by low byte),
         * rather than the more typical "little-endian" format (low byte followed by high byte).
         */
        CMD: {
            TEST_READY:     0x00,       // Test Drive Ready
            RECALIBRATE:    0x01,       // Recalibrate
            REQUEST_SENSE:  0x03,       // Request Sense Status
            FORMAT_DRIVE:   0x04,       // Format Drive
            READ_VERF:      0x05,       // Read Verify
            FORMAT_TRK:     0x06,       // Format Track
            FORMAT_BAD:     0x07,       // Format Bad Track
            READ_DATA:      0x08,       // Read
            WRITE_DATA:     0x0A,       // Write
            SEEK:           0x0B,       // Seek
            INIT_DRIVE:     0x0C,       // Initialize Drive Characteristics
            READ_ECC_BURST: 0x0D,       // Read ECC Burst Error Length
            READ_BUFFER:    0x0E,       // Read Data from Sector Buffer
            WRITE_BUFFER:   0x0F,       // Write Data to Sector Buffer
            RAM_DIAGNOSTIC: 0xE0,       // RAM Diagnostic
            DRV_DIAGNOSTIC: 0xE3,       // HDC BIOS: CHK_DRV_CMD
            CTL_DIAGNOSTIC: 0xE4,       // HDC BIOS: CNTLR_DIAG_CMD
            READ_LONG:      0xE5,       // HDC BIOS: RD_LONG_CMD
            WRITE_LONG:     0xE6        // HDC BIOS: WR_LONG_CMD
        },
        ERR: {
            /*
             * HDC error conditions, as returned in byte 0 of the (4) bytes returned by the Request Sense Status command
             */
            NONE:           0x00,
            NO_INDEX:       0x01,       // no index signal detected
            SEEK_INCOMPLETE:0x02,       // no seek-complete signal
            WRITE_FAULT:    0x03,
            NOT_READY:      0x04,       // after the controller selected the drive, the drive did not respond with a ready signal
            NO_TRACK:       0x06,       // after stepping the max number of cylinders, the controller did not receive the track 00 signal from the drive
            STILL_SEEKING:  0x08,
            ECC_ID_ERROR:   0x10,
            ECC_DATA_ERROR: 0x11,
            NO_ADDR_MARK:   0x12,
            NO_SECTOR:      0x14,
            BAD_SEEK:       0x15,       // seek error: the cylinder and/or head address did not compare with the expected target address
            ECC_CORRECTABLE:0x18,       // correctable data error
            BAD_TRACK:      0x19,
            BAD_CMD:        0x20,
            BAD_DISK_ADDR:  0x21,
            RAM:            0x30,
            CHECKSUM:       0x31,
            POLYNOMIAL:     0x32,
            MASK:           0x3F
        },
        SENSE: {
            ADDR_VALID:     0x80
        }
    },
    /*
     * XTC Status Register (0x321, read-only)
     *
     * WARNING: The IBM Technical Reference Manual *badly* confuses the XTC_DATA "status byte" (above)
     * that the controller sends following an HDC.XTC.DATA.CMD operation with the Status Register (below).
     * In fact, it's so badly confused that it completely fails to document any of the Status Register
     * bits below; I'm forced to guess at their meanings from the HDC BIOS listing.
     */
    STATUS: {
        PORT:          0x321,   // port address
        NONE:           0x00,
        REQ:            0x01,   // HDC BIOS: request bit
        IOMODE:         0x02,   // HDC BIOS: mode bit (GUESS: set whenever XTC_DATA contains a response?)
        BUS:            0x04,   // HDC BIOS: command/data bit (GUESS: set whenever XTC_DATA ready for request?)
        BUSY:           0x08,   // HDC BIOS: busy bit
        INTERRUPT:      0x20    // HDC BIOS: interrupt bit
    }
};

/*
 * XTC Config Register (0x322, read-only)
 *
 * This register is used to read HDC card switch settings that defined the "Drive Type" for
 * drives 0 and 1.  SW[1],SW[2] (for drive 0) and SW[3],SW[4] (for drive 1) are set as follows:
 *
 *      ON,  ON     Drive Type 0   (306 cylinders, 2 heads)
 *      ON,  OFF    Drive Type 1   (375 cylinders, 8 heads)
 *      OFF, ON     Drive Type 2   (306 cylinders, 6 heads)
 *      OFF, OFF    Drive Type 3   (306 cylinders, 4 heads)
 */

/*
 * HDC Command Sequences
 *
 * Unlike the FDC, all the HDC commands have fixed-length command request sequences (well, OK, except for
 * HDC.XTC.DATA.CMD.INIT_DRIVE) and fixed-length response sequences (well, OK, except for HDC.XTC.DATA.CMD.REQUEST_SENSE),
 * so a table of byte-lengths isn't much use, but having names for all the commands is still handy for debugging.
 */
if (DEBUG) {
    HDC.aATCCommands = {
        0x10: "Restore (Recalibrate)",
        0x20: "Read",
        0x30: "Write",
        0x40: "Read Verify",
        0x50: "Format Track",
        0x70: "Seek",
        0x90: "Diagnose",
        0x91: "Set Parameters"
    };
    HDC.aXTCCommands = {
        0x00: "Test Drive Ready",
        0x01: "Recalibrate",
        0x03: "Request Sense Status",
        0x04: "Format Drive",
        0x05: "Read Verify",
        0x06: "Format Track",
        0x07: "Format Bad Track",
        0x08: "Read",
        0x0A: "Write",
        0x0B: "Seek",
        0x0C: "Initialize Drive Characteristics",
        0x0D: "Read ECC Burst Error Length",
        0x0E: "Read Data from Sector Buffer",
        0x0F: "Write Data to Sector Buffer",
        0xE0: "RAM Diagnostic",
        0xE3: "Drive Diagnostic",
        0xE4: "Controller Diagnostic",
        0xE5: "Read Long",
        0xE6: "Write Long"
    };
}

/*
 * Port input notification tables
 */
HDC.aXTCPortInput = {
    0x320:  HDC.prototype.inXTCData,
    0x321:  HDC.prototype.inXTCStatus,
    0x322:  HDC.prototype.inXTCConfig
};

/*
 * For future reference, the REV2 and REV3 PC AT ROM BIOS also refer to a "FIXED DISK DIAGNOSTIC REGISTER" at
 * port 0x5F7, but I have no documentation on it, and failure to respond is non-fatal.  See the discussion of the
 * FDC diagnostic register in inFDCDiagnostic() for more details.
 */
HDC.aATCPortInput = {
    0x1F0:  HDC.prototype.inATCData,
    0x1F1:  HDC.prototype.inATCError,
    0x1F2:  HDC.prototype.inATCSecCnt,
    0x1F3:  HDC.prototype.inATCSecNum,
    0x1F4:  HDC.prototype.inATCCylLo,
    0x1F5:  HDC.prototype.inATCCylHi,
    0x1F6:  HDC.prototype.inATCDrvHd,
    0x1F7:  HDC.prototype.inATCStatus
};

/*
 * Port output notification tables
 */
HDC.aXTCPortOutput = {
    0x320:  HDC.prototype.outXTCData,
    0x321:  HDC.prototype.outXTCReset,
    0x322:  HDC.prototype.outXTCPulse,
    0x323:  HDC.prototype.outXTCPattern,
    /*
     * The PC XT Fixed Disk BIOS includes some additional "housekeeping" that it performs
     * not only on port 0x323 but also on three additional ports, at increments of 4 (see all
     * references to "RESET INT/DMA MASK" in the Fixed Disk BIOS).  It's not clear to me if
     * those ports refer to additional HDC controllers, and I haven't seen other references to
     * them, but in any case, they represent a lot of "I/O noise" that we simply squelch here.
     */
    0x327:  HDC.prototype.outXTCNoise,
    0x32B:  HDC.prototype.outXTCNoise,
    0x32F:  HDC.prototype.outXTCNoise
};

HDC.aATCPortOutput = {
    0x1F0:  HDC.prototype.outATCData,
    0x1F1:  HDC.prototype.outATCWPreC,
    0x1F2:  HDC.prototype.outATCSecCnt,
    0x1F3:  HDC.prototype.outATCSecNum,
    0x1F4:  HDC.prototype.outATCCylLo,
    0x1F5:  HDC.prototype.outATCCylHi,
    0x1F6:  HDC.prototype.outATCDrvHd,
    0x1F7:  HDC.prototype.outATCCommand,
    0x3F6:  HDC.prototype.outATCFDR
};

/*
 * Initialize every Hard Drive Controller (HDC) module on the page.
 */
Web.onInit(HDC.init);



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/debugger.js (C) Jeff Parsons 2012-2018
 */


/**
 * Debugger Address Object
 *
 * This is the basic structure; other debuggers may extend it.
 *
 *      addr            address
 *      fTemporary      true if this is a temporary breakpoint address
 *      sCmd            set for breakpoint addresses if there's an associated command string
 *      aCmds           preprocessed commands (from sCmd)
 *
 * @typedef {{
 *      addr:(number|undefined),
 *      fTemporary:(boolean|undefined),
 *      sCmd:(string|undefined),
 *      aCmds:(Array.<string>|undefined)
 * }}
 */
var DbgAddr;

/**
 * Since the Closure Compiler treats ES6 classes as @struct rather than @dict by default,
 * it deters us from defining named properties on our components; eg:
 *
 *      this['exports'] = {...}
 *
 * results in an error:
 *
 *      Cannot do '[]' access on a struct
 *
 * So, in order to define 'exports', we must override the @struct assumption by annotating
 * the class as @unrestricted (or @dict).  Note that this must be done both here and in the
 * subclass (eg, SerialPort), because otherwise the Compiler won't allow us to *reference*
 * the named property either.
 *
 * TODO: Consider marking ALL our classes unrestricted, because otherwise it forces us to
 * define every single property the class uses in its constructor, which results in a fair
 * bit of redundant initialization, since many properties aren't (and don't need to be) fully
 * initialized until the appropriate init(), reset(), restore(), etc. function is called.
 *
 * The upside, however, may be that since the structure of the class is completely defined by
 * the constructor, JavaScript engines may be able to optimize and run more efficiently.
 *
 * @unrestricted
 */
class Debugger extends Component {
    /**
     * Debugger(parmsDbg)
     *
     * The Debugger component supports the following optional (parmsDbg) properties:
     *
     *      base: the base to use for most numeric input/output (default is 16)
     *
     * The Debugger component is a shared component containing a subset of functionality used by
     * the other CPU-specific Debuggers (eg, DebuggerX86).  Over time, the goal is to factor out as
     * much common debugging support as possible from those components into this one.
     *
     * @param {Object} parmsDbg
     */
    constructor(parmsDbg)
    {
        if (DEBUGGER) {

            super("Debugger", parmsDbg);

            /*
             * Default base used to display all values; modified with the "s base" command.
             */
            this.nBase = +parmsDbg['base'] || 16;

            /*
             * Default number of bits of integer precision; it can be overridden by the Debugger
             * but there is no command to adjust it.
             */
            this.nBits = 32;

            this.achGroup = ['{','}'];
            this.achAddress = ['[',']'];

            /*
             * These keep track of instruction activity, but only when tracing or when Debugger checks
             * have been enabled (eg, one or more breakpoints have been set).
             *
             * They are zeroed by the reset() notification handler.  cInstructions is advanced by
             * stepCPU() and checkInstruction() calls.  nCycles is updated by every stepCPU() or stop()
             * call and simply represents the number of cycles performed by the last run of instructions.
             */
            this.nCycles = 0;
            this.cOpcodes = this.cOpcodesStart = 0;

            /*
             * fAssemble is true when "assemble mode" is active, false when not.
             */
            this.fAssemble = false;

            /*
             * This maintains command history.  New commands are inserted at index 0 of the array.
             * When Enter is pressed on an empty input buffer, we default to the command at aPrevCmds[0].
             */
            this.iPrevCmd = -1;
            this.aPrevCmds = [];

            /*
             * aVariables is an object with properties that grow as setVariable() assigns more variables;
             * each property corresponds to one variable, where the property name is the variable name (ie,
             * a string beginning with a non-digit, followed by zero or more symbol characters and/or digits)
             * and the property value is the variable's numeric value.  See doVar() and setVariable() for
             * details.
             *
             * Note that parseValue() parses variables before numbers, so any variable that looks like a
             * unprefixed hex value (eg, "a5" as opposed to "0xa5") will trump the numeric value.  Unprefixed
             * hex values are a convenience of parseValue(), which always calls Str.parseInt() with a default
             * base of 16; however, that default be overridden with a variety of explicit prefixes or suffixes
             * (eg, a leading "0o" to indicate octal, a trailing period to indicate decimal, etc.)
             *
             * See Str.parseInt() for more details about supported numbers.
             */
            this.aVariables = {};

        }   // endif DEBUGGER
    }

    /**
     * getRegIndex(sReg, off)
     *
     * NOTE: This must be implemented by the individual debuggers.
     *
     * @this {Debugger}
     * @param {string} sReg
     * @param {number} [off] optional offset into sReg
     * @return {number} register index, or -1 if not found
     */
    getRegIndex(sReg, off)
    {
        return -1;
    }

    /**
     * getRegValue(iReg)
     *
     * NOTE: This must be implemented by the individual debuggers.
     *
     * @this {Debugger}
     * @param {number} iReg
     * @return {number|undefined}
     */
    getRegValue(iReg)
    {
        return undefined;
    }

    /**
     * parseAddrReference(s, sAddr)
     *
     * Returns the given string with the given address reference replaced with the contents of that address.
     *
     * NOTE: This must be implemented by the individual debuggers.
     *
     * @this {Debugger}
     * @param {string} s
     * @param {string} sAddr
     * @return {string}
     */
    parseAddrReference(s, sAddr)
    {
        return s.replace('[' + sAddr + ']', "unimplemented");
    }

    /**
     * getNextCommand()
     *
     * @this {Debugger}
     * @return {string}
     */
    getNextCommand()
    {
        let sCmd;
        if (this.iPrevCmd > 0) {
            sCmd = this.aPrevCmds[--this.iPrevCmd];
        } else {
            sCmd = "";
            this.iPrevCmd = -1;
        }
        return sCmd;
    }

    /**
     * getPrevCommand()
     *
     * @this {Debugger}
     * @return {string|null}
     */
    getPrevCommand()
    {
        let sCmd = null;
        if (this.iPrevCmd < this.aPrevCmds.length - 1) {
            sCmd = this.aPrevCmds[++this.iPrevCmd];
        }
        return sCmd;
    }

    /**
     * parseCommand(sCmd, fSave, chSep)
     *
     * @this {Debugger}
     * @param {string|undefined} sCmd
     * @param {boolean} [fSave] is true to save the command, false if not
     * @param {string} [chSep] is the command separator character (default is ';')
     * @return {Array.<string>}
     */
    parseCommand(sCmd, fSave, chSep)
    {
        if (fSave) {
            if (!sCmd) {
                if (this.fAssemble) {
                    sCmd = "end";
                } else {
                    sCmd = this.aPrevCmds[this.iPrevCmd+1];
                }
            } else {
                if (this.iPrevCmd < 0 && this.aPrevCmds.length) {
                    this.iPrevCmd = 0;
                }
                if (this.iPrevCmd < 0 || sCmd != this.aPrevCmds[this.iPrevCmd]) {
                    this.aPrevCmds.splice(0, 0, sCmd);
                    this.iPrevCmd = 0;
                }
                this.iPrevCmd--;
            }
        }
        let a = [];
        if (sCmd) {
            /*
             * With the introduction of breakpoint commands (ie, quoted command sequences
             * associated with a breakpoint), we can no longer perform simplistic splitting.
             *
             *      a = sCmd.split(chSep || ';');
             *      for (let i = 0; i < a.length; i++) a[i] = Str.trim(a[i]);
             *
             * We may now split on semi-colons ONLY if they are outside a quoted sequence.
             *
             * Also, to allow quoted strings *inside* breakpoint commands, we first replace all
             * DOUBLE double-quotes with single quotes.
             */
            sCmd = sCmd.replace(/""/g, "'");

            let iPrev = 0;
            let chQuote = null;
            chSep = chSep || ';';
            /*
             * NOTE: Processing charAt() up to and INCLUDING length is not a typo; we're taking
             * advantage of the fact that charAt() with an invalid index returns an empty string,
             * allowing us to use the same substring() call to capture the final portion of sCmd.
             *
             * In a sense, it allows us to pretend that the string ends with a zero terminator.
             */
            for (let i = 0; i <= sCmd.length; i++) {
                let ch = sCmd.charAt(i);
                if (ch == '"' || ch == "'") {
                    if (!chQuote) {
                        chQuote = ch;
                    } else if (ch == chQuote) {
                        chQuote = null;
                    }
                }
                else if (ch == chSep && !chQuote || !ch) {
                    /*
                     * Recall that substring() accepts starting (inclusive) and ending (exclusive)
                     * indexes, whereas substr() accepts a starting index and a length.  We need the former.
                     */
                    a.push(Str.trim(sCmd.substring(iPrev, i)));
                    iPrev = i + 1;
                }
            }
        }
        return a;
    }

    /**
     * evalAND(dst, src)
     *
     * Adapted from /modules/pdp10/lib/cpuops.js:PDP10.AND().
     *
     * Performs the bitwise "and" (AND) of two operands > 32 bits.
     *
     * @this {Debugger}
     * @param {number} dst
     * @param {number} src
     * @return {number} (dst & src)
     */
    evalAND(dst, src)
    {
        /*
         * We AND the low 32 bits separately from the higher bits, and then combine them with addition.
         * Since all bits above 32 will be zero, and since 0 AND 0 is 0, no special masking for the higher
         * bits is required.
         *
         * WARNING: When using JavaScript's 32-bit operators with values that could set bit 31 and produce a
         * negative value, it's critical to perform a final right-shift of 0, ensuring that the final result is
         * positive.
         */
        if (this.nBits <= 32) {
            return dst & src;
        }
        /*
         * Negative values don't yield correct results when dividing, so pass them through an unsigned truncate().
         */
        dst = this.truncate(dst, 0, true);
        src = this.truncate(src, 0, true);
        return ((((dst / Debugger.TWO_POW32)|0) & ((src / Debugger.TWO_POW32)|0)) * Debugger.TWO_POW32) + ((dst & src) >>> 0);
    }

    /**
     * evalIOR(dst, src)
     *
     * Adapted from /modules/pdp10/lib/cpuops.js:PDP10.IOR().
     *
     * Performs the logical "inclusive-or" (OR) of two operands > 32 bits.
     *
     * @this {Debugger}
     * @param {number} dst
     * @param {number} src
     * @return {number} (dst | src)
     */
    evalIOR(dst, src)
    {
        /*
         * We OR the low 32 bits separately from the higher bits, and then combine them with addition.
         * Since all bits above 32 will be zero, and since 0 OR 0 is 0, no special masking for the higher
         * bits is required.
         *
         * WARNING: When using JavaScript's 32-bit operators with values that could set bit 31 and produce a
         * negative value, it's critical to perform a final right-shift of 0, ensuring that the final result is
         * positive.
         */
        if (this.nBits <= 32) {
            return dst | src;
        }
        /*
         * Negative values don't yield correct results when dividing, so pass them through an unsigned truncate().
         */
        dst = this.truncate(dst, 0, true);
        src = this.truncate(src, 0, true);
        return ((((dst / Debugger.TWO_POW32)|0) | ((src / Debugger.TWO_POW32)|0)) * Debugger.TWO_POW32) + ((dst | src) >>> 0);
    }

    /**
     * evalXOR(dst, src)
     *
     * Adapted from /modules/pdp10/lib/cpuops.js:PDP10.XOR().
     *
     * Performs the logical "exclusive-or" (XOR) of two operands > 32 bits.
     *
     * @this {Debugger}
     * @param {number} dst
     * @param {number} src
     * @return {number} (dst ^ src)
     */
    evalXOR(dst, src)
    {
        /*
         * We XOR the low 32 bits separately from the higher bits, and then combine them with addition.
         * Since all bits above 32 will be zero, and since 0 XOR 0 is 0, no special masking for the higher
         * bits is required.
         *
         * WARNING: When using JavaScript's 32-bit operators with values that could set bit 31 and produce a
         * negative value, it's critical to perform a final right-shift of 0, ensuring that the final result is
         * positive.
         */
        if (this.nBits <= 32) {
            return dst | src;
        }
        /*
         * Negative values don't yield correct results when dividing, so pass them through an unsigned truncate().
         */
        dst = this.truncate(dst, 0, true);
        src = this.truncate(src, 0, true);
        return ((((dst / Debugger.TWO_POW32)|0) ^ ((src / Debugger.TWO_POW32)|0)) * Debugger.TWO_POW32) + ((dst ^ src) >>> 0);
    }

    /**
     * evalMUL(dst, src)
     *
     * I could have adapted the code from /modules/pdp10/lib/cpuops.js:PDP10.doMUL(), but it was simpler to
     * write this base method and let the PDP-10 Debugger override it with a call to the *actual* doMUL() method.
     *
     * @this {Debugger}
     * @param {number} dst
     * @param {number} src
     * @return {number} (dst * src)
     */
    evalMUL(dst, src)
    {
        return dst * src;
    }

    /**
     * truncate(v, nBits, fUnsigned)
     *
     * @this {Debugger}
     * @param {number} v
     * @param {number} [nBits]
     * @param {boolean} [fUnsigned]
     * @return {number}
     */
    truncate(v, nBits, fUnsigned)
    {
        let limit, vNew = v;
        nBits = nBits || this.nBits;

        if (fUnsigned) {
            if (nBits == 32) {
                vNew = v >>> 0;
            }
            else if (nBits < 32) {
                vNew = v & ((1 << nBits) - 1);
            }
            else {
                limit = Math.pow(2, nBits);
                if (v < 0 || v >= limit) {
                    vNew = v % limit;
                    if (vNew < 0) vNew += limit;
                }
            }
        }
        else {
            if (nBits <= 32) {
                vNew = (v << (32 - nBits)) >> (32 - nBits);
            }
            else {
                limit = Math.pow(2, nBits - 1);
                if (v >= limit) {
                    vNew = (v % limit);
                    if (((v / limit)|0) & 1) vNew -= limit;
                } else if (v < -limit) {
                    vNew = (v % limit);
                    if ((((-v - 1) / limit) | 0) & 1) {
                        if (vNew) vNew += limit;
                    }
                    else {
                        if (!vNew) vNew -= limit;
                    }
                }
            }
        }
        if (v != vNew) {
            if (MAXDEBUG) this.println("warning: value " + v + " truncated to " + vNew);
            v = vNew;
        }
        return v;
    }

    /**
     * evalOps(aVals, aOps, cOps)
     *
     * Some of our clients want a specific number of bits of integer precision.  If that precision is
     * greater than 32, some of the operations below will fail; for example, JavaScript bitwise operators
     * always truncate the result to 32 bits, so beware when using shift operations.  Similarly, it would
     * be wrong to always "|0" the final result, which is why we rely on truncate() now.
     *
     * Note that JavaScript integer precision is limited to 52 bits.  For example, in Node, if you set a
     * variable to 0x80000001:
     *
     *      foo=0x80000001|0
     *
     * then calculate foo*foo and display the result in binary using "(foo*foo).toString(2)":
     *
     *      '11111111111111111111111111111100000000000000000000000000000000'
     *
     * which is slightly incorrect because it has overflowed JavaScript's floating-point precision.
     *
     * 0x80000001 in decimal is -2147483647, so the product is 4611686014132420609, which is 0x3FFFFFFF00000001.
     *
     * @this {Debugger}
     * @param {Array.<number>} aVals
     * @param {Array.<string>} aOps
     * @param {number} [cOps] (default is -1 for all)
     * @return {boolean} true if successful, false if error
     */
    evalOps(aVals, aOps, cOps = -1)
    {
        while (cOps-- && aOps.length) {
            let chOp = aOps.pop();
            if (aVals.length < 2) return false;
            let valNew;
            let val2 = aVals.pop();
            let val1 = aVals.pop();
            switch(chOp) {
            case '*':
                valNew = this.evalMUL(val1, val2);
                break;
            case '/':
                if (!val2) return false;
                valNew = Math.trunc(val1 / val2);
                break;
            case '^/':
                if (!val2) return false;
                valNew = val1 % val2;
                break;
            case '+':
                valNew = val1 + val2;
                break;
            case '-':
                valNew = val1 - val2;
                break;
            case '<<':
                valNew = val1 << val2;
                break;
            case '>>':
                valNew = val1 >> val2;
                break;
            case '>>>':
                valNew = val1 >>> val2;
                break;
            case '<':
                valNew = (val1 < val2? 1 : 0);
                break;
            case '<=':
                valNew = (val1 <= val2? 1 : 0);
                break;
            case '>':
                valNew = (val1 > val2? 1 : 0);
                break;
            case '>=':
                valNew = (val1 >= val2? 1 : 0);
                break;
            case '==':
                valNew = (val1 == val2? 1 : 0);
                break;
            case '!=':
                valNew = (val1 != val2? 1 : 0);
                break;
            case '&':
                valNew = this.evalAND(val1, val2);
                break;
            case '!':           // alias for MACRO-10 to perform a bitwise inclusive-or (OR)
            case '|':
                valNew = this.evalIOR(val1, val2);
                break;
            case '^!':          // since MACRO-10 uses '^' for base overrides, '^!' is used for bitwise exclusive-or (XOR)
                valNew = this.evalXOR(val1, val2);
                break;
            case '&&':
                valNew = (val1 && val2? 1 : 0);
                break;
            case '||':
                valNew = (val1 || val2? 1 : 0);
                break;
            case ',,':
                valNew = this.truncate(val1, 18, true) * Math.pow(2, 18) + this.truncate(val2, 18, true);
                break;
            case '_':
            case '^_':
                valNew = val1;
                /*
                 * While we always try to avoid assuming any particular number of bits of precision, the 'B' shift
                 * operator (which we've converted to '^_') is unique to the MACRO-10 environment, which imposes the
                 * following restrictions on the shift count.
                 */
                if (chOp == '^_') val2 = 35 - (val2 & 0xff);
                if (val2) {
                    /*
                     * Since binary shifting is a logical (not arithmetic) operation, and since shifting by division only
                     * works properly with positive numbers, we call truncate() to produce an unsigned value.
                     */
                    valNew = this.truncate(valNew, 0, true);
                    if (val2 > 0) {
                        valNew *= Math.pow(2, val2);
                    } else {
                        valNew = Math.trunc(valNew / Math.pow(2, -val2));
                    }
                }
                break;
            default:
                return false;
            }
            aVals.push(this.truncate(valNew));
        }
        return true;
    }

    /**
     * parseArray(asValues, iValue, iLimit, nBase, aUndefined)
     *
     * parseExpression() takes a complete expression and divides it into array elements, where even elements
     * are values (which may be empty if two or more operators appear consecutively) and odd elements are operators.
     *
     * For example, if the original expression was "2*{3+{4/2}}", parseExpression() would call parseArray() with:
     *
     *      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
     *      -   -   -   -   -   -   -   -   -   -  --  --  --  --  --
     *      2   *       {   3   +       {   4   /   2   }       }
     *
     * This function takes care of recursively processing grouped expressions, by processing subsets of the array,
     * as well as handling certain base overrides (eg, temporarily switching to base-10 for binary shift suffixes).
     *
     * @param {Array.<string>} asValues
     * @param {number} iValue
     * @param {number} iLimit
     * @param {number} nBase
     * @param {Array|undefined} [aUndefined]
     * @return {number|undefined}
     */
    parseArray(asValues, iValue, iLimit, nBase, aUndefined)
    {
        let value;
        let sValue, sOp;
        let fError = false;
        let nUnary = 0;
        let aVals = [], aOps = [];

        let nBasePrev = this.nBase;
        this.nBase = nBase;

        while (iValue < iLimit) {
            let v;
            sValue = asValues[iValue++].trim();
            sOp = (iValue < iLimit? asValues[iValue++] : "");

            if (sValue) {
                v = this.parseValue(sValue, undefined, aUndefined, nUnary);
            } else {
                if (sOp == '{') {
                    let cOpen = 1;
                    let iStart = iValue;
                    while (iValue < iLimit) {
                        sValue = asValues[iValue++].trim();
                        sOp = (iValue < asValues.length? asValues[iValue++] : "");
                        if (sOp == '{') {
                            cOpen++;
                        } else if (sOp == '}') {
                            if (!--cOpen) break;
                        }
                    }
                    v = this.parseArray(asValues, iStart, iValue-1, this.nBase, aUndefined);
                    if (v != null && nUnary) {
                        v = this.parseUnary(v, nUnary);
                    }
                    sValue = (iValue < iLimit? asValues[iValue++].trim() : "");
                    sOp = (iValue < iLimit? asValues[iValue++] : "");
                }
                else {
                    /*
                     * When parseExpression() calls us, it has collapsed all runs of whitespace into single spaces,
                     * and although it allows single spaces to divide the elements of the expression, a space is neither
                     * a unary nor binary operator.  It's essentially a no-op.  If we encounter it here, then it followed
                     * another operator and is easily ignored (although perhaps it should still trigger a reset of nBase
                     * and nUnary -- TBD).
                     */
                    if (sOp == ' ') {
                        continue;
                    }
                    if (sOp == '^B') {
                        this.nBase = 2;
                        continue;
                    }
                    if (sOp == '^O') {
                        this.nBase = 8;
                        continue;
                    }
                    if (sOp == '^D') {
                        this.nBase = 10;
                        continue;
                    }
                    if (!(nUnary & (0xC0000000|0))) {
                        if (sOp == '+') {
                            continue;
                        }
                        if (sOp == '-') {
                            nUnary = (nUnary << 2) | 1;
                            continue;
                        }
                        if (sOp == '~' || sOp == '^-') {
                            nUnary = (nUnary << 2) | 2;
                            continue;
                        }
                        if (sOp == '^L') {
                            nUnary = (nUnary << 2) | 3;
                            continue;
                        }
                    }
                    fError = true;
                    break;
                }
            }

            if (v === undefined) {
                if (aUndefined) {
                    aUndefined.push(sValue);
                    v = 0;
                } else {
                    fError = true;
                    aUndefined = [];
                    break;
                }
            }

            aVals.push(this.truncate(v));

            /*
             * When parseExpression() calls us, it has collapsed all runs of whitespace into single spaces,
             * and although it allows single spaces to divide the elements of the expression, a space is neither
             * a unary nor binary operator.  It's essentially a no-op.  If we encounter it here, then it followed
             * a value, and since we don't want to misinterpret the next operator as a unary operator, we look
             * ahead and grab the next operator if it's not preceded by a value.
             */
            if (sOp == ' ') {
                if (iValue < asValues.length - 1 && !asValues[iValue]) {
                    iValue++;
                    sOp = asValues[iValue++]
                } else {
                    fError = true;
                    break;
                }
            }

            if (!sOp) break;

            let aBinOp = (this.achGroup[0] == '<'? Debugger.aDECOpPrecedence : Debugger.aBinOpPrecedence);
            if (!aBinOp[sOp]) {
                fError = true;
                break;
            }
            if (aOps.length && aBinOp[sOp] <= aBinOp[aOps[aOps.length - 1]]) {
                this.evalOps(aVals, aOps, 1);
            }
            aOps.push(sOp);

            /*
             * The MACRO-10 binary shifting operator assumes a base-10 shift count, regardless of the current
             * base, so we must override the current base to ensure the count is parsed correctly.
             */
            this.nBase = (sOp == '^_')? 10 : nBase;
            nUnary = 0;
        }

        if (fError || !this.evalOps(aVals, aOps) || aVals.length != 1) {
            fError = true;
        }

        if (!fError) {
            value = aVals.pop();

        } else if (!aUndefined) {
            this.println("parse error (" + (sValue || sOp) + ")");
        }

        this.nBase = nBasePrev;
        return value;
    }

    /**
     * parseASCII(sExp, chDelim, nBits, cchMax)
     *
     * @this {Debugger}
     * @param {string} sExp
     * @param {string} chDelim
     * @param {number} nBits
     * @param {number} cchMax
     * @return {string|undefined}
     */
    parseASCII(sExp, chDelim, nBits, cchMax)
    {
        let i;
        while ((i = sExp.indexOf(chDelim)) >= 0) {
            let v = 0;
            let j = i + 1;
            let cch = cchMax;
            while (j < sExp.length) {
                let ch = sExp[j++];
                if (ch == chDelim) {
                    cch = -1;
                    break;
                }
                if (!cch) break;
                cch--;
                let c = ch.charCodeAt(0);
                if (nBits == 7) {
                    c &= 0x7F;
                } else {
                    c = (c - 0x20) & 0x3F;
                }
                v = this.truncate(v * Math.pow(2, nBits) + c, nBits * cchMax, true);
            }
            if (cch >= 0) {
                this.println("parse error (" + chDelim + sExp + chDelim + ")");
                return undefined;
            } else {
                sExp = sExp.substr(0, i) + this.toStrBase(v, -1) + sExp.substr(j);
            }
        }
        return sExp;
    }

    /**
     * parseExpression(sExp, fQuiet)
     *
     * A quick-and-dirty expression parser.  It takes an expression like:
     *
     *      EDX+EDX*4+12345678
     *
     * and builds a value stack in aVals and a "binop" (binary operator) stack in aOps:
     *
     *      aVals       aOps
     *      -----       ----
     *      EDX         +
     *      EDX         *
     *      4           +
     *      ...
     *
     * We pop 1 "binop" from aOps and 2 values from aVals whenever a "binop" of lower priority than its
     * predecessor is encountered, evaluate, and push the result back onto aVals.  Only selected unary
     * operators are supported (eg, negate and complement); no ternary operators like '?:' are supported.
     *
     * fQuiet can be used to pass an array that collects any undefined variables that parseExpression()
     * encounters; the value of an undefined variable is zero.  This mode was added for components that need
     * to support expressions containing "fixups" (ie, values that must be determined later).
     *
     * @this {Debugger}
     * @param {string|undefined} sExp
     * @param {Array|undefined|boolean} [fQuiet]
     * @return {number|undefined} numeric value, or undefined if sExp contains any undefined or invalid values
     */
    parseExpression(sExp, fQuiet)
    {
        let value = undefined;
        let fPrint = (fQuiet === false);
        let aUndefined = Array.isArray(fQuiet)? fQuiet : undefined;

        if (sExp) {

            /*
             * The default delimiting characters for grouped expressions are braces; they can be changed by altering
             * achGroup, but when that happens, instead of changing our regular expressions and operator tables,
             * we simply replace all achGroup characters with braces in the given expression.
             *
             * Why not use parentheses for grouped expressions?  Because some debuggers use parseReference() to perform
             * parenthetical value replacements in message strings, and they don't want parentheses taking on a different
             * meaning.  And for some machines, like the PDP-10, the convention is to use parentheses for other things,
             * like indexed addressing, and to use angle brackets for grouped expressions.
             */
            if (this.achGroup[0] != '{') {
                sExp = sExp.split(this.achGroup[0]).join('{').split(this.achGroup[1]).join('}');
            }

            /*
             * Quoted ASCII characters can have a numeric value, too, which must be converted now, to avoid any
             * conflicts with the operators below.
             */
            sExp = this.parseASCII(sExp, '"', 7, 5);    // MACRO-10 packs up to 5 7-bit ASCII codes into a value
            if (!sExp) return value;
            sExp = this.parseASCII(sExp, "'", 6, 6);    // MACRO-10 packs up to 6 6-bit ASCII (SIXBIT) codes into a value
            if (!sExp) return value;

            /*
             * All browsers (including, I believe, IE9 and up) support the following idiosyncrasy of a RegExp split():
             * when the RegExp uses a capturing pattern, the resulting array will include entries for all the pattern
             * matches along with the non-matches.  This effectively means that, in the set of expressions that we
             * support, all even entries in asValues will contain "values" and all odd entries will contain "operators".
             *
             * Although I started listing the operators in the RegExp in "precedential" order, that's not important;
             * what IS important is listing operators than contain shorter operators first.  For example, bitwise
             * shift operators must be listed BEFORE the logical less-than or greater-than operators.  The aBinOp tables
             * (aBinOpPrecedence and aDECOpPrecedence) are what determine precedence, not the RegExp.
             *
             * Also, to better accommodate MACRO-10 syntax, I've replaced the single '^' for XOR with '^!', and I've
             * added '!' as an alias for '|' (bitwise inclusive-or), '^-' as an alias for '~' (one's complement operator),
             * and '_' as a shift operator (+/- values specify a left/right shift, and the count is not limited to 32).
             *
             * And to avoid conflicts with MACRO-10 syntax, I've replaced the original mod operator ('%') with '^/'.
             *
             * The MACRO-10 binary shifting suffix ('B') is a bit more problematic, since a capital B can also appear
             * inside symbols, or inside hex values.  So if the default base is NOT 16, then I pre-scan for that suffix
             * and replace all non-symbolic occurrences with an internal shift operator ('^_').
             *
             * Note that Str.parseInt(), which parseValue() relies on, supports both the MACRO-10 base prefix overrides
             * and the binary shifting suffix ('B'), but since that suffix can also be a bracketed expression, we have to
             * support it here as well.
             *
             * MACRO-10 supports only a subset of all the PCjs operators; for example, MACRO-10 doesn't support any of
             * the boolean logical/compare operators.  But unless we run into conflicts, I prefer sticking with this
             * common set of operators.
             *
             * All whitespace in the expression is collapsed to single spaces, and space has been added to the list
             * of "operators", but its sole function is as a separator, not as an operator.  parseArray() will ignore
             * single spaces as long as they are preceded and/or followed by a "real" operator.  It would be dangerous
             * to remove spaces entirely, because if an operator-less expression like "A B" was passed in, we would want
             * that to generate an error; if we converted it to "AB", evaluation might inadvertently succeed.
             */
            let regExp = /({|}|\|\||&&|\||\^!|\^B|\^O|\^D|\^L|\^-|~|\^_|_|&|!=|!|==|>=|>>>|>>|>|<=|<<|<|-|\+|\^\/|\/|\*|,,| )/;
            if (this.nBase != 16) {
                sExp = sExp.replace(/(^|[^A-Z0-9$%.])([0-9]+)B/, "$1$2^_").replace(/\s+/g, ' ');
            }
            let asValues = sExp.split(regExp);
            value = this.parseArray(asValues, 0, asValues.length, this.nBase, aUndefined);
            if (value !== undefined && fPrint) {
                this.printValue(null, value);
            }
        }
        return value;
    }

    /**
     * parseReference(s)
     *
     * Returns the given string with any "{expression}" sequences replaced with the value of the expression,
     * and any "[address]" references replaced with the contents of the address.  Expressions are parsed BEFORE
     * addresses.
     *
     * @this {Debugger}
     * @param {string} s
     * @return {string|undefined}
     */
    parseReference(s)
    {
        let a;
        let chOpen = this.achGroup[0];
        let chClose = this.achGroup[1];
        let chEscape = (chOpen == '(' || chOpen == '{' || chOpen == '[')? '\\' : '';
        let chInnerEscape = (chOpen == '['? '\\' : '');
        let reSubExp = new RegExp(chEscape + chOpen + "([^" + chInnerEscape + chOpen + chInnerEscape + chClose + "]+)" + chEscape + chClose);
        while (a = s.match(reSubExp)) {
            let value = this.parseExpression(a[1]);
            if (value === undefined) return undefined;
            let sSearch = chOpen + a[1] + chClose;
            let sReplace = value != null? this.toStrBase(value) : "undefined";
            /*
             * Note that by default, the String replace() method only replaces the FIRST occurrence,
             * and there MIGHT be more than one occurrence of the expression we just parsed, so we could
             * do this instead:
             *
             *      s = s.split(sSearch).join(sReplace);
             *
             * However, that's knd of an expensive (slow) solution, and it's not strictly necessary, since
             * any additional identical expressions will be picked up on a subsequent iteration through this loop.
             */
            s = s.replace(sSearch, sReplace);
        }
        if (this.achAddress.length) {
            chOpen = this.achAddress[0];
            chClose = this.achAddress[1];
            chEscape = (chOpen == '(' || chOpen == '{' || chOpen == '[')? '\\' : '';
            chInnerEscape = (chOpen == '['? '\\' : '');
            reSubExp = new RegExp(chEscape + chOpen + "([^" + chInnerEscape + chOpen + chInnerEscape + chClose + "]+)" + chEscape + chClose);
            while (a = s.match(reSubExp)) {
                s = this.parseAddrReference(s, a[1]);
            }
        }
        return this.parseSysVars(s);
    }

    /**
     * parseSysVars(s)
     *
     * Returns the given string with any recognized "$var" replaced with its value; eg:
     *
     *      $ops: the number of opcodes executed since the last time it was displayed (or reset)
     *
     * @this {Debugger}
     * @param {string} s
     * @return {string}
     */
    parseSysVars(s)
    {
        let a;
        while (a = s.match(/\$([a-z]+)/i)) {
            let v = null;
            switch(a[1].toLowerCase()) {
            case "ops":
                v = this.cOpcodes - this.cOpcodesStart;
                break;
            }
            if (v == null) break;
            s = s.replace(a[0], v.toString());
        }
        return s;
    }

    /**
     * parseUnary(value, nUnary)
     *
     * nUnary is actually a small "stack" of unary operations encoded in successive pairs of bits.
     * As parseExpression() encounters each unary operator, nUnary is shifted left 2 bits, and the
     * new unary operator is encoded in bits 0 and 1 (0b00 is none, 0b01 is negate, 0b10 is complement,
     * and 0b11 is reserved).  Here, we process the bits in reverse order (hence the stack-like nature),
     * ensuring that we process the unary operators associated with this value right-to-left.
     *
     * Since bitwise operators see only 32 bits, more than 16 unary operators cannot be supported
     * using this method.  We'll let parseExpression() worry about that; if it ever happens in practice,
     * then we'll have to switch to a more "expensive" approach (eg, an actual array of unary operators).
     *
     * @this {Debugger}
     * @param {number} value
     * @param {number} nUnary
     * @return {number}
     */
    parseUnary(value, nUnary)
    {
        while (nUnary) {
            switch(nUnary & 0o3) {
            case 1:
                value = -this.truncate(value);
                break;
            case 2:
                value = this.evalXOR(value, -1);        // this is easier than adding an evalNOT()...
                break;
            case 3:
                let bit = 35;                           // simple left-to-right zero-bit-counting loop...
                while (bit >= 0 && !this.evalAND(value, Math.pow(2, bit))) bit--;
                value = 35 - bit;
                break;
            }
            nUnary >>>= 2;
        }
        return value;
    }

    /**
     * parseValue(sValue, sName, fQuiet, nUnary)
     *
     * @this {Debugger}
     * @param {string} [sValue]
     * @param {string} [sName] is the name of the value, if any
     * @param {Array|boolean} [fQuiet]
     * @param {number} [nUnary] (0 for none, 1 for negate, 2 for complement, 3 for leading zeros)
     * @return {number|undefined} numeric value, or undefined if sValue is either undefined or invalid
     */
    parseValue(sValue, sName, fQuiet, nUnary = 0)
    {
        let value;
        let aUndefined = Array.isArray(fQuiet)? fQuiet : undefined;

        if (sValue != undefined) {
            let iReg = this.getRegIndex(sValue);
            if (iReg >= 0) {
                value = this.getRegValue(iReg);
            } else {
                value = this.getVariable(sValue);
                if (value != undefined) {
                    let sUndefined = this.getVariableFixup(sValue);
                    if (sUndefined) {
                        if (aUndefined) {
                            aUndefined.push(sUndefined);
                        } else {
                            let valueUndefined = this.parseExpression(sUndefined, fQuiet);
                            if (valueUndefined !== undefined) {
                                value += valueUndefined;
                            } else {
                                if (!fQuiet) {
                                    this.println("undefined " + (sName || "value") + ": " + sValue + " (" + sUndefined + ")");
                                }
                                value = undefined;
                            }
                        }
                    }
                } else {
                    /*
                     * A feature of MACRO-10 is that any single-digit number is automatically interpreted as base-10.
                     */
                    value = Str.parseInt(sValue, sValue.length > 1 || this.nBase > 10? this.nBase : 10);
                }
            }
            if (value != undefined) {
                value = this.truncate(this.parseUnary(value, nUnary));
            } else {
                if (!fQuiet) {
                    this.println("invalid " + (sName || "value") + ": " + sValue);
                }
            }
        } else {
            if (!fQuiet) {
                this.println("missing " + (sName || "value"));
            }
        }
        return value;
    }

    /**
     * printValue(sVar, value)
     *
     * @this {Debugger}
     * @param {string|null|*} sVar
     * @param {number|undefined} value
     * @return {boolean} true if value defined, false if not
     */
    printValue(sVar, value)
    {
        let sValue;
        let fDefined = false;
        if (value !== undefined) {
            fDefined = true;
            if (this.nBase == 8) {
                sValue = this.toStrBase(value, this.nBits, 8, 1) + "  " + value + '.';
            } else {
                sValue = this.toStrBase(value, this.nBits, 16, 1) + "  " + this.toStrBase(value, this.nBits, 8, 1) + "  " + this.toStrBase(value, this.nBits, 2, this.nBits <= 32? 8 : 6) + "  " + value + '.';
            }
            if (value >= 0x20 && value < 0x7F) {
                sValue += " '" + String.fromCharCode(value) + "'";
            }
        }
        sVar = (sVar != null? (sVar + ": ") : "");
        this.println(sVar + sValue);
        return fDefined;
    }

    /**
     * resetVariables()
     *
     * @this {Debugger}
     * @return {Object}
     */
    resetVariables()
    {
        let a = this.aVariables;
        this.aVariables = {};
        return a;
    }

    /**
     * restoreVariables(a)
     *
     * @this {Debugger}
     * @param {Object} a (from previous resetVariables() call)
     */
    restoreVariables(a)
    {
        this.aVariables = a;
    }

    /**
     * printVariable(sVar)
     *
     * @this {Debugger}
     * @param {string} [sVar]
     * @return {boolean} true if all value(s) defined, false if not
     */
    printVariable(sVar)
    {
        let cVariables = 0;
        if (this.aVariables) {
            if (sVar) {
                return this.printValue(sVar, this.aVariables[sVar] && this.aVariables[sVar].value);
            }
            let aVars = Object.keys(this.aVariables);
            aVars.sort();
            for (let i = 0; i < aVars.length; i++) {
                this.printValue(aVars[i], this.aVariables[aVars[i]].value);
                cVariables++;
            }
        }
        return cVariables > 0;
    }

    /**
     * delVariable(sVar)
     *
     * @this {Debugger}
     * @param {string} sVar
     */
    delVariable(sVar)
    {
        delete this.aVariables[sVar];
    }

    /**
     * getVariable(sVar)
     *
     * @this {Debugger}
     * @param {string} sVar
     * @return {number|undefined}
     */
    getVariable(sVar)
    {
        if (this.aVariables[sVar]) {
            return this.aVariables[sVar].value;
        }
        sVar = sVar.substr(0, 6);
        return this.aVariables[sVar] && this.aVariables[sVar].value;
    }

    /**
     * getVariableFixup(sVar)
     *
     * @this {Debugger}
     * @param {string} sVar
     * @return {string|undefined}
     */
    getVariableFixup(sVar)
    {
        return this.aVariables[sVar] && this.aVariables[sVar].sUndefined;
    }

    /**
     * isVariable(sVar)
     *
     * @this {Debugger}
     * @param {string} sVar
     * @return {boolean}
     */
    isVariable(sVar)
    {
        return this.aVariables[sVar] !== undefined;
    }

    /**
     * setVariable(sVar, value, sUndefined)
     *
     * @this {Debugger}
     * @param {string} sVar
     * @param {number} value
     * @param {string|undefined} [sUndefined]
     */
    setVariable(sVar, value, sUndefined)
    {
        this.aVariables[sVar] = {value, sUndefined};
    }

    /**
     * toStrBase(n, nBits, nBase, nGrouping)
     *
     * Use this instead of Str's toOct()/toDec()/toHex() to convert numbers to the Debugger's default base.
     *
     * @this {Debugger}
     * @param {number|null|undefined} n
     * @param {number} [nBits] (-1 to strip leading zeros, 0 to allow a variable number of digits)
     * @param {number} [nBase]
     * @param {number} [nGrouping] (if nBase is 2, this is a grouping; otherwise, it's a prefix condition)
     * @return {string}
     */
    toStrBase(n, nBits = 0, nBase = 0, nGrouping = 0)
    {
        let s;
        switch(nBase || this.nBase) {
        case 2:
            s = Str.toBin(n, nBits > 0? nBits : 0, nGrouping);
            break;
        case 8:
            s = Str.toOct(n, nBits > 0? ((nBits + 2)/3)|0 : 0, !!nGrouping);
            break;
        case 10:
            /*
             * The multiplier is actually Math.log(2)/Math.log(10), but an approximation is more than adequate.
             */
            s = Str.toDec(n, nBits > 0? Math.ceil(nBits * 0.3) : 0);
            break;
        case 16:
        default:
            s = Str.toHex(n, nBits > 0? ((nBits + 3) >> 2) : 0, !!nGrouping);
            break;
        }
        return (nBits < 0? Str.stripLeadingZeros(s) : s);
    }
}

if (DEBUGGER) {

    /*
     * These are our operator precedence tables.  Operators toward the bottom (with higher values) have
     * higher precedence.  aBinOpPrecedence was our original table; we had to add aDECOpPrecedence because
     * the precedence of operators in DEC's MACRO-10 expressions differ.  Having separate tables also allows
     * us to remove operators that shouldn't be supported, but unless some operator creates a problem,
     * I prefer to keep as much commonality between the tables as possible.
     *
     * Missing from these tables are the (limited) set of unary operators we support (negate and complement),
     * since this is only a BINARY operator precedence, not a general-purpose precedence table.  Assume that
     * all unary operators take precedence over all binary operators.
     */
    Debugger.aBinOpPrecedence = {
        '||':   5,      // logical OR
        '&&':   6,      // logical AND
        '!':    7,      // bitwise OR (conflicts with logical NOT, but we never supported that)
        '|':    7,      // bitwise OR
        '^!':   8,      // bitwise XOR (added by MACRO-10 sometime between the 1972 and 1978 versions)
        '&':    9,      // bitwise AND
        '!=':   10,     // inequality
        '==':   10,     // equality
        '>=':   11,     // greater than or equal to
        '>':    11,     // greater than
        '<=':   11,     // less than or equal to
        '<':    11,     // less than
        '>>>':  12,     // unsigned bitwise right shift
        '>>':   12,     // bitwise right shift
        '<<':   12,     // bitwise left shift
        '-':    13,     // subtraction
        '+':    13,     // addition
        '^/':   14,     // remainder
        '/':    14,     // division
        '*':    14,     // multiplication
        '_':    19,     // MACRO-10 shift operator
        '^_':   19,     // MACRO-10 internal shift operator (converted from 'B' suffix form that MACRO-10 uses)
        '{':    20,     // open grouped expression (converted from achGroup[0])
        '}':    20      // close grouped expression (converted from achGroup[1])
    };
    Debugger.aDECOpPrecedence = {
        ',,':   1,      // high-word,,low-word
        '||':   5,      // logical OR
        '&&':   6,      // logical AND
        '!=':   10,     // inequality
        '==':   10,     // equality
        '>=':   11,     // greater than or equal to
        '>':    11,     // greater than
        '<=':   11,     // less than or equal to
        '<':    11,     // less than
        '>>>':  12,     // unsigned bitwise right shift
        '>>':   12,     // bitwise right shift
        '<<':   12,     // bitwise left shift
        '-':    13,     // subtraction
        '+':    13,     // addition
        '^/':   14,     // remainder
        '/':    14,     // division
        '*':    14,     // multiplication
        '!':    15,     // bitwise OR (conflicts with logical NOT, but we never supported that)
        '|':    15,     // bitwise OR
        '^!':   15,     // bitwise XOR (added by MACRO-10 sometime between the 1972 and 1978 versions)
        '&':    15,     // bitwise AND
        '_':    19,     // MACRO-10 shift operator
        '^_':   19,     // MACRO-10 internal shift operator (converted from 'B' suffix form that MACRO-10 uses)
        '{':    20,     // open grouped expression (converted from achGroup[0])
        '}':    20      // close grouped expression (converted from achGroup[1])
    };

    /*
     * Assorted constants
     */
    Debugger.TWO_POW32 = Math.pow(2, 32);

}   // endif DEBUGGER



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/debugger.js (C) Jeff Parsons 2012-2018
 */

if (DEBUGGER) {
}

/** @typedef {{ off: (number|undefined), sel: (number|undefined), addr: (number|undefined), type: (number|undefined), fData32: (boolean|undefined), fAddr32: (boolean|undefined), fData32Orig: (boolean|undefined), fAddr32Orig: (boolean|undefined), cOverrides: (number|undefined), fComplete: (boolean|undefined), fTempBreak: (boolean|undefined), sCmd: (string|undefined), aCmds: (Array.<string>|undefined), nCPUCycles: (number|undefined), nDebugCycles: (number|undefined), nDebugState: (number|undefined) }} */
var DbgAddrX86;

/*
 * Debugger Breakpoint Tips
 *
 * Here's an example of our powerful new breakpoint command capabilities:
 *
 *      bp 0397:022B "?'GlobalAlloc(wFlags:[ss:sp+8],dwBytes:[ss:sp+6][ss:sp+4])';g [ss:sp+2]:[ss:sp] '?ax;if ax'"
 *
 * The above breakpoint will display a pleasing "GlobalAlloc()" string containing the current
 * stack parameters, and will briefly stop execution on the return to print the result in AX,
 * halting the CPU whenever AX is zero (the default behavior of "if" whenever the expression is
 * false is to look for an "else" and automatically halt when there is no "else").
 *
 * How do you figure out where the code for GlobalAlloc is in the first place?  You need to have
 * BACKTRACK support enabled (which currently means running the non-COMPILED version), so that as
 * the Disk component loads disk images, it will automatically extract symbolic information from all
 * "NE" (New Executable) binaries on those disks, which the Debugger's "dt" command can then search
 * for you; eg:
 *
 *      ## dt globalalloc
 *      GLOBALALLOC: KRNL386.EXE 0001:022B len 0xC570
 *
 * And then you just need to do a bit more sleuthing to find the right CODE segment.  And that just
 * got easier, now that the PCx86 Debugger mimics portions of the Windows Debugger INT 0x41 interface;
 * see intWindowsDebugger() for details.  So even if you neglect to run WDEB386.EXE /E inside the
 * machine before running Windows, you should still see notifications like:
 *
 *      KERNEL!undefined code(0001)=#0397 len 0000C580
 *
 * in the PCx86 Debugger output window, as segments are being loaded by the Windows kernel.
 */

/**
 * class DebuggerX86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class DebuggerX86 extends Debugger {
    /**
     * DebuggerX86(parmsDbg)
     *
     * The DebuggerX86 component is an optional component that implements a variety of user commands
     * for controlling the CPU, dumping and editing memory, etc.
     *
     * DebuggerX86 extends the shared Debugger component and supports the following optional (parmsDbg)
     * properties:
     *
     *      commands: string containing zero or more commands, separated by ';'
     *
     *      messages: string containing zero or more message categories to enable;
     *      multiple categories must be separated by '|' or ';'.  Parsed by messageInit().
     *
     * @this {DebuggerX86}
     * @param {Object} parmsDbg
     */
    constructor(parmsDbg)
    {
        if (DEBUGGER) {

            super(parmsDbg);

            /*
             * Default number of hex chars in a register and a linear address (ie, for real-mode);
             * updated by initBus().
             */
            this.cchReg = 4;
            this.cchAddr = 5;
            this.maskAddr = 0xfffff;

            /*
             * Most commands that require an address call parseAddr(), which defaults to dbgAddrNextCode
             * or dbgAddrNextData when no address has been given.  doDump() and doUnassemble(), in turn,
             * update dbgAddrNextData and dbgAddrNextCode, respectively, when they're done.
             *
             * All dbgAddr variables contain properties off, sel, and addr, where sel:off represents the
             * segmented address and addr is the corresponding linear address (if known).  For certain
             * segmented addresses (eg, breakpoint addresses), we pre-compute the linear address and save
             * that in addr, so that the breakpoint will still operate as intended even if the mode changes
             * later (eg, from real-mode to protected-mode).
             *
             * Finally, for TEMPORARY breakpoint addresses, we set fTempBreak to true, so that they can be
             * automatically cleared when they're hit.
             */
            this.dbgAddrNextCode = this.newAddr(0, 0);
            this.dbgAddrNextData = this.newAddr(0, 0);
            this.dbgAddrAssemble = this.newAddr(0, 0);

            /*
             * aSymbolTable is an array of SymbolTable objects, one per ROM or other chunk of address space,
             * where each object contains the following properties:
             *
             *      sModule
             *      nSegment
             *      sel
             *      off
             *      addr (physical address, if any; eg, symbols for a ROM)
             *      len
             *      aSymbols
             *      aOffsets
             *
             * See addSymbols() for more details, since that's how callers add sets of symbols to the table.
             */
            this.aSymbolTable = [];

            /*
             * clearBreakpoints() initializes the breakpoints lists: aBreakExec is a list of addresses
             * to halt on whenever attempting to execute an instruction at the corresponding address,
             * and aBreakRead and aBreakWrite are lists of addresses to halt on whenever a read or write,
             * respectively, occurs at the corresponding address.
             *
             * NOTE: Curiously, after upgrading the Google Closure Compiler from v20141215 to v20150609,
             * the resulting compiled code would crash in clearBreakpoints(), because the (renamed) aBreakRead
             * property was already defined.  To eliminate whatever was confusing the Closure Compiler, I've
             * explicitly initialized all the properties that clearBreakpoints() (re)initializes.
             */
            this.aBreakExec = this.aBreakRead = this.aBreakWrite = [];
            this.clearBreakpoints();

            /*
             * The new "bn" command allows you to specify a number of instructions to execute and then stop;
             * "bn 0" disables any outstanding count.
             */
            this.nBreakIns = 0;

            /*
             * Execution history is allocated by historyInit() whenever checksEnabled() conditions change.
             * Execution history is updated whenever the CPU calls checkInstruction(), which will happen
             * only when checksEnabled() returns true (eg, whenever one or more breakpoints have been set).
             * This ensures that, by default, the CPU runs as fast as possible.
             */
            this.historyInit();

            /*
             * Initialize Debugger message and command support
             */
            this.afnDumpers = {};
            this.messageInit(parmsDbg['messages']);
            this.sCommandsInit = parmsDbg['commands'];

            /*
             * Make it easier to access Debugger commands from an external REPL, like the WebStorm "live" console
             * window; eg:
             *
             *      pcx86('r')
             *      pcx86('dw 0:0')
             *      pcx86('h')
             *      ...
             */
            let dbg = this;
            if (window) {
                if (window[PCX86.APPCLASS] === undefined) {
                    window[PCX86.APPCLASS] = function(s) { return dbg.doCommands(s); };
                }
            } else {
                if (global[PCX86.APPCLASS] === undefined) {
                    global[PCX86.APPCLASS] = function(s) { return dbg.doCommands(s); };
                }
            }

        }   // endif DEBUGGER
    }

    /**
     * initBus(bus, cpu, dbg)
     *
     * @this {DebuggerX86}
     * @param {Computer} cmp
     * @param {Bus} bus
     * @param {CPUX86} cpu
     * @param {DebuggerX86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.cmp = cmp;
        this.fdc = cmp.getMachineComponent("FDC");
        this.hdc = cmp.getMachineComponent("HDC");
        this.fpu = cmp.getMachineComponent("FPU");
        this.mouse = cmp.getMachineComponent("Mouse");


        /*
         * Re-initialize Debugger message and command support as needed
         */
        let sMessages = cmp.getMachineParm('messages');
        if (sMessages) this.messageInit(sMessages);
        this.sCommandsInit = cmp.getMachineParm('commands') || this.sCommandsInit;

        /*
         * If CHIPSET or VIDEO messages are enabled at startup, we enable ChipSet or Video diagnostic info in the
         * instruction history buffer as appropriate.
         */
        if (this.messageEnabled(Messages.CHIPSET)) {
            this.chipset = cmp.getMachineComponent("ChipSet");
        }
        else if (this.messageEnabled(Messages.VIDEO)) {
            this.video = cmp.getMachineComponent("Video");
        }

        this.cchAddr = bus.getWidth() >> 2;
        this.maskAddr = bus.nBusLimit;

        /*
         * Allocate a special segment "register", for use whenever a requested selector is not currently loaded
         */
        this.segDebugger = new SegX86(this.cpu, SegX86.ID.DBG, "DBG");

        this.aaOpDescs = DebuggerX86.aaOpDescs;
        if (this.cpu.model >= X86.MODEL_80186) {
            this.aaOpDescs = DebuggerX86.aaOpDescs.slice();
            this.aaOpDescs[0x0F] = DebuggerX86.aOpDescUndefined;
            if (this.cpu.model >= X86.MODEL_80286) {
                /*
                 * TODO: Consider whether the aOpDesc0F table should be split in two: one for 80286-only instructions,
                 * and one for both 80286 and 80386.  For now, the Debugger is not as strict as the CPUX86 is about
                 * the instructions it supports for each type of CPU, in part because an 80286 machine could still be
                 * presented with 80386-only code that is simply "skipped over" when then CPU doesn't support it.
                 *
                 * Obviously I'm not being entirely consistent, since I don't disassemble *any* 0x0F opcodes for any
                 * pre-80286 CPUs.  But at least I'm being up front about it.
                 */
                this.aaOpDescs[0x0F] = DebuggerX86.aOpDesc0F;
                if (I386 && this.cpu.model >= X86.MODEL_80386) this.cchReg = 8;
            }
        }

        this.messageDump(Messages.BUS,  function onDumpBus(asArgs) { dbg.dumpBus(asArgs); });
        this.messageDump(Messages.DESC, function onDumpSel(asArgs) { dbg.dumpSel(asArgs); });
        this.messageDump(Messages.DOS,  function onDumpDOS(asArgs) { dbg.dumpDOS(asArgs); });
        this.messageDump(Messages.MEM,  function onDumpMem(asArgs) { dbg.dumpMem(asArgs); });
        this.messageDump(Messages.TSS,  function onDumpTSS(asArgs) { dbg.dumpTSS(asArgs); });

        if (Interrupts.WINDBG.ENABLED || Interrupts.WINDBGRM.ENABLED) {
            this.fWinDbg = null;
            this.cTrapFaults = 0;
            this.fIgnoreNextCheckFault = false;
            this.cpu.addIntNotify(Interrupts.WINCB.VECTOR, this.intWindowsCallBack.bind(this));
            this.cpu.addIntNotify(Interrupts.WINDBG.VECTOR, this.intWindowsDebugger.bind(this));
        }
        if (Interrupts.WINDBGRM.ENABLED) {
            this.fWinDbgRM = null;
            this.cpu.addIntNotify(Interrupts.WINDBGRM.VECTOR, this.intWindowsDebuggerRM.bind(this));
        }

        this.setReady();
    }

    /**
     * addSegmentInfo(dbgAddr, nSegment, sel, fCode, fPrint)
     *
     * CONDITIONAL: if (Interrupts.WINDBG.ENABLED || Interrupts.WINDBGRM.ENABLED)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr (address of module name)
     * @param {number} nSegment (logical segment number)
     * @param {number} sel (current selector)
     * @param {boolean} fCode (true if code segment, false if data segment)
     * @param {boolean} [fPrint] (false means we're merely monitoring, so let WDEB386 print its own notifications)
     */
    addSegmentInfo(dbgAddr, nSegment, sel, fCode, fPrint)
    {
        let sModule = this.getSZ(dbgAddr);
        let seg = this.getSegment(sel);
        let len = seg? seg.limit + 1 : 0;
        let sSection = (fCode? "_CODE" : "_DATA") + Str.toHex(nSegment, 2);
        if (fPrint && this.messageEnabled(Messages.MEM)) {
            this.message(sModule + ' ' + (fCode? "code" : "data") + '(' + Str.toHex(nSegment, 4) + ")=#" + Str.toHex(sel, 4) + " len " + Str.toHex(len));
        }
        let off = 0;
        let aSymbols = this.findModuleInfo(sModule, nSegment);
        aSymbols[sModule + sSection] = off;
        this.addSymbols(sModule, nSegment, sel, off, null, len, aSymbols);
    }

    /**
     * removeSegmentInfo(sel, fPrint)
     *
     * CONDITIONAL: if (Interrupts.WINDBG.ENABLED || Interrupts.WINDBGRM.ENABLED)
     *
     * @this {DebuggerX86}
     * @param {number} sel
     * @param {boolean} [fPrint] (false means we're merely monitoring OR we don't really care about these notifications)
     */
    removeSegmentInfo(sel, fPrint)
    {
        let sModuleRemoved = this.removeSymbols(null, sel);
        if (fPrint && this.messageEnabled(Messages.MEM)) {
            if (sModuleRemoved) {
                this.message(sModuleRemoved + " #" + Str.toHex(sel, 4) + " removed");
            } else {
                this.message("unable to remove module for segment #" + Str.toHex(sel, 4));
            }
        }
    }

    /**
     * addSectionInfo(dbgAddr, fCode, fPrint)
     *
     * CONDITIONAL: if (Interrupts.WINDBG.ENABLED || Interrupts.WINDBGRM.ENABLED)
     *
     *  dbgAddr -> D386_Device_Params structure:
     *      DD_logical_seg  dw  ?   ; logical segment # from map
     *      DD_actual_sel   dw  ?   ; actual selector value
     *      DD_base         dd  ?   ; linear address offset for start of segment
     *      DD_length       dd  ?   ; actual length of segment
     *      DD_name         df  ?   ; 16:32 ptr to null terminated module name
     *      DD_sym_name     df  ?   ; 16:32 ptr to null terminated parent name (eg, "DOS386")
     *      DD_alias_sel    dw  ?   ; alias selector value (0 = none)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr (address of D386_Device_Params)
     * @param {boolean} fCode (true if code section, false if data section)
     * @param {boolean} [fPrint] (false means we're merely monitoring, so let WDEB386 print its own notifications)
     */
    addSectionInfo(dbgAddr, fCode, fPrint)
    {
        let nSegment = this.getShort(dbgAddr, 2);
        let sel = this.getShort(dbgAddr, 2);
        let off = this.getLong(dbgAddr, 4);
        let len = this.getLong(dbgAddr, 4);
        let dbgAddrModule = this.newAddr(this.getLong(dbgAddr, 4), this.getShort(dbgAddr, 2));
        let dbgAddrParent = this.newAddr(this.getLong(dbgAddr, 4), this.getShort(dbgAddr, 2));
        // sel = this.getShort(dbgAddr, 2) || sel;
        let sParent = this.getSZ(dbgAddrParent).toUpperCase();
        let sModule = this.getSZ(dbgAddrModule).toUpperCase();
        if (sParent == sModule) {
            sParent = "";
        } else {
            sParent += '!';
        }
        let sSection = (fCode? "_CODE" : "_DATA") + Str.toHex(nSegment, 2);
        if (fPrint && this.messageEnabled(Messages.MEM)) {
            /*
             * Mimics WDEB386 output, except that WDEB386 only displays a linear address, omitting the selector.
             */
            this.message(sParent + sModule + ' ' + (fCode? "code" : "data") + '(' + Str.toHex(nSegment, 4) + ")=" + Str.toHex(sel, 4) + ':' + Str.toHex(off) + " len " + Str.toHex(len));
        }
        /*
         * TODO: Add support for 32-bit symbols; findModuleInfo() relies on Disk.getModuleInfo(), and the Disk
         * component doesn't yet know how to parse 32-bit executables.
         */
        let aSymbols = this.findModuleInfo(sModule, nSegment);
        aSymbols[sModule + sSection] = off;
        this.addSymbols(sModule, nSegment, sel, off, null, len, aSymbols);
    }

    /**
     * removeSectionInfo(nSegment, dbgAddr, fPrint)
     *
     * CONDITIONAL: if (Interrupts.WINDBG.ENABLED || Interrupts.WINDBGRM.ENABLED)
     *
     * @this {DebuggerX86}
     * @param {number} nSegment (logical segment number)
     * @param {DbgAddrX86} dbgAddr (address of module)
     * @param {boolean} [fPrint] (false means we're merely monitoring OR we don't really care about these notifications)
     */
    removeSectionInfo(nSegment, dbgAddr, fPrint)
    {
        let sModule = this.getSZ(dbgAddr).toUpperCase();
        let sModuleRemoved = this.removeSymbols(sModule, nSegment);
        if (fPrint && this.messageEnabled(Messages.MEM)) {
            if (sModuleRemoved) {
                this.message(sModule + ' ' + Str.toHex(nSegment, 4) + " removed");
            } else {
                this.message("unable to remove " + sModule + " for section " + Str.toHex(nSegment, 4));
            }
        }
    }

    /**
     * intWindowsCallBack()
     *
     * CONDITIONAL: if (Interrupts.WINDBG.ENABLED || Interrupts.WINDBGRM.ENABLED)
     *
     * This intercepts calls to Windows callback addresses, which use INT 0x30 (aka Transfer Space Faults).
     *
     * We're only interested in one particular callback: the VW32_Int41Dispatch (0x002A002A) that KERNEL32
     * issues as 32-bit executable sections are loaded.
     *
     * At the time that INT 0x30 occurs, a far 32-bit call has been made, preceded by a near 32-bit call,
     * preceded by a 32-bit push of the Windows Debugger function # that would normally be in EAX if this had
     * been an actual INT 0x41.
     *
     * NOTE: Regardless whether we're "handling" INT 0x41 or merely "monitoring" INT 0x41, as far as THIS
     * interrupt is concerned, we always let the system process it, because execution never continues at the
     * instruction following an INT 0x30; in fact, execution doesn't even continue after the far 32-bit call
     * (even though the kernel places a "RET 4" after that call).  So, rather than recreate all that automatic
     * address popping, we let the system do it for us, since it's designed to work whether a debugger (eg,
     * WDEB386's DEBUG VxD) is installed or not.
     *
     * TODO: Consider "consuming" all VW32_Int41Dispatch callbacks, because the Windows 95 kernel goes to
     * great effort to pass those requests on to the DEBUG VxD, which end up going nowhere when the VxD isn't
     * loaded (to load it, you must either run WDEB386.EXE or install the VxD via SYSTEM.INI).  Regrettably,
     * Windows 95 assumes that if WDEB386 support is present, then a DEBUG VxD must be present as well.
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @return {boolean} true to proceed with the INT 0x30 software interrupt
     */
    intWindowsCallBack(addr)
    {
        let cpu = this.cpu;

        if (this.fWinDbg != null && cpu.regEAX == 0x002A002A) {

            let DX = cpu.regEDX & 0xffff;
            let SI = cpu.regESI & 0xffff;
            let dbgAddr = this.newAddr(cpu.getSP() + 0x0C, cpu.getSS());
            let EAX = this.getLong(dbgAddr);

            switch(EAX) {
            case Interrupts.WINDBG.LOADSEG32:
                /*
                 *  SI == segment type:
                 *      0x0     code selector
                 *      0x1     data selector
                 *  DX:EBX -> D386_Device_Params structure (see addSectionInfo() for details)
                 */
                this.addSectionInfo(this.newAddr(cpu.regEBX, DX), !SI, !!this.fWinDbg);
                break;
            }
        }
        return true;
    }

    /**
     * intWindowsDebugger()
     *
     * CONDITIONAL: if (Interrupts.WINDBG.ENABLED || Interrupts.WINDBGRM.ENABLED)
     *
     * This intercepts calls to the Windows Debugger protected-mode interface (INT 0x41).
     *
     * It's enabled if Interrupts.WINDBG.ENABLED is true, but it must ALSO be enabled if
     * Interrupts.WINDBGRM.ENABLED is true, because if the latter decides to respond to requests,
     * then we must start responding, too.  Windows assumes that if INT 0x68 support is present,
     * then INT 0x41 support must be present as well.
     *
     * That is why intWindowsDebuggerRM() will also set this.fWinDbg to true: we MUST return false
     * for all INT 0x41 requests, so that all requests are consumed, since there's no guarantee
     * that a valid INT 0x41 handler will exist inside the machine.
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @return {boolean} true to proceed with the INT 0x41 software interrupt, false to skip
     */
    intWindowsDebugger(addr)
    {
        let dbgAddr;
        let cpu = this.cpu;
        let AX = cpu.regEAX & 0xffff;
        let BX = cpu.regEBX & 0xffff;
        let CX = cpu.regECX & 0xffff;
        let DX = cpu.regEDX & 0xffff;
        let SI = cpu.regESI & 0xffff;
        let DI = cpu.regEDI & 0xffff;
        let ES = cpu.segES.sel;

        if (this.fWinDbg == null) {
            if (AX == Interrupts.WINDBG.IS_LOADED) {
                /*
                 * We're only going to respond to this function if no one else did, in which case,
                 * we'll set fWinDbg to true and handle additional notifications.
                 */
                cpu.addIntReturn(addr, function(dbg) {
                    return function onInt41Return(nLevel) {
                        if ((cpu.regEAX & 0xffff) != Interrupts.WINDBG.LOADED) {
                            cpu.regEAX = (cpu.regEAX & ~0xffff) | Interrupts.WINDBG.LOADED;
                            /*
                             * TODO: We need a DEBUGGER message category; using the MEM category for now.
                             */
                            dbg.printMessage("INT 0x41 handling enabled", Messages.MEM);
                            dbg.fWinDbg = true;
                        } else {
                            dbg.printMessage("INT 0x41 monitoring enabled", Messages.MEM);
                            dbg.fWinDbg = false;
                        }
                    };
                }(this));
            }
            return true;
        }

        /*
         * NOTE: If this.fWinDbg is true, then all cases should return false, because we're taking full
         * responsibility for all requests (don't assume there's valid interrupt handler inside the machine).
         */
        switch(AX) {
        case Interrupts.WINDBG.IS_LOADED:           // 0x004F
            if (this.fWinDbg) {
                cpu.regEAX = (cpu.regEAX & ~0xffff) | Interrupts.WINDBG.LOADED;
                this.printMessage("INT 0x41 handling enabled", Messages.MEM);
            }
            break;

        case Interrupts.WINDBG.LOADSEG:             // 0x0050
            this.addSegmentInfo(this.newAddr(DI, ES), BX+1, CX, !(SI & 0x1), !!this.fWinDbg);
            break;

        case Interrupts.WINDBG.FREESEG:             // 0x0052
            this.removeSegmentInfo(BX);
            break;

        case Interrupts.WINDBG.KRNLVARS:            // 0x005A
            /*
             *  BX = version number of this data (0x3A0)
             *  DX:CX points to:
             *      WORD    hGlobalHeap     ****
             *      WORD    pGlobalHeap     ****
             *      WORD    hExeHead        ****
             *      WORD    hExeSweep
             *      WORD    topPDB
             *      WORD    headPDB
             *      WORD    topsizePDB
             *      WORD    headTDB         ****
             *      WORD    curTDB          ****
             *      WORD    loadTDB
             *      WORD    LockTDB
             *      WORD    SelTableLen     ****
             *      DWORD   SelTableStart   ****
             */
            break;

        case Interrupts.WINDBG.RELSEG:              // 0x005C
        case Interrupts.WINDBG.EXITCALL:            // 0x0062
        case Interrupts.WINDBG.LOADDLL:             // 0x0064
        case Interrupts.WINDBG.DELMODULE:           // 0x0065
        case Interrupts.WINDBG.UNKNOWN66:           // 0x0066
        case Interrupts.WINDBG.UNKNOWN67:           // 0x0067
            /*
             * TODO: Figure out what to do with these notifications, if anything
             */
            break;

        case Interrupts.WINDBG.LOADHIGH:            // 0x005D
        case Interrupts.WINDBG.REGDOTCMD:           // 0x0070
        case Interrupts.WINDBG.CONDBP:              // 0xF001
            break;

        case Interrupts.WINDBG.CHECKFAULT:          // 0x007F
            if (this.fWinDbg) {
                /*
                 * AX == 0 means handle fault normally, 1 means issue TRAPFAULT
                 */
                cpu.regEAX = (cpu.regEAX & ~0xffff) | (this.fIgnoreNextCheckFault? 0 : 1);
                if (DEBUG) this.println("INT 0x41 CHECKFAULT: fault=" + Str.toHexWord(BX) + " type=" + Str.toHexWord(CX) + " trap=" + !this.fIgnoreNextCheckFault);
            }
            break;

        case Interrupts.WINDBG.TRAPFAULT:           // 0x0083
            /*
             * If we responded with AX == 1 to a preceding CHECKFAULT notification, then we should receive the
             * following TRAPFAULT notification; additionally, a TRAPFAULT notification may be issued without
             * any CHECKFAULT warning if the user was presented with a fault dialog containing a "Debug" button,
             * and the user clicked it.
             *
             * Regardless, whenever we receive this notification, we allocate a temporary breakpoint at the
             * reported fault address.
             */
            if (this.fWinDbg) {
                dbgAddr = this.newAddr(cpu.regEDX, CX);
                if (!this.cTrapFaults++) {
                    this.println("INT 0x41 TRAPFAULT: fault=" + Str.toHexWord(BX) + " error=" + Str.toHexLong(cpu.regESI) + " addr=" + this.toHexAddr(dbgAddr));
                    this.addBreakpoint(this.aBreakExec, dbgAddr, true);
                    this.historyInit(true);         // temporary breakpoints don't normally trigger history, but in this case, we want it to
                } else {
                    this.println("TRAPFAULT failed");
                    this.findBreakpoint(this.aBreakExec, dbgAddr, true, true, true);
                    this.cTrapFaults = 0;
                    this.stopCPU();
                }
            }
            break;

        case Interrupts.WINDBG.GETSYMBOL:           // 0x008D
            if (this.fWinDbg) cpu.regEAX = (cpu.regEAX & ~0xffff)|1;        // AX == 1 means not found
            break;

        case Interrupts.WINDBG.LOADSEG32:           // 0x0150
            /*
             *  SI == segment type:
             *      0x0     code selector
             *      0x1     data selector
             *  DX:EBX -> D386_Device_Params structure (see addSectionInfo() for details)
             */
            this.addSectionInfo(this.newAddr(cpu.regEBX, DX), !SI, !!this.fWinDbg);
            break;

        case Interrupts.WINDBG.FREESEG32:           // 0x0152
            /*
             *  BX == segment number
             *  DX:EDI -> module name
             */
            this.removeSectionInfo(BX, this.newAddr(cpu.regEDI, DX));
            break;

        default:
            if (DEBUG && this.fWinDbg) {
                this.println("INT 0x41: " + Str.toHexWord(AX));
            }
            break;
        }

        /*
         * Let's try to limit the scope of any "gt" command by resetting this flag after any INT 0x41
         */
        this.fIgnoreNextCheckFault = false;

        return !this.fWinDbg;
    }

    /**
     * intWindowsDebuggerRM()
     *
     * CONDITIONAL: if (Interrupts.WINDBGRM.ENABLED)
     *
     * This intercepts calls to the Windows Debugger real-mode interface (INT 0x68).
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @return {boolean} true to proceed with the INT 0x68 software interrupt, false to skip
     */
    intWindowsDebuggerRM(addr)
    {
        let cpu = this.cpu;
        let AL = cpu.regEAX & 0xff;
        let AH = (cpu.regEAX >> 8) & 0xff;
        let BX = cpu.regEBX & 0xffff;
        let CX = cpu.regECX & 0xffff;
        let DX = cpu.regEDX & 0xffff;
        let DI = cpu.regEDI & 0xffff;
        let ES = cpu.segES.sel;

        if (this.fWinDbgRM == null) {
            if (AH == Interrupts.WINDBGRM.IS_LOADED) {
                /*
                 * It looks like IFSHLP.SYS issues a preliminary INT 0x68 before Windows 95 gets rolling,
                 * and the Windows Debugger will not have had a chance to load yet, so we need to ignore
                 * that call.  We detect IFSHLP.SYS by looking for "IFS$" in the caller's code segment,
                 * where the IFSHLP device driver header is located.
                 */
                if (cpu.getLong((cpu.segCS.sel << 4) + 0x0A) == 0x24534649) {
                    if (DEBUG) this.println("Ignoring INT 0x68 from IFSHLP.SYS");
                    return true;
                }
                /*
                 * Ditto for WDEB386 itself, which presumably wants to avoid loading on top of itself.
                 */
                if (cpu.getLong((cpu.segCS.sel << 4) + 0x5F) == 0x42454457) {
                    if (DEBUG) this.println("Ignoring INT 0x68 from WDEB386.EXE");
                    return true;
                }
                /*
                 * We're only going to respond to this function if no one else did, in which case, we'll set
                 * fWinDbgRM to true and handle additional notifications.
                 */
                cpu.addIntReturn(addr, function(dbg) {
                    return function onInt68Return(nLevel) {
                        if ((cpu.regEAX & 0xffff) != Interrupts.WINDBGRM.LOADED) {
                            cpu.regEAX = (cpu.regEAX & ~0xffff) | Interrupts.WINDBGRM.LOADED;
                            dbg.printMessage("INT 0x68 handling enabled", Messages.MEM);
                            /*
                             * If we turn on INT 0x68 handling, we must also turn on INT 0x41 handling,
                             * because Windows assumes that the latter handler exists whenever the former does.
                             */
                            dbg.fWinDbg = dbg.fWinDbgRM = true;
                        } else {
                            dbg.printMessage("INT 0x68 monitoring enabled", Messages.MEM);
                            dbg.fWinDbgRM = false;
                        }
                    };
                }(this));
            }
            return true;
        }

        /*
         * NOTE: If this.fWinDbgRM is true, then all cases should return false, because we're taking full
         * responsibility for all requests (don't assume there's valid interrupt handler inside the machine).
         */
        switch(AH) {
        case Interrupts.WINDBGRM.IS_LOADED:         // 0x43
            if (this.fWinDbgRM) {
                cpu.regEAX = (cpu.regEAX & ~0xffff) | Interrupts.WINDBGRM.LOADED;
            }
            break;

        case Interrupts.WINDBGRM.PREP_PMODE:        // 0x44
            if (this.fWinDbgRM) {
                /*
                 * Use our fancy new "call break" mechanism to obtain a special address that will
                 * trap all calls, routing control to the specified function (callWindowsDebuggerPMInit).
                 */
                let a = cpu.segCS.addCallBreak(this.callWindowsDebuggerPMInit.bind(this));
                if (a) {
                    cpu.regEDI = a[0];              // ES:EDI receives the "call break" address
                    cpu.setES(a[1]);
                }
            }
            break;

        case Interrupts.WINDBGRM.FREESEG:           // 0x48
            this.removeSegmentInfo(BX);
            break;

        case Interrupts.WINDBGRM.REMOVESEGS:        // 0x4F
            /*
             * TODO: This probably just signals the end of module loading; nothing is required, but we should
             * clean up whatever we can....
             */
            break;

        case Interrupts.WINDBGRM.LOADSEG:           // 0x50
            if (AL == 0x20) {
                /*
                 *  Real-mode EXE
                 *  CX == paragraph
                 *  ES:DI -> module name
                 */
                this.addSegmentInfo(this.newAddr(DI, ES), 0, CX, true, !!this.fWinDbgRM);
            }
            else if (AL < 0x80) {
                /*
                 *  AL == segment type:
                 *      0x00    code selector
                 *      0x01    data selector
                 *      0x10    code segment
                 *      0x11    data segment
                 *      0x40    code segment & sel
                 *      0x41    data segment & sel
                 *  BX == segment #
                 *  CX == actual segment/selector
                 *  DX == actual selector (if 0x40 or 0x41)
                 *  ES:DI -> module name
                 */
                this.addSegmentInfo(this.newAddr(DI, ES), BX+1, (AL & 0x40)? DX : CX, !(AL & 0x1), !!this.fWinDbgRM);
            }
            else {
                /*
                 *  AL == segment type:
                 *      0x80    device driver code seg
                 *      0x81    device driver data seg
                 *  ES:DI -> D386_Device_Params structure (see addSectionInfo() for details)
                 */
                this.addSectionInfo(this.newAddr(DI, ES), !(AL & 0x1), !!this.fWinDbgRM);
            }
            if (this.fWinDbgRM) {
                cpu.regEAX = (cpu.regEAX & ~0xff) | 0x01;
            }
            break;

        default:
            if (DEBUG && this.fWinDbgRM) {
                this.println("INT 0x68: " + Str.toHexByte(AH));
            }
            break;
        }

        return !this.fWinDbgRM;
    }

    /**
     * callWindowsDebuggerPMInit()
     *
     * CONDITIONAL: if (Interrupts.WINDBGRM.ENABLED)
     *
     * This intercepts calls to the Windows Debugger "PMInit" interface; eg:
     *
     *      AL = function code
     *
     *          0 - initialize IDT
     *              ES:EDI points to protected mode IDT
     *
     *          1 - initialize page checking
     *              BX = physical selector
     *              ECX = linear bias
     *
     *          2 - specify that debug queries are supported
     *
     *          3 - initialize spare PTE
     *              EBX = linear address of spare PTE
     *              EDX = linear address the PTE represents
     *
     *          4 - set Enter/Exit VMM routine address
     *              EBX = Enter VMM routine address
     *              ECX = Exit VMM routine address
     *              EDX = $_Debug_Out_Service address
     *              ESI = $_Trace_Out_Service address
     *              The VMM enter/exit routines must return with a retfd
     *
     *          5 - get debugger size/physical address
     *              returns: AL = 0 (don't call AL = 1)
     *              ECX = size in bytes
     *              ESI = starting physical code/data address
     *
     *          6 - set debugger base/initialize spare PTE
     *              EBX = linear address of spare PTE
     *              EDX = linear address the PTE represents
     *              ESI = starting linear address of debug code/data
     *
     *          7 - enable memory context functions
     *
     * @this {DebuggerX86}
     * @return {boolean} (must always return false to skip the call, because the call is using a CALLBREAK address)
     */
    callWindowsDebuggerPMInit()
    {
        let cpu = this.cpu;
        let AL = cpu.regEAX & 0xff;
        if (MAXDEBUG) this.println("INT 0x68 callback: " + Str.toHexByte(AL));
        if (AL == 5) {
            cpu.regECX = cpu.regESI = 0;                // our in-machine debugger footprint is zero
            cpu.regEAX = (cpu.regEAX & ~0xff) | 0x01;   // TODO: Returning a "don't call" response sounds good, but what does it REALLY mean?
        }
        return false;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {DebuggerX86}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "debugInput")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let dbg = this;
        switch (sBinding) {

        case "debugInput":
            this.bindings[sBinding] = control;
            this.controlDebug = /** @type {HTMLInputElement} */ (control);
            /*
             * For halted machines, this is fine, but for auto-start machines, it can be annoying.
             *
             *      controlInput.focus();
             */
            control.onkeydown = function onKeyDownDebugInput(event) {
                let sCmd;
                if (event.keyCode == Keys.KEYCODE.CR) {
                    sCmd = dbg.controlDebug.value;
                    dbg.controlDebug.value = "";
                    dbg.doCommands(sCmd, true);
                }
                else if (event.keyCode == Keys.KEYCODE.ESC) {
                    dbg.controlDebug.value = sCmd = "";
                }
                else {
                    if (event.keyCode == Keys.KEYCODE.UP) {
                        sCmd = dbg.getPrevCommand();
                    }
                    else if (event.keyCode == Keys.KEYCODE.DOWN) {
                        sCmd = dbg.getNextCommand();
                    }
                    if (sCmd != null) {
                        let cch = sCmd.length;
                        dbg.controlDebug.value = sCmd;
                        dbg.controlDebug.setSelectionRange(cch, cch);
                    }
                }
                if (sCmd != null && event.preventDefault) event.preventDefault();
            };
            return true;

        case "debugEnter":
            this.bindings[sBinding] = control;
            Web.onClickRepeat(
                control,
                500, 100,
                function onClickDebugEnter(fRepeat) {
                    if (dbg.controlDebug) {
                        let sCommands = dbg.controlDebug.value;
                        dbg.controlDebug.value = "";
                        dbg.doCommands(sCommands, true);
                        return true;
                    }
                    if (DEBUG) dbg.log("no debugger input buffer");
                    return false;
                }
            );
            return true;

        case "step":
            this.bindings[sBinding] = control;
            Web.onClickRepeat(
                control,
                500, 100,
                function onClickStep(fRepeat) {
                    let fCompleted = false;
                    if (!dbg.isBusy(true)) {
                        dbg.setBusy(true);
                        fCompleted = dbg.stepCPU(fRepeat? 1 : 0);
                        dbg.setBusy(false);
                    }
                    return fCompleted;
                }
            );
            return true;

        default:
            break;
        }
        return false;
    }

    /**
     * updateFocus()
     *
     * @this {DebuggerX86}
     */
    updateFocus()
    {
        if (this.controlDebug) this.controlDebug.focus();
    }

    /**
     * getCPUMode()
     *
     * @this {DebuggerX86}
     * @return {boolean} (true if protected mode, false if not)
     */
    getCPUMode()
    {
        return !!(this.cpu && (this.cpu.regCR0 & X86.CR0.MSW.PE) && !(this.cpu.regPS & X86.PS.VM));
    }

    /**
     * getAddressType()
     *
     * @this {DebuggerX86}
     * @return {number}
     */
    getAddressType()
    {
        return this.getCPUMode()? DebuggerX86.ADDRTYPE.PROT : DebuggerX86.ADDRTYPE.REAL;
    }

    /**
     * getSegment(sel, type)
     *
     * If the selector matches that of any of the CPU segment registers, then return the CPU's segment
     * register, instead of using our own segDebugger segment register.  This makes it possible for us to
     * see what the CPU is seeing at certain critical junctures, such as after an LMSW instruction has
     * switched the processor from real to protected mode.  Actually loading the selector from the GDT/LDT
     * should be done only as a last resort.
     *
     * @this {DebuggerX86}
     * @param {number|undefined} sel
     * @param {number} [type] (defaults to getAddressType())
     * @return {SegX86|null} seg
     */
    getSegment(sel, type)
    {
        let typeDefault = this.getAddressType();

        if (!type) type = typeDefault;

        if (type == typeDefault) {
            if (sel === this.cpu.getCS()) return this.cpu.segCS;
            if (sel === this.cpu.getDS()) return this.cpu.segDS;
            if (sel === this.cpu.getES()) return this.cpu.segES;
            if (sel === this.cpu.getSS()) return this.cpu.segSS;
            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                if (sel === this.cpu.getFS()) return this.cpu.segFS;
                if (sel === this.cpu.getGS()) return this.cpu.segGS;
            }
            /*
             * Even if nSuppressBreaks is set, we'll allow the call in real-mode,
             * because a loadReal() request using segDebugger should generally be safe.
             */
            if (this.nSuppressBreaks && type == DebuggerX86.ADDRTYPE.PROT || !this.segDebugger) return null;
        }
        let seg = this.segDebugger;
        if (type != DebuggerX86.ADDRTYPE.PROT) {
            seg.loadReal(sel);
            seg.limit = 0xffff;         // although an ACTUAL real-mode segment load would not modify the limit,
            seg.offMax = 0x10000;       // proper segDebugger operation requires that we update the limit ourselves
        } else {
            seg.probeDesc(sel);
        }
        return seg;
    }

    /**
     * getAddr(dbgAddr, fWrite, nb)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86|undefined} dbgAddr
     * @param {boolean} [fWrite]
     * @param {number} [nb] number of bytes to check (1, 2 or 4); default is 1
     * @return {number} is the corresponding linear address, or X86.ADDR_INVALID
     */
    getAddr(dbgAddr, fWrite, nb)
    {
        /*
         * Some addresses (eg, breakpoint addresses) save their original linear address in dbgAddr.addr,
         * so we want to use that if it's there, but otherwise, dbgAddr is assumed to be a segmented address
         * whose linear address must always be (re)calculated based on current machine state (mode, active
         * descriptor tables, etc).
         */
        let addr = dbgAddr && dbgAddr.addr;
        if (addr == undefined) {
            addr = X86.ADDR_INVALID;
            if (dbgAddr) {
                /*
                 * TODO: We should try to cache the seg inside dbgAddr, to avoid unnecessary calls to getSegment().
                 */
                let seg = this.getSegment(dbgAddr.sel, dbgAddr.type);
                if (seg) {
                    if (!fWrite) {
                        addr = seg.checkReadDebugger(dbgAddr.off || 0, nb || 1);
                    } else {
                        addr = seg.checkWriteDebugger(dbgAddr.off || 0, nb || 1);
                    }
                    dbgAddr.addr = addr;
                }
            }
        }
        return addr;
    }

    /**
     * getByte(dbgAddr, inc)
     *
     * We must route all our memory requests through the CPU now, in case paging is enabled.
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {number} [inc]
     * @return {number}
     */
    getByte(dbgAddr, inc)
    {
        let b = 0xff;
        let addr = this.getAddr(dbgAddr, false, 1);
        if (addr !== X86.ADDR_INVALID) {
            /*
             * TODO: Determine what we should do about the fact that we're masking any error from probeAddr()
             */
            b = this.cpu.probeAddr(addr, 1, dbgAddr.type == DebuggerX86.ADDRTYPE.PHYSICAL) | 0;
            if (inc) this.incAddr(dbgAddr, inc);
        }
        return b;
    }

    /**
     * getWord(dbgAddr, fAdvance)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {boolean} [fAdvance]
     * @return {number}
     */
    getWord(dbgAddr, fAdvance)
    {
        return dbgAddr.fData32? this.getLong(dbgAddr, fAdvance? 4 : 0) : this.getShort(dbgAddr, fAdvance? 2 : 0);
    }

    /**
     * getShort(dbgAddr, inc)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {number} [inc]
     * @return {number}
     */
    getShort(dbgAddr, inc)
    {
        let w = 0xffff;
        let addr = this.getAddr(dbgAddr, false, 2);
        if (addr !== X86.ADDR_INVALID) {
            /*
             * TODO: Determine what we should do about the fact that we're masking any error from probeAddr()
             */
            w = this.cpu.probeAddr(addr, 2, dbgAddr.type == DebuggerX86.ADDRTYPE.PHYSICAL) | 0;
            if (inc) this.incAddr(dbgAddr, inc);
        }
        return w;
    }

    /**
     * getLong(dbgAddr, inc)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {number} [inc]
     * @return {number}
     */
    getLong(dbgAddr, inc)
    {
        let l = -1;
        let addr = this.getAddr(dbgAddr, false, 4);
        if (addr !== X86.ADDR_INVALID) {
            /*
             * TODO: Determine what we should do about the fact that we're masking any error from probeAddr()
             */
            l = this.cpu.probeAddr(addr, 4, dbgAddr.type == DebuggerX86.ADDRTYPE.PHYSICAL) | 0;
            if (inc) this.incAddr(dbgAddr, inc);
        }
        return l;
    }

    /**
     * setByte(dbgAddr, b, inc, fNoUpdate)
     *
     * NOTE: If you need to patch a ROM, you MUST use the ROM location's physical address.
     *
     * WARNING: Be careful with the editing commands that use function, because we don't have a safe
     * counterpart to cpu.probeAddr().
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {number} b
     * @param {number} [inc]
     * @param {boolean} [fNoUpdate] (when doing a large number of setByte() calls, set this to true and call cpu.updateCPU() when you're done)
     */
    setByte(dbgAddr, b, inc, fNoUpdate)
    {
        let addr = this.getAddr(dbgAddr, true, 1);
        if (addr !== X86.ADDR_INVALID) {
            if (dbgAddr.type != DebuggerX86.ADDRTYPE.PHYSICAL) {
                this.cpu.setByte(addr, b);
            } else {
                this.bus.setByteDirect(addr, b);
            }
            if (inc) this.incAddr(dbgAddr, inc);
            if (!fNoUpdate) this.cpu.updateCPU(true);   // we set fForce to true in case video memory was the target
        }
    }

    /**
     * setShort(dbgAddr, w, inc)
     *
     * NOTE: If you need to patch a ROM, you MUST use the ROM location's physical address.
     *
     * WARNING: Be careful with the editing commands that use function, because we don't have a safe
     * counterpart to cpu.probeAddr().
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {number} w
     * @param {number} [inc]
     */
    setShort(dbgAddr, w, inc)
    {
        let addr = this.getAddr(dbgAddr, true, 2);
        if (addr !== X86.ADDR_INVALID) {
            if (dbgAddr.type != DebuggerX86.ADDRTYPE.PHYSICAL) {
                this.cpu.setShort(addr, w);
            } else {
                this.bus.setShortDirect(addr, w);
            }
            if (inc) this.incAddr(dbgAddr, inc);
            this.cpu.updateCPU(true);           // we set fForce to true in case video memory was the target
        }
    }

    /**
     * newAddr(off, sel, addr, type, fData32, fAddr32)
     *
     * Returns a NEW DbgAddrX86 object, initialized with specified values and/or defaults.
     *
     * @this {DebuggerX86}
     * @param {number} [off] (default is zero)
     * @param {number} [sel] (default is undefined)
     * @param {number} [addr] (default is undefined)
     * @param {number} [type] (default is based on current CPU mode)
     * @param {boolean} [fData32] (default is the current CPU operand size)
     * @param {boolean} [fAddr32] (default is the current CPU address size)
     * @return {DbgAddrX86}
     */
    newAddr(off, sel, addr, type, fData32, fAddr32)
    {
        return this.setAddr({}, off, sel, addr, type, fData32, fAddr32);
    }

    /**
     * getAddrPrefix(dbgAddr)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @return {string}
     */
    getAddrPrefix(dbgAddr)
    {
        let ch;

        switch (dbgAddr.type) {
        case DebuggerX86.ADDRTYPE.REAL:
        case DebuggerX86.ADDRTYPE.V86:
            ch = '&';
            break;
        case DebuggerX86.ADDRTYPE.PROT:
            ch = '#';
            break;
        case DebuggerX86.ADDRTYPE.LINEAR:
            ch = '%';
            break;
        case DebuggerX86.ADDRTYPE.PHYSICAL:
            ch = '%%';
            break;
        default:
            ch = dbgAddr.sel? '' : '%';
            break;
        }
        return ch;
    }

    /**
     * setAddr(dbgAddr, off, sel, addr, type, fData32, fAddr32)
     *
     * Updates an EXISTING DbgAddrX86 object, initialized with specified values and/or defaults.
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {number} [off] (default is zero)
     * @param {number} [sel] (default is undefined)
     * @param {number} [addr] (default is undefined)
     * @param {number} [type] (default is based on current CPU mode)
     * @param {boolean} [fData32] (default is the current CPU operand size)
     * @param {boolean} [fAddr32] (default is the current CPU address size)
     * @return {DbgAddrX86}
     */
    setAddr(dbgAddr, off, sel, addr, type, fData32, fAddr32)
    {
        dbgAddr.off = off || 0;
        dbgAddr.sel = sel;
        dbgAddr.addr = addr;
        dbgAddr.type = type || this.getAddressType();
        dbgAddr.fData32 = (fData32 != undefined)? fData32 : !!(this.cpu && this.cpu.segCS.sizeData == 4);
        dbgAddr.fAddr32 = (fAddr32 != undefined)? fAddr32 : !!(this.cpu && this.cpu.segCS.sizeAddr == 4);
        dbgAddr.fTempBreak = false;
        return dbgAddr;
    }

    /**
     * packAddr(dbgAddr)
     *
     * Packs a DbgAddrX86 object into an Array suitable for saving in a machine state object.
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @return {Array}
     */
    packAddr(dbgAddr)
    {
        return [dbgAddr.off, dbgAddr.sel, dbgAddr.addr, dbgAddr.fTempBreak, dbgAddr.fData32, dbgAddr.fAddr32, dbgAddr.cOverrides, dbgAddr.fComplete];
    }

    /**
     * unpackAddr(aAddr)
     *
     * Unpacks a DbgAddrX86 object from an Array created by packAddr() and restored from a saved machine state.
     *
     * @this {DebuggerX86}
     * @param {Array} aAddr
     * @return {DbgAddrX86}
     */
    unpackAddr(aAddr)
    {
        return {off: aAddr[0], sel: aAddr[1], addr: aAddr[2], fTempBreak: aAddr[3], fData32: aAddr[4], fAddr32: aAddr[5], cOverrides: aAddr[6], fComplete: aAddr[7]};
    }

    /**
     * checkLimit(dbgAddr, fUpdate)
     *
     * Used by incAddr() and parseAddr() to ensure that the (updated) dbgAddr offset is within segment bounds.
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {boolean} [fUpdate] (true to update segment info)
     * @return {boolean}
     */
    checkLimit(dbgAddr, fUpdate)
    {
        if (dbgAddr.sel != undefined) {
            let seg = this.getSegment(dbgAddr.sel, dbgAddr.type);
            if (seg) {
                let off = dbgAddr.off;
                if (!seg.fExpDown) {
                    if ((off >>> 0) >= seg.offMax) {
                        return false;
                    }
                }
                else {
                    if ((off >>> 0) < seg.offMax) {
                        return false;
                    }
                }
                if (fUpdate) {
                    dbgAddr.off = off & seg.maskAddr;
                    dbgAddr.fData32 = (seg.sizeData == 4);
                    dbgAddr.fAddr32 = (seg.sizeAddr == 4);
                }
            }
        }
        return true;
    }

    /**
     * parseAddr(sAddr, fCode, fNoChecks, fQuiet)
     *
     * As discussed above, dbgAddr variables contain one or more of: off, sel, and addr.  They represent
     * a segmented address (sel:off) when sel is defined or a linear address (addr) when sel is undefined.
     *
     * To create a segmented address, specify two values separated by ':'; for a linear address, use
     * a '%' prefix.  We check for ':' after '%', so if for some strange reason you specify both, the
     * address will be treated as segmented, not linear.
     *
     * The '%' syntax is similar to that used by the Windows 80386 kernel debugger (wdeb386) for linear
     * addresses.  If/when we add support for processors with page tables, we will likely adopt the same
     * convention for linear addresses and provide a different syntax (eg, "%%") physical memory references.
     *
     * Address evaluation and validation (eg, range checks) are no longer performed at this stage.  That's
     * done later, by getAddr(), which returns X86.ADDR_INVALID for invalid segments, out-of-range offsets,
     * etc.  The Debugger's low-level get/set memory functions verify all getAddr() results, but even if an
     * invalid address is passed through to the Bus memory interfaces, the address will simply be masked with
     * Bus.nBusLimit; in the case of X86.ADDR_INVALID, that will generally refer to the top of the physical
     * address space.
     *
     * @this {DebuggerX86}
     * @param {string|undefined} sAddr
     * @param {boolean} [fCode] (true if target is code, false if target is data)
     * @param {boolean} [fNoChecks] (true when setting breakpoints that may not be valid now, but will be later)
     * @param {boolean} [fQuiet]
     * @return {DbgAddrX86|undefined}
     */
    parseAddr(sAddr, fCode, fNoChecks, fQuiet)
    {
        let dbgAddr;
        let dbgAddrNext = (fCode? this.dbgAddrNextCode : this.dbgAddrNextData);

        let type = fNoChecks? DebuggerX86.ADDRTYPE.NONE : dbgAddrNext.type;
        let off = dbgAddrNext.off, sel = dbgAddrNext.sel, addr = dbgAddrNext.addr;

        if (sAddr !== undefined) {

            sAddr = this.parseReference(sAddr);

            let ch = sAddr.charAt(0);
            let iColon = sAddr.indexOf(':');

            switch(ch) {
            case '&':
                type = DebuggerX86.ADDRTYPE.REAL;
                break;
            case '#':
                type = DebuggerX86.ADDRTYPE.PROT;
                break;
            case '%':
                type = DebuggerX86.ADDRTYPE.LINEAR;
                ch = sAddr.charAt(1);
                if (ch == '%') {
                    type = DebuggerX86.ADDRTYPE.PHYSICAL;
                    ch += ch;
                }
                off = addr = 0;
                sel = undefined;        // we still have code that relies on this crutch, instead of the type field
                break;
            default:
                if (iColon >= 0) type = DebuggerX86.ADDRTYPE.NONE;
                ch = '';
                break;
            }

            if (ch) {
                sAddr = sAddr.substr(ch.length);
                iColon -= ch.length;
            }

            dbgAddr = this.findSymbolAddr(sAddr);
            if (dbgAddr) return dbgAddr;

            if (iColon < 0) {
                if (sel != undefined) {
                    off = this.parseExpression(sAddr, fQuiet);
                    addr = undefined;
                } else {
                    addr = this.parseExpression(sAddr, fQuiet);
                    if (addr == undefined) off = undefined;
                }
            }
            else {
                sel = this.parseExpression(sAddr.substring(0, iColon), fQuiet);
                off = this.parseExpression(sAddr.substring(iColon + 1), fQuiet);
                addr = undefined;
            }
        }

        if (off != undefined) {
            dbgAddr = this.newAddr(off, sel, addr, type);
            if (!fNoChecks && !this.checkLimit(dbgAddr, true)) {
                this.println("invalid offset: " + this.toHexAddr(dbgAddr));
                dbgAddr = undefined;
            }
        }
        return dbgAddr;
    }

    /**
     * parseAddrOptions(dbgAddr, sOptions)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {string} [sOptions]
     */
    parseAddrOptions(dbgAddr, sOptions)
    {
        if (sOptions) {
            let a = sOptions.match(/(['"])(.*?)\1/);
            if (a) {
                dbgAddr.aCmds = this.parseCommand(dbgAddr.sCmd = a[2]);
            }
        }
    }

    /**
     * parseAddrReference(s, sAddr)
     *
     * Returns the given string with the given address references replaced with the contents of the address.
     *
     * @this {Debugger}
     * @param {string} s
     * @param {string} sAddr
     * @return {string}
     */
    parseAddrReference(s, sAddr)
    {
        let dbgAddr = this.parseAddr(sAddr);
        return s.replace('[' + sAddr + ']', dbgAddr? Str.toHex(this.getWord(dbgAddr), dbgAddr.fData32? 8 : 4) : "undefined");
    }

    /**
     * incAddr(dbgAddr, inc)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {number} [inc] contains value to increment dbgAddr by (default is 1)
     */
    incAddr(dbgAddr, inc)
    {
        inc = inc || 1;
        if (dbgAddr.addr != undefined) {
            dbgAddr.addr += inc;
        }
        if (dbgAddr.sel != undefined) {
            dbgAddr.off += inc;
            if (!this.checkLimit(dbgAddr)) {
                dbgAddr.off = 0;
                dbgAddr.addr = undefined;
            }
        }
    }

    /**
     * toHexOffset(off, sel, fAddr32)
     *
     * @this {DebuggerX86}
     * @param {number|undefined} [off]
     * @param {number|undefined} [sel]
     * @param {boolean} [fAddr32] is true for 32-bit ADDRESS size
     * @return {string} the hex representation of off (or sel:off)
     */
    toHexOffset(off, sel, fAddr32)
    {
        if (sel != undefined) {
            return Str.toHex(sel, 4) + ':' + Str.toHex(off, (off & ~0xffff) || fAddr32? 8 : 4);
        }
        return Str.toHex(off);
    }

    /**
     * toHexAddr(dbgAddr)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @return {string} the hex representation of the address
     */
    toHexAddr(dbgAddr)
    {
        let ch = this.getAddrPrefix(dbgAddr);
        /*
         * TODO: Revisit the decision to check sel == undefined; I would rather see these decisions based on type.
         */
        return (dbgAddr.type >= DebuggerX86.ADDRTYPE.LINEAR || dbgAddr.sel == undefined)? (ch + Str.toHex(dbgAddr.addr)) : (ch + this.toHexOffset(dbgAddr.off, dbgAddr.sel, dbgAddr.fAddr32));
    }

    /**
     * getSZ(dbgAddr, cchMax)
     *
     * Gets zero-terminated (aka "ASCIIZ") string from dbgAddr.  It also stops at the first '$', in case this is
     * a '$'-terminated string -- mainly because I'm lazy and didn't feel like writing a separate get() function.
     * Yes, a zero-terminated string containing a '$' will be prematurely terminated, and no, I don't care.
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {number} [cchMax] (default is 256)
     * @return {string} (and dbgAddr advanced past the terminating zero)
     */
    getSZ(dbgAddr, cchMax)
    {
        let s = "";
        cchMax = cchMax || 256;
        while (s.length < cchMax) {
            let b = this.getByte(dbgAddr, 1);
            if (!b || b == 0x24 || b >= 127) break;
            s += (b >= 32? String.fromCharCode(b) : '.');
        }
        return s;
    }

    /**
     * dumpBackTrack(asArgs)
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    dumpBackTrack(asArgs)
    {
        let sInfo = "no information";
        if (BACKTRACK) {
            let sAddr = asArgs[0];
            let dbgAddr = this.parseAddr(sAddr, true, true, true);
            if (dbgAddr) {
                let addr = this.getAddr(dbgAddr);
                if (dbgAddr.type != DebuggerX86.ADDRTYPE.PHYSICAL) {
                    let pageInfo = this.getPageInfo(addr);
                    if (pageInfo) {
                        dbgAddr.addr = pageInfo.addrPhys;
                        dbgAddr.type = DebuggerX86.ADDRTYPE.PHYSICAL;
                    }
                }
                sInfo = this.toHexAddr(dbgAddr) + ": " + (this.bus.getSymbol(addr, true) || sInfo);
            } else {
                let component, componentPrev = null;
                while (component = this.cmp.getMachineComponent("Disk", componentPrev)) {
                    let aInfo = component.getSymbolInfo(sAddr);
                    if (aInfo.length) {
                        sInfo = "";
                        for (let i in aInfo) {
                            let a = aInfo[i];
                            if (sInfo) sInfo += '\n';
                            sInfo += a[0] + ": " + a[1] + ' ' + Str.toHex(a[2], 4) + ':' + Str.toHex(a[3], 4) + " len " + Str.toHexWord(a[4]);
                        }
                    }
                    componentPrev = component;
                }
            }
        }
        return sInfo;
    }

    /**
     * dumpBlocks(aBlocks, sAddr, fLinear)
     *
     * @this {DebuggerX86}
     * @param {Array} aBlocks
     * @param {string} [sAddr] (optional block address)
     * @param {boolean} [fLinear] (true if linear, physical otherwise)
     */
    dumpBlocks(aBlocks, sAddr, fLinear)
    {
        let addr = 0, i = 0, n = aBlocks.length;

        if (sAddr) {
            addr = this.getAddr(this.parseAddr(sAddr));
            if (addr === X86.ADDR_INVALID) {
                this.println("invalid address: " + sAddr);
                return;
            }
            i = addr >>> this.cpu.nBlockShift;
            n = 1;
        }

        this.println("blockid   " + (fLinear? "linear  " : "physical") + "   blockaddr   used    size    type");
        this.println("--------  ---------  ----------  ------  ------  ----");

        let typePrev = -1, cPrev = 0;
        while (n--) {
            let block = aBlocks[i];
            /*
             * We need to replicate a portion of what probeAddr() does, which is to "peek" at the
             * underlying physical block of any UNPAGED block.  An UNPAGED block doesn't imply
             * that the page is invalid, but merely that the CPU has not yet been asked to perform
             * the page directory/page table lookup.
             *
             * To do that, we use the same mapPageBlock() interface that the CPU uses, with fSuppress
             * set, so that it doesn't 1) generate a fault or 2) modify the block.  Blocks should only
             * "validated" when a CPU operation touches the corresponding page, and they should be only
             * be "invalidated" when the CPU wants to flush the TLB (ie, whenever CR3 is updated).
             */
            if (block && block.type == Memory.TYPE.UNPAGED) {
                block = this.cpu.mapPageBlock(addr, false, true);
            }
            if (block.type == typePrev) {
                if (!cPrev++) this.println("...");
            } else {
                typePrev = block.type;
                let sType = Memory.TYPE.NAMES[typePrev];
                if (typePrev == Memory.TYPE.PAGED) {
                    block = block.blockPhys;

                    sType += " -> " + Memory.TYPE.NAMES[block.type];
                }
                if (block) {
                    this.println(Str.toHex(block.id, 8) + "  %" + Str.toHex(i << this.cpu.nBlockShift, 8) + "  %%" + Str.toHex(block.addr, 8) + "  " + Str.toHexWord(block.used) + "  " + Str.toHexWord(block.size) + "  " + sType);
                }
                if (typePrev != Memory.TYPE.NONE && typePrev != Memory.TYPE.UNPAGED) typePrev = -1;
                cPrev = 0;
            }
            addr += this.cpu.nBlockSize;
            i++;
        }
    }

    /**
     * dumpBus(asArgs)
     *
     * Dumps Bus allocations.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs (asArgs[0] is an optional block address)
     */
    dumpBus(asArgs)
    {
        this.dumpBlocks(this.cpu.aBusBlocks, asArgs[0]);
    }

    /**
     * dumpDOS(asArgs)
     *
     * Dumps DOS MCBs (Memory Control Blocks).
     *
     * TODO: Add some code to detect the current version of DOS (if any) and locate the first MCB automatically.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    dumpDOS(asArgs)
    {
        let mcb;
        let sMCB = asArgs[0];
        if (sMCB) {
            mcb = this.parseValue(sMCB);
        }
        if (mcb === undefined) {
            this.println("invalid MCB");
            return;
        }
        this.println("dumpMCB(" + Str.toHexWord(mcb) + ')');
        while (mcb) {
            let dbgAddr = this.newAddr(0, mcb);
            let bSig = this.getByte(dbgAddr, 1);
            let wPID = this.getShort(dbgAddr, 2);
            let wParas = this.getShort(dbgAddr, 5);
            if (bSig != 0x4D && bSig != 0x5A) break;
            this.println(this.toHexOffset(0, mcb) + ": '" + String.fromCharCode(bSig) + "' PID=" + Str.toHexWord(wPID) + " LEN=" + Str.toHexWord(wParas) + ' "' + this.getSZ(dbgAddr, 8) + '"');
            mcb += 1 + wParas;
        }
    }

    /**
     * dumpIDT(asArgs)
     *
     * Dumps an IDT vector entry.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    dumpIDT(asArgs)
    {
        let sIDT = asArgs[0];

        if (!sIDT) {
            this.println("no IDT vector");
            return;
        }

        let nIDT = this.parseValue(sIDT);
        if (nIDT === undefined || nIDT < 0 || nIDT > 255) {
            this.println("invalid vector: " + sIDT);
            return;
        }

        let ch = '&', fProt = this.cpu.isProtMode(), fAddr32 = false;
        let addrIDT = this.cpu.addrIDT + (nIDT << (fProt? 3 : 2));
        let off = this.cpu.getShort(addrIDT + X86.DESC.LIMIT.OFFSET);
        let sel = this.cpu.getShort(addrIDT + X86.DESC.BASE.OFFSET);
        if (fProt) {
            ch = '#';
            let acc = this.cpu.getShort(addrIDT + X86.DESC.ACC.OFFSET);
            if (acc & X86.DESC.ACC.TYPE.NONSEG_386) {
                fAddr32 = true;
                off |= this.cpu.getShort(addrIDT + X86.DESC.EXT.OFFSET) << 16;
            }
        }

        this.println("dumpIDT(" + Str.toHexWord(nIDT) + "): " + ch + Str.toHex(sel, 4) + ':' + Str.toHex(off, fAddr32? 8 : 4));
    }

    /**
     * dumpMem(asArgs)
     *
     * Dumps page allocations.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs (asArgs[0] is an optional block address)
     */
    dumpMem(asArgs)
    {
        this.dumpBlocks(this.cpu.aMemBlocks, asArgs[0], this.cpu.aMemBlocks !== this.cpu.aBusBlocks);
    }

    /**
     * getPageEntry(addrPE, lPE, fPTE)
     *
     * @this {DebuggerX86}
     * @param {number} addrPE
     * @param {number} lPE
     * @param {boolean} [fPTE] (true if the entry is a PTE, false if it's a PDE)
     * @return {string}
     */
    getPageEntry(addrPE, lPE, fPTE)
    {
        let s = Str.toHex(addrPE) + ' ' + Str.toHex(lPE) + ' ';
        s += (fPTE && (lPE & X86.PTE.DIRTY))? 'D' : '-';
        s += (lPE & X86.PTE.ACCESSED)? 'A' : '-';
        s += (lPE & X86.PTE.USER)? 'U' : 'S';
        s += (lPE & X86.PTE.READWRITE)? 'W' : 'R';
        s += (lPE & X86.PTE.PRESENT)? 'P' : 'N';
        return s;
    }

    /**
     * getPageInfo(addr)
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @return {Object|null}
     */
    getPageInfo(addr)
    {
        let pageInfo = null;
        if (I386 && this.cpu.model >= X86.MODEL_80386) {
            let bus = this.bus;
            /*
             * Here begins code remarkably similar to mapPageBlock() (with fSuppress set).
             */
            pageInfo = {};
            pageInfo.offPDE = (addr & X86.LADDR.PDE.MASK) >>> X86.LADDR.PDE.SHIFT;
            pageInfo.addrPDE = this.cpu.regCR3 + pageInfo.offPDE;
            pageInfo.blockPDE = bus.aMemBlocks[(pageInfo.addrPDE & bus.nBusMask) >>> bus.nBlockShift];
            pageInfo.lPDE = pageInfo.blockPDE.readLong(pageInfo.offPDE);
            pageInfo.offPTE = (addr & X86.LADDR.PTE.MASK) >>> X86.LADDR.PTE.SHIFT;
            pageInfo.addrPTE = (pageInfo.lPDE & X86.PTE.FRAME) + pageInfo.offPTE;
            pageInfo.blockPTE = bus.aMemBlocks[(pageInfo.addrPTE & bus.nBusMask) >>> bus.nBlockShift];
            pageInfo.lPTE = pageInfo.blockPTE.readLong(pageInfo.offPTE);
            pageInfo.addrPhys = (pageInfo.lPTE & X86.PTE.FRAME) + (addr & X86.LADDR.OFFSET);
            //let blockPhys = bus.aMemBlocks[(addrPhys & bus.nBusMask) >>> bus.nBlockShift];
        }
        return pageInfo;
    }

    /**
     * dumpPage(asArgs)
     *
     * Dumps page table information about the given linear address.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    dumpPage(asArgs)
    {
        let sAddr = asArgs[0];
        if (!sAddr) {
            this.println("missing address");
            return;
        }

        let addr = this.getAddr(this.parseAddr(sAddr));
        if (addr === X86.ADDR_INVALID) {
            this.println("invalid address: " + sAddr);
            return;
        }

        let pageInfo = this.getPageInfo(addr);
        if (!pageInfo) {
            this.println("unsupported operation");
            return;
        }

        this.println("linear     PDE addr   PDE             PTE addr   PTE             physical" );
        this.println("---------  ---------- --------        ---------- --------        ----------");
        let s = '%' + Str.toHex(addr);
        s += "  %%" + this.getPageEntry(pageInfo.addrPDE, pageInfo.lPDE);
        s += "  %%" + this.getPageEntry(pageInfo.addrPTE, pageInfo.lPTE, true);
        s += "  %%" + Str.toHex(pageInfo.addrPhys);
        this.println(s);
    }

    /**
     * dumpSel(asArgs)
     *
     * Dumps a descriptor for the given selector.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    dumpSel(asArgs)
    {
        let sSel = asArgs[0];

        if (!sSel) {
            this.println("no selector");
            return;
        }

        let sel = this.parseValue(sSel);
        if (sel === undefined) {
            this.println("invalid selector: " + sSel);
            return;
        }

        let seg = this.getSegment(sel, DebuggerX86.ADDRTYPE.PROT);
        this.println("dumpSel(" + Str.toHexWord(seg? seg.sel : sel) + "): %" + Str.toHex(seg? seg.addrDesc : null, this.cchAddr));
        if (!seg) return;

        let sType;
        let fGate = false;
        if (seg.type & X86.DESC.ACC.TYPE.SEG) {
            if (seg.type & X86.DESC.ACC.TYPE.CODE) {
                sType = "code";
                sType += (seg.type & X86.DESC.ACC.TYPE.READABLE)? ",readable" : ",execonly";
                if (seg.type & X86.DESC.ACC.TYPE.CONFORMING) sType += ",conforming";
            }
            else {
                sType = "data";
                sType += (seg.type & X86.DESC.ACC.TYPE.WRITABLE)? ",writable" : ",readonly";
                if (seg.type & X86.DESC.ACC.TYPE.EXPDOWN) sType += ",expdown";
            }
            if (seg.type & X86.DESC.ACC.TYPE.ACCESSED) sType += ",accessed";
        }
        else {
            let sysDesc = DebuggerX86.SYSDESCS[seg.type];
            if (sysDesc) {
                sType = sysDesc[0];
                fGate = sysDesc[1];
            }
        }

        if (sType && !(seg.acc & X86.DESC.ACC.PRESENT)) sType += ",not present";

        let sDump;
        if (fGate) {
            sDump = "seg=" + Str.toHexWord(seg.base & 0xffff) + " off=" + Str.toHexWord(seg.limit);
        } else {
            sDump = "base=" + Str.toHex(seg.base, this.cchAddr) + " limit=" + this.getLimitString(seg.limit);
        }
        /*
         * When we dump the EXT word, we mask off the LIMIT1619 and BASE2431 bits, because those have already
         * been incorporated into the limit and base properties of the segment register; all we care about here
         * are whether EXT contains any of the AVAIL (0x10), BIG (0x40) or LIMITPAGES (0x80) bits.
         */
        this.println(sDump + " type=" + Str.toHexByte(seg.type >> 8) + " (" + sType + ')' + " ext=" + Str.toHexWord(seg.ext & ~(X86.DESC.EXT.LIMIT1619 | X86.DESC.EXT.BASE2431)) + " dpl=" + Str.toHexByte(seg.dpl));
    }

    /**
     * dumpHistory(sPrev, sLines, sComment)
     *
     * If sLines is not a number, it can be a instruction filter.  However, for the moment, the only
     * supported filter is "call", which filters the history buffer for all CALL and RET instructions
     * from the specified previous point forward.
     *
     * @this {DebuggerX86}
     * @param {string} [sPrev] is a (decimal) number of instructions to rewind to (default is 10)
     * @param {string} [sLines] is a (decimal) number of instructions to print (default is, again, 10)
     * @param {string} [sComment] (should be either "history" or "cycles"; default is "history")
     */
    dumpHistory(sPrev, sLines, sComment = "history")
    {
        let sMore = "";
        let cHistory = 0;
        let iHistory = this.iOpcodeHistory;
        let aHistory = this.aOpcodeHistory;

        if (aHistory.length) {

            let nPrev = +sPrev || this.nextHistory;
            let nLines = +sLines || 10;

            if (isNaN(nPrev)) {
                nPrev = nLines;
            } else {
                sMore = "more ";
            }

            if (nPrev > aHistory.length) {
                this.println("note: only " + aHistory.length + " available");
                nPrev = aHistory.length;
            }

            iHistory -= nPrev;
            if (iHistory < 0) {
                /*
                 * If the dbgAddr of the last aHistory element contains a valid selector, wrap around.
                 */
                if (aHistory[aHistory.length - 1].sel == null) {
                    nPrev = iHistory + nPrev;
                    iHistory = 0;
                } else {
                    iHistory += aHistory.length;
                }
            }

            let aFilters = [];
            if (sLines == "call") {
                nLines = 100000;
                aFilters = ["CALL"];
            }

            if (sPrev !== undefined) {
                this.println(nPrev + " instructions earlier:");
            }

            let sBuffer = "";
            let nCyclesPrev = 0;
            let fDumpCycles = (sComment == "cycles");

            /*
             * TODO: The following is necessary to prevent dumpHistory() from causing additional (or worse, recursive)
             * faults due to segmented addresses that are no longer valid, but the only alternative is to dramatically
             * increase the amount of memory used to store instruction history (eg, storing copies of all the instruction
             * bytes alongside the execution addresses).
             *
             * For now, we're living dangerously, so that our history dumps actually work.
             *
             *      this.nSuppressBreaks++;
             *
             * If you re-enable this protection, be sure to re-enable the decrement below, too.
             */
            while (nLines > 0 && iHistory != this.iOpcodeHistory) {

                let dbgAddr = aHistory[iHistory++];
                if (dbgAddr.sel == null) break;

                /*
                 * We must create a new dbgAddr from the address in aHistory, because dbgAddr was
                 * a reference, not a copy, and we don't want getInstruction() modifying the original.
                 */
                let dbgAddrNew = this.newAddr(dbgAddr.off, dbgAddr.sel, dbgAddr.addr, dbgAddr.type, dbgAddr.fData32, dbgAddr.fAddr32);

                let nSequence = nPrev--;
                if (fDumpCycles) {
                    nSequence = nCyclesPrev;
                    if (dbgAddr.nCPUCycles != null) {
                        nSequence = dbgAddr.nCPUCycles - nCyclesPrev;
                        nCyclesPrev = dbgAddr.nCPUCycles;
                    }
                }

                let sInstruction = this.getInstruction(dbgAddrNew, sComment, nSequence);

                if (dbgAddr.nDebugCycles != null) {
                    sInstruction += " (" + dbgAddr.nDebugCycles + "," + Str.toHexByte(dbgAddr.nDebugState) + ")";
                }

                if (!aFilters.length || sInstruction.indexOf(aFilters[0]) >= 0) {
                    sBuffer += (sBuffer? '\n' : '') + sInstruction;
                }

                /*
                 * If there were OPERAND or ADDRESS overrides on the previous instruction, getInstruction()
                 * will have automatically disassembled additional bytes, so skip additional history entries.
                 */
                if (dbgAddrNew.cOverrides) {
                    iHistory += dbgAddrNew.cOverrides; nLines -= dbgAddrNew.cOverrides; nPrev -= dbgAddrNew.cOverrides;
                }

                if (iHistory >= aHistory.length) iHistory = 0;
                this.nextHistory = nPrev;
                cHistory++;
                nLines--;
            }

            if (sBuffer) this.println(sBuffer);

            /*
             * See comments above.
             *
             *      this.nSuppressBreaks--;
             */
        }

        if (!cHistory) {
            this.println("no " + sMore + "history available");
            this.nextHistory = undefined;
        }
    }

    /**
     * dumpTSS(asArgs)
     *
     * This dumps a TSS using the given selector.  If none is specified, the current TR is used.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    dumpTSS(asArgs)
    {
        let seg, sel;
        let sSel = asArgs[0];

        if (!sSel) {
            seg = this.cpu.segTSS;
        } else {
            sel = this.parseValue(sSel);
            if (sel === undefined) {
                this.println("invalid task selector: " + sSel);
                return;
            }
            seg = this.getSegment(sel, DebuggerX86.ADDRTYPE.PROT);
        }

        this.println("dumpTSS(" + Str.toHexWord(seg? seg.sel : sel) + "): %" + Str.toHex(seg? seg.base : null, this.cchAddr));
        if (!seg) return;

        let sDump = "";
        let type = seg.type & ~X86.DESC.ACC.TYPE.TSS_BUSY;
        let cch = (type == X86.DESC.ACC.TYPE.TSS286? 4 : 8);
        let aTSSFields = (type == X86.DESC.ACC.TYPE.TSS286? DebuggerX86.TSS286 : DebuggerX86.TSS386);
        let off, addr, v;
        for (let sField in aTSSFields) {
            off = aTSSFields[sField];
            addr = seg.base + off;
            v = this.cpu.probeAddr(addr, 2);
            if (type == X86.DESC.ACC.TYPE.TSS386) {
                v |= this.cpu.probeAddr(addr + 2, 2) << 16;
            }
            if (sDump) sDump += '\n';
            sDump += Str.toHexWord(off) + ' ' + Str.pad(sField + ':', 11) + Str.toHex(v, cch);
        }
        if (type == X86.DESC.ACC.TYPE.TSS386) {
            let iPort = 0;
            off = (v >>> 16);
            /*
             * We arbitrarily cut the IOPM dump off at port 0x3FF; we're not currently interested in anything above that.
             */
            while (off < seg.offMax && iPort < 0x3ff) {
                addr = seg.base + off;
                v = this.cpu.probeAddr(addr, 2);
                sDump += "\n" + Str.toHexWord(off) + " ports " + Str.toHexWord(iPort) + '-' + Str.toHexWord(iPort+15) + ": " + Str.toBinBytes(v, 2);
                iPort += 16;
                off += 2;
            }
        }
        this.println(sDump);
    }

    /**
     * findModuleInfo(sModule, nSegment)
     *
     * Since we're not sure what Disk the module was loaded from, we have to check all of them.
     *
     * @this {DebuggerX86}
     * @param {string} sModule
     * @param {number} nSegment
     * @return {Object}
     */
    findModuleInfo(sModule, nSegment)
    {
        let aSymbols = [];
        if (SYMBOLS) {
            let component, componentPrev = null;
            while (component = this.cmp.getMachineComponent("Disk", componentPrev)) {
                aSymbols = component.getModuleInfo(sModule, nSegment);
                if (aSymbols.length) break;
                componentPrev = component;
            }
        }
        return aSymbols;
    }

    /**
     * messageInit(sEnable)
     *
     * @this {DebuggerX86}
     * @param {string|undefined} sEnable contains zero or more message categories to enable, separated by '|'
     */
    messageInit(sEnable)
    {
        this.dbg = this;
        this.bitsMessage = Messages.WARN;
        this.sMessagePrev = null;
        this.aMessageBuffer = [];
        let aEnable = this.parseCommand(sEnable, false, '|');
        if (aEnable.length) {
            this.bitsMessage = Messages.NONE;       // when specific messages are being enabled, WARN must be explicitly set
            for (let m in Messages.CATEGORIES) {
                if (Usr.indexOf(aEnable, m) >= 0) {
                    this.bitsMessage |= Messages.CATEGORIES[m];
                    this.println(m + " messages enabled");
                }
            }
        }
        this.historyInit();     // call this just in case Messages.INT was turned on
    }

    /**
     * messageDump(bitMessage, fnDumper)
     *
     * @this {DebuggerX86}
     * @param {number} bitMessage is one Messages category flag
     * @param {function(Array.<string>)} fnDumper is a function the Debugger can use to dump data for that category
     * @return {boolean} true if successfully registered, false if not
     */
    messageDump(bitMessage, fnDumper)
    {
        for (let m in Messages.CATEGORIES) {
            if (bitMessage == Messages.CATEGORIES[m]) {
                this.afnDumpers[m] = fnDumper;
                return true;
            }
        }
        return false;
    }

    /**
     * getRegIndex(sReg, off)
     *
     * @this {DebuggerX86}
     * @param {string} sReg
     * @param {number} [off] optional offset into sReg
     * @return {number} register index, or -1 if not found
     */
    getRegIndex(sReg, off)
    {
        let i;
        sReg = sReg.toUpperCase();
        if (off == null) {
            i = Usr.indexOf(DebuggerX86.REGS, sReg);
        } else {
            i = Usr.indexOf(DebuggerX86.REGS, sReg.substr(off, 3));
            if (i < 0) i = Usr.indexOf(DebuggerX86.REGS, sReg.substr(off, 2));
        }
        return i;
    }

    /**
     * getRegString(iReg)
     *
     * @this {DebuggerX86}
     * @param {number} iReg
     * @return {string}
     */
    getRegString(iReg)
    {
        let cch = 0;
        let n = this.getRegValue(iReg);
        if (n != null) {
            switch(iReg) {
            case DebuggerX86.REG_AL:
            case DebuggerX86.REG_CL:
            case DebuggerX86.REG_DL:
            case DebuggerX86.REG_BL:
            case DebuggerX86.REG_AH:
            case DebuggerX86.REG_CH:
            case DebuggerX86.REG_DH:
            case DebuggerX86.REG_BH:
                cch = 2;
                break;
            case DebuggerX86.REG_AX:
            case DebuggerX86.REG_CX:
            case DebuggerX86.REG_DX:
            case DebuggerX86.REG_BX:
            case DebuggerX86.REG_SP:
            case DebuggerX86.REG_BP:
            case DebuggerX86.REG_SI:
            case DebuggerX86.REG_DI:
            case DebuggerX86.REG_IP:
            case DebuggerX86.REG_SEG + DebuggerX86.REG_ES:
            case DebuggerX86.REG_SEG + DebuggerX86.REG_CS:
            case DebuggerX86.REG_SEG + DebuggerX86.REG_SS:
            case DebuggerX86.REG_SEG + DebuggerX86.REG_DS:
            case DebuggerX86.REG_SEG + DebuggerX86.REG_FS:
            case DebuggerX86.REG_SEG + DebuggerX86.REG_GS:
                cch = 4;
                break;
            case DebuggerX86.REG_EAX:
            case DebuggerX86.REG_ECX:
            case DebuggerX86.REG_EDX:
            case DebuggerX86.REG_EBX:
            case DebuggerX86.REG_ESP:
            case DebuggerX86.REG_EBP:
            case DebuggerX86.REG_ESI:
            case DebuggerX86.REG_EDI:
            case DebuggerX86.REG_CR0:
            case DebuggerX86.REG_CR1:
            case DebuggerX86.REG_CR2:
            case DebuggerX86.REG_CR3:
            case DebuggerX86.REG_EIP:
                cch = 8;
                break;
            case DebuggerX86.REG_PS:
                cch = this.cchReg;
                break;
            }
        }
        return cch? Str.toHex(n, cch) : "??";
    }

    /**
     * getRegValue(iReg)
     *
     * @this {DebuggerX86}
     * @param {number} iReg
     * @return {number|undefined}
     */
    getRegValue(iReg)
    {
        let n;
        if (iReg >= 0) {
            let cpu = this.cpu;
            switch(iReg) {
            case DebuggerX86.REG_AL:
                n = cpu.regEAX & 0xff;
                break;
            case DebuggerX86.REG_CL:
                n = cpu.regECX & 0xff;
                break;
            case DebuggerX86.REG_DL:
                n = cpu.regEDX & 0xff;
                break;
            case DebuggerX86.REG_BL:
                n = cpu.regEBX & 0xff;
                break;
            case DebuggerX86.REG_AH:
                n = (cpu.regEAX >> 8) & 0xff;
                break;
            case DebuggerX86.REG_CH:
                n = (cpu.regECX >> 8) & 0xff;
                break;
            case DebuggerX86.REG_DH:
                n = (cpu.regEDX >> 8) & 0xff;
                break;
            case DebuggerX86.REG_BH:
                n = (cpu.regEBX >> 8) & 0xff;
                break;
            case DebuggerX86.REG_AX:
                n = cpu.regEAX & 0xffff;
                break;
            case DebuggerX86.REG_CX:
                n = cpu.regECX & 0xffff;
                break;
            case DebuggerX86.REG_DX:
                n = cpu.regEDX & 0xffff;
                break;
            case DebuggerX86.REG_BX:
                n = cpu.regEBX & 0xffff;
                break;
            case DebuggerX86.REG_SP:
                n = cpu.getSP() & 0xffff;
                break;
            case DebuggerX86.REG_BP:
                n = cpu.regEBP & 0xffff;
                break;
            case DebuggerX86.REG_SI:
                n = cpu.regESI & 0xffff;
                break;
            case DebuggerX86.REG_DI:
                n = cpu.regEDI & 0xffff;
                break;
            case DebuggerX86.REG_IP:
                n = cpu.getIP() & 0xffff;
                break;
            case DebuggerX86.REG_PS:
                n = cpu.getPS();
                break;
            case DebuggerX86.REG_SEG + DebuggerX86.REG_ES:
                n = cpu.getES();
                break;
            case DebuggerX86.REG_SEG + DebuggerX86.REG_CS:
                n = cpu.getCS();
                break;
            case DebuggerX86.REG_SEG + DebuggerX86.REG_SS:
                n = cpu.getSS();
                break;
            case DebuggerX86.REG_SEG + DebuggerX86.REG_DS:
                n = cpu.getDS();
                break;
            default:
                if (this.cpu.model == X86.MODEL_80286) {
                    if (iReg == DebuggerX86.REG_CR0) {
                        n = cpu.regCR0;
                    }
                }
                else if (I386 && this.cpu.model >= X86.MODEL_80386) {
                    switch(iReg) {
                    case DebuggerX86.REG_EAX:
                        n = cpu.regEAX;
                        break;
                    case DebuggerX86.REG_ECX:
                        n = cpu.regECX;
                        break;
                    case DebuggerX86.REG_EDX:
                        n = cpu.regEDX;
                        break;
                    case DebuggerX86.REG_EBX:
                        n = cpu.regEBX;
                        break;
                    case DebuggerX86.REG_ESP:
                        n = cpu.getSP();
                        break;
                    case DebuggerX86.REG_EBP:
                        n = cpu.regEBP;
                        break;
                    case DebuggerX86.REG_ESI:
                        n = cpu.regESI;
                        break;
                    case DebuggerX86.REG_EDI:
                        n = cpu.regEDI;
                        break;
                    case DebuggerX86.REG_CR0:
                        n = cpu.regCR0;
                        break;
                    case DebuggerX86.REG_CR1:
                        n = cpu.regCR1;
                        break;
                    case DebuggerX86.REG_CR2:
                        n = cpu.regCR2;
                        break;
                    case DebuggerX86.REG_CR3:
                        n = cpu.regCR3;
                        break;
                    case DebuggerX86.REG_SEG + DebuggerX86.REG_FS:
                        n = cpu.getFS();
                        break;
                    case DebuggerX86.REG_SEG + DebuggerX86.REG_GS:
                        n = cpu.getGS();
                        break;
                    case DebuggerX86.REG_EIP:
                        n = cpu.getIP();
                        break;
                    }
                }
                break;
            }
        }
        return n;
    }

    /**
     * replaceRegs(s)
     *
     * @this {DebuggerX86}
     * @param {string} s
     * @return {string}
     */
    replaceRegs(s)
    {
        /*
         * Replace any references first; this means that register references inside the reference
         * do NOT need to be prefixed with '@'.
         */
        s = this.parseReference(s) || s;

        /*
         * Replace every @XX (or @XXX), where XX (or XXX) is a register, with the register's value.
         */
        let i = 0;
        let b, sChar, sAddr, dbgAddr, sReplace;
        while ((i = s.indexOf('@', i)) >= 0) {
            let iReg = this.getRegIndex(s, i + 1);
            if (iReg >= 0) {
                s = s.substr(0, i) + this.getRegString(iReg) + s.substr(i + 1 + DebuggerX86.REGS[iReg].length);
            }
            i++;
        }
        /*
         * Replace every #XX, where XX is a hex byte value, with the corresponding ASCII character (if printable).
         */
        i = 0;
        while ((i = s.indexOf('#', i)) >= 0) {
            sChar = s.substr(i+1, 2);
            b = Str.parseInt(sChar, 16);
            if (b != null && b >= 32 && b < 127) {
                sReplace = sChar + " '" + String.fromCharCode(b) + "'";
                s = s.replace('#' + sChar, sReplace);
                i += sReplace.length;
                continue;
            }
            i++;
        }
        /*
         * Replace every $XXXX:XXXX, where XXXX:XXXX is a segmented address, with the zero-terminated string at that address.
         */
        i = 0;
        while ((i = s.indexOf('$', i)) >= 0) {
            sAddr = s.substr(i+1, 9);
            dbgAddr = this.parseAddr(sAddr);
            if (dbgAddr) {
                sReplace = sAddr + ' "' + this.getSZ(dbgAddr) + '"';
                s = s.replace('$' + sAddr, sReplace);
                i += sReplace.length;
                continue;
            }
            i++;
        }
        /*
         * Replace every ^XXXX:XXXX, where XXXX:XXXX is a segmented address, with the FCB filename stored at that address.
         */
        i = 0;
        while ((i = s.indexOf('^', i)) >= 0) {
            sAddr = s.substr(i+1, 9);
            dbgAddr = this.parseAddr(sAddr);
            if (dbgAddr) {
                this.incAddr(dbgAddr);
                sReplace = sAddr + ' "' + this.getSZ(dbgAddr, 11) + '"';
                s = s.replace('^' + sAddr, sReplace);
                i += sReplace.length;
                continue;
            }
            i++;
        }
        return s;
    }

    /**
     * message(sMessage, fAddress)
     *
     * @this {DebuggerX86}
     * @param {string} sMessage is any caller-defined message string
     * @param {boolean} [fAddress] is true to display the current CS:IP
     */
    message(sMessage, fAddress)
    {
        if (fAddress) {
            sMessage += " at " + this.toHexAddr(this.newAddr(this.cpu.getIP(), this.cpu.getCS())) + " (%" + Str.toHex(this.cpu.regLIP) + ")";
        }

        if ((this.bitsMessage & Messages.BUFFER) == Messages.BUFFER) {
            this.aMessageBuffer.push(sMessage);
            return;
        }

        if (this.sMessagePrev && sMessage == this.sMessagePrev) return;
        this.sMessagePrev = sMessage;

        if ((this.bitsMessage & Messages.HALT) == Messages.HALT) {
            this.stopCPU();
            sMessage += " (cpu halted)";
        }

        this.println(sMessage); // + " (" + this.cpu.getCycles() + " cycles)"

        /*
         * We have no idea what the frequency of println() calls might be; all we know is that they easily
         * screw up the CPU's careful assumptions about cycles per burst.  So we call yieldCPU() after every
         * message, to effectively end the current burst and start fresh.
         *
         * TODO: See CPU.calcStartTime() for a discussion of why we might want to call yieldCPU() *before*
         * we display the message.
         */
        if (this.cpu) this.cpu.yieldCPU();
    }

    /**
     * messageInt(nInt, addr, fForce)
     *
     * @this {DebuggerX86}
     * @param {number} nInt
     * @param {number} addr (LIP after the "INT n" instruction has been fetched but not dispatched)
     * @param {boolean} [fForce] (true if the message should be forced)
     * @return {boolean} true if message generated (which in turn triggers addIntReturn() inside checkIntNotify()), false if not
     */
    messageInt(nInt, addr, fForce)
    {
        let AH, DL;
        let fMessage = fForce;
        let nCategory;

        /*
         * We currently arrive here only because the CPU has already determined that INT messages are enabled,
         * or because the ChipSet's RTC interrupt handler has already determined that INT messages are enabled.
         *
         * But software interrupts are very common, so we generally require additional categories to be enabled;
         * unless the caller has set fForce, we check those additional categories now.
         */
        if (!fMessage) {
            /*
             * Display all software interrupts if CPU messages are enabled (and it's not an "annoying" interrupt);
             * note that in some cases, even "annoying" interrupts can be turned with an extra message category.
             */
            fMessage = this.messageEnabled(Messages.CPU) && DebuggerX86.INT_ANNOYING.indexOf(nInt) < 0;
            if (!fMessage) {
                /*
                 * Alternatively, display this software interrupt if its corresponding message category is enabled.
                 */
                nCategory = DebuggerX86.INT_MESSAGES[nInt];
                if (nCategory) {
                    if (this.messageEnabled(nCategory)) {
                        fMessage = true;
                    } else {
                        /*
                         * Alternatively, display this FDC interrupt if HDC messages are enabled (since they share
                         * a common software interrupt).  Normally, an HDC BIOS will copy the original DISK (0x13)
                         * vector to the ALT_DISK (0x40) vector, but it's a nuisance having to check different
                         * interrupts in different configurations for the same frickin' functionality, so we don't.
                         */
                        fMessage = (nCategory == Messages.FDC && this.messageEnabled(nCategory = Messages.HDC));
                    }
                }
            }
        }
        if (fMessage) {
            AH = (this.cpu.regEAX >> 8) & 0xff;
            DL = this.cpu.regEDX & 0xff;
            if (nInt == Interrupts.DOS /* 0x21 */ && AH == 0x0b ||
                nCategory == Messages.FDC && DL >= 0x80 || nCategory == Messages.HDC && DL < 0x80) {
                fMessage = false;
            }
        }
        if (fMessage) {
            let aFuncs = Interrupts.FUNCS[nInt];
            let sFunc = (aFuncs && aFuncs[AH]) || "";
            if (sFunc) sFunc = ' ' + this.replaceRegs(sFunc);
            /*
             * For display purposes only, rewind addr to the address of the responsible "INT n" instruction;
             * we know it's the two-byte "INT n" instruction because that's the only opcode handler that calls
             * checkIntNotify() at the moment.
             */
            addr -= 2;
            this.message("INT " + Str.toHexByte(nInt) + ": AH=" + Str.toHexByte(AH) + " at " + this.toHexOffset(addr - this.cpu.segCS.base, this.cpu.getCS()) + sFunc);
        }
        return fMessage;
    }

    /**
     * messageIntReturn(nInt, nLevel, nCycles)
     *
     * @this {DebuggerX86}
     * @param {number} nInt
     * @param {number} nLevel
     * @param {number} nCycles
     * @param {string} [sResult]
     */
    messageIntReturn(nInt, nLevel, nCycles, sResult)
    {
        this.message("INT " + Str.toHexByte(nInt) + ": C=" + (this.cpu.getCF()? 1 : 0) + (sResult || "") + " (cycles=" + nCycles + (nLevel? ",level=" + (nLevel+1) : "") + ')');
    }

    /**
     * messageIO(component, port, bOut, addrFrom, name, bIn, bitsMessage)
     *
     * @this {DebuggerX86}
     * @param {Component} component
     * @param {number} port
     * @param {number} [bOut] if an output operation
     * @param {number} [addrFrom]
     * @param {string} [name] of the port, if any
     * @param {number} [bIn] is the input value, if known, on an input operation
     * @param {number} [bitsMessage] is one or more Messages category flag(s)
     */
    messageIO(component, port, bOut, addrFrom, name, bIn, bitsMessage)
    {
        bitsMessage |= Messages.PORT;
        if (!name) bitsMessage |= Messages.WARN;        // we don't want to see "unknown" I/O messages unless WARN is enabled
        if (addrFrom == undefined || (this.bitsMessage & bitsMessage) == bitsMessage) {
            let selFrom = undefined;
            if (addrFrom != undefined) {
                selFrom = this.cpu.getCS();
                addrFrom -= this.cpu.segCS.base;
            }
            this.message(component.idComponent + '.' + (bOut != undefined? "outPort" : "inPort") + '(' + Str.toHexWord(port) + ',' + (name? name : "unknown") + (bOut != undefined? ',' + Str.toHexByte(bOut) : "") + ')' + (bIn != undefined? (": " + Str.toHexByte(bIn)) : "") + (addrFrom != undefined? (" at " + this.toHexOffset(addrFrom, selFrom)) : ""));
        }
    }

    /**
     * init()
     *
     * @this {DebuggerX86}
     */
    init()
    {
        this.println("Type ? for help with PCx86 Debugger commands");
        this.updateStatus();
        if (this.sCommandsInit) {
            let sCommands = this.sCommandsInit;
            this.sCommandsInit = null;
            this.doCommands(sCommands);
        }
    }

    /**
     * historyInit(fQuiet)
     *
     * This function is intended to be called by the constructor, reset(), addBreakpoint(), findBreakpoint()
     * and any other function that changes the checksEnabled() criteria used to decide whether checkInstruction()
     * should be called.
     *
     * That is, if the history arrays need to be allocated and haven't already been allocated, then allocate them,
     * and if the arrays are no longer needed, then deallocate them.
     *
     * @this {DebuggerX86}
     * @param {boolean} [fQuiet]
     */
    historyInit(fQuiet)
    {
        let i;
        if (!this.checksEnabled()) {
            if (this.aOpcodeHistory && this.aOpcodeHistory.length && !fQuiet) {
                this.println("instruction history buffer freed");
            }
            this.iOpcodeHistory = 0;
            this.aOpcodeHistory = [];
            this.aaOpcodeCounts = [];
            return;
        }
        if (!this.aOpcodeHistory || !this.aOpcodeHistory.length) {
            this.aOpcodeHistory = new Array(DebuggerX86.HISTORY_LIMIT);
            for (i = 0; i < this.aOpcodeHistory.length; i++) {
                /*
                 * Preallocate dummy Addr (Array) objects in every history slot, so that
                 * checkInstruction() doesn't need to call newAddr() on every slot update.
                 */
                this.aOpcodeHistory[i] = this.newAddr();
            }
            this.iOpcodeHistory = 0;
            if (!fQuiet) {
                this.println("instruction history buffer allocated");
            }
        }
        if (!this.aaOpcodeCounts || !this.aaOpcodeCounts.length) {
            this.aaOpcodeCounts = new Array(256);
            for (i = 0; i < this.aaOpcodeCounts.length; i++) {
                this.aaOpcodeCounts[i] = [i, 0];
            }
        }
    }

    /**
     * startCPU(fUpdateFocus, fQuiet)
     *
     * @this {DebuggerX86}
     * @param {boolean} [fUpdateFocus]
     * @param {boolean} [fQuiet]
     * @return {boolean} true if run request successful, false if not
     */
    startCPU(fUpdateFocus, fQuiet)
    {
        if (this.checkCPU(fQuiet)) {
            return this.cpu.startCPU(fUpdateFocus, fQuiet);
        }
        return false;
    }

    /**
     * stepCPU(nCycles, fRegs, fUpdateCPU)
     *
     * @this {DebuggerX86}
     * @param {number} nCycles (0 for one instruction without checking breakpoints)
     * @param {boolean} [fRegs] is true to display registers after step (default is false)
     * @param {boolean} [fUpdateCPU] is false to disable calls to updateCPU() (default is true)
     * @return {boolean}
     */
    stepCPU(nCycles, fRegs, fUpdateCPU)
    {
        if (!this.checkCPU()) return false;

        this.nCycles = 0;
        do {
            if (!nCycles) {
                /*
                 * When single-stepping, the CPU won't call checkInstruction(), which is good for
                 * avoiding breakpoints, but bad for instruction data collection if checks are enabled.
                 * So we call checkInstruction() ourselves.
                 */
                if (this.checksEnabled()) this.checkInstruction(this.cpu.regLIP, 0);
            }
            /*
             * For our typically tiny bursts (usually single instructions), mimic what runCPU() does.
             */
            try {
                let nCyclesStep = this.cpu.stepCPU(nCycles);
                if (nCyclesStep > 0) {
                    this.nCycles += nCyclesStep;
                    this.cpu.addCycles(nCyclesStep, true);
                    this.cpu.updateTimers(nCyclesStep);
                    this.cpu.updateChecksum(nCyclesStep);
                    this.cOpcodes++;
                }
            }
            catch(exception) {
                if (typeof exception != "number") {
                    let e = exception;
                    this.nCycles = 0;
                    this.cpu.setError(e.stack || e.message);
                }
            }
        } while (this.cpu.opFlags & X86.OPFLAG_PREFIXES);

        /*
         * Because we called cpu.stepCPU() and not cpu.startCPU(), we must nudge the cpu's update code,
         * and then update our own state.  Normally, the only time fUpdateCPU will be false is when doTrace()
         * is calling us in a loop, in which case it will perform its own updateCPU() when it's done.
         */
        if (fUpdateCPU !== false) this.cpu.updateCPU(true);

        this.updateStatus(fRegs || false);
        return (this.nCycles > 0);
    }

    /**
     * stopCPU()
     *
     * @this {DebuggerX86}
     * @param {boolean} [fComplete]
     * @return {boolean}
     */
    stopCPU(fComplete)
    {
        return this.cpu && this.cpu.stopCPU(fComplete) || false;
    }

    /**
     * updateStatus(fRegs)
     *
     * @this {DebuggerX86}
     * @param {boolean} [fRegs] (default is true)
     */
    updateStatus(fRegs)
    {
        if (fRegs === undefined) fRegs = true;

        this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
        /*
         * this.nStep used to be a simple boolean, but now it's 0 (or undefined)
         * if inactive, 1 if stepping over an instruction without a register dump, or 2
         * if stepping over an instruction with a register dump.
         */
        if (!fRegs || this.nStep == 1)
            this.doUnassemble();
        else {
            this.doRegisters();
        }
    }

    /**
     * checkCPU(fQuiet)
     *
     * Make sure the CPU is ready (finished initializing), not busy (already running), and not in an error state.
     *
     * @this {DebuggerX86}
     * @param {boolean} [fQuiet]
     * @return {boolean}
     */
    checkCPU(fQuiet)
    {
        if (!this.cpu || !this.cpu.isReady() || !this.cpu.isPowered() || this.cpu.isRunning()) {
            if (!fQuiet) this.println("cpu busy or unavailable, command ignored");
            return false;
        }
        return !this.cpu.isError();
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {DebuggerX86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @return {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            /*
             * Because Debugger save/restore support is somewhat limited (and didn't always exist),
             * we deviate from the typical save/restore design pattern: instead of reset OR restore,
             * we always reset and then perform a (potentially limited) restore.
             */
            this.reset(true);

            // this.println(data? "resuming" : "powering up");

            if (data && this.restore) {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {DebuggerX86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @return {Object|boolean}
     */
    powerDown(fSave, fShutdown)
    {
        if (fShutdown) this.println(fSave? "suspending" : "shutting down");
        return fSave? this.save() : true;
    }

    /**
     * reset(fQuiet)
     *
     * This is a notification handler, called by the Computer, to inform us of a reset.
     *
     * @this {DebuggerX86}
     * @param {boolean} fQuiet (true only when called from our own powerUp handler)
     */
    reset(fQuiet)
    {
        this.historyInit();
        this.cOpcodes = this.cOpcodesStart = 0;
        this.sMessagePrev = null;
        this.nCycles = 0;
        this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
        this.clearTempBreakpoint();
        if (!fQuiet && !this.flags.running) this.updateStatus();
    }

    /**
     * save()
     *
     * This implements (very rudimentary) save support for the Debugger component.
     *
     * @this {DebuggerX86}
     * @return {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.packAddr(this.dbgAddrNextCode));
        state.set(1, this.packAddr(this.dbgAddrNextData));
        state.set(2, this.packAddr(this.dbgAddrAssemble));
        state.set(3, [this.aPrevCmds, this.fAssemble, this.bitsMessage]);
        state.set(4, this.aSymbolTable);
        state.set(5, [this.aBreakExec, this.aBreakRead, this.aBreakWrite]);
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements (very rudimentary) restore support for the Debugger component.
     *
     * @this {DebuggerX86}
     * @param {Object} data
     * @return {boolean} true if successful, false if failure
     */
    restore(data)
    {
        let i = 0;
        if (data[i]) this.dbgAddrNextCode = this.unpackAddr(data[i++]);
        /*
         * dbgAddrNextData wasn't saved until there were at least 6 elements, hence the check for data[5] instead of data[i]
         */
        if (data[5]) this.dbgAddrNextData = this.unpackAddr(data[i++]);
        if (data[i]) this.dbgAddrAssemble = this.unpackAddr(data[i++]);
        if (data[i]) {
            this.aPrevCmds = data[i][0];
            if (typeof this.aPrevCmds == "string") this.aPrevCmds = [this.aPrevCmds];
            this.fAssemble = data[i][1];
            let bits = data[i][2];
            /*
             * We supplement the message bits only the incoming bits adhere to the new format (ie, if bits exist in both the high
             * nibble and one of the low nibbles).
             */
            if ((bits & 0xf0000000) && (bits & 0x0fffffff)) {
                this.bitsMessage |= bits;       // include any saved message bits ONLY if they match our new format (ie, bits in both high and low nibbles)
            }
            i++;
        }
        if (data[i]) {
            this.aSymbolTable = data[i++];
        }
        if (data[i]) {
            this.restoreBreakpoints(this.aBreakExec, data[i][0]);
            this.restoreBreakpoints(this.aBreakRead, data[i][1]);
            this.restoreBreakpoints(this.aBreakWrite, data[i][2]);
        }
        return true;
    }

    /**
     * start(ms, nCycles)
     *
     * This is a notification handler, called by the Computer, to inform us the CPU has started.
     *
     * @this {DebuggerX86}
     * @param {number} ms
     * @param {number} nCycles
     */
    start(ms, nCycles)
    {
        if (!this.nStep) this.println("running");
        this.flags.running = true;
        this.msStart = ms;
        this.nCyclesStart = nCycles;
    }

    /**
     * stop(ms, nCycles)
     *
     * This is a notification handler, called by the Computer, to inform us the CPU has now stopped.
     *
     * @this {DebuggerX86}
     * @param {number} ms
     * @param {number} nCycles
     */
    stop(ms, nCycles)
    {
        if (this.flags.running) {
            this.flags.running = false;
            this.nCycles = nCycles - this.nCyclesStart;
            if (!this.nStep) {
                let sStopped = "stopped";
                if (this.nCycles) {
                    let msTotal = ms - this.msStart;
                    let nCyclesPerSecond = (msTotal > 0? Math.round(this.nCycles * 1000 / msTotal) : 0);
                    sStopped += " (";
                    if (this.checksEnabled()) {
                        sStopped += this.cOpcodes + " opcodes, ";
                        /*
                         * $ops displays progress by calculating cOpcodes - cOpcodesStart, so before
                         * zeroing cOpcodes, we should subtract cOpcodes from cOpcodesStart (since we're
                         * effectively subtracting cOpcodes from cOpcodes as well).
                         */
                        this.cOpcodesStart -= this.cOpcodes;
                        this.cOpcodes = 0;
                    }
                    sStopped += this.nCycles + " cycles, " + msTotal + " ms, " + nCyclesPerSecond + " hz)";
                    if (MAXDEBUG && this.chipset) {
                        let i, c, n;
                        for (i = 0; i < this.chipset.acInterrupts.length; i++) {
                            c = this.chipset.acInterrupts[i];
                            if (!c) continue;
                            n = c / Math.round(msTotal / 1000);
                            this.println("IRQ" + i + ": " + c + " interrupts (" + n + " per sec)");
                            this.chipset.acInterrupts[i] = 0;
                        }
                        for (i = 0; i < this.chipset.acTimersFired.length; i++) {
                            c = this.chipset.acTimersFired[i];
                            if (!c) continue;
                            n = c / Math.round(msTotal / 1000);
                            this.println("TIMER" + i + ": " + c + " fires (" + n + " per sec)");
                            this.chipset.acTimersFired[i] = 0;
                        }
                        n = 0;
                        for (i = 0; i < this.chipset.acTimer0Counts.length; i++) {
                            let a = this.chipset.acTimer0Counts[i];
                            n += a[0];
                            this.println("TIMER0 update #" + i + ": [" + a[0] + ',' + a[1] + ',' + a[2] + ']');
                        }
                        this.chipset.acTimer0Counts = [];
                    }
                } else {
                    if (this.messageEnabled(Messages.HALT)) {
                        /*
                         * It's possible the user is trying to 'g' past a fault that was blocked by helpCheckFault()
                         * for the Debugger's benefit; if so, it will continue to be blocked, so try displaying a helpful
                         * message (another helpful tip would be to simply turn off the "halt" message category).
                         */
                        sStopped += " (use the 't' command to execute blocked faults)";
                    }
                }
                this.println(sStopped);
            }
            this.updateStatus(true);
            this.updateFocus();
            this.clearTempBreakpoint(this.cpu.regLIP);
        }
    }

    /**
     * checksEnabled(fRelease)
     *
     * This "check" function is called by the CPU; we indicate whether or not every instruction needs to be checked.
     *
     * Originally, this returned true even when there were only read and/or write breakpoints, but those breakpoints
     * no longer require the intervention of checkInstruction(); the Bus component automatically swaps in/out appropriate
     * "checked" Memory access functions to deal with those breakpoints in the corresponding Memory blocks.  So I've
     * simplified the test below.
     *
     * @this {DebuggerX86}
     * @param {boolean} [fRelease] is true for release criteria only; default is false (any criteria)
     * @return {boolean} true if every instruction needs to pass through checkInstruction(), false if not
     */
    checksEnabled(fRelease)
    {
        return ((DEBUG && !fRelease)? true : (this.aBreakExec.length > 1 || !!this.nBreakIns || this.messageEnabled(Messages.INT) /* || this.aBreakRead.length > 1 || this.aBreakWrite.length > 1 */));
    }

    /**
     * checkInstruction(addr, nState)
     *
     * This "check" function is called by the CPU to inform us about the next instruction to be executed,
     * giving us an opportunity to look for "exec" breakpoints and update opcode frequencies and instruction history.
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @param {number} nState is < 0 if stepping, 0 if starting, or > 0 if running
     * @return {boolean} true if breakpoint hit, false if not
     */
    checkInstruction(addr, nState)
    {
        let cpu = this.cpu;

        if (nState > 0) {
            if (this.nBreakIns && !--this.nBreakIns) {
                return true;
            }
            if (this.checkBreakpoint(addr, 1, this.aBreakExec)) {
                return true;
            }
            /*
             * Halt if running with interrupts disabled and IOPL < CPL, because that's likely an error
             */
            if (MAXDEBUG && !(cpu.regPS & X86.PS.IF) && cpu.nIOPL < cpu.nCPL) {
                this.printMessage("interrupts disabled at IOPL " + cpu.nIOPL + " and CPL " + cpu.nCPL, true);
                return true;
            }
        }

        /*
         * The rest of the instruction tracking logic can only be performed if historyInit() has allocated the
         * necessary data structures.  Note that there is no explicit UI for enabling/disabling history, other than
         * adding/removing breakpoints, simply because it's breakpoints that trigger the call to checkInstruction();
         * well, OK, and a few other things now, like enabling Messages.INT messages.
         */
        if (nState >= 0 && this.aaOpcodeCounts.length) {
            this.cOpcodes++;
            let bOpcode = cpu.probeAddr(addr);
            if (bOpcode != null) {
                this.aaOpcodeCounts[bOpcode][1]++;
                let dbgAddr = this.aOpcodeHistory[this.iOpcodeHistory];
                this.setAddr(dbgAddr, cpu.getIP(), cpu.getCS());
                dbgAddr.nCPUCycles = cpu.getCycles();
                /*
                 * For debugging timer issues, we can snap cycles remaining in the current burst, and the state of
                 * TIMER0.
                 */
                if (this.chipset) {
                    let timer = this.chipset.aTimers[0];
                    dbgAddr.nDebugCycles = cpu.nStepCycles;
                    dbgAddr.nDebugState = timer.countCurrent[0] | (timer.countCurrent[1] << 8);
                }
                /*
                 * For debugging video timing (eg, retrace) issues, it's helpful to record the state of the Video
                 * component's countdown timer.  timerVideo will be set to null if there's no Video component or the
                 * timer doesn't exist, so findTimer() should be called at most once.
                 */
                else if (this.video) {
                    if (this.timerVideo === undefined) {
                        this.timerVideo = cpu.findTimer(this.video.id);
                    }
                    if (this.timerVideo) {
                        dbgAddr.nDebugCycles = this.timerVideo[1];
                        dbgAddr.nDebugState = this.video.getRetraceBits(this.video.cardActive);
                    }
                }
                if (++this.iOpcodeHistory == this.aOpcodeHistory.length) this.iOpcodeHistory = 0;
            }
        }
        return false;
    }

    /**
     * checkMemoryRead(addr, nb)
     *
     * This "check" function is called by a Memory block to inform us that a memory read occurred, giving us an
     * opportunity to track the read if we want, and look for a matching "read" breakpoint, if any.
     *
     * In the "old days", it would be an error for this call to fail to find a matching Debugger breakpoint, but now
     * Memory blocks have no idea whether the Debugger or the machine's Debug register(s) triggered this "checked" read.
     *
     * If we return true, we "trump" the machine's Debug register(s); false allows normal Debug register processing.
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @param {number} [nb] (# of bytes; default is 1)
     * @return {boolean} true if breakpoint hit, false if not
     */
    checkMemoryRead(addr, nb)
    {
        if (this.checkBreakpoint(addr, nb || 1, this.aBreakRead)) {
            this.stopCPU(true);
            return true;
        }
        return false;
    }

    /**
     * checkMemoryWrite(addr, nb)
     *
     * This "check" function is called by a Memory block to inform us that a memory write occurred, giving us an
     * opportunity to track the write if we want, and look for a matching "write" breakpoint, if any.
     *
     * In the "old days", it would be an error for this call to fail to find a matching Debugger breakpoint, but now
     * Memory blocks have no idea whether the Debugger or the machine's Debug register(s) triggered this "checked" write.
     *
     * If we return true, we "trump" the machine's Debug register(s); false allows normal Debug register processing.
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @param {number} [nb] (# of bytes; default is 1)
     * @return {boolean} true if breakpoint hit, false if not
     */
    checkMemoryWrite(addr, nb)
    {
        if (this.checkBreakpoint(addr, nb || 1, this.aBreakWrite)) {
            this.stopCPU(true);
            return true;
        }
        return false;
    }

    /**
     * checkPortInput(port, size, data)
     *
     * This "check" function is called by the Bus component to inform us that port input occurred.
     *
     * @this {DebuggerX86}
     * @param {number} port
     * @param {number} size
     * @param {number} data
     * @return {boolean} true if breakpoint hit, false if not
     */
    checkPortInput(port, size, data)
    {
        /*
         * We trust that the Bus component won't call us unless we told it to, so we halt unconditionally
         */
        this.println("break on input from port " + Str.toHexWord(port) + ": " + Str.toHex(data));
        this.stopCPU(true);
        return true;
    }

    /**
     * checkPortOutput(port, size, data)
     *
     * This "check" function is called by the Bus component to inform us that port output occurred.
     *
     * @this {DebuggerX86}
     * @param {number} port
     * @param {number} size
     * @param {number} data
     * @return {boolean} true if breakpoint hit, false if not
     */
    checkPortOutput(port, size, data)
    {
        /*
         * We trust that the Bus component won't call us unless we told it to, so we halt unconditionally
         */
        this.println("break on output to port " + Str.toHexWord(port) + ": " + Str.toHex(data));
        this.stopCPU(true);
        return true;
    }

    /**
     * clearBreakpoints()
     *
     * @this {DebuggerX86}
     */
    clearBreakpoints()
    {
        let i, dbgAddr;
        this.aBreakExec = ["bp"];
        if (this.aBreakRead !== undefined) {
            for (i = 1; i < this.aBreakRead.length; i++) {
                dbgAddr = this.aBreakRead[i];
                this.cpu.removeMemBreak(this.getAddr(dbgAddr), false, dbgAddr.type == DebuggerX86.ADDRTYPE.PHYSICAL);
            }
        }
        this.aBreakRead = ["br"];
        if (this.aBreakWrite !== undefined) {
            for (i = 1; i < this.aBreakWrite.length; i++) {
                dbgAddr = this.aBreakWrite[i];
                this.cpu.removeMemBreak(this.getAddr(dbgAddr), true, dbgAddr.type == DebuggerX86.ADDRTYPE.PHYSICAL);
            }
        }
        this.aBreakWrite = ["bw"];
        /*
         * nSuppressBreaks ensures we can't get into an infinite loop where a breakpoint lookup requires
         * reading a segment descriptor via getSegment(), and that triggers more memory reads, which triggers
         * more breakpoint checks.
         */
        this.nSuppressBreaks = 0;
    }

    /**
     * addBreakpoint(aBreak, dbgAddr, fTempBreak, fQuiet)
     *
     * In case you haven't already figured this out, all our breakpoint commands use the address
     * to identify a breakpoint, not an incrementally assigned breakpoint index like other debuggers;
     * see doBreak() for details.
     *
     * This has a few implications, one being that you CANNOT set more than one kind of breakpoint
     * on a single address.  In practice, that's rarely a problem, because you can almost always set
     * a different breakpoint on a neighboring address.
     *
     * Also, there is one exception to the "one address, one breakpoint" rule, and that involves
     * temporary breakpoints (ie, one-time execution breakpoints that either a "p" or "g" command
     * may create to step over a chunk of code).  Those breakpoints automatically clear themselves,
     * so there usually isn't any need to refer to them using breakpoint commands.
     *
     * TODO: Consider supporting the more "traditional" breakpoint index syntax; the current
     * address-based syntax was implemented solely for expediency and consistency.  At the same time,
     * also consider a more WDEB386-like syntax, where "br" is used to set a variety of access-specific
     * breakpoints, using modifiers like "r1", "r2", "w1", "w2, etc.
     *
     * @this {DebuggerX86}
     * @param {Array} aBreak
     * @param {DbgAddrX86} dbgAddr
     * @param {boolean} [fTempBreak]
     * @param {boolean} [fQuiet]
     * @return {boolean} true if breakpoint added, false if already exists
     */
    addBreakpoint(aBreak, dbgAddr, fTempBreak, fQuiet)
    {
        let fSuccess = true;

        // this.nSuppressBreaks++;

        /*
         * Instead of complaining that a breakpoint already exists (as we used to do), we now
         * allow breakpoints to be re-set; this makes it easier to update any commands that may
         * be associated with the breakpoint.
         *
         * The only exception: we DO allow a temporary breakpoint at an address where there may
         * already be a breakpoint, so that you can easily step ("p" or "g") over such addresses.
         */
        if (!fTempBreak) {
            this.findBreakpoint(aBreak, dbgAddr, true, false, true);
        }

        if (aBreak != this.aBreakExec) {
            let addr = this.getAddr(dbgAddr);
            if (addr === X86.ADDR_INVALID) {
                this.println("invalid address: " + this.toHexAddr(dbgAddr));
                fSuccess = false;
            } else {
                this.cpu.addMemBreak(addr, aBreak == this.aBreakWrite, dbgAddr.type == DebuggerX86.ADDRTYPE.PHYSICAL);
            }
        }

        if (fSuccess) {
            aBreak.push(dbgAddr);
            if (fTempBreak) {
                /*
                 * Force temporary breakpoints to use their linear address, if one is available, by zapping
                 * the selector; this allows us to step over calls or interrupts that change the processor mode.
                 *
                 * TODO: Unfortunately, this will fail to "step" over a call in segment that moves during the call;
                 * consider alternatives.
                 */
                if (dbgAddr.addr != undefined) dbgAddr.sel = undefined;
                dbgAddr.fTempBreak = true;
            }
            else {
                if (!fQuiet) this.printBreakpoint(aBreak, aBreak.length-1, "set");
                this.historyInit();
            }
        }

        // this.nSuppressBreaks--;

        return fSuccess;
    }

    /**
     * findBreakpoint(aBreak, dbgAddr, fRemove, fTempBreak, fQuiet)
     *
     * @this {DebuggerX86}
     * @param {Array} aBreak
     * @param {DbgAddrX86} dbgAddr
     * @param {boolean} [fRemove]
     * @param {boolean} [fTempBreak]
     * @param {boolean} [fQuiet]
     * @return {boolean} true if found, false if not
     */
    findBreakpoint(aBreak, dbgAddr, fRemove, fTempBreak, fQuiet)
    {
        let fFound = false;
        let addr = this.mapBreakpoint(this.getAddr(dbgAddr));
        for (let i = 1; i < aBreak.length; i++) {
            let dbgAddrBreak = aBreak[i];
            if (addr !== X86.ADDR_INVALID && addr == this.mapBreakpoint(this.getAddr(dbgAddrBreak)) ||
                addr === X86.ADDR_INVALID && dbgAddr.sel == dbgAddrBreak.sel && dbgAddr.off == dbgAddrBreak.off) {
                if (!fTempBreak || dbgAddrBreak.fTempBreak) {
                    fFound = true;
                    if (fRemove) {
                        if (!dbgAddrBreak.fTempBreak && !fQuiet) {
                            this.printBreakpoint(aBreak, i, "cleared");
                        }
                        aBreak.splice(i, 1);
                        if (aBreak != this.aBreakExec) {
                            this.cpu.removeMemBreak(addr, aBreak == this.aBreakWrite, dbgAddrBreak.type == DebuggerX86.ADDRTYPE.PHYSICAL);
                        }
                        /*
                         * We'll mirror the logic in addBreakpoint() and leave the history buffer alone if this
                         * was a temporary breakpoint.
                         */
                        if (!dbgAddrBreak.fTempBreak) {
                            this.historyInit();
                        }
                        break;
                    }
                    if (!fQuiet) this.printBreakpoint(aBreak, i, "exists");
                    break;
                }
            }
        }
        return fFound;
    }

    /**
     * listBreakpoints(aBreak)
     *
     * @this {DebuggerX86}
     * @param {Array} aBreak
     * @return {number} of breakpoints listed, 0 if none
     */
    listBreakpoints(aBreak)
    {
        for (let i = 1; i < aBreak.length; i++) {
            this.printBreakpoint(aBreak, i);
        }
        return aBreak.length - 1;
    }

    /**
     * printBreakpoint(aBreak, i, sAction)
     *
     * TODO: We may need to start printing linear addresses also (if any), because segmented address can be ambiguous.
     *
     * @this {DebuggerX86}
     * @param {Array} aBreak
     * @param {number} i
     * @param {string} [sAction]
     */
    printBreakpoint(aBreak, i, sAction)
    {
        let dbgAddr = aBreak[i];
        this.println(aBreak[0] + ' ' + this.toHexAddr(dbgAddr) + (sAction? (' ' + sAction) : (dbgAddr.sCmd? (' "' + dbgAddr.sCmd + '"') : '')));
    }

    /**
     * restoreBreakpoints(aBreak, aDbgAddr)
     *
     * @this {DebuggerX86}
     * @param {Array} aBreak
     * @param {Array} aDbgAddr
     */
    restoreBreakpoints(aBreak, aDbgAddr)
    {
        if (aDbgAddr[0] != aBreak[0]) return;
        for (let i = 1; i < aDbgAddr.length; i++) {
            let dbgAddr = aDbgAddr[i];
            this.addBreakpoint(aBreak, dbgAddr, dbgAddr.fTempBreak, true);
        }
    }

    /**
     * setTempBreakpoint(dbgAddr)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr of new temp breakpoint
     */
    setTempBreakpoint(dbgAddr)
    {
        this.addBreakpoint(this.aBreakExec, dbgAddr, true);
    }

    /**
     * clearTempBreakpoint(addr)
     *
     * @this {DebuggerX86}
     * @param {number|undefined} [addr] clear all temp breakpoints if no address specified
     */
    clearTempBreakpoint(addr)
    {
        if (addr !== undefined) {
            this.checkBreakpoint(addr, 1, this.aBreakExec, true);
            this.nStep = 0;
        } else {
            for (let i = 1; i < this.aBreakExec.length; i++) {
                let dbgAddrBreak = this.aBreakExec[i];
                if (dbgAddrBreak.fTempBreak) {
                    if (!this.findBreakpoint(this.aBreakExec, dbgAddrBreak, true, true)) break;
                    i = 0;
                }
            }
        }
    }

    /**
     * mapBreakpoint(addr)
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @return {number}
     */
    mapBreakpoint(addr)
    {
        /*
         * Map addresses in the top 64Kb at the top of the address space (assuming either a 16Mb or 4Gb
         * address space) to the top of the 1Mb range.
         *
         * The fact that those two 64Kb regions are aliases of each other on an 80286 is a pain in the BUTT,
         * because any CS-based breakpoint you set immediately after a CPU reset will have a physical address
         * in the top 16Mb, yet after the first inter-segment JMP, you will be running in the first 1Mb.
         */
        if (addr !== X86.ADDR_INVALID) {
            let mask = (this.maskAddr & ~0xffff);
            if ((addr & mask) == mask) addr &= 0x000fffff;
        }
        return addr;
    }

    /**
     * checkBreakpoint(addr, nb, aBreak, fTempBreak)
     *
     * @this {DebuggerX86}
     * @param {number} addr
     * @param {number} nb (# of bytes)
     * @param {Array} aBreak
     * @param {boolean} [fTempBreak]
     * @return {boolean} true if breakpoint has been hit, false if not
     */
    checkBreakpoint(addr, nb, aBreak, fTempBreak)
    {
        /*
         * Time to check for execution breakpoints; note that this should be done BEFORE updating frequency
         * or history data (see checkInstruction), since we might not actually execute the current instruction.
         */
        let fBreak = false;

        if (!this.nSuppressBreaks++) {

            addr = this.mapBreakpoint(addr);

            /*
             * As discussed in opINT3(), I decided to check for INT3 instructions here: we'll tell the CPU to
             * stop on INT3 whenever both the INT and HALT message bits are set; a simple "g" command allows you
             * to continue.
             */
            if (this.messageEnabled(Messages.INT | Messages.HALT)) {
                if (this.cpu.probeAddr(addr) == X86.OPCODE.INT3) {
                    fBreak = true;
                }
            }

            for (let i = 1; !fBreak && i < aBreak.length; i++) {

                let dbgAddrBreak = aBreak[i];

                if (fTempBreak && !dbgAddrBreak.fTempBreak) continue;

                /*
                 * We need to zap the linear address field of the breakpoint address before
                 * calling getAddr(), to force it to recalculate the linear address every time,
                 * unless this is a breakpoint on a linear address (as indicated by a null sel).
                 */
                if (dbgAddrBreak.sel != null) dbgAddrBreak.addr = undefined;

                /*
                 * We used to calculate the linear address of the breakpoint at the time the
                 * breakpoint was added, so that a breakpoint set in one mode (eg, in real-mode)
                 * would still work as intended if the mode changed later (eg, to protected-mode).
                 *
                 * However, that created difficulties setting protected-mode breakpoints in segments
                 * that might not be defined yet, or that could move in physical memory.
                 *
                 * If you want to create a real-mode breakpoint that will break regardless of mode,
                 * use the physical address of the real-mode memory location instead.
                 */
                let addrBreak = this.mapBreakpoint(this.getAddr(dbgAddrBreak));
                for (let n = 0; n < nb; n++) {
                    if (addr + n == addrBreak) {
                        let a;
                        fBreak = true;
                        if (dbgAddrBreak.fTempBreak) {
                            this.findBreakpoint(aBreak, dbgAddrBreak, true, true);
                            fTempBreak = true;
                        }
                        if (a = dbgAddrBreak.aCmds) {
                            /*
                             * When one or more commands are attached to a breakpoint, we don't halt by default.
                             * Instead, we set fBreak to true only if, at the completion of all the commands, the
                             * CPU is halted; in other words, you should include "h" as one of the breakpoint commands
                             * if you want the breakpoint to stop execution.
                             *
                             * Another useful command is "if", which will return false if the expression is false,
                             * at which point we'll jump ahead to the next "else" command, and if there isn't an "else",
                             * we abort.
                             */
                            fBreak = false;
                            for (let j = 0; j < a.length; j++) {
                                if (!this.doCommand(a[j], true)) {
                                    if (a[j].indexOf("if")) {
                                        fBreak = true;          // the failed command wasn't "if", so abort
                                        break;
                                    }
                                    let k = j + 1;
                                    for (; k < a.length; k++) {
                                        if (!a[k].indexOf("else")) break;
                                        j++;
                                    }
                                    if (k == a.length) {        // couldn't find an "else" after the "if", so abort
                                        fBreak = true;
                                        break;
                                    }
                                    /*
                                     * If we're still here, we'll execute the "else" command (which is just a no-op),
                                     * followed by any remaining commands.
                                     */
                                }
                            }
                            if (!this.cpu.isRunning()) fBreak = true;
                        }
                        if (fBreak) {
                            if (!fTempBreak) this.printBreakpoint(aBreak, i, "hit");
                            break;
                        }
                    }
                }
            }
        }
        this.nSuppressBreaks--;
        return fBreak;
    }

    /**
     * getInstruction(dbgAddr, sComment, nSequence)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {string} [sComment] is an associated comment
     * @param {number} [nSequence] is an associated sequence number, -1 or undefined if none
     * @return {string} (and dbgAddr is updated to the next instruction)
     */
    getInstruction(dbgAddr, sComment, nSequence)
    {
        let dbgAddrIns = this.newAddr(dbgAddr.off, dbgAddr.sel, dbgAddr.addr, dbgAddr.type);

        let bOpcode = this.getByte(dbgAddr, 1);

        /*
         * Incorporate OPERAND and ADDRESS size prefixes into the current instruction.
         *
         * And the verdict is in: redundant OPERAND and ADDRESS prefixes must be ignored;
         * see opOS() and opAS() for details.  We limit the amount of redundancy to something
         * reasonable (ie, 4).
         */
        let cMaxOverrides = 4, cOverrides = 0;
        let fDataPrefix = false, fAddrPrefix = false;

        while ((bOpcode == X86.OPCODE.OS || bOpcode == X86.OPCODE.AS) && cMaxOverrides--) {
            if (bOpcode == X86.OPCODE.OS) {
                if (!fDataPrefix) {
                    dbgAddr.fData32 = !dbgAddr.fData32;
                    fDataPrefix = true;
                }
                cOverrides++;
            } else {
                if (!fAddrPrefix) {
                    dbgAddr.fAddr32 = !dbgAddr.fAddr32;
                    fAddrPrefix = true;
                }
                cOverrides++;
            }
            bOpcode = this.getByte(dbgAddr, 1);
        }

        let bModRM = -1;
        let asOpcodes = DebuggerX86.INS_NAMES;
        let aOpDesc = this.aaOpDescs[bOpcode];
        let iIns = aOpDesc[0];

        if (iIns == DebuggerX86.INS.OP0F) {
            let b = this.getByte(dbgAddr, 1);
            aOpDesc = DebuggerX86.aaOp0FDescs[b] || DebuggerX86.aOpDescUndefined;
            bOpcode |= (b << 8);
            iIns = aOpDesc[0];
        }

        if (iIns == DebuggerX86.INS.ESC) {
            bModRM = this.getByte(dbgAddr, 1);
            let aOpFPUDesc = this.getFPUInstruction(bOpcode, bModRM);
            if (aOpFPUDesc) {
                asOpcodes = DebuggerX86.FINS_NAMES;
                aOpDesc = aOpFPUDesc;
                iIns = aOpDesc[0];
            }
        }

        if (iIns >= asOpcodes.length) {
            bModRM = this.getByte(dbgAddr, 1);
            aOpDesc = DebuggerX86.aaGrpDescs[iIns - asOpcodes.length][(bModRM >> 3) & 0x7];
            iIns = aOpDesc[0];
        }

        let sOpcode = asOpcodes[iIns];
        let cOperands = aOpDesc.length - 1;
        let sOperands = "";

        if (dbgAddr.fData32) {
            if (iIns == DebuggerX86.INS.CBW) {
                sOpcode = "CWDE";           // sign-extend AX into EAX, instead of AL into AX
            }
            else if (iIns == DebuggerX86.INS.CWD) {
                sOpcode = "CDQ";            // sign-extend EAX into EDX:EAX, instead of AX into DX:AX
            }
            else if (iIns >= DebuggerX86.INS.POPA && iIns <= DebuggerX86.INS.PUSHA) {
                sOpcode += 'D';             // transform POPA/POPF/PUSHF/PUSHA to POPAD/POPFD/PUSHFD/PUSHAD as appropriate
            }
        }
        if (this.isStringIns(bOpcode)) {
            cOperands = 0;              // suppress operands for string instructions, and add 'D' suffix as appropriate
            if (dbgAddr.fData32 && sOpcode.slice(-1) == 'W') sOpcode = sOpcode.slice(0, -1) + 'D';
        }

        let typeCPU = -1;
        let fComplete = true;

        for (let iOperand = 1; iOperand <= cOperands; iOperand++) {

            let disp, off, cch;
            let sOperand = "";
            let type = aOpDesc[iOperand];
            if (type === undefined) continue;

            if (typeCPU < 0) typeCPU = type >> DebuggerX86.TYPE_CPU_SHIFT;

            if (iIns == DebuggerX86.INS.LOADALL) {
                if (typeCPU == DebuggerX86.CPU_80286) {
                    sOperands = "[%800]";
                } else if (typeCPU == DebuggerX86.CPU_80386) {
                    sOperands = "ES:[" + (dbgAddr.fAddr32? 'E':'') + "DI]";
                }
            }

            let typeSize = type & DebuggerX86.TYPE_SIZE;
            if (typeSize == DebuggerX86.TYPE_NONE) {
                continue;
            }
            if (typeSize == DebuggerX86.TYPE_PREFIX) {
                fComplete = false;
                continue;
            }
            let typeMode = type & DebuggerX86.TYPE_MODE;
            if (typeMode >= DebuggerX86.TYPE_MODRM) {
                if (bModRM < 0) {
                    bModRM = this.getByte(dbgAddr, 1);
                }
                if (typeMode < DebuggerX86.TYPE_MODREG) {
                    /*
                     * This test also encompasses TYPE_MODMEM, which is basically the inverse of the case
                     * below (ie, only Mod values *other* than 11 are allowed); however, I believe that in
                     * some cases that's merely a convention, and that if you try to execute an instruction
                     * like "LEA AX,BX", it will actually do something (on some if not all processors), so
                     * there's probably some diagnostic value in allowing those cases to be disassembled.
                     */
                    sOperand = this.getModRMOperand(sOpcode, bModRM, type, cOperands, dbgAddr);
                }
                else if (typeMode == DebuggerX86.TYPE_MODREG) {
                    /*
                     * TYPE_MODREG instructions assume that Mod is 11 (only certain early 80486 steppings
                     * actually *required* that Mod contain 11) and always treat RM as a register (which we
                     * could also simulate by setting Mod to 11 and letting getModRMOperand() do its thing).
                     */
                    sOperand = this.getRegOperand(bModRM & 0x7, type, dbgAddr);
                }
                else {
                    /*
                     * All remaining cases are register-based (eg, TYPE_REG); getRegOperand() will figure out which.
                     */
                    sOperand = this.getRegOperand((bModRM >> 3) & 0x7, type, dbgAddr);
                }
            }
            else if (typeMode == DebuggerX86.TYPE_ONE) {
                sOperand = '1';
            }
            else if (typeMode == DebuggerX86.TYPE_IMM) {
                sOperand = this.getImmOperand(type, dbgAddr);
            }
            else if (typeMode == DebuggerX86.TYPE_IMMOFF) {
                if (!dbgAddr.fAddr32) {
                    cch = 4;
                    off = this.getShort(dbgAddr, 2);
                } else {
                    cch = 8;
                    off = this.getLong(dbgAddr, 4);
                }
                sOperand = '[' + Str.toHex(off, cch) + ']';
            }
            else if (typeMode == DebuggerX86.TYPE_IMMREL) {
                if (typeSize == DebuggerX86.TYPE_BYTE) {
                    disp = ((this.getByte(dbgAddr, 1) << 24) >> 24);
                }
                else {
                    disp = this.getWord(dbgAddr, true);
                }
                off = (dbgAddr.off + disp) & (dbgAddr.fData32? -1 : 0xffff);
                sOperand = Str.toHex(off, dbgAddr.fData32? 8: 4);
                let aSymbol = this.findSymbol(this.newAddr(off, dbgAddr.sel));
                if (aSymbol[0]) sOperand += " (" + aSymbol[0] + ")";
            }
            else if (typeMode == DebuggerX86.TYPE_IMPREG) {
                if (typeSize == DebuggerX86.TYPE_ST) {
                    sOperand = "ST";
                } else if (typeSize == DebuggerX86.TYPE_STREG) {
                    sOperand = "ST(" + (bModRM & 0x7) + ")";
                } else {
                    sOperand = this.getRegOperand((type & DebuggerX86.TYPE_IREG) >> 8, type, dbgAddr);
                }
            }
            else if (typeMode == DebuggerX86.TYPE_IMPSEG) {
                sOperand = this.getRegOperand((type & DebuggerX86.TYPE_IREG) >> 8, DebuggerX86.TYPE_SEGREG, dbgAddr);
            }
            else if (typeMode == DebuggerX86.TYPE_DSSI) {
                sOperand = "DS:[SI]";
            }
            else if (typeMode == DebuggerX86.TYPE_ESDI) {
                sOperand = "ES:[DI]";
            }
            if (!sOperand || !sOperand.length) {
                sOperands = "INVALID";
                break;
            }
            if (sOperands.length > 0) sOperands += ',';
            sOperands += (sOperand || "???");
        }

        let sBytes = "";
        let sLine = this.toHexAddr(dbgAddrIns) + ' ';
        if (dbgAddrIns.addr !== X86.ADDR_INVALID && dbgAddr.addr !== X86.ADDR_INVALID) {
            do {
                sBytes += Str.toHex(this.getByte(dbgAddrIns, 1), 2);
                if (dbgAddrIns.addr === X86.ADDR_INVALID || dbgAddrIns.addr == undefined) break;
            } while (dbgAddrIns.addr != dbgAddr.addr);
        }

        sLine += Str.pad(sBytes, dbgAddrIns.fAddr32? 25 : 17);
        sLine += Str.pad(sOpcode, 8);
        if (sOperands) sLine += ' ' + sOperands;

        if (this.cpu.model < DebuggerX86.CPUS[typeCPU]) {
            sComment = DebuggerX86.CPUS[typeCPU] + " CPU only";
        }

        if (sComment && fComplete) {
            sLine = Str.pad(sLine, dbgAddrIns.fAddr32? 74 : 62) + ';' + sComment;
            if (!this.cpu.flags.checksum) {
                sLine += (nSequence >= 0? '=' + nSequence.toString() : "");
            } else {
                let nCycles = this.cpu.getCycles();
                sLine += "cycles=" + nCycles.toString() + " cs=" + Str.toHex(this.cpu.counts.nChecksum);
            }
        }

        this.initAddrSize(dbgAddr, fComplete, cOverrides);
        return sLine;
    }

    /**
     * getFPUInstruction(bOpcode, bModRM)
     *
     * @this {DebuggerX86}
     * @param {number} bOpcode
     * @param {number} bModRM
     * @return {Array|null} (FPU instruction group, or null if none)
     */
    getFPUInstruction(bOpcode, bModRM)
    {
        let aOpDesc = null;

        let mod = (bModRM >> 6) & 0x3;
        let reg = (bModRM >> 3) & 0x7;
        let r_m = (bModRM & 0x7);

        /*
         * Similar to how opFPU() decodes FPU instructions, we combine mod and reg into one
         * decodable value: put mod in the high nibble and reg in the low nibble, after first
         * collapsing all mod values < 3 to zero.
         */
        let modReg = (mod < 3? 0 : 0x30) + reg;

        /*
         * All values >= 0x34 imply mod == 3 and reg >= 4, so now we shift reg into the high
         * nibble and r_m into the low, yielding values >= 0x40.
         */
        if ((bOpcode == X86.OPCODE.ESC1 || bOpcode == X86.OPCODE.ESC3) && modReg >= 0x34) {
            modReg = (reg << 4) | r_m;
        }

        let aaOpDesc = DebuggerX86.aaaOpFPUDescs[bOpcode];
        if (aaOpDesc) aOpDesc = aaOpDesc[modReg];

        return aOpDesc;
    }

    /**
     * getImmOperand(type, dbgAddr)
     *
     * @this {DebuggerX86}
     * @param {number} type
     * @param {DbgAddrX86} dbgAddr
     * @return {string} operand
     */
    getImmOperand(type, dbgAddr)
    {
        let sOperand = ' ';
        let typeSize = type & DebuggerX86.TYPE_SIZE;

        switch (typeSize) {
        case DebuggerX86.TYPE_BYTE:
            /*
             * There's the occasional immediate byte we don't need to display (eg, the 0x0A
             * following an AAM or AAD instruction), so we suppress the byte if it lacks a TYPE_IN
             * or TYPE_OUT designation (and TYPE_BOTH, as the name implies, includes both).
             */
            if (type & DebuggerX86.TYPE_BOTH) {
                sOperand = Str.toHex(this.getByte(dbgAddr, 1), 2);
            }
            break;
        case DebuggerX86.TYPE_SBYTE:
            sOperand = Str.toHex((this.getByte(dbgAddr, 1) << 24) >> 24, dbgAddr.fData32? 8: 4);
            break;
        case DebuggerX86.TYPE_WORD:
            if (dbgAddr.fData32) {
                sOperand = Str.toHex(this.getLong(dbgAddr, 4));
                break;
            }
            /* falls through */
        case DebuggerX86.TYPE_SHORT:
            sOperand = Str.toHex(this.getShort(dbgAddr, 2), 4);
            break;
        case DebuggerX86.TYPE_FARP:
            dbgAddr = this.newAddr(this.getWord(dbgAddr, true), this.getShort(dbgAddr, 2), undefined, dbgAddr.type, dbgAddr.fData32, dbgAddr.fAddr32);
            sOperand = this.toHexAddr(dbgAddr);
            let aSymbol = this.findSymbol(dbgAddr);
            if (aSymbol[0]) sOperand += " (" + aSymbol[0] + ")";
            break;
        default:
            sOperand = "imm(" + Str.toHexWord(type) + ')';
            break;
        }
        return sOperand;
    }

    /**
     * getRegOperand(bReg, type, dbgAddr)
     *
     * @this {DebuggerX86}
     * @param {number} bReg
     * @param {number} type
     * @param {DbgAddrX86} dbgAddr
     * @return {string} operand
     */
    getRegOperand(bReg, type, dbgAddr)
    {
        let typeMode = type & DebuggerX86.TYPE_MODE;
        if (typeMode == DebuggerX86.TYPE_SEGREG) {
            if (bReg > DebuggerX86.REG_GS ||
                bReg >= DebuggerX86.REG_FS && this.cpu.model < X86.MODEL_80386) return "??";
            bReg += DebuggerX86.REG_SEG;
        }
        else if (typeMode == DebuggerX86.TYPE_CTLREG) {
            bReg += DebuggerX86.REG_CR0;
        }
        else if (typeMode == DebuggerX86.TYPE_DBGREG) {
            bReg += DebuggerX86.REG_DR0;
        }
        else if (typeMode == DebuggerX86.TYPE_TSTREG) {
            bReg += DebuggerX86.REG_TR0;
        }
        else {
            let typeSize = type & DebuggerX86.TYPE_SIZE;
            if (typeSize >= DebuggerX86.TYPE_SHORT) {
                if (bReg < DebuggerX86.REG_AX) {
                    bReg += DebuggerX86.REG_AX - DebuggerX86.REG_AL;
                }
                if (typeSize == DebuggerX86.TYPE_LONG || typeSize == DebuggerX86.TYPE_WORD && dbgAddr.fData32) {
                    bReg += DebuggerX86.REG_EAX - DebuggerX86.REG_AX;
                }
            }
        }
        return DebuggerX86.REGS[bReg];
    }

    /**
     * getSIBOperand(bMod, dbgAddr)
     *
     * @this {DebuggerX86}
     * @param {number} bMod
     * @param {DbgAddrX86} dbgAddr
     * @return {string} operand
     */
    getSIBOperand(bMod, dbgAddr)
    {
        let bSIB = this.getByte(dbgAddr, 1);
        let bScale = bSIB >> 6;
        let bIndex = (bSIB >> 3) & 0x7;
        let bBase = bSIB & 0x7;
        let sOperand = "";
        /*
         * Unless bMod is zero AND bBase is 5, there's always a base register.
         */
        if (bMod || bBase != 5) {
            sOperand = DebuggerX86.RMS[bBase + 8];
        }
        if (bIndex != 4) {
            if (sOperand) sOperand += '+';
            sOperand += DebuggerX86.RMS[bIndex + 8];
            if (bScale) sOperand += '*' + (0x1 << bScale);
        }
        /*
         * If bMod is zero AND bBase is 5, there's a 32-bit displacement instead of a base register.
         */
        if (!bMod && bBase == 5) {
            if (sOperand) sOperand += '+';
            sOperand += Str.toHex(this.getLong(dbgAddr, 4));
        }
        return sOperand;
    }

    /**
     * getModRMOperand(sOpcode, bModRM, type, cOperands, dbgAddr)
     *
     * @this {DebuggerX86}
     * @param {string} sOpcode
     * @param {number} bModRM
     * @param {number} type
     * @param {number} cOperands (if 1, memory operands are prefixed with the size; otherwise, size can be inferred)
     * @param {DbgAddrX86} dbgAddr
     * @return {string} operand
     */
    getModRMOperand(sOpcode, bModRM, type, cOperands, dbgAddr)
    {
        let sOperand = "";
        let bMod = bModRM >> 6;
        let bRM = bModRM & 0x7;
        if (bMod < 3) {
            let disp;
            let fInteger = (sOpcode.indexOf("FI") == 0);
            if (!bMod && (!dbgAddr.fAddr32 && bRM == 6 || dbgAddr.fAddr32 && bRM == 5)) {
                bMod = 2;
            } else {
                if (dbgAddr.fAddr32) {
                    if (bRM != 4) {
                        bRM += 8;
                    } else {
                        sOperand = this.getSIBOperand(bMod, dbgAddr);
                    }
                }
                if (!sOperand) sOperand = DebuggerX86.RMS[bRM];
            }
            if (bMod == 1) {
                disp = this.getByte(dbgAddr, 1);
                if (!(disp & 0x80)) {
                    sOperand += '+' + Str.toHex(disp, 2);
                }
                else {
                    disp = ((disp << 24) >> 24);
                    sOperand += '-' + Str.toHex(-disp, 2);
                }
            }
            else if (bMod == 2) {
                if (sOperand) sOperand += '+';
                if (!dbgAddr.fAddr32) {
                    disp = this.getShort(dbgAddr, 2);
                    sOperand += Str.toHex(disp, 4);
                } else {
                    disp = this.getLong(dbgAddr, 4);
                    sOperand += Str.toHex(disp);
                }
            }
            sOperand = '[' + sOperand + ']';
            if (cOperands == 1) {
                let sPrefix = "";
                type &= DebuggerX86.TYPE_SIZE;
                if (type == DebuggerX86.TYPE_WORD) {
                    type = (dbgAddr.fData32? DebuggerX86.TYPE_LONG : DebuggerX86.TYPE_SHORT);
                }
                switch(type) {
                case DebuggerX86.TYPE_FARP:
                    sPrefix = "FAR";
                    break;
                case DebuggerX86.TYPE_BYTE:
                    sPrefix = "BYTE";
                    break;
                case DebuggerX86.TYPE_SHORT:
                    if (fInteger) {
                        sPrefix = "INT16";
                        break;
                    }
                    /* falls through */
                    sPrefix = "WORD";
                    break;
                case DebuggerX86.TYPE_LONG:
                    sPrefix = "DWORD";
                    break;
                case DebuggerX86.TYPE_SINT:
                    if (fInteger) {
                        sPrefix = "INT32";
                        break;
                    }
                    /* falls through */
                case DebuggerX86.TYPE_SREAL:
                    sPrefix = "REAL32";
                    break;
                case DebuggerX86.TYPE_LINT:
                    if (fInteger) {
                        sPrefix = "INT64";
                        break;
                    }
                    /* falls through */
                case DebuggerX86.TYPE_LREAL:
                    sPrefix = "REAL64";
                    break;
                case DebuggerX86.TYPE_TREAL:
                    sPrefix = "REAL80";
                    break;
                case DebuggerX86.TYPE_BCD80:
                    sPrefix = "BCD80";
                    break;
                }
                if (sPrefix) sOperand = sPrefix + ' ' + sOperand;
            }
        }
        else {
            sOperand = this.getRegOperand(bRM, type, dbgAddr);
        }
        return sOperand;
    }

    /**
     * parseInstruction(sOp, sOperand, addr)
     *
     * TODO: Unimplemented.  See parseInstruction() in modules/c1pjs/lib/debugger.js for a working implementation.
     *
     * @this {DebuggerX86}
     * @param {string} sOp
     * @param {string|undefined} sOperand
     * @param {DbgAddrX86} dbgAddr of memory where this instruction is being assembled
     * @return {Array.<number>} of opcode bytes; if the instruction can't be parsed, the array will be empty
     */
    parseInstruction(sOp, sOperand, dbgAddr)
    {
        let aOpBytes = [];
        this.println("not supported yet");
        return aOpBytes;
    }

    /**
     * getFlagOutput(sFlag)
     *
     * @this {DebuggerX86}
     * @param {string} sFlag
     * @return {string} value of flag
     */
    getFlagOutput(sFlag)
    {
        let b;
        switch (sFlag) {
        case 'V':
            b = this.cpu.getOF();
            break;
        case 'D':
            b = this.cpu.getDF();
            break;
        case 'I':
            b = this.cpu.getIF();
            break;
        case 'T':
            b = this.cpu.getTF();
            break;
        case 'S':
            b = this.cpu.getSF();
            break;
        case 'Z':
            b = this.cpu.getZF();
            break;
        case 'A':
            b = this.cpu.getAF();
            break;
        case 'P':
            b = this.cpu.getPF();
            break;
        case 'C':
            b = this.cpu.getCF();
            break;
        default:
            b = 0;
            break;
        }
        return sFlag + (b? '1' : '0') + ' ';
    }

    /**
     * getLimitString(l)
     *
     * @this {DebuggerX86}
     * @param {number} l
     * @return {string}
     */
    getLimitString(l)
    {
        return Str.toHex(l, (l & ~0xffff)? 8 : 4);
    }

    /**
     * getRegOutput(iReg)
     *
     * @this {DebuggerX86}
     * @param {number} iReg
     * @return {string}
     */
    getRegOutput(iReg)
    {
        if (iReg >= DebuggerX86.REG_AX && iReg <= DebuggerX86.REG_DI && this.cchReg > 4) iReg += DebuggerX86.REG_EAX - DebuggerX86.REG_AX;
        let sReg = DebuggerX86.REGS[iReg];
        if (iReg == DebuggerX86.REG_CR0 && this.cpu.model == X86.MODEL_80286) sReg = "MS";
        return sReg + '=' + this.getRegString(iReg) + ' ';
    }

    /**
     * getSegOutput(seg, fProt)
     *
     * @this {DebuggerX86}
     * @param {SegX86} seg
     * @param {boolean} [fProt]
     * @return {string}
     */
    getSegOutput(seg, fProt)
    {
        return seg.sName + '=' + Str.toHex(seg.sel, 4) + (fProt? '[' + Str.toHex(seg.base, this.cchAddr) + ',' + this.getLimitString(seg.limit) + ']' : "");
    }

    /**
     * getDTROutput(sName, sel, addr, addrLimit)
     *
     * @this {DebuggerX86}
     * @param {string} sName
     * @param {number|null|*} sel
     * @param {number} addr
     * @param {number} addrLimit
     * @return {string}
     */
    getDTROutput(sName, sel, addr, addrLimit)
    {
        return sName + '=' + (sel != null? Str.toHex(sel, 4) : "") + '[' + Str.toHex(addr, this.cchAddr) + ',' + Str.toHex(addrLimit - addr, 4) + ']';
    }

    /**
     * getRegDump(fProt)
     *
     * Sample 8086 and 80286 real-mode register dump:
     *
     *      AX=0000 BX=0000 CX=0000 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
     *      SS=0000 DS=0000 ES=0000 PS=0002 V0 D0 I0 T0 S0 Z0 A0 P0 C0
     *      F000:FFF0 EA5BE000F0    JMP      F000:E05B
     *
     * Sample 80386 real-mode register dump:
     *
     *      EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000000
     *      ESP=00000000 EBP=00000000 ESI=00000000 EDI=00000000
     *      SS=0000 DS=0000 ES=0000 FS=0000 GS=0000 PS=00000002 V0 D0 I0 T0 S0 Z0 A0 P0 C0
     *      F000:FFF0 EA05F900F0    JMP      F000:F905
     *
     * Sample 80286 protected-mode register dump:
     *
     *      AX=0000 BX=0000 CX=0000 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
     *      SS=0000[000000,FFFF] DS=0000[000000,FFFF] ES=0000[000000,FFFF] A20=ON
     *      CS=F000[FF0000,FFFF] LD=0000[000000,FFFF] GD=[000000,FFFF] ID=[000000,03FF]
     *      TR=0000 MS=FFF0 PS=0002 V0 D0 I0 T0 S0 Z0 A0 P0 C0
     *      F000:FFF0 EA5BE000F0    JMP      F000:E05B
     *
     * Sample 80386 protected-mode register dump:
     *
     *      EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000000
     *      ESP=00000000 EBP=00000000 ESI=00000000 EDI=00000000
     *      SS=0000[00000000,FFFF] DS=0000[00000000,FFFF] ES=0000[00000000,FFFF]
     *      CS=F000[FFFF0000,FFFF] FS=0000[00000000,FFFF] GS=0000[00000000,FFFF]
     *      LD=0000[00000000,FFFF] GD=[00000000,FFFF] ID=[00000000,03FF] TR=0000 A20=ON
     *      CR0=00000010 CR2=00000000 CR3=00000000 PS=00000002 V0 D0 I0 T0 S0 Z0 A0 P0 C0
     *      F000:0000FFF0 EA05F900F0    JMP      F000:0000F905
     *
     * This no longer includes CS in real-mode (or EIP in any mode), because that information can be obtained from the
     * first line of disassembly, which an "r" or "rp" command will also display.
     *
     * Note that even when the processor is in real mode, you can always use the "rp" command to force a protected-mode
     * dump, in case you need to verify any selector base or limit values, since those also affect real-mode operation.
     *
     * @this {DebuggerX86}
     * @param {boolean} [fProt]
     * @return {string}
     */
    getRegDump(fProt)
    {
        let s;
        if (fProt === undefined) fProt = this.getCPUMode();

        s = this.getRegOutput(DebuggerX86.REG_AX) +
            this.getRegOutput(DebuggerX86.REG_BX) +
            this.getRegOutput(DebuggerX86.REG_CX) +
            this.getRegOutput(DebuggerX86.REG_DX) + (this.cchReg > 4? '\n' : '') +
            this.getRegOutput(DebuggerX86.REG_SP) +
            this.getRegOutput(DebuggerX86.REG_BP) +
            this.getRegOutput(DebuggerX86.REG_SI) +
            this.getRegOutput(DebuggerX86.REG_DI) + '\n' +
            this.getSegOutput(this.cpu.segSS, fProt) + ' ' +
            this.getSegOutput(this.cpu.segDS, fProt) + ' ' +
            this.getSegOutput(this.cpu.segES, fProt) + ' ';

        if (fProt) {
            let sTR = "TR=" + Str.toHex(this.cpu.segTSS.sel, 4);
            let sA20 = "A20=" + (this.bus.getA20()? "ON " : "OFF ");
            if (this.cpu.model < X86.MODEL_80386) {
                sTR = '\n' + sTR;
                s += sA20; sA20 = '';
            }
            s += '\n' + this.getSegOutput(this.cpu.segCS, fProt) + ' ';
            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                sA20 += '\n';
                s += this.getSegOutput(this.cpu.segFS, fProt) + ' ' +
                     this.getSegOutput(this.cpu.segGS, fProt) + '\n';
            }
            s += this.getDTROutput("LD", this.cpu.segLDT.sel, this.cpu.segLDT.base, this.cpu.segLDT.base + this.cpu.segLDT.limit) + ' ' +
                 this.getDTROutput("GD", null, this.cpu.addrGDT, this.cpu.addrGDTLimit) + ' ' +
                 this.getDTROutput("ID", null, this.cpu.addrIDT, this.cpu.addrIDTLimit) + ' ';
            s += sTR + ' ' + sA20;
            s += this.getRegOutput(DebuggerX86.REG_CR0);
            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                s += this.getRegOutput(DebuggerX86.REG_CR2) + this.getRegOutput(DebuggerX86.REG_CR3);
            }
        } else {
            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                s += this.getSegOutput(this.cpu.segFS, fProt) + ' ' +
                     this.getSegOutput(this.cpu.segGS, fProt) + ' ';
            }
        }

        s += this.getRegOutput(DebuggerX86.REG_PS) +
             this.getFlagOutput('V') + this.getFlagOutput('D') + this.getFlagOutput('I') + this.getFlagOutput('T') +
             this.getFlagOutput('S') + this.getFlagOutput('Z') + this.getFlagOutput('A') + this.getFlagOutput('P') + this.getFlagOutput('C');

        return s;
    }

    /**
     * comparePairs(p1, p2)
     *
     * @this {DebuggerX86}
     * @param {number|string|Array|Object} p1
     * @param {number|string|Array|Object} p2
     * @return {number}
     */
    comparePairs(p1, p2)
    {
        return p1[0] > p2[0]? 1 : p1[0] < p2[0]? -1 : 0;
    }

    /**
     * addSymbols(sModule, nSegment, sel, off, addr, len, aSymbols)
     *
     * As filedump.js (formerly convrom.php) explains, aSymbols is a JSON-encoded object whose properties consist
     * of all the symbols (in upper-case), and the values of those properties are objects containing any or all of
     * the following properties:
     *
     *      'v': the value of an absolute (unsized) value
     *      'b': either 1, 2, 4 or undefined if an unsized value
     *      's': either a hard-coded segment or undefined
     *      'o': the offset of the symbol within the associated address space
     *      'l': the original-case version of the symbol, present only if it wasn't originally upper-case
     *      'a': annotation for the specified offset; eg, the original assembly language, with optional comment
     *
     * To that list of properties, we also add:
     *
     *      'p': the physical address (calculated whenever both 's' and 'o' properties are defined)
     *
     * Note that values for any 'v', 'b', 's' and 'o' properties are unquoted decimal values, and the values
     * for any 'l' or 'a' properties are quoted strings. Also, if double-quotes were used in any of the original
     * annotation ('a') values, they will have been converted to two single-quotes, so we're responsible for
     * converting them back to individual double-quotes.
     *
     * For example:
     *      {
     *          'HF_PORT': {
     *              'v':800
     *          },
     *          'HDISK_INT': {
     *              'b':4, 's':0, 'o':52
     *          },
     *          'ORG_VECTOR': {
     *              'b':4, 's':0, 'o':76
     *          },
     *          'CMD_BLOCK': {
     *              'b':1, 's':64, 'o':66
     *          },
     *          'DISK_SETUP': {
     *              'o':3
     *          },
     *          '.40': {
     *              'o':40, 'a':"MOV AX,WORD PTR ORG_VECTOR ;GET DISKETTE VECTOR"
     *          }
     *      }
     *
     * If a symbol only has an offset, then that offset value can be assigned to the symbol property directly:
     *
     *          'DISK_SETUP': 3
     *
     * The last property is an example of an "anonymous" entry, for offsets where there is no associated symbol.
     * Such entries are identified by a period followed by a unique number (usually the offset of the entry), and
     * they usually only contain offset ('o') and annotation ('a') properties.  I could eliminate the leading
     * period, but it offers a very convenient way of quickly discriminating among genuine vs. anonymous symbols.
     *
     * We add all these entries to our internal symbol table, which is an array of 4-element arrays, each of which
     * look like:
     *
     *      [sel, off, addr, len, aSymbols, aOffsets]
     *
     * There are two basic symbol operations: findSymbol(), which takes an address and finds the symbol, if any,
     * at that address, and findSymbolAddr(), which takes a string and attempts to match it to a non-anonymous
     * symbol with a matching offset ('o') property.
     *
     * To implement findSymbol() efficiently, addSymbols() creates an array of [offset, sSymbol] pairs
     * (aOffsets), one pair for each symbol that corresponds to an offset within the specified address space.
     *
     * We guarantee the elements of aOffsets are in offset order, because we build it using binaryInsert();
     * it's quite likely that the MAP file already ordered all its symbols in offset order, but since they're
     * hand-edited files, we can't assume that, and we need to ensure that findSymbol()'s binarySearch() operates
     * properly.
     *
     * @this {DebuggerX86}
     * @param {string|null} sModule
     * @param {number} nSegment (zero if undefined)
     * @param {number} sel (the default segment/selector for all symbols in this group)
     * @param {number} off (from the base of the given selector)
     * @param {number|null|*} addr (physical address where the symbols are located, if the memory is physical; eg, ROM)
     * @param {number} len (the size of the region, in bytes)
     * @param {Object} aSymbols (collection of symbols in this group; the format of this collection is described below)
     */
    addSymbols(sModule, nSegment, sel, off, addr, len, aSymbols)
    {
        let dbgAddr = {};
        let aOffsets = [];
        for (let sSymbol in aSymbols) {
            let symbol = aSymbols[sSymbol];
            if (typeof symbol == "number") {
                aSymbols[sSymbol] = symbol = {'o': symbol};
            }
            let offSymbol = symbol['o'];
            let selSymbol = symbol['s'];
            let sAnnotation = symbol['a'];
            if (offSymbol !== undefined) {
                if (selSymbol !== undefined) {
                    dbgAddr.off = offSymbol;
                    dbgAddr.sel = selSymbol;
                    dbgAddr.addr = undefined;
                    /*
                     * getAddr() computes the corresponding physical address and saves it in dbgAddr.addr.
                     */
                    this.getAddr(dbgAddr);
                    /*
                     * The physical address for any symbol located in the top 64Kb of the machine's address space
                     * should be relocated to the top 64Kb of the first 1Mb, so that we're immune from any changes
                     * to the A20 line.
                     */
                    if ((dbgAddr.addr & ~0xffff) == (this.bus.nBusLimit & ~0xffff)) {
                        dbgAddr.addr &= 0x000fffff;
                    }
                    symbol['p'] = dbgAddr.addr;
                }
                Usr.binaryInsert(aOffsets, [offSymbol >>> 0, sSymbol], this.comparePairs);
            }
            if (sAnnotation) symbol['a'] = sAnnotation.replace(/''/g, "\"");
        }
        let symbolTable = {
            sModule: sModule,
            nSegment: nSegment,
            sel: sel,
            off: off,
            addr: addr,
            len: len,
            aSymbols: aSymbols,
            aOffsets: aOffsets
        };
        this.aSymbolTable.push(symbolTable);
    }

    /**
     * removeSymbols(sModule, nSegment)
     *
     * @this {DebuggerX86}
     * @param {string|null|*} sModule
     * @param {number} [nSegment] (segment # if sModule set, selector if sModule clear)
     * @return {string|null} name of the module removed, or null if no module was found
     */
    removeSymbols(sModule, nSegment)
    {
        let sModuleRemoved = null;
        for (let iTable = 0; iTable < this.aSymbolTable.length; iTable++) {
            let symbolTable = this.aSymbolTable[iTable];
            if (sModule && symbolTable.sModule != sModule) continue;
            if (sModule && nSegment == symbolTable.nSegment || !sModule && nSegment == symbolTable.sel) {
                sModuleRemoved = symbolTable.sModule;
                this.aSymbolTable.splice(iTable, 1);
                break;
            }
        }
        return sModuleRemoved;
    }

    /**
     * dumpSymbols()
     *
     * TODO: Add "numerical" and "alphabetical" dump options. This is simply dumping them in whatever
     * order they appeared in the original MAP file.
     *
     * @this {DebuggerX86}
     */
    dumpSymbols()
    {
        for (let iTable = 0; iTable < this.aSymbolTable.length; iTable++) {
            let symbolTable = this.aSymbolTable[iTable];
            for (let sSymbol in symbolTable.aSymbols) {
                if (sSymbol.charAt(0) == '.') continue;
                let symbol = symbolTable.aSymbols[sSymbol];
                let offSymbol = symbol['o'];
                if (offSymbol === undefined) continue;
                let selSymbol = symbol['s'];
                if (selSymbol === undefined) selSymbol = symbolTable.sel;
                let sSymbolOrig = symbolTable.aSymbols[sSymbol]['l'];
                if (sSymbolOrig) sSymbol = sSymbolOrig;
                this.println(this.toHexOffset(offSymbol, selSymbol) + ' ' + sSymbol);
            }
        }
    }

    /**
     * findSymbol(dbgAddr, fNearest)
     *
     * Search aSymbolTable for dbgAddr, and return an Array for the corresponding symbol (empty if not found).
     *
     * If fNearest is true, and no exact match was found, then the Array returned will contain TWO sets of
     * entries: [0]-[3] will refer to closest preceding symbol, and [4]-[7] will refer to the closest subsequent symbol.
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {boolean} [fNearest]
     * @return {Array} where [0] == symbol name, [1] == symbol value, [2] == any annotation, and [3] == any associated comment
     */
    findSymbol(dbgAddr, fNearest)
    {
        let aSymbol = [];
        let offSymbol = dbgAddr.off >>> 0;
        let addrSymbol = this.getAddr(dbgAddr) >>> 0;
        for (let iTable = 0; iTable < this.aSymbolTable.length; iTable++) {
            let symbolTable = this.aSymbolTable[iTable];
            let sel = symbolTable.sel;
            let off = symbolTable.off >>> 0;
            let addr = symbolTable.addr;
            if (addr != null) addr >>>= 0;
            let len = symbolTable.len;
            if (sel == 0x30) sel = 0x28;        // TODO: Remove this hack once we're able to differentiate Windows 95 ring 0 code and data
            if (sel == dbgAddr.sel && offSymbol >= off && offSymbol < off + len || addr != null && addrSymbol >= addr && addrSymbol < addr + len) {
                let result = Usr.binarySearch(symbolTable.aOffsets, [offSymbol], this.comparePairs);
                if (result >= 0) {
                    this.returnSymbol(iTable, result, aSymbol);
                }
                else if (fNearest) {
                    result = ~result;
                    this.returnSymbol(iTable, result-1, aSymbol);
                    this.returnSymbol(iTable, result, aSymbol);
                }
                break;
            }
        }
        if (!aSymbol.length) {
            let sSymbol = this.bus.getSymbol(addrSymbol, true);
            if (sSymbol) {
                aSymbol.push(sSymbol);
                aSymbol.push(addrSymbol);
            }
        }
        return aSymbol;
    }

    /**
     * findSymbolAddr(sSymbol)
     *
     * Search aSymbolTable for sSymbol, and if found, return a dbgAddr (same as parseAddr())
     *
     * @this {DebuggerX86}
     * @param {string} sSymbol
     * @return {DbgAddrX86|undefined}
     */
    findSymbolAddr(sSymbol)
    {
        let dbgAddr;
        if (sSymbol.match(/^[a-z_][a-z0-9_]*$/i)) {
            let sUpperCase = sSymbol.toUpperCase();
            for (let iTable = 0; iTable < this.aSymbolTable.length; iTable++) {
                let symbolTable = this.aSymbolTable[iTable];
                let symbol = symbolTable.aSymbols[sUpperCase];
                if (symbol !== undefined) {
                    let offSymbol = symbol['o'];
                    if (offSymbol !== undefined) {
                        /*
                         * We assume that every ROM is ORG'ed at 0x0000, and therefore unless the symbol has an
                         * explicitly-defined segment, we return the segment associated with the entire group; for
                         * a ROM, that segment is normally "addrROM >>> 4".  Down the road, we may want/need to
                         * support a special symbol entry (eg, ".ORG") that defines an alternate origin.
                         */
                        let selSymbol = symbol['s'];
                        if (selSymbol === undefined) selSymbol = symbolTable.sel;
                        dbgAddr = this.newAddr(offSymbol, selSymbol, symbol['p']);
                    }
                    /*
                     * The symbol matched, but it wasn't for an address (no 'o' offset), and there's no point
                     * looking any farther, since each symbol appears only once, so we indicate it's an unknown symbol.
                     */
                    break;
                }
            }
        }
        return dbgAddr;
    }

    /**
     * returnSymbol(iTable, iOffset, aSymbol)
     *
     * Helper function for findSymbol().
     *
     * @param {number} iTable
     * @param {number} iOffset
     * @param {Array} aSymbol is updated with the specified symbol, if it exists
     */
    returnSymbol(iTable, iOffset, aSymbol)
    {
        let symbol = {};
        let aOffsets = this.aSymbolTable[iTable].aOffsets;
        let offset = 0, sSymbol = null;
        if (iOffset >= 0 && iOffset < aOffsets.length) {
            offset = aOffsets[iOffset][0];
            sSymbol = aOffsets[iOffset][1];
        }
        if (sSymbol) {
            symbol = this.aSymbolTable[iTable].aSymbols[sSymbol];
            sSymbol = (sSymbol.charAt(0) == '.'? null : (symbol['l'] || sSymbol));
        }
        aSymbol.push(sSymbol);
        aSymbol.push(offset);
        aSymbol.push(symbol['a']);
        aSymbol.push(symbol['c']);
    }

    /**
     * doHelp()
     *
     * @this {DebuggerX86}
     */
    doHelp()
    {
        let s = "commands:";
        for (let sCommand in DebuggerX86.COMMANDS) {
            s += '\n' + Str.pad(sCommand, 7) + DebuggerX86.COMMANDS[sCommand];
        }
        if (!this.checksEnabled()) s += "\nnote: frequency/history disabled if no exec breakpoints";
        this.println(s);
    }

    /**
     * doAssemble(asArgs)
     *
     * This always receives the complete argument array, where the order of the arguments is:
     *
     *      [0]: the assemble command (assumed to be "a")
     *      [1]: the target address (eg, "200")
     *      [2]: the operation code, aka instruction name (eg, "adc")
     *      [3]: the operation mode operand, if any (eg, "14", "[1234]", etc)
     *
     * The Debugger enters "assemble mode" whenever only the first (or first and second) arguments are present.
     * As long as "assemble mode is active, the user can omit the first two arguments on all later assemble commands
     * until "assemble mode" is cancelled with an empty command line; the command processor automatically prepends "a"
     * and the next available target address to the argument array.
     *
     * Entering "assemble mode" is optional; one could enter a series of fully-qualified assemble commands; eg:
     *
     *      a ff00 cld
     *      a ff01 ldx 28
     *      ...
     *
     * without ever entering "assemble mode", but of course, that requires more typing and doesn't take advantage
     * of automatic target address advancement (see dbgAddrAssemble).
     *
     * NOTE: As the previous example implies, you can even assemble new instructions into ROM address space;
     * as our setByte() function explains, the ROM write-notification handlers only refuse writes from the CPU.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs is the complete argument array, beginning with the "a" command in asArgs[0]
     */
    doAssemble(asArgs)
    {
        let dbgAddr = this.parseAddr(asArgs[1], true);
        if (!dbgAddr) return;

        this.dbgAddrAssemble = dbgAddr;
        if (asArgs[2] === undefined) {
            this.println("begin assemble at " + this.toHexAddr(dbgAddr));
            this.fAssemble = true;
            this.cpu.updateCPU();
            return;
        }

        let aOpBytes = this.parseInstruction(asArgs[2], asArgs[3], dbgAddr);
        if (aOpBytes.length) {
            for (let i = 0; i < aOpBytes.length; i++) {
                this.setByte(dbgAddr, aOpBytes[i], 1);
            }
            /*
             * Since getInstruction() also updates the specified address, dbgAddrAssemble is automatically advanced.
             */
            this.println(this.getInstruction(this.dbgAddrAssemble));
        }
    }

    /**
     * doBreak(sCmd, sAddr, sOptions)
     *
     * As the "help" output below indicates, the following breakpoint commands are supported:
     *
     *      bp [a]  set exec breakpoint on linear addr [a]
     *      br [a]  set read breakpoint on linear addr [a]
     *      bw [a]  set write breakpoint on linear addr [a]
     *      bc [a]  clear breakpoint on linear addr [a] (use "*" for all breakpoints)
     *      bl      list breakpoints
     *
     * to which we have recently added the following I/O breakpoint commands:
     *
     *      bi [p]  toggle input breakpoint on port [p] (use "*" for all input ports)
     *      bo [p]  toggle output breakpoint on port [p] (use "*" for all output ports)
     *
     * These two new commands operate as toggles so that if "*" is used to trap all input (or output),
     * you can also use these commands to NOT trap specific ports.
     *
     *      bn [n]  break after [n] instructions
     *
     * TODO: Update the "bl" command to include any/all I/O breakpoints, and the "bc" command to
     * clear them.  Because "bi" and "bo" commands are piggy-backing on Bus functions, those breakpoints
     * are currently outside the realm of what the "bl" and "bc" commands are aware of.
     *
     * @this {DebuggerX86}
     * @param {string} sCmd
     * @param {string|undefined} [sAddr]
     * @param {string} [sOptions] (the rest of the breakpoint command-line)
     */
    doBreak(sCmd, sAddr, sOptions)
    {
        if (sAddr == '?') {
            this.println("breakpoint commands:");
            this.println("\tbi [p]\ttoggle break on input port [p]");
            this.println("\tbo [p]\ttoggle break on output port [p]");
            this.println("\tbp [a]\tset exec breakpoint at addr [a]");
            this.println("\tbr [a]\tset read breakpoint at addr [a]");
            this.println("\tbw [a]\tset write breakpoint at addr [a]");
            this.println("\tbc [a]\tclear breakpoint at addr [a]");
            this.println("\tbl\tlist all breakpoints");
            this.println("\tbn [n]\tbreak after [n] instruction(s)");
            return;
        }
        let sParm = sCmd.charAt(1);
        if (sParm == 'l') {
            let cBreaks = 0;
            cBreaks += this.listBreakpoints(this.aBreakExec);
            cBreaks += this.listBreakpoints(this.aBreakRead);
            cBreaks += this.listBreakpoints(this.aBreakWrite);
            if (!cBreaks) this.println("no breakpoints");
            return;
        }
        if (sParm == 'n') {
            this.nBreakIns = this.parseValue(sAddr);
            this.println("break after " + this.nBreakIns + " instruction(s)");
            return;
        }
        if (sAddr === undefined) {
            this.println("missing breakpoint address");
            return;
        }
        let dbgAddr = {};
        if (sAddr != '*') {
            dbgAddr = this.parseAddr(sAddr, true, true);
            if (!dbgAddr) return;
        }

        sAddr = (dbgAddr.off == null? sAddr : Str.toHexWord(dbgAddr.off));

        if (sParm == 'c') {
            if (dbgAddr.off == null) {
                this.clearBreakpoints();
                this.println("all breakpoints cleared");
                return;
            }
            if (this.findBreakpoint(this.aBreakExec, dbgAddr, true))
                return;
            if (this.findBreakpoint(this.aBreakRead, dbgAddr, true))
                return;
            if (this.findBreakpoint(this.aBreakWrite, dbgAddr, true))
                return;
            this.println("breakpoint missing: " + this.toHexAddr(dbgAddr));
            return;
        }

        if (sParm == 'i') {
            this.println("breakpoint " + (this.bus.addPortInputBreak(dbgAddr.off)? "enabled" : "cleared") + ": port " + sAddr + " (input)");
            return;
        }

        if (sParm == 'o') {
            this.println("breakpoint " + (this.bus.addPortOutputBreak(dbgAddr.off)? "enabled" : "cleared") + ": port " + sAddr + " (output)");
            return;
        }

        if (dbgAddr.off == null) return;

        this.parseAddrOptions(dbgAddr, sOptions);

        if (sParm == 'p') {
            this.addBreakpoint(this.aBreakExec, dbgAddr);
            return;
        }
        if (sParm == 'r') {
            this.addBreakpoint(this.aBreakRead, dbgAddr);
            return;
        }
        if (sParm == 'w') {
            this.addBreakpoint(this.aBreakWrite, dbgAddr);
            return;
        }
        this.println("unknown breakpoint command: " + sParm);
    }

    /**
     * doClear(sCmd)
     *
     * @this {DebuggerX86}
     * @param {string} [sCmd] (eg, "cls" or "clear")
     */
    doClear(sCmd)
    {
        this.cmp.clearPanel();
    }

    /**
     * doDump(asArgs)
     *
     * For memory dumps, the second parameter (sLen) is interpreted as a length (by default, in hex)
     * only if it contains an 'l' prefix; otherwise it's interpreted as an ending address (inclusive).
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs (formerly sCmd, [sAddr], [sLen] and [sBytes])
     */
    doDump(asArgs)
    {
        let m;
        let sCmd = asArgs[0];
        let sAddr = asArgs[1];
        let sLen = asArgs[2];
        let sBytes = asArgs[3];

        if (sAddr == '?') {
            let sDumpers = "";
            for (m in Messages.CATEGORIES) {
                if (this.afnDumpers[m]) {
                    if (sDumpers) sDumpers += ',';
                    sDumpers += m;
                }
            }
            sDumpers += ",state,symbols";
            this.println("dump memory commands:");
            this.println("\tda [a] [#]    dump # ASCII chars at address a");
            this.println("\tdb [a] [#]    dump # bytes at address a");
            this.println("\tdw [a] [#]    dump # words at address a");
            this.println("\tdd [a] [#]    dump # dwords at address a");
            this.println("\tdh [n] [#]    dump # instructions from history n");
            this.println("\tdi [#]        dump descriptor info for IDT #");
            this.println("\tds [#]        dump descriptor info for selector #");
            if (BACKTRACK) {
                this.println("\tdt [a]        dump backtrack info for address a");
            }
            this.println("\tdby,dwy,ddy   dump data in binary");
            if (sDumpers.length) this.println("dump extension commands:\n\t" + sDumpers);
            return;
        }

        if (sAddr == "state") {
            let sState = this.cmp.powerOff(true);
            if (!sState) {
                this.println("powerOff() error");
            }
            else if (sLen == "console") {
                /*
                 * Console buffers are notoriously small, and even the following code, which breaks the
                 * data into parts (eg, "d state console 1", "d state console 2", etc) just isn't that helpful.
                 *
                 *      let nPart = +sBytes;
                 *      if (nPart) sState = sState.substr(1000000 * (nPart-1), 1000000);
                 *
                 * So, the best way to capture a large machine state is to use the new "Save Machine" link
                 * that downloads a machine's entire state.  Alternatively, run your own local server and use
                 * server-side storage.  Take a look at the "Save" binding in computer.js, which binds an HTML
                 * control to the computer.powerOff() and computer.saveServerState() functions.
                 */
                console.log(sState);
            } else {
                this.doClear();
                this.println(sState);
            }
            return;
        }

        if (sAddr == "symbols") {
            this.dumpSymbols();
            return;
        }

        /*
         * Transform a "ds" command into a "d desc" command (simply as shorthand); ditto for "dg" and "dl",
         * only because that's the syntax that WDEB386 used.  I'm uncertain what WDEB386 would do with an LDT
         * selector passed to "dg" or a GDT selector passed to "dl" (because I'm too lazy to check right now),
         * but that seems nonsensical.
         */
        if (sCmd == "ds" || sCmd == "dg" || sCmd == "dl") {
            sCmd = "d";
            asArgs = [sCmd, "desc", sAddr];
        }

        /*
         * Handle the "dp" (aka "d page") commands here.
         */
        if (sCmd == "d" && sAddr == "page") {
            sCmd = "dp";
            asArgs.shift();
        }
        if (sCmd == "dp") {
            asArgs.shift();
            this.dumpPage(asArgs);
            return;
        }

        if (sCmd == "d") {
            /*
             * Transform a "d disk" command into a "l json" command (TODO: Register a dumper for "disk" instead?)
             */
            if (sAddr == "disk") {
                asArgs[0] = "l";
                asArgs[1] = "json";
                this.doLoad(asArgs);
                return;
            }
            for (m in Messages.CATEGORIES) {
                if (asArgs[1] == m) {
                    let fnDumper = this.afnDumpers[m];
                    if (fnDumper) {
                        asArgs.shift();
                        asArgs.shift();
                        fnDumper(asArgs);
                    } else {
                        this.println("no dump registered for " + sAddr);
                    }
                    return;
                }
            }
            if (!sAddr) sCmd = this.sCmdDumpPrev || "db";
        }

        if (sCmd == "dh") {
            this.dumpHistory(sAddr, sLen, sBytes);
            return;
        }

        if (sCmd == "di") {
            asArgs.shift();
            this.dumpIDT(asArgs);
            return;
        }

        if (sCmd == "dt") {
            asArgs.shift();
            let sInfo = this.dumpBackTrack(asArgs);
            this.println(sInfo);
            return;
        }

        if (sCmd[1] && "abwd".indexOf(sCmd[1]) < 0) {
            this.println("unrecognized dump command");
            return;
        }

        this.sCmdDumpPrev = sCmd;

        let dbgAddr = this.parseAddr(sAddr);
        if (!dbgAddr || dbgAddr.sel == null && dbgAddr.addr == null) return;

        let len = 0;
        if (sLen) {
            if (sLen.charAt(0) == 'l') {
                sLen = sLen.substr(1) || sBytes;
                len = this.parseValue(sLen);
            } else {
                let dbgAddrEnd = this.parseAddr(sLen);
                if (!dbgAddrEnd) return;
                /*
                 * To be more DEBUG-like, when an ending address is used instead of a length, we treat it inclusively, hence the "+ 1".
                 */
                if (dbgAddr.type != DebuggerX86.ADDRTYPE.LINEAR) {
                    len = dbgAddrEnd.off - dbgAddr.off + 1;
                } else {
                    len = dbgAddrEnd.addr - dbgAddr.addr + 1;
                }
            }
            if (len < 0 || len > 0x10000) len = 0;
        }

        let sDump = "", fASCII = false, cchBinary = 0;
        let size = (sCmd[1] == 'd'? 4 : (sCmd[1] == 'w'? 2 : 1));
        let cb = (size * len) || 128;
        let cLines = ((cb + 15) >> 4) || 1;
        let cbLine = (size == 4? 16 : this.nBase);  // the base also happens to be a reasonable number of bytes/line

        /*
         * The "da" variation uses a line size of 160 bytes, because that's the number of characters
         * per line in a text frame buffer; if no ending address or length is specified, the number of
         * lines defaults to 25 (the typical number of visible lines in a frame buffer).
         *
         * Beyond that, the command doesn't make any other assumptions about the memory format.  Video
         * frame buffers usually dump nicely because all the attribute bytes tend to be non-ASCII.
         */
        if (sCmd[1] == 'a') {
            fASCII = true;
            cbLine = 160;
            cLines = (len <= 1? 25 : Math.ceil(len / cbLine));
            cb = cLines * cbLine;
        }
        else if (sCmd[2] == 'y') {
            cbLine = size;
            if (!len) cb = 8;
            cLines = cb;
            cchBinary = size * 8;
        }

        while (cLines-- && cb > 0) {
            let data = 0, iByte = 0, i;
            let sData = "", sChars = "";
            sAddr = this.toHexAddr(dbgAddr);
            for (i = cbLine; i > 0 && cb > 0; i--) {
                let b = this.getByte(dbgAddr, 1);
                data |= (b << (iByte++ << 3));
                if (iByte == size) {
                    sData += (this.nBase == 8? Str.toOct(data, size * 3) : Str.toHex(data, size * 2));
                    sData += (size == 1? (i == 9? '-' : ' ') : "  ");
                    if (cchBinary) sChars += Str.toBin(data, cchBinary);
                    data = iByte = 0;
                }
                if (!cchBinary) sChars += (b >= 32 && b < 127? String.fromCharCode(b) : (fASCII? '' : '.'));
                cb--;
            }
            if (sDump) sDump += '\n';
            if (fASCII) {
                sDump += sChars;
            } else {
                sDump += sAddr + "  " + sData + Str.pad(sChars, sChars.length + i * 3 + 1, true);
            }
        }
        if (sDump) this.println(sDump.replace(/\s*$/, ""));
        this.dbgAddrNextData = dbgAddr;
    }

    /**
     * doEdit(asArgs)
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    doEdit(asArgs)
    {
        let size = 1;
        let mask = 0xff;
        let fnGet = this.getByte;
        let fnSet = this.setByte;
        if (asArgs[0] == "ew") {
            size = 2;
            mask = 0xffff;
            fnGet = this.getShort;
            fnSet = this.setShort;
        }
        let cch = size << 1;

        let sAddr = asArgs[1];
        if (sAddr == null) {
            this.println("edit memory commands:");
            this.println("\teb [a] [...]  edit bytes at address a");
            this.println("\tew [a] [...]  edit words at address a");
            return;
        }

        let dbgAddr = this.parseAddr(sAddr);
        if (!dbgAddr) return;

        let fASCII = false;
        for (let i = 2; i < asArgs.length; i++) {
            let sArg = asArgs[i];
            /*
             * Now that all debugger commands go through parseCommand(), we can accept interesting commands like this:
             *
             *      ew b800:0 "Happy Birthday"
             *
             * and the quoted string will arrive as a single argument.  We now parse such a string into a series of byte
             * values, and additionally, if you're using "ew" instead of "eb", only the low byte of every word will be
             * updated.  This is what we call ASCII replacement mode (fASCII is true), which ends as soon as we encounter
             * the empty string that we add to the end of the series.
             */
            if (sArg[0] == '"' || sArg[0] == "'") {
                let asNum = [];
                for (let j = 1; j < sArg.length; j++) {
                    let ch = sArg[j];
                    if (ch == sArg[0]) break;
                    asNum.push(Str.toHexByte(ch.charCodeAt(0)));
                }
                asNum.push("");
                asArgs.splice(i, 1, ...asNum);
                sArg = asArgs[i];
                fASCII = true;
            }
            if (!sArg) {
                fASCII = false;
                continue;
            }
            let vNew = this.parseExpression(sArg);
            if (vNew === undefined) {
                this.println("unrecognized value: " + sArg);
                break;
            }
            if (vNew & ~mask) {
                this.println("warning: " + Str.toHex(vNew) + " exceeds " + size + "-byte value");
            }
            let vOld = fnGet.call(this, dbgAddr);
            if (fASCII) vNew = (vOld & ~0xff) | (vNew & 0x7f);
            this.println("changing " + this.toHexAddr(dbgAddr) + " from " + Str.toHex(vOld, cch, true) + " to " + Str.toHex(vNew, cch, true));
            fnSet.call(this, dbgAddr, vNew, size);
        }
    }

    /**
     * doFreqs(sParm)
     *
     * @this {DebuggerX86}
     * @param {string|undefined} sParm
     */
    doFreqs(sParm)
    {
        if (sParm == '?') {
            this.println("frequency commands:");
            this.println("\tclear\tclear all frequency counts");
            return;
        }
        let i;
        let cData = 0;
        if (this.aaOpcodeCounts) {
            if (sParm == "clear") {
                for (i = 0; i < this.aaOpcodeCounts.length; i++)
                    this.aaOpcodeCounts[i] = [i, 0];
                this.println("frequency data cleared");
                cData++;
            }
            else if (sParm !== undefined) {
                this.println("unknown frequency command: " + sParm);
                cData++;
            }
            else {
                let aaSortedOpcodeCounts = this.aaOpcodeCounts.slice();
                aaSortedOpcodeCounts.sort(function(p, q) {
                    return q[1] - p[1];
                });
                for (i = 0; i < aaSortedOpcodeCounts.length; i++) {
                    let bOpcode = aaSortedOpcodeCounts[i][0];
                    let cFreq = aaSortedOpcodeCounts[i][1];
                    if (cFreq) {
                        this.println((DebuggerX86.INS_NAMES[this.aaOpDescs[bOpcode][0]] + "  ").substr(0, 5) + " (" + Str.toHexByte(bOpcode) + "): " + cFreq + " times");
                        cData++;
                    }
                }
            }
        }
        if (!cData) {
            this.println("no frequency data available");
        }
    }

    /**
     * doHalt(fQuiet)
     *
     * @this {DebuggerX86}
     * @param {boolean} [fQuiet]
     */
    doHalt(fQuiet)
    {
        if (!this.stopCPU()) {
            if (this.isBusy(true)) return;
            if (!fQuiet) this.println("already halted");
        }
    }

    /**
     * doIf(sCmd, fQuiet)
     *
     * NOTE: Don't forget that the default base for all numeric constants is 16 (hex), so when you evaluate
     * an expression like "a==10", it will compare the value of the variable "a" to 0x10; use a trailing period
     * (eg, "10.") if you really intend decimal.
     *
     * Also, if no variable named "a" exists, "a" will evaluate to 0x0A, so the expression "a==10" becomes
     * "0x0A==0x10" (false), whereas the expression "a==10." becomes "0x0A==0x0A" (true).
     *
     * @this {DebuggerX86}
     * @param {string} sCmd
     * @param {boolean} [fQuiet]
     * @return {boolean} true if expression is non-zero, false if zero (or undefined due to a parse error)
     */
    doIf(sCmd, fQuiet)
    {
        sCmd = Str.trim(sCmd);
        if (!this.parseExpression(sCmd)) {
            if (!fQuiet) this.println("false: " + sCmd);
            return false;
        }
        if (!fQuiet) this.println("true: " + sCmd);
        return true;
    }

    /**
     * doInfo(asArgs)
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     * @return {boolean} true only if the instruction info command ("n") is supported
     */
    doInfo(asArgs)
    {
        if (DEBUG) {
            this.println("msPerYield: " + this.cpu.counts.msPerYield);
            this.println("nCyclesPerYield: " + this.cpu.counts.nCyclesPerYield);
            return true;
        }
        return false;
    }

    /**
     * doInput(sPort)
     *
     * Simulate a 1-byte port input operation.
     *
     * @this {DebuggerX86}
     * @param {string|undefined} sPort
     */
    doInput(sPort)
    {
        if (!sPort || sPort == '?') {
            this.println("input commands:");
            this.println("\ti [p]\tread port [p]");
            /*
             * TODO: Regarding this warning, consider adding an "unchecked" version of
             * bus.checkPortInputNotify(), since all Debugger memory accesses are unchecked, too.
             *
             * All port I/O handlers ARE aware when the Debugger is calling (addrFrom is undefined),
             * but changing them all to be non-destructive would take time, and situations where you
             * actually want to affect the hardware state are just as likely as not....
             */
            this.println("warning: port accesses can affect hardware state");
            return;
        }
        let port = this.parseValue(sPort);
        if (port !== undefined) {
            let bIn = this.bus.checkPortInputNotify(port, 1);
            this.println(Str.toHexWord(port) + ": " + Str.toHexByte(bIn));
        }
    }

    /**
     * doInt(sInt)
     *
     * Displays information about the given software interrupt (assuming that said interrupt is in progress).
     *
     * These messages also reset the system variable $ops (by updating cOpcodesStart), to make it easier to see
     * how many opcodes were executed since these interrupts "started".
     *
     * @this {DebuggerX86}
     * @param {string|undefined} sInt
     * @return {boolean} true if successful, false if not
     */
    doInt(sInt)
    {
        switch(this.parseValue(sInt)) {
        case 0x13:
            this.messageInt(Interrupts.DISK, this.cpu.regLIP, true);
            this.cOpcodesStart = this.cOpcodes;
            return true;
        case 0x21:
            this.messageInt(Interrupts.DOS, this.cpu.regLIP, true);
            this.cOpcodesStart = this.cOpcodes;
            return true;
        default:
            return false;
        }
    }

    /**
     * doVar(sCmd)
     *
     * The command must be of the form "{variable} = [{expression}]", where expression may contain constants,
     * operators, registers, symbols, other variables, or nothing at all; in the latter case, the variable, if
     * any, is deleted.
     *
     * Other supported shorthand: "var" with no parameters prints the values of all variables, and "let {variable}"
     * prints the value of the specified variable.
     *
     * @this {DebuggerX86}
     * @param {string} sCmd
     * @return {boolean} true if valid "var" assignment, false if not
     */
    doVar(sCmd)
    {
        let a = sCmd.match(/^\s*([A-Z_]?[A-Z0-9_]*)\s*(=?)\s*(.*)$/i);
        if (a) {
            if (!a[1]) {
                if (!this.printVariable()) this.println("no variables");
                return true;    // it's not considered an error to print an empty list of variables
            }
            if (!a[2]) {
                return this.printVariable(a[1]);
            }
            if (!a[3]) {
                this.delVariable(a[1]);
                return true;    // it's not considered an error to delete a variable that didn't exist
            }
            let v = this.parseExpression(a[3]);
            if (v !== undefined) {
                this.setVariable(a[1], v);
                return true;
            }
            return false;
        }
        this.println("invalid assignment:" + sCmd);
        return false;
    }

    /**
     * doList(sAddr, fPrint)
     *
     * @this {DebuggerX86}
     * @param {string} sAddr
     * @param {boolean} [fPrint]
     * @return {string|null}
     */
    doList(sAddr, fPrint)
    {
        let sSymbol = null;

        let dbgAddr = this.parseAddr(sAddr, true);
        if (dbgAddr) {

            let addr = this.getAddr(dbgAddr);
            if (MAXDEBUG && fPrint) {
                this.println(this.toHexAddr(dbgAddr) + " (%" + Str.toHex(addr, this.cchAddr) + ')');
            }

            let aSymbol = this.findSymbol(dbgAddr, true);
            if (aSymbol.length) {
                let nDelta, sDelta, s;
                if (aSymbol[0]) {
                    sDelta = "";
                    nDelta = dbgAddr.off - aSymbol[1];
                    if (nDelta) sDelta = " + " + Str.toHex(nDelta, 0, true);
                    s = aSymbol[0] + " (" + this.toHexOffset(aSymbol[1], dbgAddr.sel) + ')' + sDelta;
                    if (fPrint) this.println(s);
                    sSymbol = s;
                }
                if (aSymbol.length > 4 && aSymbol[4]) {
                    sDelta = "";
                    nDelta = aSymbol[5] - dbgAddr.off;
                    if (nDelta) sDelta = " - " + Str.toHex(nDelta, 0, true);
                    s = aSymbol[4] + " (" + this.toHexOffset(aSymbol[5], dbgAddr.sel) + ')' + sDelta;
                    if (fPrint) this.println(s);
                    if (!sSymbol) sSymbol = s;
                }
            } else {
                if (fPrint) this.println("no symbols");
            }
        }
        return sSymbol;
    }

    /**
     * doLoad(asArgs)
     *
     * The format of this command mirrors the DOS DEBUG "L" command:
     *
     *      l [address] [drive #] [sector #] [# sectors]
     *
     * The only optional parameter is the last, which defaults to 1 sector if not specified.
     *
     * As a quick-and-dirty way of getting the current contents of a disk image as a JSON dump
     * (which you can then save as .json disk image file), I also support this command:
     *
     *      l json [drive #]
     *
     * which is aliased to this command:
     *
     *      d disk [drive #]
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    doLoad(asArgs)
    {
        if (!asArgs[1] || asArgs[1] == '?') {
            this.println("load commands:");
            this.println("\tl [address] [drive #] [sector #] [# sectors]");
            return;
        }

        let fJSON = (asArgs[1] == "json");
        let iDrive, iSector = 0, nSectors = 0;

        let dbgAddr = (fJSON? {} : this.parseAddr(asArgs[1]));
        if (!dbgAddr) return;

        iDrive = this.parseValue(asArgs[2], "drive #");
        if (iDrive === undefined) return;
        if (!fJSON) {
            iSector = this.parseValue(asArgs[3], "sector #");
            if (iSector === undefined) return;
            nSectors = this.parseValue(asArgs[4], "# of sectors");
            if (nSectors === undefined) nSectors = 1;
        }

        /*
         * We choose the disk controller very simplistically: FDC for drives 0 or 1, and HDC for drives 2
         * and up, unless no HDC is present, in which case we assume FDC for all drive numbers.
         *
         * Both controllers must obviously support the same interfaces; ie, copyDrive(), seekDrive(),
         * and readData().  We also rely on the disk property to determine whether the drive is "loaded".
         *
         * In the case of the HDC, if the drive is valid, then by definition it is also "loaded", since an HDC
         * drive and its disk are inseparable; it's certainly possible that the disk object may be empty at
         * this point (ie, if the disk is uninitialized and unformatted), but that will only affect whether the
         * read succeeds or not.
         */
        let dc = this.fdc;
        if (iDrive >= 2 && this.hdc) {
            iDrive -= 2;
            dc = this.hdc;
        }
        if (dc) {
            let drive = dc.copyDrive(iDrive);
            if (drive) {
                if (drive.disk) {
                    if (fJSON) {
                        /*
                         * This is an interim solution to dumping disk images in JSON.  It has many problems, the
                         * "biggest" being that the large disk images really need to be compressed first, because they
                         * get "inflated" with use.  See the dump() method in the Disk component for more details.
                         */
                        this.doClear();
                        this.println(drive.disk.convertToJSON());
                        return;
                    }
                    if (dc.seekDrive(drive, iSector, nSectors)) {
                        let cb = 0;
                        let fAbort = false;
                        let sAddr = this.toHexAddr(dbgAddr);
                        while (!fAbort && drive.nBytes-- > 0) {
                            (function(dbg, dbgAddrCur) {
                                dc.readData(drive, function(b, fAsync) {
                                    if (b < 0) {
                                        dbg.println("out of data at address " + dbg.toHexAddr(dbgAddrCur));
                                        fAbort = true;
                                        return;
                                    }
                                    dbg.setByte(dbgAddrCur, b, 1, true);
                                    cb++;
                                });
                            }(this, dbgAddr));
                        }
                        /*
                         * Call updateCPU() now, since we forced setByte() to defer all updates
                         */
                        this.cpu.updateCPU(true);
                        this.println(cb + " bytes read at " + sAddr);
                    } else {
                        this.println("sector " + iSector + " request out of range");
                    }
                } else {
                    this.println("drive " + iDrive + " not loaded");
                }
            } else {
                this.println("invalid drive: " + iDrive);
            }
        } else {
            this.println("disk controller not present");
        }
    }

    /**
     * doMessages(asArgs)
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    doMessages(asArgs)
    {
        let m;
        let fCriteria = null;
        let sCategory = asArgs[1];
        if (sCategory == '?') sCategory = undefined;

        if (sCategory !== undefined) {
            let bitsMessage = 0;
            if (sCategory == "all") {
                bitsMessage = (0xffffffff|0) & ~(Messages.HALT | Messages.BUFFER);
                sCategory = null;
            } else if (sCategory == "on") {
                fCriteria = true;
                sCategory = null;
            } else if (sCategory == "off") {
                fCriteria = false;
                sCategory = null;
            } else {
                for (m in Messages.CATEGORIES) {
                    if (sCategory == m) {
                        bitsMessage = Messages.CATEGORIES[m];
                        fCriteria = ((this.bitsMessage & bitsMessage) === bitsMessage);
                        break;
                    }
                }
                if (!bitsMessage) {
                    this.println("unknown message category: " + sCategory);
                    return;
                }
            }
            if (bitsMessage) {
                if (asArgs[2] == "on") {
                    this.bitsMessage |= bitsMessage;
                    fCriteria = true;
                }
                else if (asArgs[2] == "off") {
                    this.bitsMessage &= ~bitsMessage;
                    if (!(this.bitsMessage & 0xF0000000) && bitsMessage) {
                        this.bitsMessage = 0;   // if all the high (shared) bits were turned off, ensure all the low bits are off as well.
                    }
                    fCriteria = false;
                    if (bitsMessage == Messages.BUFFER) {
                        this.println(this.aMessageBuffer.join('\n'));
                        this.aMessageBuffer = [];
                    }
                }
            }
        }

        /*
         * Display those message categories that match the current criteria (on or off)
         */
        let n = 0;
        let sCategories = "";
        for (m in Messages.CATEGORIES) {
            if (!sCategory || sCategory == m) {
                let bitsMessage = Messages.CATEGORIES[m];
                let fEnabled = ((this.bitsMessage & bitsMessage) === bitsMessage);
                if (fCriteria !== null && fCriteria != fEnabled) continue;
                if (sCategories) sCategories += ',';
                if (!(++n % 10)) sCategories += "\n\t";     // jshint ignore:line
                sCategories += m;
            }
        }

        if (sCategory === undefined) {
            this.println("message commands:\n\tm [category] [on|off]\tturn categories on/off");
        }

        this.println((fCriteria !== null? (fCriteria? "messages on:  " : "messages off: ") : "message categories:\n\t") + (sCategories || "none"));

        this.historyInit();     // call this just in case Messages.INT was turned on
    }

    /**
     * doMouse(sAction, sDelta)
     *
     * When using the "click" action, specify 0 for Mouse.BUTTON.LEFT or 2 for Mouse.BUTTON.RIGHT.
     *
     * @this {DebuggerX86}
     * @param {string} sAction
     * @param {string} sDelta
     */
    doMouse(sAction, sDelta)
    {
        if (this.mouse) {
            let n = 0, sign = 1;
            if (sDelta) {
                if (sDelta.charAt(0) == '-') {
                    sign = -1;
                    sDelta = sDelta.substr(1);
                }
                n = this.parseValue(sDelta, sAction);
                if (n === undefined) return;
                n = (n * sign)|0;
            }
            switch(sAction) {
            case "x":
                this.mouse.moveMouse(n, 0);
                break;
            case "y":
                this.mouse.moveMouse(0, n);
                break;
            case "click":
                this.mouse.clickMouse(n, true);
                this.mouse.clickMouse(n, false);
                break;
            default:
                this.println("unknown action: " + sAction);
                break;
            }
            return;
        }
        this.println("no mouse");
    }

    /**
     * doExecOptions(asArgs)
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} asArgs
     */
    doExecOptions(asArgs)
    {
        if (!asArgs[1] || asArgs[1] == '?') {
            this.println("execution options:");
            this.println("\tcs int #\tset checksum cycle interval to #");
            this.println("\tcs start #\tset checksum cycle start count to #");
            this.println("\tcs stop #\tset checksum cycle stop count to #");
            this.println("\tsp #\t\tset speed multiplier to #");
            return;
        }
        switch (asArgs[1]) {
        case "cs":
            let nCycles;
            if (asArgs[3] !== undefined) nCycles = +asArgs[3];          // warning: decimal instead of hex conversion
            switch (asArgs[2]) {
                case "int":
                    this.cpu.counts.nCyclesChecksumInterval = nCycles;
                    break;
                case "start":
                    this.cpu.counts.nCyclesChecksumStart = nCycles;
                    break;
                case "stop":
                    this.cpu.counts.nCyclesChecksumStop = nCycles;
                    break;
                default:
                    this.println("unknown cs option");
                    return;
            }
            if (nCycles !== undefined) {
                this.cpu.resetChecksum();
            }
            this.println("checksums " + (this.cpu.flags.checksum? "enabled" : "disabled"));
            break;
        case "sp":
            if (asArgs[2] !== undefined) {
                if (!this.cpu.setSpeed(+asArgs[2])) {
                    this.println("warning: using 1x multiplier, previous target not reached");
                }
            }
            this.println("target speed: " + this.cpu.getSpeedTarget() + " (" + this.cpu.getSpeed() + "x)");
            break;
        default:
            this.println("unknown option: " + asArgs[1]);
            break;
        }
    }

    /**
     * doOutput(sPort, sByte)
     *
     * Simulate a 1-byte port output operation.
     *
     * @this {DebuggerX86}
     * @param {string|undefined} sPort
     * @param {string|undefined} sByte (string representation of 1 byte)
     */
    doOutput(sPort, sByte)
    {
        if (!sPort || sPort == '?') {
            this.println("output commands:");
            this.println("\to [p] [b]\twrite byte [b] to port [p]");
            /*
             * TODO: Regarding this warning, consider adding an "unchecked" version of
             * bus.checkPortOutputNotify(), since all Debugger memory accesses are unchecked, too.
             *
             * All port I/O handlers ARE aware when the Debugger is calling (addrFrom is undefined),
             * but changing them all to be non-destructive would take time, and situations where you
             * actually want to affect the hardware state are just as likely as not....
             */
            this.println("warning: port accesses can affect hardware state");
            return;
        }
        let port = this.parseValue(sPort, "port #");
        let bOut = this.parseValue(sByte);
        if (port !== undefined && bOut !== undefined) {
            this.bus.checkPortOutputNotify(port, 1, bOut);
            this.println(Str.toHexWord(port) + ": " + Str.toHexByte(bOut));
        }
    }

    /**
     * doRegisters(asArgs, fInstruction)
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} [asArgs]
     * @param {boolean} [fInstruction] (true to include the current instruction; default is true)
     */
    doRegisters(asArgs, fInstruction)
    {
        if (asArgs && asArgs[1] == '?') {
            this.println("register commands:");
            this.println("\tr\tdump registers");
            if (this.fpu) this.println("\trfp\tdump floating-point registers");
            this.println("\trp\tdump all registers");
            this.println("\trx [#]\tset flag or register x to [#]");
            return;
        }

        let fProt;
        if (fInstruction == null) fInstruction = true;

        if (asArgs != null && asArgs.length > 1) {
            let sReg = asArgs[1];
            if (this.fpu && sReg == "fp") {
                this.doFPURegisters(asArgs);
                return;
            }
            if (sReg == 'p') {
                fProt = (this.cpu.model >= X86.MODEL_80286);
            }
            else {
             // fInstruction = false;
                let sValue = null;
                let i = sReg.indexOf('=');
                if (i > 0) {
                    sValue = sReg.substr(i + 1);
                    sReg = sReg.substr(0, i);
                }
                else if (asArgs.length > 2) {
                    sValue = asArgs[2];
                }
                else {
                    this.println("missing value for " + asArgs[1]);
                    return;
                }

                let w = this.parseExpression(sValue);
                if (w === undefined) return;

                let fValid = true;
                let sRegMatch = sReg.toUpperCase();
                if (sRegMatch.charAt(0) == 'E' && this.cchReg <= 4) {
                    sRegMatch = null;
                }
                switch (sRegMatch) {
                case "AL":
                    this.cpu.regEAX = (this.cpu.regEAX & ~0xff) | (w & 0xff);
                    break;
                case "AH":
                    this.cpu.regEAX = (this.cpu.regEAX & ~0xff00) | ((w << 8) & 0xff);
                    break;
                case "AX":
                    this.cpu.regEAX = (this.cpu.regEAX & ~0xffff) | (w & 0xffff);
                    break;
                case "BL":
                    this.cpu.regEBX = (this.cpu.regEBX & ~0xff) | (w & 0xff);
                    break;
                case "BH":
                    this.cpu.regEBX = (this.cpu.regEBX & ~0xff00) | ((w << 8) & 0xff);
                    break;
                case "BX":
                    this.cpu.regEBX = (this.cpu.regEBX & ~0xffff) | (w & 0xffff);
                    break;
                case "CL":
                    this.cpu.regECX = (this.cpu.regECX & ~0xff) | (w & 0xff);
                    break;
                case "CH":
                    this.cpu.regECX = (this.cpu.regECX & ~0xff00) | ((w << 8) & 0xff);
                    break;
                case "CX":
                    this.cpu.regECX = (this.cpu.regECX & ~0xffff) | (w & 0xffff);
                    break;
                case "DL":
                    this.cpu.regEDX = (this.cpu.regEDX & ~0xff) | (w & 0xff);
                    break;
                case "DH":
                    this.cpu.regEDX = (this.cpu.regEDX & ~0xff00) | ((w << 8) & 0xff);
                    break;
                case "DX":
                    this.cpu.regEDX = (this.cpu.regEDX & ~0xffff) | (w & 0xffff);
                    break;
                case "SP":
                    this.cpu.setSP((this.cpu.getSP() & ~0xffff) | (w & 0xffff));
                    break;
                case "BP":
                    this.cpu.regEBP = (this.cpu.regEBP & ~0xffff) | (w & 0xffff);
                    break;
                case "SI":
                    this.cpu.regESI = (this.cpu.regESI & ~0xffff) | (w & 0xffff);
                    break;
                case "DI":
                    this.cpu.regEDI = (this.cpu.regEDI & ~0xffff) | (w & 0xffff);
                    break;
                /*
                 * DANGER: For any of the segment loads below, by going through the normal CPU
                 * segment load procedure, you run the risk of generating a fault in the machine
                 * if you're not careful.  So, um, be careful.
                 */
                case "DS":
                    this.cpu.setDS(w);
                    break;
                case "ES":
                    this.cpu.setES(w);
                    break;
                case "SS":
                    this.cpu.setSS(w);
                    break;
                case "CS":
                 // fInstruction = true;
                    this.cpu.setCS(w);
                    this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
                    break;
                case "IP":
                case "EIP":
                 // fInstruction = true;
                    this.cpu.setIP(w);
                    this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
                    break;
                /*
                 * I used to alias "PC" (Program Counter) to "IP" (Instruction Pointer), because in PC-DOS 1.00
                 * through 2.10, DEBUG.COM did the same thing.  Then I discovered that, starting with PC-DOS 3.00,
                 * DEBUG.COM changed "PC" to refer to the 16-bit flags register (Program or Processor Control?)
                 * I've elected to go for PC-DOS 3.00+ compatibility, since that will be more widely known.
                 *
                 * PCx86 prefers "PS" (Processor Status) for accessing the FLAGS register in its 16-bit (or 32-bit)
                 * entirety.  Individual flag bits can also be accessed as 1-bit registers, using the names shown
                 * below ("C", "P", "A", "Z", etc.)
                 */
                case "PC":
                case "PS":
                    this.cpu.setPS(w);
                    break;
                case 'C':
                    if (w) this.cpu.setCF(); else this.cpu.clearCF();
                    break;
                case 'P':
                    if (w) this.cpu.setPF(); else this.cpu.clearPF();
                    break;
                case 'A':
                    if (w) this.cpu.setAF(); else this.cpu.clearAF();
                    break;
                case 'Z':
                    if (w) this.cpu.setZF(); else this.cpu.clearZF();
                    break;
                case 'S':
                    if (w) this.cpu.setSF(); else this.cpu.clearSF();
                    break;
                case 'I':
                    if (w) this.cpu.setIF(); else this.cpu.clearIF();
                    break;
                case 'D':
                    if (w) this.cpu.setDF(); else this.cpu.clearDF();
                    break;
                case 'V':
                    if (w) this.cpu.setOF(); else this.cpu.clearOF();
                    break;
                default:
                    let fUnknown = true;
                    if (this.cpu.model >= X86.MODEL_80286) {
                        fUnknown = false;
                        switch(sRegMatch){
                        case "MS":
                            this.cpu.setMSW(w);
                            break;
                        case "TR":
                            /*
                             * DANGER: Like any of the segment loads above, by going through the normal CPU
                             * segment load procedure, you run the risk of generating a fault in the machine
                             * if you're not careful.  So, um, be careful.
                             */
                            if (this.cpu.segTSS.load(w) === X86.ADDR_INVALID) {
                                fValid = false;
                            }
                            break;
                        /*
                         * TODO: Add support for GDTR (addr and limit), IDTR (addr and limit), and perhaps
                         * even the ability to edit descriptor information associated with each segment register.
                         */
                        default:
                            fUnknown = true;
                            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                                fUnknown = false;
                                switch(sRegMatch){
                                case "EAX":
                                    this.cpu.regEAX = w;
                                    break;
                                case "EBX":
                                    this.cpu.regEBX = w;
                                    break;
                                case "ECX":
                                    this.cpu.regECX = w;
                                    break;
                                case "EDX":
                                    this.cpu.regEDX = w;
                                    break;
                                case "ESP":
                                    this.cpu.setSP(w);
                                    break;
                                case "EBP":
                                    this.cpu.regEBP = w;
                                    break;
                                case "ESI":
                                    this.cpu.regESI = w;
                                    break;
                                case "EDI":
                                    this.cpu.regEDI = w;
                                    break;
                                /*
                                 * DANGER: For any of the segment loads below, by going through the normal CPU
                                 * segment load procedure, you run the risk of generating a fault in the machine
                                 * if you're not careful.  So, um, be careful.
                                 */
                                case "FS":
                                    this.cpu.setFS(w);
                                    break;
                                case "GS":
                                    this.cpu.setGS(w);
                                    break;
                                case "CR0":
                                    this.cpu.regCR0 = w;
                                    X86.helpLoadCR0.call(this.cpu, w);
                                    break;
                                case "CR2":
                                    this.cpu.regCR2 = w;
                                    break;
                                case "CR3":
                                    this.cpu.regCR3 = w;
                                    X86.helpLoadCR3.call(this.cpu, w);
                                    break;
                                /*
                                 * TODO: Add support for DR0-DR7 and TR6-TR7.
                                 */
                                default:
                                    fUnknown = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    if (fUnknown) {
                        this.println("unknown register: " + sReg);
                        return;
                    }
                }
                if (!fValid) {
                    this.println("invalid value: " + sValue);
                    return;
                }
                this.cpu.updateCPU();
                this.println("updated registers:");
            }
        }

        this.println(this.getRegDump(fProt));

        if (fInstruction) {
            this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
            this.doUnassemble(this.toHexAddr(this.dbgAddrNextCode));
        }
    }

    /**
     * doFPURegisters(asArgs)
     *
     * NOTE: If we're called, the existence of an FPU has already been verified.
     *
     * @this {DebuggerX86}
     * @param {Array.<string>} [asArgs]
     */
    doFPURegisters(asArgs)
    {
        let fpu = this.fpu;

        let wStatus = fpu.getStatus(), wControl = fpu.getControl();
        for (let i = 0; i < 8; i++) {
            let a = fpu.readFPUStack(i);
            if (!a) break;
            let sValue = Str.pad(a[2].toFixed(15), 24, true);
            this.println("ST" + i + ": " + sValue + "  " + Str.toHex(a[4]) + "," + Str.toHex(a[3]) + "  [" + a[0] + ":" + DebuggerX86.FPU_TAGS[a[1]] + "]");
            // this.println("  REG" + a[0] + " " + Str.toBin(a[7], 16) + Str.toBin(a[6]) + Str.toBin(a[5]));
        }
        this.println("    B3SSS210ESPUOZDI               xxxIRRPPIxPUOZDI");
        this.println("SW: " + Str.toBin(wStatus, 16) + " (" + Str.toHexWord(wStatus) + ")  CW: " + Str.toBin(wControl, 16) + " (" + Str.toHexWord(wControl) + ")");
    }

    /**
     * doRun(sCmd, sAddr, sOptions, fQuiet)
     *
     * @this {DebuggerX86}
     * @param {string} sCmd
     * @param {string|undefined} [sAddr]
     * @param {string} [sOptions] (the rest of the breakpoint command-line)
     * @param {boolean} [fQuiet]
     */
    doRun(sCmd, sAddr, sOptions, fQuiet)
    {
        if (sCmd == "gt") {
            this.fIgnoreNextCheckFault = true;
        }
        if (sAddr !== undefined) {
            let dbgAddr = this.parseAddr(sAddr, true);
            if (!dbgAddr) return;
            this.parseAddrOptions(dbgAddr, sOptions);
            this.setTempBreakpoint(dbgAddr);
        }
        this.startCPU(true, fQuiet);
    }

    /**
     * doPrint(sCmd)
     *
     * NOTE: If the string to print is a quoted string, then we run it through replaceRegs(), so that
     * you can take advantage of all the special replacement options used for software interrupt logging.
     *
     * @this {DebuggerX86}
     * @param {string} sCmd
     */
    doPrint(sCmd)
    {
        sCmd = Str.trim(sCmd);
        let a = sCmd.match(/^(['"])(.*?)\1$/);
        if (!a) {
            this.parseExpression(sCmd, false);
        } else {
            this.println(this.replaceRegs(a[2]));
        }
    }

    /**
     * doStep(sCmd)
     *
     * @this {DebuggerX86}
     * @param {string} [sCmd] "p" or "pr"
     */
    doStep(sCmd)
    {
        let fCallStep = true;
        let nRegs = (sCmd == "pr"? 1 : 0);
        /*
         * Set up the value for this.nStep (ie, 1 or 2) depending on whether the user wants
         * a subsequent register dump ("pr") or not ("p").
         */
        let nStep = 1 + nRegs;
        if (!this.nStep) {
            let fPrefix;
            let fRepeat = false;
            let dbgAddr = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
            do {
                fPrefix = false;
                let bOpcode = this.getByte(dbgAddr);
                switch (bOpcode) {
                case X86.OPCODE.ES:
                case X86.OPCODE.CS:
                case X86.OPCODE.SS:
                case X86.OPCODE.DS:
                case X86.OPCODE.FS:     // I386 only
                case X86.OPCODE.GS:     // I386 only
                case X86.OPCODE.OS:     // I386 only
                case X86.OPCODE.AS:     // I386 only
                case X86.OPCODE.LOCK:
                    this.incAddr(dbgAddr, 1);
                    fPrefix = true;
                    break;
                case X86.OPCODE.INT3:
                case X86.OPCODE.INTO:
                    this.nStep = nStep;
                    this.incAddr(dbgAddr, 1);
                    break;
                case X86.OPCODE.INTN:
                case X86.OPCODE.LOOPNZ:
                case X86.OPCODE.LOOPZ:
                case X86.OPCODE.LOOP:
                    this.nStep = nStep;
                    this.incAddr(dbgAddr, dbgAddr.fData32? 4 : 2);
                    break;
                case X86.OPCODE.CALL:
                    if (fCallStep) {
                        this.nStep = nStep;
                        this.incAddr(dbgAddr, dbgAddr.fData32? 5 : 3);
                    }
                    break;
                case X86.OPCODE.CALLF:
                    if (fCallStep) {
                        this.nStep = nStep;
                        this.incAddr(dbgAddr, dbgAddr.fData32? 7 : 5);
                    }
                    break;
                case X86.OPCODE.GRP4W:
                    if (fCallStep) {
                        let w = this.getWord(dbgAddr) & X86.OPCODE.CALLMASK;
                        if (w == X86.OPCODE.CALLW || w == X86.OPCODE.CALLFDW) {
                            this.nStep = nStep;
                            this.getInstruction(dbgAddr);       // advance dbgAddr past this variable-length CALL
                        }
                    }
                    break;
                case X86.OPCODE.REPZ:
                case X86.OPCODE.REPNZ:
                    this.incAddr(dbgAddr, 1);
                    fRepeat = fPrefix = true;
                    break;
                case X86.OPCODE.INSB:
                case X86.OPCODE.INSW:
                case X86.OPCODE.OUTSB:
                case X86.OPCODE.OUTSW:
                case X86.OPCODE.MOVSB:
                case X86.OPCODE.MOVSW:
                case X86.OPCODE.CMPSB:
                case X86.OPCODE.CMPSW:
                case X86.OPCODE.STOSB:
                case X86.OPCODE.STOSW:
                case X86.OPCODE.LODSB:
                case X86.OPCODE.LODSW:
                case X86.OPCODE.SCASB:
                case X86.OPCODE.SCASW:
                    if (fRepeat) {
                        this.nStep = nStep;
                        this.incAddr(dbgAddr, 1);
                    }
                    break;
                default:
                    break;
                }
            } while (fPrefix);

            if (this.nStep) {
                this.setTempBreakpoint(dbgAddr);
                if (!this.startCPU()) {
                    if (this.cmp) this.cmp.updateFocus();
                    this.nStep = 0;
                }
                /*
                 * A successful run will ultimately call stop(), which will in turn call clearTempBreakpoint(),
                 * which will clear nStep, so there's your assurance that nStep will be reset.  Now we may have
                 * stopped for reasons unrelated to the temporary breakpoint, but that's OK.
                 */
            } else {
                this.doTrace(nRegs? "tr" : "t");
            }
        } else {
            this.println("step in progress");
        }
    }

    /**
     * getCall(dbgAddr, fFar)
     *
     * Given a possible return address (typically from the stack), look for a matching CALL (or INT) that
     * immediately precedes that address.
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {boolean} [fFar]
     * @return {string|null} CALL instruction at or near dbgAddr, or null if none
     */
    getCall(dbgAddr, fFar)
    {
        let sCall = null;
        let off = dbgAddr.off;
        let offOrig = off;
        for (let n = 1; n <= 6 && !!off; n++) {
            if (n > 2) {
                dbgAddr.off = off;
                dbgAddr.addr = undefined;
                let s = this.getInstruction(dbgAddr);
                if (s.indexOf("CALL") >= 0 || fFar && s.indexOf("INT") >= 0) {
                    /*
                     * Verify that the length of this CALL (or INT), when added to the address of the CALL (or INT),
                     * matches the original return address.  We do this by getting the string index of the opcode bytes,
                     * subtracting that from the string index of the next space, and dividing that difference by two,
                     * to yield the length of the CALL (or INT) instruction, in bytes.
                     */
                    let i = s.indexOf(' ');
                    let j = s.indexOf(' ', i+1);
                    if (off + (j - i - 1)/2 == offOrig) {
                        sCall = s;
                        break;
                    }
                }
            }
            off--;
        }
        dbgAddr.off = offOrig;
        return sCall;
    }

    /**
     * doStackTrace(sCmd, sAddr)
     *
     * Use "k" for a normal stack trace and "ks" for a stack trace with symbolic info.
     *
     * @this {DebuggerX86}
     * @param {string} [sCmd]
     * @param {string} [sAddr] (not used yet)
     */
    doStackTrace(sCmd, sAddr)
    {
        if (sAddr == '?') {
            this.println("stack trace commands:");
            this.println("\tk\tshow frame addresses");
            this.println("\tks\tshow symbol information");
            return;
        }

        let nFrames = 10, cFrames = 0;
        let selCode = this.cpu.segCS.sel;
        let dbgAddrCall = this.newAddr();
        let dbgAddrStack = this.newAddr(this.cpu.getSP(), this.cpu.getSS());
        this.println("stack trace for " + this.toHexAddr(dbgAddrStack));

        while (cFrames < nFrames) {
            let sCall = null, sCallPrev = null, cTests = 256;
            while ((dbgAddrStack.off >>> 0) < this.cpu.regLSPLimit) {
                dbgAddrCall.off = this.getWord(dbgAddrStack, true);
                /*
                 * Because we're using the auto-increment feature of getWord(), and because that will automatically
                 * wrap the offset around the end of the segment, we must also check the addr property to detect the wrap.
                 */
                if (dbgAddrStack.addr == null || !cTests--) break;
                dbgAddrCall.sel = selCode;
                sCall = this.getCall(dbgAddrCall);
                if (sCall) break;
                dbgAddrCall.sel = this.getWord(dbgAddrStack);
                sCall = this.getCall(dbgAddrCall, true);
                if (sCall) {
                    selCode = this.getWord(dbgAddrStack, true);
                    /*
                     * It's not strictly necessary that we skip over the flags word that's pushed as part of any INT
                     * instruction, but it reduces the risk of misinterpreting it as a return address on the next iteration.
                     */
                    if (sCall.indexOf("INT") > 0) this.getWord(dbgAddrStack, true);
                    break;
                }
            }
            /*
             * The sCallPrev check eliminates duplicate sequential calls, which are usually (but not always)
             * indicative of a false positive, in which case the previous call is probably bogus as well, but
             * at least we won't duplicate that mistake.  Of course, there are always exceptions, recursion
             * being one of them, but it's rare that we're debugging recursive code.
             */
            if (!sCall || sCall == sCallPrev) break;
            let sSymbol = null;
            if (sCmd == "ks") {
                let a = sCall.match(/[0-9A-F]+$/);
                if (a) sSymbol = this.doList(a[0]);
            }
            sCall = Str.pad(sCall, dbgAddrCall.fAddr32? 74 : 62) + ';' + (sSymbol || "stack=" + this.toHexAddr(dbgAddrStack)); // + " return=" + this.toHexAddr(dbgAddrCall));
            this.println(sCall);
            sCallPrev = sCall;
            cFrames++;
        }
        if (!cFrames) this.println("no return addresses found");
    }

    /**
     * doTrace(sCmd, sCount)
     *
     * The "t" and "tr" commands interpret the count as a number of instructions, and since
     * we call the Debugger's stepCPU() for each iteration, a single instruction includes
     * any/all prefixes; the CPU's stepCPU() treats prefixes as discrete operations.  The only
     * difference between "t" and "tr": the former displays only the next instruction, while
     * the latter also displays the (updated) registers.
     *
     * The "tc" command interprets the count as a number of cycles rather than instructions,
     * allowing you to quickly execute large chunks of instructions with a single command; it
     * doesn't display anything until the the chunk has finished.
     *
     * However, generally a more useful command is "bn", which allows you to break after some
     * number of instructions have been executed (as opposed to some number of cycles).
     *
     * @this {DebuggerX86}
     * @param {string} [sCmd] ("t", "tc", or "tr")
     * @param {string} [sCount] # of instructions to step
     */
    doTrace(sCmd, sCount)
    {
        let dbg = this;
        let fRegs = (sCmd != "t");
        let nCount = this.parseValue(sCount, undefined, true) || 1;
        let nCycles = (nCount == 1? 0 : 1);
        if (sCmd == "tc") {
            nCycles = nCount;
            nCount = 1;
        }
        Web.onCountRepeat(
            nCount,
            function onCountStep() {
                return dbg.setBusy(true) && dbg.stepCPU(nCycles, fRegs, false);
            },
            function onCountStepComplete() {
                /*
                 * We explicitly called stepCPU() with fUpdateCPU === false, because repeatedly
                 * calling updateCPU() can be very slow, especially when fDisplayLiveRegs is true,
                 * so once the repeat count has been exhausted, we must perform a final updateCPU().
                 */
                dbg.cpu.updateCPU(true);
                dbg.setBusy(false);
            }
        );
    }

    /**
     * initAddrSize(dbgAddr, fComplete, cOverrides)
     *
     * @this {DebuggerX86}
     * @param {DbgAddrX86} dbgAddr
     * @param {boolean} fComplete
     * @param {number} [cOverrides]
     */
    initAddrSize(dbgAddr, fComplete, cOverrides)
    {
        /*
         * We use dbgAddr.fComplete to record whether or not the caller (ie, getInstruction())
         * processed a complete instruction.
         */
        dbgAddr.fComplete = fComplete;
        /*
         * For proper disassembly of instructions preceded by an OPERAND (0x66) size prefix, we set
         * dbgAddr.fData32 to true whenever the operand size is 32-bit; similarly, for an ADDRESS (0x67)
         * size prefix, we set dbgAddr.fAddr32 to true whenever the address size is 32-bit.
         *
         * Initially (and every time we've processed a complete instruction), both fields must be
         * set to their original value.
         */
        if (fComplete) {
            if (dbgAddr.fData32Orig != null) dbgAddr.fData32 = dbgAddr.fData32Orig;
            if (dbgAddr.fAddr32Orig != null) dbgAddr.fAddr32 = dbgAddr.fAddr32Orig;
            dbgAddr.fData32Orig = dbgAddr.fData32;
            dbgAddr.fAddr32Orig = dbgAddr.fAddr32;
        }
        /*
         * Use cOverrides to record whether we previously processed any OPERAND or ADDRESS overrides.
         */
        dbgAddr.cOverrides = cOverrides || 0;
    }

    /**
     * isStringIns(bOpcode)
     *
     * @this {DebuggerX86}
     * @param {number} bOpcode
     * @return {boolean} true if string instruction, false if not
     */
    isStringIns(bOpcode)
    {
        return (bOpcode >= X86.OPCODE.MOVSB && bOpcode <= X86.OPCODE.CMPSW || bOpcode >= X86.OPCODE.STOSB && bOpcode <= X86.OPCODE.SCASW);
    }

    /**
     * doUnassemble(sAddr, sAddrEnd, n)
     *
     * @this {DebuggerX86}
     * @param {string} [sAddr]
     * @param {string} [sAddrEnd]
     * @param {number} [n]
     */
    doUnassemble(sAddr, sAddrEnd, n)
    {
        let dbgAddr = this.parseAddr(sAddr, true);
        if (!dbgAddr) return;

        if (n === undefined) n = 1;

        let cb = 0x100;
        if (sAddrEnd !== undefined) {

            let dbgAddrEnd = this.parseAddr(sAddrEnd, true);
            if (!dbgAddrEnd || dbgAddrEnd.off < dbgAddr.off) return;

            /*
             * We now +1 the count to make the ending address inclusive (just like the dump command).
             */
            cb = dbgAddrEnd.off - dbgAddr.off + 1;
            if (cb < 0) cb = 1;
            /*
             * Limiting the amount of disassembled code to 4K helps prevent the user from wedging the browser.
             */
            if (cb > 0x1000) cb = 0x1000;
            n = -1;
        }

        let cLines = 0;
        let sInstruction;
        this.initAddrSize(dbgAddr, true);

        while (cb > 0 && n--) {

            let nSequence = (this.isBusy(false) || this.nStep)? this.nCycles : -1;
            let sComment = (nSequence >= 0? "cycles" : "");
            let aSymbol = this.findSymbol(dbgAddr);

            let addr = dbgAddr.addr;    // we snap dbgAddr.addr *after* calling findSymbol(), which re-evaluates it

            if (aSymbol[0] && n) {
                if (!cLines && n || aSymbol[0].indexOf('+') < 0) {
                    let sLabel = aSymbol[0] + ':';
                    if (aSymbol[2]) sLabel += ' ' + aSymbol[2];
                    this.println(sLabel);
                }
            }

            if (aSymbol[3]) {
                sComment = aSymbol[3];
                nSequence = -1;
            }

            sInstruction = this.getInstruction(dbgAddr, sComment, nSequence);

            /*
             * If getInstruction() reported that it did not process a complete instruction (via dbgAddr.fComplete),
             * then bump the instruction count by one, so that we display one more line (and hopefully the complete
             * instruction).
             */
            if (!dbgAddr.fComplete && !n) n++;

            this.println(sInstruction);
            this.dbgAddrNextCode = dbgAddr;
            cb -= dbgAddr.addr - addr;
            cLines++;
        }
    }

    /**
     * parseCommand(sCmd, fSave, chSep)
     *
     * @this {DebuggerX86}
     * @param {string|undefined} sCmd
     * @param {boolean} [fSave] is true to save the command, false if not
     * @param {string} [chSep] is the command separator character (default is ';')
     * @return {Array.<string>}
     */
    parseCommand(sCmd, fSave, chSep = ';')
    {
        if (fSave) {
            if (!sCmd) {
                sCmd = this.aPrevCmds[this.iPrevCmd+1];
            } else {
                if (this.iPrevCmd < 0 && this.aPrevCmds.length) {
                    this.iPrevCmd = 0;
                }
                if (this.iPrevCmd < 0 || sCmd != this.aPrevCmds[this.iPrevCmd]) {
                    this.aPrevCmds.splice(0, 0, sCmd);
                    this.iPrevCmd = 0;
                }
                this.iPrevCmd--;
            }
        }
        let asArgs = [];
        if (sCmd) {
            /*
             * With the introduction of breakpoint commands (ie, quoted command sequences
             * associated with a breakpoint), we can no longer perform simplistic splitting.
             *
             *      asArgs = sCmd.split(chSep);
             *      for (let i = 0; i < asArgs.length; i++) asArgs[i] = Str.trim(asArgs[i]);
             *
             * We may now split on semi-colons ONLY if they are outside a quoted sequence.
             *
             * Also, to allow quoted strings *inside* breakpoint commands, we first replace all
             * DOUBLE double-quotes with single quotes.
             */
            sCmd = sCmd.replace(/""/g, "'");

            let iPrev = 0;
            let chQuote = null;
            /*
             * NOTE: Processing charAt() up to and INCLUDING length is not a typo; we're taking
             * advantage of the fact that charAt() with an invalid index returns an empty string,
             * allowing us to use the same substring() call to capture the final portion of sCmd.
             *
             * In a sense, it allows us to pretend that the string ends with a zero terminator.
             */
            let fQuoted = false;
            for (let i = 0, chPrev = null; i <= sCmd.length; i++) {
                let ch = sCmd.charAt(i);
                if (ch == '"' || ch == "'") {
                    if (!chQuote) {
                        chQuote = ch;
                        fQuoted = true;
                    } else if (ch == chQuote) {
                        chQuote = null;
                    }
                }
                else if (ch == chSep && !chQuote && ch != chPrev || !ch) {
                    /*
                     * Recall that substring() accepts starting (inclusive) and ending (exclusive)
                     * indexes, whereas substr() accepts a starting index and a length.  We need the former.
                     */
                    let s = Str.trim(sCmd.substring(iPrev, i));
                    if (!fQuoted) s = s.toLowerCase();
                    asArgs.push(s);
                    iPrev = i + 1;
                    fQuoted = false;
                }
                chPrev = ch;
            }
            if (chSep == ' ' && asArgs.length) {
                /*
                 * I've folded in the old shiftArgs() code here: deal with any command (eg, "r") that allows but
                 * doesn't require whitespace between the command and first argument, and break them apart anyway.
                 */
                let s0 = asArgs[0];
                let ch0 = s0.charAt(0);
                for (let i = 1; i < s0.length; i++) {
                    let ch = s0.charAt(i);
                    if (ch0 == '?' || ch0 == 'r' || ch < 'a' || ch > 'z') {
                        asArgs[0] = s0.substr(i);
                        asArgs.unshift(s0.substr(0, i));
                        break;
                    }
                }
            }
        }
        return asArgs;
    }

    /**
     * doCommand(sCmd, fQuiet)
     *
     * @this {DebuggerX86}
     * @param {string} sCmd
     * @param {boolean} [fQuiet]
     * @return {boolean} true if command processed, false if unrecognized
     */
    doCommand(sCmd, fQuiet)
    {
        let result = true;

        try {
            if (!sCmd.length || sCmd == "end") {
                if (this.fAssemble) {
                    this.println("ended assemble at " + this.toHexAddr(this.dbgAddrAssemble));
                    this.dbgAddrNextCode = this.dbgAddrAssemble;
                    this.fAssemble = false;
                }
                sCmd = "";
            }
            else if (!fQuiet) {
                let sPrompt = ">> ";
                if (this.cpu.regCR0 & X86.CR0.MSW.PE) {
                    sPrompt = (this.cpu.regPS & X86.PS.VM)? "-- " : "## ";
                }
                this.println(sPrompt + sCmd);
            }

            let ch = sCmd.charAt(0);
            if (ch == '"' || ch == "'") return true;

            /*
             * Zap the previous message buffer to ensure the new command's output is not tossed out as a repeat.
             */
            this.sMessagePrev = null;

            /*
             * I've relaxed the !isBusy() requirement, to maximize our ability to issue Debugger commands externally.
             */
            if (this.isReady() /* && !this.isBusy(true) */ && sCmd.length > 0) {

                if (this.fAssemble) {
                    sCmd = "a " + this.toHexAddr(this.dbgAddrAssemble) + ' ' + sCmd;
                }

                let asArgs = this.parseCommand(sCmd, false, ' ');

                switch (asArgs[0].charAt(0)) {
                case 'a':
                    this.doAssemble(asArgs);
                    break;
                case 'b':
                    this.doBreak(asArgs[0], asArgs[1], sCmd);
                    break;
                case 'c':
                    this.doClear(asArgs[0]);
                    break;
                case 'd':
                    if (!PCX86.COMPILED && sCmd == "debug") {
                        window.DEBUG = true;
                        this.println("DEBUG checks on");
                        break;
                    }
                    this.doDump(asArgs);
                    break;
                case 'e':
                    if (asArgs[0] == "else") break;
                    this.doEdit(asArgs);
                    break;
                case 'f':
                    this.doFreqs(asArgs[1]);
                    break;
                case 'g':
                    this.doRun(asArgs[0], asArgs[1], sCmd, fQuiet);
                    break;
                case 'h':
                    this.doHalt(fQuiet);
                    break;
                case 'i':
                    if (asArgs[0] == "if") {
                        if (!this.doIf(sCmd.substr(2), fQuiet)) {
                            result = false;
                        }
                        break;
                    }
                    if (asArgs[0] == "int") {
                        if (!this.doInt(asArgs[1])) {
                            result = false;
                        }
                        break;
                    }
                    this.doInput(asArgs[1]);
                    break;
                case 'k':
                    this.doStackTrace(asArgs[0], asArgs[1]);
                    break;
                case 'l':
                    if (asArgs[0] == "ln") {
                        this.doList(asArgs[1], true);
                        break;
                    }
                    this.doLoad(asArgs);
                    break;
                case 'm':
                    if (asArgs[0] == "mouse") {
                        this.doMouse(asArgs[1], asArgs[2]);
                        break;
                    }
                    this.doMessages(asArgs);
                    break;
                case 'o':
                    this.doOutput(asArgs[1], asArgs[2]);
                    break;
                case 'p':
                    if (asArgs[0] == "print") {
                        this.doPrint(sCmd.substr(5));
                        break;
                    }
                    this.doStep(asArgs[0]);
                    break;
                case 'r':
                    if (sCmd == "reset") {
                        if (this.cmp) this.cmp.reset();
                        break;
                    }
                    this.doRegisters(asArgs);
                    break;
                case 't':
                    this.doTrace(asArgs[0], asArgs[1]);
                    break;
                case 'u':
                    this.doUnassemble(asArgs[1], asArgs[2], 8);
                    break;
                case 'v':
                    if (asArgs[0] == "var") {
                        if (!this.doVar(sCmd.substr(3))) {
                            result = false;
                        }
                        break;
                    }
                    this.println((PCX86.APPNAME || "PCx86") + " version " + (XMLVERSION || PCX86.APPVERSION) + " (" + this.cpu.model + (PCX86.COMPILED? ",RELEASE" : (PCX86.DEBUG? ",DEBUG" : ",NODEBUG")) + (PCX86.PREFETCH? ",PREFETCH" : ",NOPREFETCH") + (PCX86.TYPEDARRAYS? ",TYPEDARRAYS" : (PCX86.BYTEARRAYS? ",BYTEARRAYS" : ",LONGARRAYS")) + (PCX86.BACKTRACK? ",BACKTRACK" : ",NOBACKTRACK") + ')');
                    this.println(Web.getUserAgent());
                    break;
                case 'x':
                    this.doExecOptions(asArgs);
                    break;
                case '?':
                    if (asArgs[1]) {
                        this.doPrint(sCmd.substr(1));
                        break;
                    }
                    this.doHelp();
                    break;
                case 'n':
                    if (!PCX86.COMPILED && sCmd == "nodebug") {
                        window.DEBUG = false;
                        this.println("DEBUG checks off");
                        break;
                    }
                    if (this.doInfo(asArgs)) break;
                    /* falls through */
                default:
                    this.println("unknown command: " + sCmd);
                    result = false;
                    break;
                }
            }
        } catch(e) {
            this.println("debugger error: " + (e.stack || e.message));
            result = false;
        }
        return result;
    }

    /**
     * doCommands(sCommands, fSave)
     *
     * @this {DebuggerX86}
     * @param {string} sCommands
     * @param {boolean} [fSave]
     * @return {boolean} true if all commands processed, false if not
     */
    doCommands(sCommands, fSave)
    {
        let a = this.parseCommand(sCommands, fSave);
        for (let s in a) {
            if (!this.doCommand(a[+s])) return false;
        }
        return true;
    }

    /**
     * DebuggerX86.init()
     *
     * This function operates on every HTML element of class "debugger", extracting the
     * JSON-encoded parameters for the Debugger constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Debugger component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeDbg = Component.getElementsByClass(document, PCX86.APPCLASS, "debugger");
        for (let iDbg = 0; iDbg < aeDbg.length; iDbg++) {
            let eDbg = aeDbg[iDbg];
            let parmsDbg = Component.getComponentParms(eDbg);
            let dbg = new DebuggerX86(parmsDbg);
            Component.bindComponentControls(dbg, eDbg, PCX86.APPCLASS);
        }
    }
}

if (DEBUGGER) {

    /*
     * NOTE: The Debugger properties below are considered "class constants"; most of them use our "all-caps"
     * convention (and all of them SHOULD, but that wouldn't help us catch any bugs).
     *
     * Technically, all of them should ALSO be preceded by a "@const" annotation, but that's a lot of work and it
     * really clutters the code.  I wish the Closure Compiler had a way to annotate every definition with a given
     * section with a single annotation....
     *
     * Bugs can slip through the cracks without those annotations; for example, I unthinkingly redefined TYPE_SI
     * at one point, and if all the definitions had been preceded by an "@const", that mistake would have been
     * caught at compile-time.
     */

    /*
     * Information regarding interrupts of interest (used by messageInt() and others)
     */
    DebuggerX86.INT_MESSAGES = {
        0x10:       Messages.VIDEO,
        0x13:       Messages.FDC,
        0x15:       Messages.CHIPSET,
        0x16:       Messages.KBD,
     // 0x1A:       Messages.RTC,       // ChipSet contains its own custom messageInt() handler for the RTC
        0x1C:       Messages.TIMER,
        0x21:       Messages.DOS,
        0x33:       Messages.MOUSE
    };

    /*
     * Information regarding "annoying" interrupts (which aren't annoying so much as too frequent);
     * note that some of these can still be enabled if you really want them (eg, RTC can be turned on
     * with RTC messages, ALT_TIMER with TIMER messages, etc).
     */
    DebuggerX86.INT_ANNOYING = [Interrupts.TIMER, Interrupts.TMR_BREAK, Interrupts.DOS_IDLE, Interrupts.DOS_NETBIOS, Interrupts.ALT_VIDEO];

    DebuggerX86.COMMANDS = {
        '?':     "help/print",
        'a [#]': "assemble",            // TODO: Implement this command someday
        'b [#]': "breakpoint",          // multiple variations (use b? to list them)
        'c':     "clear output",
        'd [#]': "dump memory",         // additional syntax: d [#] [l#], where l# is a number of bytes to dump
        'e [#]': "edit memory",
        'f':     "frequencies",
        'g [#]': "go [to #]",
        'h':     "halt",
        'i [#]': "input port #",
        'if':    "eval expression",
        'k':     "stack trace",
        'l':     "load sector(s)",
        "ln":    "list nearest symbol(s)",
        'm':     "messages",
        'mouse': "mouse action",        // syntax: mouse {action} {delta} (eg, mouse x 10, mouse click 0, etc)
        'o [#]': "output port #",
        'p':     "step over",           // other variations: pr (step and dump registers)
        'print': "print expression",
        'r':     "dump/set registers",
        'reset': "reset machine",
        't [#]': "trace",               // other variations: tr (trace and dump registers)
        'u [#]': "unassemble",
        'x':     "execution options",
        'v':     "print version",
        'var':   "assign variable"
    };

    /*
     * Supported address types; the type field in a DbgAddrX86 object may be one of:
     *
     *      NONE, REAL, PROT, V86, LINEAR or PHYSICAL
     *
     * REAL and V86 addresses are specified with a '&' prefix, PROT addresses with a '#' prefix,
     * LINEAR addresses with '%', and PHYSICAL addresses with '%%'.
     */
    DebuggerX86.ADDRTYPE = {
        NONE:       0x00,
        REAL:       0x01,
        PROT:       0x02,
        V86:        0x03,
        LINEAR:     0x04,
        PHYSICAL:   0x05
    };

    /*
     * CPU instruction ordinals
     *
     * Note that individual instructions end with ordinal 163 and instruction groups begin with ordinal 164;
     * the disassembler knows it's dealing with a group whenever the ordinal is not a valid index into INS_NAMES.
     *
     * NOTE: While this list started alphabetical, there are a few wrinkles; eg, POPA/POPF/PUSHF/PUSHA are
     * sequential to make it easier to detect instructions that require a D suffix when the operand size is 32 bits.
     */
    DebuggerX86.INS = {
        NONE:   0,   AAA:    1,   AAD:    2,   AAM:    3,   AAS:    4,   ADC:    5,   ADD:    6,   AND:    7,
        ARPL:   8,   AS:     9,   BOUND:  10,  BSF:    11,  BSR:    12,  BT:     13,  BTC:    14,  BTR:    15,
        BTS:    16,  CALL:   17,  CBW:    18,  CLC:    19,  CLD:    20,  CLI:    21,  CLTS:   22,  CMC:    23,
        CMP:    24,  CMPSB:  25,  CMPSW:  26,  CS:     27,  CWD:    28,  DAA:    29,  DAS:    30,  DEC:    31,
        DIV:    32,  DS:     33,  ENTER:  34,  ES:     35,  ESC:    36,  FS:     37,  GS:     38,  HLT:    39,
        IBTS:   40,  IDIV:   41,  IMUL:   42,  IN:     43,  INC:    44,  INS:    45,  INT:    46,  INT1:   47,
        INT3:   48,  INTO:   49,  IRET:   50,  JBE:    51,  JC:     52,  JCXZ:   53,  JG:     54,  JGE:    55,
        JL:     56,  JLE:    57,  JMP:    58,  JA:     59,  JNC:    60,  JNO:    61,  JNP:    62,  JNS:    63,
        JNZ:    64,  JO:     65,  JP:     66,  JS:     67,  JZ:     68,  LAHF:   69,  LAR:    70,  LDS:    71,
        LEA:    72,  LEAVE:  73,  LES:    74,  LFS:    75,  LGDT:   76,  LGS:    77,  LIDT:   78,  LLDT:   79,
        LMSW:   80,  LOADALL:81,  LOCK:   82,  LODSB:  83,  LODSW:  84,  LOOP:   85,  LOOPNZ: 86,  LOOPZ:  87,
        LSL:    88,  LSS:    89,  LTR:    90,  MOV:    91,  MOVSB:  92,  MOVSW:  93,  MOVSX:  94,  MOVZX:  95,
        MUL:    96,  NEG:    97,  NOP:    98,  NOT:    99,  OR:     100, OS:     101, OUT:    102, OUTS:   103,
        POP:    104, POPA:   105, POPF:   106, PUSHF:  107, PUSHA:  108, PUSH:   109, RCL:    110, RCR:    111,
        REPNZ:  112, REPZ:   113, RET:    114, RETF:   115, ROL:    116, ROR:    117, SAHF:   118, SALC:   119,
        SAR:    120, SBB:    121, SCASB:  122, SCASW:  123, SETBE:  124, SETC:   125, SETG:   126, SETGE:  127,
        SETL:   128, SETLE:  129, SETNBE: 130, SETNC:  131, SETNO:  132, SETNP:  133, SETNS:  134, SETNZ:  135,
        SETO:   136, SETP:   137, SETS:   138, SETZ:   139, SGDT:   140, SHL:    141, SHLD:   142, SHR:    143,
        SHRD:   144, SIDT:   145, SLDT:   146, SMSW:   147, SS:     148, STC:    149, STD:    150, STI:    151,
        STOSB:  152, STOSW:  153, STR:    154, SUB:    155, TEST:   156, VERR:   157, VERW:   158, WAIT:   159,
        XBTS:   160, XCHG:   161, XLAT:   162, XOR:    163, GRP1B:  164, GRP1W:  165, GRP1SW: 166, GRP2B:  167,
        GRP2W:  168, GRP2B1: 169, GRP2W1: 170, GRP2BC: 171, GRP2WC: 172, GRP3B:  173, GRP3W:  174, GRP4B:  175,
        GRP4W:  176, OP0F:   177, GRP6:   178, GRP7:   179, GRP8:   180
    };

    /*
     * CPU instruction names (mnemonics), indexed by CPU instruction ordinal (above)
     */
    DebuggerX86.INS_NAMES = [
        "INVALID","AAA",    "AAD",    "AAM",    "AAS",    "ADC",    "ADD",    "AND",
        "ARPL",   "AS:",    "BOUND",  "BSF",    "BSR",    "BT",     "BTC",    "BTR",
        "BTS",    "CALL",   "CBW",    "CLC",    "CLD",    "CLI",    "CLTS",   "CMC",
        "CMP",    "CMPSB",  "CMPSW",  "CS:",    "CWD",    "DAA",    "DAS",    "DEC",
        "DIV",    "DS:",    "ENTER",  "ES:",    "ESC",    "FS:",    "GS:",    "HLT",
        "IBTS",   "IDIV",   "IMUL",   "IN",     "INC",    "INS",    "INT",    "INT1",
        "INT3",   "INTO",   "IRET",   "JBE",    "JC",     "JCXZ",   "JG",     "JGE",
        "JL",     "JLE",    "JMP",    "JA",     "JNC",    "JNO",    "JNP",    "JNS",
        "JNZ",    "JO",     "JP",     "JS",     "JZ",     "LAHF",   "LAR",    "LDS",
        "LEA",    "LEAVE",  "LES",    "LFS",    "LGDT",   "LGS",    "LIDT",   "LLDT",
        "LMSW",   "LOADALL","LOCK",   "LODSB",  "LODSW",  "LOOP",   "LOOPNZ", "LOOPZ",
        "LSL",    "LSS",    "LTR",    "MOV",    "MOVSB",  "MOVSW",  "MOVSX",  "MOVZX",
        "MUL",    "NEG",    "NOP",    "NOT",    "OR",     "OS:",    "OUT",    "OUTS",
        "POP",    "POPA",   "POPF",   "PUSHF",  "PUSHA",  "PUSH",   "RCL",    "RCR",
        "REPNZ",  "REPZ",   "RET",    "RETF",   "ROL",    "ROR",    "SAHF",   "SALC",
        "SAR",    "SBB",    "SCASB",  "SCASW",  "SETBE",  "SETC",   "SETG",   "SETGE",
        "SETL",   "SETLE",  "SETNBE", "SETNC",  "SETNO",  "SETNP",  "SETNS",  "SETNZ",
        "SETO",   "SETP",   "SETS",   "SETZ",   "SGDT",   "SHL",    "SHLD",   "SHR",
        "SHRD",   "SIDT",   "SLDT",   "SMSW",   "SS:",    "STC",    "STD",    "STI",
        "STOSB",  "STOSW",  "STR",    "SUB",    "TEST",   "VERR",   "VERW",   "WAIT",
        "XBTS",   "XCHG",   "XLAT",   "XOR"
    ];

    /*
     * FPU instruction ordinals
     *
     * Unlike CPU instruction ordinals, these are not organized alphabetically (which I did only for the
     * sake of tidiness), but rather by functionality; ie:
     *
     *      0-3:    real transfers
     *      4-6:    integer transfers
     *      7-8:    packed decimal transfers
     *      9-11:   addition
     *      12-17:  subtraction
     *      18-20:  multiplication
     *      21-26:  division
     *      27-33:  other
     *      34-40:  comparisons
     *      41-45:  transcendental
     *      46-52:  constants
     *      53-77:  coprocessor control
     *      78---:  new for 80287 or higher
     *
     * Also, unlike the CPU instructions, there is no NONE ("INVALID") instruction; if an ESC instruction
     * can't be decoded as a valid FPU instruction, then it should remain an ESC instruction.
     */
    DebuggerX86.FINS = {
        FLD:    0,   FST:    1,   FSTP:   2,   FXCH:   3,   FILD:   4,   FIST:   5,   FISTP:  6,   FBLD:   7,
        FBSTP:  8,   FADD:   9,   FADDP:  10,  FIADD:  11,  FSUB:   12,  FSUBP:  13,  FISUB:  14,  FSUBR:  15,
        FSUBRP: 16,  FISUBR: 17,  FMUL:   18,  FMULP:  19,  FIMUL:  20,  FDIV:   21,  FDIVP:  22,  FIDIV:  23,
        FDIVR:  24,  FDIVRP: 25,  FIDIVR: 26,  FSQRT:  27,  FSCALE: 28,  FPREM:  29,  FRNDINT:30,  FXTRACT:31,
        FABS:   32,  FCHS:   33,  FCOM:   34,  FCOMP:  35,  FCOMPP: 36,  FICOM:  37,  FICOMP: 38,  FTST:   39,
        FXAM:   40,  FPTAN:  41,  FPATAN: 42,  F2XM1:  43,  FYL2X:  44,  FYL2XP1:45,  FLDZ:   46,  FLD1:   47,
        FLDPI:  48,  FLDL2T: 49,  FLDL2E: 50,  FLDLG2: 51,  FLDLN2: 52,  FINIT:  53,  FNINIT: 54,  FDISI:  55,
        FNDISI: 56,  FENI:   57,  FNENI:  58,  FLDCW:  59,  FSTCW:  60,  FNSTCW: 61,  FSTSW:  62,  FNSTSW: 63,
        FCLEX:  64,  FNCLEX: 65,  FSTENV: 66,  FNSTENV:67,  FLDENV: 68,  FSAVE:  69,  FNSAVE: 70,  FRSTOR: 71,
        FINCSTP:72,  FDECSTP:73,  FFREE:  74,  FFREEP: 75,  FNOP:   76,  FWAIT:  77,  FSETPM: 78,  FSINCOS:79,
        FSTSWAX:80
    };

    /*
     * FPU instruction names (mnemonics), indexed by FPU instruction ordinal (above)
     */
    DebuggerX86.FINS_NAMES = [
        "FLD",    "FST",    "FSTP",   "FXCH",   "FILD",   "FIST",   "FISTP",  "FBLD",
        "FBSTP",  "FADD",   "FADDP",  "FIADD",  "FSUB",   "FSUBP",  "FISUB",  "FSUBR",
        "FSUBRP", "FISUBR", "FMUL",   "FMULP",  "FIMUL",  "FDIV",   "FDIVP",  "FIDIV",
        "FDIVR",  "FDIVRP", "FIDIVR", "FSQRT",  "FSCALE", "FPREM",  "FRNDINT","FXTRACT",
        "FABS",   "FCHS",   "FCOM",   "FCOMP",  "FCOMPP", "FICOM",  "FICOMP", "FTST",
        "FXAM",   "FPTAN",  "FPATAN", "F2XM1",  "FYL2X",  "FYL2XP1","FLDZ",   "FLD1",
        "FLDPI",  "FLDL2T", "FLDL2E", "FLDLG2", "FLDLN2", "FINIT",  "FNINIT", "FDISI",
        "FNDISI", "FENI",   "FNENI",  "FLDCW",  "FSTCW",  "FNSTCW", "FSTSW",  "FNSTSW",
        "FCLEX",  "FNCLEX", "FSTENV", "FNSTENV","FLDENV", "FSAVE",  "FNSAVE", "FRSTOR",
        "FINCSTP","FDECSTP","FFREE",  "FFREEP", "FNOP",   "FWAIT",  "FSETPM", "FSINCOS",
        "FSTSWAX"
    ];

    DebuggerX86.FPU_TAGS = ["VALID", "ZERO ", "SPEC ", "EMPTY"];

    DebuggerX86.CPU_8086  = 0;
    DebuggerX86.CPU_80186 = 1;
    DebuggerX86.CPU_80286 = 2;
    DebuggerX86.CPU_80386 = 3;
    DebuggerX86.CPUS = [8086, 80186, 80286, 80386];

    /*
     * ModRM masks and definitions
     */
    DebuggerX86.REG_AL         = 0x00;          // bits 0-2 are standard Reg encodings
    DebuggerX86.REG_CL         = 0x01;
    DebuggerX86.REG_DL         = 0x02;
    DebuggerX86.REG_BL         = 0x03;
    DebuggerX86.REG_AH         = 0x04;
    DebuggerX86.REG_CH         = 0x05;
    DebuggerX86.REG_DH         = 0x06;
    DebuggerX86.REG_BH         = 0x07;
    DebuggerX86.REG_AX         = 0x08;
    DebuggerX86.REG_CX         = 0x09;
    DebuggerX86.REG_DX         = 0x0A;
    DebuggerX86.REG_BX         = 0x0B;
    DebuggerX86.REG_SP         = 0x0C;
    DebuggerX86.REG_BP         = 0x0D;
    DebuggerX86.REG_SI         = 0x0E;
    DebuggerX86.REG_DI         = 0x0F;
    DebuggerX86.REG_SEG        = 0x10;
    DebuggerX86.REG_IP         = 0x16;
    DebuggerX86.REG_PS         = 0x17;
    DebuggerX86.REG_EAX        = 0x18;
    DebuggerX86.REG_ECX        = 0x19;
    DebuggerX86.REG_EDX        = 0x1A;
    DebuggerX86.REG_EBX        = 0x1B;
    DebuggerX86.REG_ESP        = 0x1C;
    DebuggerX86.REG_EBP        = 0x1D;
    DebuggerX86.REG_ESI        = 0x1E;
    DebuggerX86.REG_EDI        = 0x1F;
    DebuggerX86.REG_CR0        = 0x20;
    DebuggerX86.REG_CR1        = 0x21;
    DebuggerX86.REG_CR2        = 0x22;
    DebuggerX86.REG_CR3        = 0x23;
    DebuggerX86.REG_DR0        = 0x28;
    DebuggerX86.REG_DR1        = 0x29;
    DebuggerX86.REG_DR2        = 0x2A;
    DebuggerX86.REG_DR3        = 0x2B;
    DebuggerX86.REG_DR6        = 0x2E;
    DebuggerX86.REG_DR7        = 0x2F;
    DebuggerX86.REG_TR0        = 0x30;
    DebuggerX86.REG_TR6        = 0x36;
    DebuggerX86.REG_TR7        = 0x37;
    DebuggerX86.REG_EIP        = 0x38;

    DebuggerX86.REGS = [
        "AL",  "CL",  "DL",  "BL",  "AH",  "CH",  "DH",  "BH",
        "AX",  "CX",  "DX",  "BX",  "SP",  "BP",  "SI",  "DI",
        "ES",  "CS",  "SS",  "DS",  "FS",  "GS",  "IP",  "PS",
        "EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI",
        "CR0", "CR1", "CR2", "CR3", null,  null,  null,  null,  // register names used with TYPE_CTLREG
        "DR0", "DR1", "DR2", "DR3", null,  null,  "DR6", "DR7", // register names used with TYPE_DBGREG
        null,  null,  null,  null,  null,  null,  "TR6", "TR7", // register names used with TYPE_TSTREG
        "EIP"
    ];

    DebuggerX86.REG_ES         = 0x00;          // bits 0-1 are standard SegReg encodings
    DebuggerX86.REG_CS         = 0x01;
    DebuggerX86.REG_SS         = 0x02;
    DebuggerX86.REG_DS         = 0x03;
    DebuggerX86.REG_FS         = 0x04;
    DebuggerX86.REG_GS         = 0x05;
    DebuggerX86.REG_UNKNOWN    = 0x00;

    DebuggerX86.MOD_NODISP     = 0x00;          // use RM below, no displacement
    DebuggerX86.MOD_DISP8      = 0x01;          // use RM below + 8-bit displacement
    DebuggerX86.MOD_DISP16     = 0x02;          // use RM below + 16-bit displacement
    DebuggerX86.MOD_REGISTER   = 0x03;          // use REG above

    DebuggerX86.RM_BXSI        = 0x00;
    DebuggerX86.RM_BXDI        = 0x01;
    DebuggerX86.RM_BPSI        = 0x02;
    DebuggerX86.RM_BPDI        = 0x03;
    DebuggerX86.RM_SI          = 0x04;
    DebuggerX86.RM_DI          = 0x05;
    DebuggerX86.RM_BP          = 0x06;
    DebuggerX86.RM_IMMOFF      = DebuggerX86.RM_BP;       // only if MOD_NODISP
    DebuggerX86.RM_BX          = 0x07;

    DebuggerX86.RMS = [
        "BX+SI", "BX+DI", "BP+SI", "BP+DI", "SI",    "DI",    "BP",    "BX",
        "EAX",   "ECX",   "EDX",   "EBX",   "ESP",   "EBP",   "ESI",   "EDI"
    ];

    /*
     * Operand type descriptor masks and definitions
     *
     * Note that the letters in () in the comments refer to Intel's
     * nomenclature used in Appendix A of the 80386 Programmers Reference Manual.
     */
    DebuggerX86.TYPE_SIZE      = 0x000F;        // size field
    DebuggerX86.TYPE_MODE      = 0x00F0;        // mode field
    DebuggerX86.TYPE_IREG      = 0x0F00;        // implied register field
    DebuggerX86.TYPE_OTHER     = 0xF000;        // "other" field

    /*
     * TYPE_SIZE values.  Some definitions use duplicate values when the operands are the
     * same size and the Debugger doesn't need to make a distinction.
     */
    DebuggerX86.TYPE_NONE      = 0x0000;        //     (all other TYPE fields ignored)
    DebuggerX86.TYPE_BYTE      = 0x0001;        // (b) byte, regardless of operand size
    DebuggerX86.TYPE_SBYTE     = 0x0002;        //     byte sign-extended to word
    DebuggerX86.TYPE_SHORT     = 0x0003;        // (w) 16-bit value
    DebuggerX86.TYPE_WORD      = 0x0004;        // (v) 16-bit or 32-bit value
    DebuggerX86.TYPE_LONG      = 0x0005;        // (d) 32-bit value
    DebuggerX86.TYPE_SEGP      = 0x0006;        // (p) 32-bit or 48-bit pointer
    DebuggerX86.TYPE_FARP      = 0x0007;        // (p) 32-bit or 48-bit pointer for JMP/CALL
    DebuggerX86.TYPE_PREFIX    = 0x0008;        //     (treat similarly to TYPE_NONE)
    /*
     * The remaining TYPE_SIZE values are for the FPU.  Note that there are not enough values
     * within this nibble for every type to have a unique value, so to differentiate between two
     * types of the same size (eg, SINT and SREAL), we can inspect the opcode string, because only
     * FI* instructions use INT operands.  Also, some FPU sizes are not in this list (eg, the
     * so-called "word-integer"); since a word-integer is always 16 bits, we specify TYPE_SHORT,
     * which the Debugger should display as "INT16" for FI* instructions.
     */
    DebuggerX86.TYPE_ST        = 0x0009;        //     FPU ST (implicit stack top)
    DebuggerX86.TYPE_STREG     = 0x000A;        //     FPU ST (explicit stack register, relative to top)
    DebuggerX86.TYPE_SINT      = 0x000B;        //     FPU SI (short-integer; 32-bit); displayed as "INT32"
    DebuggerX86.TYPE_SREAL     = 0x000B;        //     FPU SR (short-real; 32-bit); displayed as "REAL32"
    DebuggerX86.TYPE_LINT      = 0x000C;        //     FPU LI (long-integer; 64-bit); displayed as "INT64"
    DebuggerX86.TYPE_LREAL     = 0x000C;        //     FPU LR (long-real; 64-bit); displayed as "REAL64"
    DebuggerX86.TYPE_TREAL     = 0x000D;        //     FPU TR (temp-real; 80-bit); displayed as "REAL80"
    DebuggerX86.TYPE_BCD80     = 0x000E;        //     FPU PD (packed-decimal; 18 BCD digits in 80 bits, bits 72-78 unused, sign in bit 79); displayed as "BCD80"
    DebuggerX86.TYPE_ENV       = 0x000F;        //     FPU ENV (environment; 14 bytes in real-mode, 28 bytes in protected-mode)
    DebuggerX86.TYPE_FPU       = 0x000F;        //     FPU SAVE (save/restore; 94 bytes in real-mode, 108 bytes in protected-mode)

    /*
     * TYPE_MODE values.  Order is somewhat important, as all values implying
     * the presence of a ModRM byte are assumed to be >= TYPE_MODRM.
     */
    DebuggerX86.TYPE_IMM       = 0x0000;        // (I) immediate data
    DebuggerX86.TYPE_ONE       = 0x0010;        //     implicit 1 (eg, shifts/rotates)
    DebuggerX86.TYPE_IMMOFF    = 0x0020;        // (A) immediate offset
    DebuggerX86.TYPE_IMMREL    = 0x0030;        // (J) immediate relative
    DebuggerX86.TYPE_DSSI      = 0x0040;        // (X) memory addressed by DS:SI
    DebuggerX86.TYPE_ESDI      = 0x0050;        // (Y) memory addressed by ES:DI
    DebuggerX86.TYPE_IMPREG    = 0x0060;        //     implicit register in TYPE_IREG
    DebuggerX86.TYPE_IMPSEG    = 0x0070;        //     implicit segment reg in TYPE_IREG
    DebuggerX86.TYPE_MODRM     = 0x0080;        // (E) standard ModRM decoding
    DebuggerX86.TYPE_MODMEM    = 0x0090;        // (M) ModRM refers to memory only
    DebuggerX86.TYPE_MODREG    = 0x00A0;        // (R) ModRM refers to register only
    DebuggerX86.TYPE_REG       = 0x00B0;        // (G) standard Reg decoding
    DebuggerX86.TYPE_SEGREG    = 0x00C0;        // (S) Reg selects segment register
    DebuggerX86.TYPE_CTLREG    = 0x00D0;        // (C) Reg selects control register
    DebuggerX86.TYPE_DBGREG    = 0x00E0;        // (D) Reg selects debug register
    DebuggerX86.TYPE_TSTREG    = 0x00F0;        // (T) Reg selects test register

    /*
     * TYPE_IREG values, based on the REG_* constants.
     * For convenience, they include TYPE_IMPREG or TYPE_IMPSEG as appropriate.
     */
    DebuggerX86.TYPE_AL = (DebuggerX86.REG_AL << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_BYTE);
    DebuggerX86.TYPE_CL = (DebuggerX86.REG_CL << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_BYTE);
    DebuggerX86.TYPE_DL = (DebuggerX86.REG_DL << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_BYTE);
    DebuggerX86.TYPE_BL = (DebuggerX86.REG_BL << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_BYTE);
    DebuggerX86.TYPE_AH = (DebuggerX86.REG_AH << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_BYTE);
    DebuggerX86.TYPE_CH = (DebuggerX86.REG_CH << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_BYTE);
    DebuggerX86.TYPE_DH = (DebuggerX86.REG_DH << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_BYTE);
    DebuggerX86.TYPE_BH = (DebuggerX86.REG_BH << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_BYTE);
    DebuggerX86.TYPE_AX = (DebuggerX86.REG_AX << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_WORD);
    DebuggerX86.TYPE_CX = (DebuggerX86.REG_CX << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_WORD);
    DebuggerX86.TYPE_DX = (DebuggerX86.REG_DX << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_WORD);
    DebuggerX86.TYPE_BX = (DebuggerX86.REG_BX << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_WORD);
    DebuggerX86.TYPE_SP = (DebuggerX86.REG_SP << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_WORD);
    DebuggerX86.TYPE_BP = (DebuggerX86.REG_BP << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_WORD);
    DebuggerX86.TYPE_SI = (DebuggerX86.REG_SI << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_WORD);
    DebuggerX86.TYPE_DI = (DebuggerX86.REG_DI << 8 | DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_WORD);
    DebuggerX86.TYPE_ES = (DebuggerX86.REG_ES << 8 | DebuggerX86.TYPE_IMPSEG | DebuggerX86.TYPE_SHORT);
    DebuggerX86.TYPE_CS = (DebuggerX86.REG_CS << 8 | DebuggerX86.TYPE_IMPSEG | DebuggerX86.TYPE_SHORT);
    DebuggerX86.TYPE_SS = (DebuggerX86.REG_SS << 8 | DebuggerX86.TYPE_IMPSEG | DebuggerX86.TYPE_SHORT);
    DebuggerX86.TYPE_DS = (DebuggerX86.REG_DS << 8 | DebuggerX86.TYPE_IMPSEG | DebuggerX86.TYPE_SHORT);
    DebuggerX86.TYPE_FS = (DebuggerX86.REG_FS << 8 | DebuggerX86.TYPE_IMPSEG | DebuggerX86.TYPE_SHORT);
    DebuggerX86.TYPE_GS = (DebuggerX86.REG_GS << 8 | DebuggerX86.TYPE_IMPSEG | DebuggerX86.TYPE_SHORT);

    /*
     * TYPE_OTHER bit definitions
     */
    DebuggerX86.TYPE_IN    = 0x1000;            // operand is input
    DebuggerX86.TYPE_OUT   = 0x2000;            // operand is output
    DebuggerX86.TYPE_BOTH  = (DebuggerX86.TYPE_IN | DebuggerX86.TYPE_OUT);
    DebuggerX86.TYPE_8086  = (DebuggerX86.CPU_8086 << 14);
    DebuggerX86.TYPE_8087  = DebuggerX86.TYPE_8086;
    DebuggerX86.TYPE_80186 = (DebuggerX86.CPU_80186 << 14);
    DebuggerX86.TYPE_80286 = (DebuggerX86.CPU_80286 << 14);
    DebuggerX86.TYPE_80287 = DebuggerX86.TYPE_80286;
    DebuggerX86.TYPE_80386 = (DebuggerX86.CPU_80386 << 14);
    DebuggerX86.TYPE_80387 = DebuggerX86.TYPE_80386;
    DebuggerX86.TYPE_CPU_SHIFT = 14;

    DebuggerX86.HISTORY_LIMIT = DEBUG? 100000 : 1000;

    /*
     * Opcode 0x0F has a distinguished history:
     *
     *      On the 8086, it functioned as POP CS
     *      On the 80186, it generated an Invalid Opcode (UD_FAULT) exception
     *      On the 80286, it introduced a new (and growing) series of two-byte opcodes
     *
     * Based on the active CPU model, we make every effort to execute and disassemble this (and every other)
     * opcode appropriately, by setting the opcode's entry in aaOpDescs accordingly.  0x0F in aaOpDescs points
     * to the 8086 table: aOpDescPopCS.
     *
     * Note that we must NOT modify aaOpDescs directly.  this.aaOpDescs will point to DebuggerX86.aaOpDescs
     * if the processor is an 8086, because that's the processor that the hard-coded contents of the table
     * represent; for all other processors, this.aaOpDescs will contain a copy of the table that we can modify.
     */
    DebuggerX86.aOpDescPopCS     = [DebuggerX86.INS.POP,  DebuggerX86.TYPE_CS   | DebuggerX86.TYPE_OUT];
    DebuggerX86.aOpDescUndefined = [DebuggerX86.INS.NONE, DebuggerX86.TYPE_NONE];
    DebuggerX86.aOpDesc0F        = [DebuggerX86.INS.OP0F, DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_BOTH];

    /*
     * The aaOpDescs array is indexed by opcode, and each element is a sub-array (aOpDesc) that describes
     * the corresponding opcode. The sub-elements are as follows:
     *
     *      [0]: {number} of the opcode name (see INS.*)
     *      [1]: {number} containing the destination operand descriptor bit(s), if any
     *      [2]: {number} containing the source operand descriptor bit(s), if any
     *      [3]: {number} containing the occasional third operand descriptor bit(s), if any
     *
     * These sub-elements are all optional. If [0] is not present, the opcode is undefined; if [1] is not
     * present (or contains zero), the opcode has no (or only implied) operands; if [2] is not present, the
     * opcode has only a single operand.  And so on.
     */
    DebuggerX86.aaOpDescs = [
    /* 0x00 */ [DebuggerX86.INS.ADD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x01 */ [DebuggerX86.INS.ADD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x02 */ [DebuggerX86.INS.ADD,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x03 */ [DebuggerX86.INS.ADD,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x04 */ [DebuggerX86.INS.ADD,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x05 */ [DebuggerX86.INS.ADD,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x06 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_ES     | DebuggerX86.TYPE_IN],
    /* 0x07 */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_ES     | DebuggerX86.TYPE_OUT],

    /* 0x08 */ [DebuggerX86.INS.OR,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x09 */ [DebuggerX86.INS.OR,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x0A */ [DebuggerX86.INS.OR,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x0B */ [DebuggerX86.INS.OR,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x0C */ [DebuggerX86.INS.OR,    DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x0D */ [DebuggerX86.INS.OR,    DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x0E */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_CS     | DebuggerX86.TYPE_IN],
    /* 0x0F */ DebuggerX86.aOpDescPopCS,

    /* 0x10 */ [DebuggerX86.INS.ADC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x11 */ [DebuggerX86.INS.ADC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x12 */ [DebuggerX86.INS.ADC,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x13 */ [DebuggerX86.INS.ADC,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x14 */ [DebuggerX86.INS.ADC,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x15 */ [DebuggerX86.INS.ADC,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x16 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_SS     | DebuggerX86.TYPE_IN],
    /* 0x17 */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_SS     | DebuggerX86.TYPE_OUT],

    /* 0x18 */ [DebuggerX86.INS.SBB,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x19 */ [DebuggerX86.INS.SBB,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x1A */ [DebuggerX86.INS.SBB,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x1B */ [DebuggerX86.INS.SBB,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x1C */ [DebuggerX86.INS.SBB,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x1D */ [DebuggerX86.INS.SBB,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x1E */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_DS     | DebuggerX86.TYPE_IN],
    /* 0x1F */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_DS     | DebuggerX86.TYPE_OUT],

    /* 0x20 */ [DebuggerX86.INS.AND,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x21 */ [DebuggerX86.INS.AND,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x22 */ [DebuggerX86.INS.AND,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x23 */ [DebuggerX86.INS.AND,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x24 */ [DebuggerX86.INS.AND,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x25 */ [DebuggerX86.INS.AND,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x26 */ [DebuggerX86.INS.ES,    DebuggerX86.TYPE_PREFIX],
    /* 0x27 */ [DebuggerX86.INS.DAA],

    /* 0x28 */ [DebuggerX86.INS.SUB,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x29 */ [DebuggerX86.INS.SUB,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x2A */ [DebuggerX86.INS.SUB,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x2B */ [DebuggerX86.INS.SUB,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x2C */ [DebuggerX86.INS.SUB,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x2D */ [DebuggerX86.INS.SUB,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x2E */ [DebuggerX86.INS.CS,    DebuggerX86.TYPE_PREFIX],
    /* 0x2F */ [DebuggerX86.INS.DAS],

    /* 0x30 */ [DebuggerX86.INS.XOR,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x31 */ [DebuggerX86.INS.XOR,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x32 */ [DebuggerX86.INS.XOR,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x33 */ [DebuggerX86.INS.XOR,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x34 */ [DebuggerX86.INS.XOR,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x35 */ [DebuggerX86.INS.XOR,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x36 */ [DebuggerX86.INS.SS,    DebuggerX86.TYPE_PREFIX],
    /* 0x37 */ [DebuggerX86.INS.AAA],

    /* 0x38 */ [DebuggerX86.INS.CMP,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x39 */ [DebuggerX86.INS.CMP,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x3A */ [DebuggerX86.INS.CMP,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x3B */ [DebuggerX86.INS.CMP,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x3C */ [DebuggerX86.INS.CMP,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_IN,     DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x3D */ [DebuggerX86.INS.CMP,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_IN,     DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x3E */ [DebuggerX86.INS.DS,    DebuggerX86.TYPE_PREFIX],
    /* 0x3F */ [DebuggerX86.INS.AAS],

    /* 0x40 */ [DebuggerX86.INS.INC,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH],
    /* 0x41 */ [DebuggerX86.INS.INC,   DebuggerX86.TYPE_CX     | DebuggerX86.TYPE_BOTH],
    /* 0x42 */ [DebuggerX86.INS.INC,   DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_BOTH],
    /* 0x43 */ [DebuggerX86.INS.INC,   DebuggerX86.TYPE_BX     | DebuggerX86.TYPE_BOTH],
    /* 0x44 */ [DebuggerX86.INS.INC,   DebuggerX86.TYPE_SP     | DebuggerX86.TYPE_BOTH],
    /* 0x45 */ [DebuggerX86.INS.INC,   DebuggerX86.TYPE_BP     | DebuggerX86.TYPE_BOTH],
    /* 0x46 */ [DebuggerX86.INS.INC,   DebuggerX86.TYPE_SI     | DebuggerX86.TYPE_BOTH],
    /* 0x47 */ [DebuggerX86.INS.INC,   DebuggerX86.TYPE_DI     | DebuggerX86.TYPE_BOTH],

    /* 0x48 */ [DebuggerX86.INS.DEC,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH],
    /* 0x49 */ [DebuggerX86.INS.DEC,   DebuggerX86.TYPE_CX     | DebuggerX86.TYPE_BOTH],
    /* 0x4A */ [DebuggerX86.INS.DEC,   DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_BOTH],
    /* 0x4B */ [DebuggerX86.INS.DEC,   DebuggerX86.TYPE_BX     | DebuggerX86.TYPE_BOTH],
    /* 0x4C */ [DebuggerX86.INS.DEC,   DebuggerX86.TYPE_SP     | DebuggerX86.TYPE_BOTH],
    /* 0x4D */ [DebuggerX86.INS.DEC,   DebuggerX86.TYPE_BP     | DebuggerX86.TYPE_BOTH],
    /* 0x4E */ [DebuggerX86.INS.DEC,   DebuggerX86.TYPE_SI     | DebuggerX86.TYPE_BOTH],
    /* 0x4F */ [DebuggerX86.INS.DEC,   DebuggerX86.TYPE_DI     | DebuggerX86.TYPE_BOTH],

    /* 0x50 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_IN],
    /* 0x51 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_CX     | DebuggerX86.TYPE_IN],
    /* 0x52 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_IN],
    /* 0x53 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_BX     | DebuggerX86.TYPE_IN],
    /* 0x54 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_SP     | DebuggerX86.TYPE_IN],
    /* 0x55 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_BP     | DebuggerX86.TYPE_IN],
    /* 0x56 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_SI     | DebuggerX86.TYPE_IN],
    /* 0x57 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_DI     | DebuggerX86.TYPE_IN],

    /* 0x58 */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_OUT],
    /* 0x59 */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_CX     | DebuggerX86.TYPE_OUT],
    /* 0x5A */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_OUT],
    /* 0x5B */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_BX     | DebuggerX86.TYPE_OUT],
    /* 0x5C */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_SP     | DebuggerX86.TYPE_OUT],
    /* 0x5D */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_BP     | DebuggerX86.TYPE_OUT],
    /* 0x5E */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_SI     | DebuggerX86.TYPE_OUT],
    /* 0x5F */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_DI     | DebuggerX86.TYPE_OUT],

    /* 0x60 */ [DebuggerX86.INS.PUSHA, DebuggerX86.TYPE_NONE   | DebuggerX86.TYPE_80186],
    /* 0x61 */ [DebuggerX86.INS.POPA,  DebuggerX86.TYPE_NONE   | DebuggerX86.TYPE_80186],
    /* 0x62 */ [DebuggerX86.INS.BOUND, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80186, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x63 */ [DebuggerX86.INS.ARPL,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
    /* 0x64 */ [DebuggerX86.INS.FS,    DebuggerX86.TYPE_PREFIX | DebuggerX86.TYPE_80386],
    /* 0x65 */ [DebuggerX86.INS.GS,    DebuggerX86.TYPE_PREFIX | DebuggerX86.TYPE_80386],
    /* 0x66 */ [DebuggerX86.INS.OS,    DebuggerX86.TYPE_PREFIX | DebuggerX86.TYPE_80386],
    /* 0x67 */ [DebuggerX86.INS.AS,    DebuggerX86.TYPE_PREFIX | DebuggerX86.TYPE_80386],

    /* 0x68 */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80186],
    /* 0x69 */ [DebuggerX86.INS.IMUL,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80186, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x6A */ [DebuggerX86.INS.PUSH,  DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80186],
    /* 0x6B */ [DebuggerX86.INS.IMUL,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80186, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x6C */ [DebuggerX86.INS.INS,   DebuggerX86.TYPE_ESDI   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80186, DebuggerX86.TYPE_DX    | DebuggerX86.TYPE_IN],
    /* 0x6D */ [DebuggerX86.INS.INS,   DebuggerX86.TYPE_ESDI   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80186, DebuggerX86.TYPE_DX    | DebuggerX86.TYPE_IN],
    /* 0x6E */ [DebuggerX86.INS.OUTS,  DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_IN    | DebuggerX86.TYPE_80186, DebuggerX86.TYPE_DSSI | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x6F */ [DebuggerX86.INS.OUTS,  DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_IN    | DebuggerX86.TYPE_80186, DebuggerX86.TYPE_DSSI | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],

    /* 0x70 */ [DebuggerX86.INS.JO,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x71 */ [DebuggerX86.INS.JNO,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x72 */ [DebuggerX86.INS.JC,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x73 */ [DebuggerX86.INS.JNC,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x74 */ [DebuggerX86.INS.JZ,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x75 */ [DebuggerX86.INS.JNZ,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x76 */ [DebuggerX86.INS.JBE,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x77 */ [DebuggerX86.INS.JA,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],

    /* 0x78 */ [DebuggerX86.INS.JS,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x79 */ [DebuggerX86.INS.JNS,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x7A */ [DebuggerX86.INS.JP,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x7B */ [DebuggerX86.INS.JNP,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x7C */ [DebuggerX86.INS.JL,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x7D */ [DebuggerX86.INS.JGE,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x7E */ [DebuggerX86.INS.JLE,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x7F */ [DebuggerX86.INS.JG,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],

    /* 0x80 */ [DebuggerX86.INS.GRP1B, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x81 */ [DebuggerX86.INS.GRP1W, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x82 */ [DebuggerX86.INS.GRP1B, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x83 */ [DebuggerX86.INS.GRP1SW,DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x84 */ [DebuggerX86.INS.TEST,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x85 */ [DebuggerX86.INS.TEST,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_REG   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x86 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH],
    /* 0x87 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH],

    /* 0x88 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x89 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x8A */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0x8B */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x8C */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,  DebuggerX86.TYPE_SEGREG | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
    /* 0x8D */ [DebuggerX86.INS.LEA,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,  DebuggerX86.TYPE_MODMEM | DebuggerX86.TYPE_WORD ],
    /* 0x8E */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_SEGREG | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0x8F */ [DebuggerX86.INS.POP,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT],

    /* 0x90 */ [DebuggerX86.INS.NOP],
    /* 0x91 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_CX  | DebuggerX86.TYPE_BOTH],
    /* 0x92 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_DX  | DebuggerX86.TYPE_BOTH],
    /* 0x93 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_BX  | DebuggerX86.TYPE_BOTH],
    /* 0x94 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_SP  | DebuggerX86.TYPE_BOTH],
    /* 0x95 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_BP  | DebuggerX86.TYPE_BOTH],
    /* 0x96 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_SI  | DebuggerX86.TYPE_BOTH],
    /* 0x97 */ [DebuggerX86.INS.XCHG,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_BOTH,   DebuggerX86.TYPE_DI  | DebuggerX86.TYPE_BOTH],

    /* 0x98 */ [DebuggerX86.INS.CBW],
    /* 0x99 */ [DebuggerX86.INS.CWD],
    /* 0x9A */ [DebuggerX86.INS.CALL,  DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_FARP |  DebuggerX86.TYPE_IN],
    /* 0x9B */ [DebuggerX86.INS.WAIT],
    /* 0x9C */ [DebuggerX86.INS.PUSHF],
    /* 0x9D */ [DebuggerX86.INS.POPF],
    /* 0x9E */ [DebuggerX86.INS.SAHF],
    /* 0x9F */ [DebuggerX86.INS.LAHF],

    /* 0xA0 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMMOFF | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xA1 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMMOFF | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xA2 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_IMMOFF | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT,     DebuggerX86.TYPE_AL    | DebuggerX86.TYPE_IN],
    /* 0xA3 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_IMMOFF | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,     DebuggerX86.TYPE_AX    | DebuggerX86.TYPE_IN],
    /* 0xA4 */ [DebuggerX86.INS.MOVSB, DebuggerX86.TYPE_ESDI   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT,     DebuggerX86.TYPE_DSSI  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xA5 */ [DebuggerX86.INS.MOVSW, DebuggerX86.TYPE_ESDI   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,     DebuggerX86.TYPE_DSSI  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xA6 */ [DebuggerX86.INS.CMPSB, DebuggerX86.TYPE_ESDI   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN,      DebuggerX86.TYPE_DSSI  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xA7 */ [DebuggerX86.INS.CMPSW, DebuggerX86.TYPE_ESDI   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN,      DebuggerX86.TYPE_DSSI  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],

    /* 0xA8 */ [DebuggerX86.INS.TEST,  DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_IN,     DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xA9 */ [DebuggerX86.INS.TEST,  DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_IN,     DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xAA */ [DebuggerX86.INS.STOSB, DebuggerX86.TYPE_ESDI   | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT,   DebuggerX86.TYPE_AL    | DebuggerX86.TYPE_IN],
    /* 0xAB */ [DebuggerX86.INS.STOSW, DebuggerX86.TYPE_ESDI   | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,   DebuggerX86.TYPE_AX    | DebuggerX86.TYPE_IN],
    /* 0xAC */ [DebuggerX86.INS.LODSB, DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_DSSI | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xAD */ [DebuggerX86.INS.LODSW, DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_DSSI | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xAE */ [DebuggerX86.INS.SCASB, DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_IN,     DebuggerX86.TYPE_ESDI | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xAF */ [DebuggerX86.INS.SCASW, DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_IN,     DebuggerX86.TYPE_ESDI | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],

    /* 0xB0 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xB1 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_CL     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xB2 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_DL     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xB3 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_BL     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xB4 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_AH     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xB5 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_CH     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xB6 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_DH     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xB7 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_BH     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],

    /* 0xB8 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xB9 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_CX     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xBA */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xBB */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_BX     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xBC */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_SP     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xBD */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_BP     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xBE */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_SI     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xBF */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_DI     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],

    /* 0xC0 */ [DebuggerX86.INS.GRP2B, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80186,  DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
    /* 0xC1 */ [DebuggerX86.INS.GRP2W, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80186,  DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
    /* 0xC2 */ [DebuggerX86.INS.RET,   DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
    /* 0xC3 */ [DebuggerX86.INS.RET],
    /* 0xC4 */ [DebuggerX86.INS.LES,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,   DebuggerX86.TYPE_MODMEM  | DebuggerX86.TYPE_SEGP  | DebuggerX86.TYPE_IN],
    /* 0xC5 */ [DebuggerX86.INS.LDS,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,   DebuggerX86.TYPE_MODMEM  | DebuggerX86.TYPE_SEGP  | DebuggerX86.TYPE_IN],
    /* 0xC6 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT,   DebuggerX86.TYPE_IMM     | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xC7 */ [DebuggerX86.INS.MOV,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,   DebuggerX86.TYPE_IMM     | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],

    /* 0xC8 */ [DebuggerX86.INS.ENTER, DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80186,    DebuggerX86.TYPE_IMM   | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
    /* 0xC9 */ [DebuggerX86.INS.LEAVE, DebuggerX86.TYPE_NONE   | DebuggerX86.TYPE_80186],
    /* 0xCA */ [DebuggerX86.INS.RETF,  DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
    /* 0xCB */ [DebuggerX86.INS.RETF],
    /* 0xCC */ [DebuggerX86.INS.INT3],
    /* 0xCD */ [DebuggerX86.INS.INT,   DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xCE */ [DebuggerX86.INS.INTO],
    /* 0xCF */ [DebuggerX86.INS.IRET],

    /* 0xD0 */ [DebuggerX86.INS.GRP2B1,DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH,  DebuggerX86.TYPE_ONE    | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
    /* 0xD1 */ [DebuggerX86.INS.GRP2W1,DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH,  DebuggerX86.TYPE_ONE    | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
    /* 0xD2 */ [DebuggerX86.INS.GRP2BC,DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH,  DebuggerX86.TYPE_CL     | DebuggerX86.TYPE_IN],
    /* 0xD3 */ [DebuggerX86.INS.GRP2WC,DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH,  DebuggerX86.TYPE_CL     | DebuggerX86.TYPE_IN],
    /* 0xD4 */ [DebuggerX86.INS.AAM,   DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_BYTE],
    /* 0xD5 */ [DebuggerX86.INS.AAD,   DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_BYTE],
    /* 0xD6 */ [DebuggerX86.INS.SALC],
    /* 0xD7 */ [DebuggerX86.INS.XLAT],

    /* 0xD8 */ [DebuggerX86.INS.ESC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xD9 */ [DebuggerX86.INS.ESC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xDA */ [DebuggerX86.INS.ESC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xDB */ [DebuggerX86.INS.ESC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xDC */ [DebuggerX86.INS.ESC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xDD */ [DebuggerX86.INS.ESC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xDE */ [DebuggerX86.INS.ESC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xDF */ [DebuggerX86.INS.ESC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],

    /* 0xE0 */ [DebuggerX86.INS.LOOPNZ,DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xE1 */ [DebuggerX86.INS.LOOPZ, DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xE2 */ [DebuggerX86.INS.LOOP,  DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xE3 */ [DebuggerX86.INS.JCXZ,  DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xE4 */ [DebuggerX86.INS.IN,    DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
    /* 0xE5 */ [DebuggerX86.INS.IN,    DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_IMM  | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
    /* 0xE6 */ [DebuggerX86.INS.OUT,   DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN,    DebuggerX86.TYPE_AL   | DebuggerX86.TYPE_IN],
    /* 0xE7 */ [DebuggerX86.INS.OUT,   DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN,    DebuggerX86.TYPE_AX   | DebuggerX86.TYPE_IN],

    /* 0xE8 */ [DebuggerX86.INS.CALL,  DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xE9 */ [DebuggerX86.INS.JMP,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
    /* 0xEA */ [DebuggerX86.INS.JMP,   DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_FARP  | DebuggerX86.TYPE_IN],
    /* 0xEB */ [DebuggerX86.INS.JMP,   DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
    /* 0xEC */ [DebuggerX86.INS.IN,    DebuggerX86.TYPE_AL     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_DX   | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
    /* 0xED */ [DebuggerX86.INS.IN,    DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_OUT,    DebuggerX86.TYPE_DX   | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
    /* 0xEE */ [DebuggerX86.INS.OUT,   DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN,    DebuggerX86.TYPE_AL    | DebuggerX86.TYPE_IN],
    /* 0xEF */ [DebuggerX86.INS.OUT,   DebuggerX86.TYPE_DX     | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN,    DebuggerX86.TYPE_AX    | DebuggerX86.TYPE_IN],

    /* 0xF0 */ [DebuggerX86.INS.LOCK,  DebuggerX86.TYPE_PREFIX],
    /* 0xF1 */ [DebuggerX86.INS.INT1,  DebuggerX86.TYPE_NONE   | DebuggerX86.TYPE_80386],
    /* 0xF2 */ [DebuggerX86.INS.REPNZ, DebuggerX86.TYPE_PREFIX],
    /* 0xF3 */ [DebuggerX86.INS.REPZ,  DebuggerX86.TYPE_PREFIX],
    /* 0xF4 */ [DebuggerX86.INS.HLT],
    /* 0xF5 */ [DebuggerX86.INS.CMC],
    /* 0xF6 */ [DebuggerX86.INS.GRP3B, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH],
    /* 0xF7 */ [DebuggerX86.INS.GRP3W, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH],

    /* 0xF8 */ [DebuggerX86.INS.CLC],
    /* 0xF9 */ [DebuggerX86.INS.STC],
    /* 0xFA */ [DebuggerX86.INS.CLI],
    /* 0xFB */ [DebuggerX86.INS.STI],
    /* 0xFC */ [DebuggerX86.INS.CLD],
    /* 0xFD */ [DebuggerX86.INS.STD],
    /* 0xFE */ [DebuggerX86.INS.GRP4B, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH],
    /* 0xFF */ [DebuggerX86.INS.GRP4W, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH]
    ];

    DebuggerX86.aaOp0FDescs = {
        0x00: [DebuggerX86.INS.GRP6,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_BOTH],
        0x01: [DebuggerX86.INS.GRP7,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_BOTH],
        0x02: [DebuggerX86.INS.LAR,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_MODMEM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN],
        0x03: [DebuggerX86.INS.LSL,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_MODMEM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN],
        0x05: [DebuggerX86.INS.LOADALL,DebuggerX86.TYPE_80286],
        0x06: [DebuggerX86.INS.CLTS,   DebuggerX86.TYPE_80286],
        0x07: [DebuggerX86.INS.LOADALL,DebuggerX86.TYPE_80386],   // TODO: implied operand is ES:[(E)DI]
        0x20: [DebuggerX86.INS.MOV,    DebuggerX86.TYPE_MODREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_CTLREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_IN],
        0x21: [DebuggerX86.INS.MOV,    DebuggerX86.TYPE_MODREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_DBGREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_IN],
        0x22: [DebuggerX86.INS.MOV,    DebuggerX86.TYPE_CTLREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_IN],
        0x23: [DebuggerX86.INS.MOV,    DebuggerX86.TYPE_DBGREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_IN],
        0x24: [DebuggerX86.INS.MOV,    DebuggerX86.TYPE_MODREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_TSTREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_IN],
        0x26: [DebuggerX86.INS.MOV,    DebuggerX86.TYPE_TSTREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODREG | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_IN],
        0x80: [DebuggerX86.INS.JO,     DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x81: [DebuggerX86.INS.JNO,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x82: [DebuggerX86.INS.JC,     DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x83: [DebuggerX86.INS.JNC,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x84: [DebuggerX86.INS.JZ,     DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x85: [DebuggerX86.INS.JNZ,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x86: [DebuggerX86.INS.JBE,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x87: [DebuggerX86.INS.JA,     DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x88: [DebuggerX86.INS.JS,     DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x89: [DebuggerX86.INS.JNS,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x8A: [DebuggerX86.INS.JP,     DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x8B: [DebuggerX86.INS.JNP,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x8C: [DebuggerX86.INS.JL,     DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x8D: [DebuggerX86.INS.JGE,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x8E: [DebuggerX86.INS.JLE,    DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x8F: [DebuggerX86.INS.JG,     DebuggerX86.TYPE_IMMREL | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386],
        0x90: [DebuggerX86.INS.SETO,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x91: [DebuggerX86.INS.SETNO,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x92: [DebuggerX86.INS.SETC,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x93: [DebuggerX86.INS.SETNC,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x94: [DebuggerX86.INS.SETZ,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x95: [DebuggerX86.INS.SETNZ,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x96: [DebuggerX86.INS.SETBE,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x97: [DebuggerX86.INS.SETNBE, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x98: [DebuggerX86.INS.SETS,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x99: [DebuggerX86.INS.SETNS,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x9A: [DebuggerX86.INS.SETP,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x9B: [DebuggerX86.INS.SETNP,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x9C: [DebuggerX86.INS.SETL,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x9D: [DebuggerX86.INS.SETGE,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x9E: [DebuggerX86.INS.SETLE,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0x9F: [DebuggerX86.INS.SETG,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386],
        0xA0: [DebuggerX86.INS.PUSH,   DebuggerX86.TYPE_FS     | DebuggerX86.TYPE_IN    | DebuggerX86.TYPE_80386],
        0xA1: [DebuggerX86.INS.POP,    DebuggerX86.TYPE_FS     | DebuggerX86.TYPE_OUT   | DebuggerX86.TYPE_80386],
        0xA3: [DebuggerX86.INS.BT,     DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN   | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        0xA4: [DebuggerX86.INS.SHLD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        0xA5: [DebuggerX86.INS.SHLD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_CL  | DebuggerX86.TYPE_IN],
        0xA6: [DebuggerX86.INS.XBTS,   DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_AX  | DebuggerX86.TYPE_IN,  DebuggerX86.TYPE_CL    | DebuggerX86.TYPE_IN],
        0xA7: [DebuggerX86.INS.IBTS,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_AX     | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_CL  | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        0xA8: [DebuggerX86.INS.PUSH,   DebuggerX86.TYPE_GS     | DebuggerX86.TYPE_IN    | DebuggerX86.TYPE_80386],
        0xA9: [DebuggerX86.INS.POP,    DebuggerX86.TYPE_GS     | DebuggerX86.TYPE_OUT   | DebuggerX86.TYPE_80386],
        0xAB: [DebuggerX86.INS.BTS,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        0xAC: [DebuggerX86.INS.SHRD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        0xAD: [DebuggerX86.INS.SHRD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN, DebuggerX86.TYPE_CL  | DebuggerX86.TYPE_IN],
        0xAF: [DebuggerX86.INS.IMUL,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        0xB2: [DebuggerX86.INS.LSS,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,                           DebuggerX86.TYPE_MODMEM | DebuggerX86.TYPE_SEGP  | DebuggerX86.TYPE_IN],
        0xB3: [DebuggerX86.INS.BTR,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        0xB4: [DebuggerX86.INS.LFS,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,                           DebuggerX86.TYPE_MODMEM | DebuggerX86.TYPE_SEGP  | DebuggerX86.TYPE_IN],
        0xB5: [DebuggerX86.INS.LGS,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT,                           DebuggerX86.TYPE_MODMEM | DebuggerX86.TYPE_SEGP  | DebuggerX86.TYPE_IN],
        0xB6: [DebuggerX86.INS.MOVZX,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
        0xB7: [DebuggerX86.INS.MOVZX,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
        0xBA: [DebuggerX86.INS.GRP8,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_IMM    | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
        0xBB: [DebuggerX86.INS.BTC,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        0xBC: [DebuggerX86.INS.BSF,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        0xBD: [DebuggerX86.INS.BSR,    DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        0xBE: [DebuggerX86.INS.MOVSX,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
        0xBF: [DebuggerX86.INS.MOVSX,  DebuggerX86.TYPE_REG    | DebuggerX86.TYPE_LONG  | DebuggerX86.TYPE_OUT  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN]
    };

    /*
     * Be sure to keep the following table in sync with FPUX86.aaOps
     */
    DebuggerX86.aaaOpFPUDescs = {
        0xD8: {
            0x00: [DebuggerX86.FINS.FADD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x01: [DebuggerX86.FINS.FMUL,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x02: [DebuggerX86.FINS.FCOM,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x03: [DebuggerX86.FINS.FCOMP,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x04: [DebuggerX86.FINS.FSUB,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x05: [DebuggerX86.FINS.FSUBR,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x06: [DebuggerX86.FINS.FDIV,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x07: [DebuggerX86.FINS.FDIVR,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x30: [DebuggerX86.FINS.FADD,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST    | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x31: [DebuggerX86.FINS.FMUL,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST    | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x32: [DebuggerX86.FINS.FCOM,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST    | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x33: [DebuggerX86.FINS.FCOMP,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST    | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x34: [DebuggerX86.FINS.FSUB,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST    | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x35: [DebuggerX86.FINS.FSUBR,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST    | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x36: [DebuggerX86.FINS.FDIV,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST    | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x37: [DebuggerX86.FINS.FDIVR,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST    | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN]
        },
        0xD9: {
            0x00: [DebuggerX86.FINS.FLD,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_IN],
            0x02: [DebuggerX86.FINS.FST,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_OUT],
            0x03: [DebuggerX86.FINS.FSTP,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SREAL | DebuggerX86.TYPE_OUT],
            0x04: [DebuggerX86.FINS.FLDENV, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_ENV   | DebuggerX86.TYPE_IN],
            0x05: [DebuggerX86.FINS.FLDCW,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x06: [DebuggerX86.FINS.FSTENV, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_ENV   | DebuggerX86.TYPE_OUT],
            0x07: [DebuggerX86.FINS.FSTCW,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT],
            0x30: [DebuggerX86.FINS.FLD,    DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT],
            0x31: [DebuggerX86.FINS.FXCH,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT],
            0x32: [DebuggerX86.FINS.FNOP],
            0x33: [DebuggerX86.FINS.FSTP,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT],   // Obsolete encoding
            0x40: [DebuggerX86.FINS.FCHS],
            0x41: [DebuggerX86.FINS.FABS],
            0x44: [DebuggerX86.FINS.FTST],
            0x45: [DebuggerX86.FINS.FXAM],
            0x50: [DebuggerX86.FINS.FLD1],
            0x51: [DebuggerX86.FINS.FLDL2T],
            0x52: [DebuggerX86.FINS.FLDL2E],
            0x53: [DebuggerX86.FINS.FLDPI],
            0x54: [DebuggerX86.FINS.FLDLG2],
            0x55: [DebuggerX86.FINS.FLDLN2],
            0x56: [DebuggerX86.FINS.FLDZ],
            0x60: [DebuggerX86.FINS.F2XM1],
            0x61: [DebuggerX86.FINS.FYL2X],
            0x62: [DebuggerX86.FINS.FPTAN],
            0x63: [DebuggerX86.FINS.FPATAN],
            0x64: [DebuggerX86.FINS.FXTRACT],
            0x66: [DebuggerX86.FINS.FDECSTP],
            0x67: [DebuggerX86.FINS.FINCSTP],
            0x70: [DebuggerX86.FINS.FPREM],
            0x71: [DebuggerX86.FINS.FYL2XP1],
            0x72: [DebuggerX86.FINS.FSQRT],
            0x74: [DebuggerX86.FINS.FRNDINT],
            0x75: [DebuggerX86.FINS.FSCALE]
        },
        0xDA: {
            0x00: [DebuggerX86.FINS.FIADD,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT | DebuggerX86.TYPE_IN],
            0x01: [DebuggerX86.FINS.FIMUL,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT | DebuggerX86.TYPE_IN],
            0x02: [DebuggerX86.FINS.FICOM,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT | DebuggerX86.TYPE_IN],
            0x03: [DebuggerX86.FINS.FICOMP, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT | DebuggerX86.TYPE_IN],
            0x04: [DebuggerX86.FINS.FISUB,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT | DebuggerX86.TYPE_IN],
            0x05: [DebuggerX86.FINS.FISUBR, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT | DebuggerX86.TYPE_IN],
            0x06: [DebuggerX86.FINS.FIDIV,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT | DebuggerX86.TYPE_IN],
            0x07: [DebuggerX86.FINS.FIDIVR, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT | DebuggerX86.TYPE_IN]
        },
        0xDB: {
            0x00: [DebuggerX86.FINS.FILD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT  | DebuggerX86.TYPE_IN],
            0x02: [DebuggerX86.FINS.FIST,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT  | DebuggerX86.TYPE_OUT],
            0x03: [DebuggerX86.FINS.FISTP,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SINT  | DebuggerX86.TYPE_OUT],
            0x05: [DebuggerX86.FINS.FLD,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_TREAL | DebuggerX86.TYPE_IN],
            0x07: [DebuggerX86.FINS.FSTP,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_TREAL | DebuggerX86.TYPE_OUT],
            0x40: [DebuggerX86.FINS.FENI],
            0x41: [DebuggerX86.FINS.FDISI],
            0x42: [DebuggerX86.FINS.FCLEX],
            0x43: [DebuggerX86.FINS.FINIT],
            0x44: [DebuggerX86.FINS.FSETPM,  DebuggerX86.TYPE_80287],
            0x73: [DebuggerX86.FINS.FSINCOS, DebuggerX86.TYPE_80387]
        },
        0xDC: {
            0x00: [DebuggerX86.FINS.FADD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x01: [DebuggerX86.FINS.FMUL,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x02: [DebuggerX86.FINS.FCOM,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x03: [DebuggerX86.FINS.FCOMP,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x04: [DebuggerX86.FINS.FSUB,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x05: [DebuggerX86.FINS.FSUBR,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x06: [DebuggerX86.FINS.FDIV,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x07: [DebuggerX86.FINS.FDIVR,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x30: [DebuggerX86.FINS.FADD,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x31: [DebuggerX86.FINS.FMUL,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x32: [DebuggerX86.FINS.FCOM,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],    // Obsolete encoding
            0x33: [DebuggerX86.FINS.FCOMP,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],    // Obsolete encoding
            0x34: [DebuggerX86.FINS.FSUBR,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x35: [DebuggerX86.FINS.FSUB,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x36: [DebuggerX86.FINS.FDIVR,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x37: [DebuggerX86.FINS.FDIV,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN]
        },
        0xDD: {
            0x00: [DebuggerX86.FINS.FLD,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_IN],
            0x02: [DebuggerX86.FINS.FST,    DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_OUT],
            0x03: [DebuggerX86.FINS.FSTP,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LREAL | DebuggerX86.TYPE_OUT],
            0x04: [DebuggerX86.FINS.FRSTOR, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_FPU   | DebuggerX86.TYPE_IN],
            0x06: [DebuggerX86.FINS.FSAVE,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_FPU   | DebuggerX86.TYPE_OUT],
            0x07: [DebuggerX86.FINS.FSTSW,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT],
            0x30: [DebuggerX86.FINS.FFREE,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x31: [DebuggerX86.FINS.FXCH,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT],   // Obsolete encoding
            0x32: [DebuggerX86.FINS.FST,    DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x33: [DebuggerX86.FINS.FSTP,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN]
        },
        0xDE: {
            0x00: [DebuggerX86.FINS.FIADD,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x01: [DebuggerX86.FINS.FIMUL,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x02: [DebuggerX86.FINS.FICOM,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x03: [DebuggerX86.FINS.FICOMP, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x04: [DebuggerX86.FINS.FISUB,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x05: [DebuggerX86.FINS.FISUBR, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x06: [DebuggerX86.FINS.FIDIV,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x07: [DebuggerX86.FINS.FIDIVR, DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x30: [DebuggerX86.FINS.FADDP,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x31: [DebuggerX86.FINS.FMULP,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x32: [DebuggerX86.FINS.FCOMP,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],    // Obsolete encoding
            0x33: [DebuggerX86.FINS.FCOMPP, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],
            0x34: [DebuggerX86.FINS.FSUBRP, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x35: [DebuggerX86.FINS.FSUBP,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x36: [DebuggerX86.FINS.FDIVRP, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN],
            0x37: [DebuggerX86.FINS.FDIVP,  DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_ST | DebuggerX86.TYPE_IN]
        },
        0xDF: {
            0x00: [DebuggerX86.FINS.FILD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_IN],
            0x02: [DebuggerX86.FINS.FIST,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT],
            0x03: [DebuggerX86.FINS.FISTP,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_SHORT | DebuggerX86.TYPE_OUT],
            0x04: [DebuggerX86.FINS.FBLD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BCD80 | DebuggerX86.TYPE_IN],
            0x05: [DebuggerX86.FINS.FILD,   DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LINT  | DebuggerX86.TYPE_IN],
            0x06: [DebuggerX86.FINS.FBSTP,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_BCD80 | DebuggerX86.TYPE_OUT],
            0x07: [DebuggerX86.FINS.FISTP,  DebuggerX86.TYPE_MODRM  | DebuggerX86.TYPE_LINT  | DebuggerX86.TYPE_OUT],
            0x30: [DebuggerX86.FINS.FFREEP, DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],    // Obsolete encoding
            0x31: [DebuggerX86.FINS.FXCH,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_OUT],   // Obsolete encoding
            0x32: [DebuggerX86.FINS.FSTP,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],    // Obsolete encoding
            0x33: [DebuggerX86.FINS.FSTP,   DebuggerX86.TYPE_IMPREG | DebuggerX86.TYPE_STREG | DebuggerX86.TYPE_IN],    // Obsolete encoding
            0x34: [DebuggerX86.FINS.FSTSWAX, DebuggerX86.TYPE_80287]
        }
    };

    DebuggerX86.aaGrpDescs = [
      [
        /* GRP1B */
        [DebuggerX86.INS.ADD,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.OR,   DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ADC,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SBB,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.AND,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SUB,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.XOR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.CMP,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP1W */
        [DebuggerX86.INS.ADD,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.OR,   DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ADC,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SBB,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.AND,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SUB,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.XOR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.CMP,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP1SW */
        [DebuggerX86.INS.ADD,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.OR,   DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ADC,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SBB,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.AND,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SUB,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.XOR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.CMP,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_SBYTE | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP2B */
        [DebuggerX86.INS.ROL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ROR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.SAR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP2W */
        [DebuggerX86.INS.ROL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ROR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.SAR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH | DebuggerX86.TYPE_80286, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP2B1 */
        [DebuggerX86.INS.ROL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ROR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.SAR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP2W1 */
        [DebuggerX86.INS.ROL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ROR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.SAR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_ONE | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP2BC */
        [DebuggerX86.INS.ROL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ROR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.SAR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP2WC */
        [DebuggerX86.INS.ROL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.ROR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.RCR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.SHR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.SAR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH, DebuggerX86.TYPE_CL | DebuggerX86.TYPE_IN]
      ],
      [
        /* GRP3B */
        [DebuggerX86.INS.TEST, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.NOT,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.NEG,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.MUL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.IMUL, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.DIV,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.IDIV, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH]
      ],
      [
        /* GRP3W */
        [DebuggerX86.INS.TEST, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN,   DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.NOT,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.NEG,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.MUL,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.IMUL, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.DIV,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.IDIV, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH]
      ],
      [
        /* GRP4B */
        [DebuggerX86.INS.INC,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.DEC,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_BYTE  | DebuggerX86.TYPE_BOTH],
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined
      ],
      [
        /* GRP4W */
        [DebuggerX86.INS.INC,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.DEC,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_BOTH],
        [DebuggerX86.INS.CALL, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.CALL, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_FARP  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.JMP,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.JMP,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_FARP  | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.PUSH, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN],
         DebuggerX86.aOpDescUndefined
      ],
      [ /* OP0F */ ],
      [
        /* GRP6 */
        [DebuggerX86.INS.SLDT, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_OUT | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.STR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_OUT | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.LLDT, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN  | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.LTR,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN  | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.VERR, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN  | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.VERW, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN  | DebuggerX86.TYPE_80286],
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined
      ],
      [
        /* GRP7 */
        [DebuggerX86.INS.SGDT, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_OUT | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.SIDT, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_OUT | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.LGDT, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN  | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.LIDT, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN  | DebuggerX86.TYPE_80286],
        [DebuggerX86.INS.SMSW, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_OUT | DebuggerX86.TYPE_80286],
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.LMSW, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_SHORT| DebuggerX86.TYPE_IN  | DebuggerX86.TYPE_80286],
         DebuggerX86.aOpDescUndefined
      ],
      [
        /* GRP8 */
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined,
         DebuggerX86.aOpDescUndefined,
        [DebuggerX86.INS.BT,  DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_IN  | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.BTS, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.BTR, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN],
        [DebuggerX86.INS.BTC, DebuggerX86.TYPE_MODRM | DebuggerX86.TYPE_WORD  | DebuggerX86.TYPE_OUT | DebuggerX86.TYPE_80386, DebuggerX86.TYPE_IMM | DebuggerX86.TYPE_BYTE | DebuggerX86.TYPE_IN]
      ]
    ];

    /*
     * Table of system (non-segment) descriptors, including indicators of which ones are gates.
     */
    DebuggerX86.SYSDESCS = {
        0x0100: ["tss286",       false],
        0x0200: ["ldt",          false],
        0x0300: ["busy tss286",  false],
        0x0400: ["call gate",    true],
        0x0500: ["task gate",    true],
        0x0600: ["int gate286",  true],
        0x0700: ["trap gate286", true],
        0x0900: ["tss386",       false],
        0x0B00: ["busy tss386",  false],
        0x0C00: ["call gate386", true],
        0x0E00: ["int gate386",  true],
        0x0F00: ["trap gate386", true]
    };

    /*
     * TSS field names and offsets used by dumpTSS()
     */
    DebuggerX86.TSS286 = {
        "PREV_TSS":     0x00,
        "CPL0_SP":      0x02,
        "CPL0_SS":      0x04,
        "CPL1_SP":      0x06,
        "CPL1_SS":      0x08,
        "CPL2_SP":      0x0a,
        "CPL2_SS":      0x0c,
        "TASK_IP":      0x0e,
        "TASK_PS":      0x10,
        "TASK_AX":      0x12,
        "TASK_CX":      0x14,
        "TASK_DX":      0x16,
        "TASK_BX":      0x18,
        "TASK_SP":      0x1a,
        "TASK_BP":      0x1c,
        "TASK_SI":      0x1e,
        "TASK_DI":      0x20,
        "TASK_ES":      0x22,
        "TASK_CS":      0x24,
        "TASK_SS":      0x26,
        "TASK_DS":      0x28,
        "TASK_LDT":     0x2a
    };
    DebuggerX86.TSS386 = {
        "PREV_TSS":     0x00,
        "CPL0_ESP":     0x04,
        "CPL0_SS":      0x08,
        "CPL1_ESP":     0x0c,
        "CPL1_SS":      0x10,
        "CPL2_ESP":     0x14,
        "CPL2_SS":      0x18,
        "TASK_CR3":     0x1C,
        "TASK_EIP":     0x20,
        "TASK_PS":      0x24,
        "TASK_EAX":     0x28,
        "TASK_ECX":     0x2C,
        "TASK_EDX":     0x30,
        "TASK_EBX":     0x34,
        "TASK_ESP":     0x38,
        "TASK_EBP":     0x3C,
        "TASK_ESI":     0x40,
        "TASK_EDI":     0x44,
        "TASK_ES":      0x48,
        "TASK_CS":      0x4C,
        "TASK_SS":      0x50,
        "TASK_DS":      0x54,
        "TASK_FS":      0x58,
        "TASK_GS":      0x5C,
        "TASK_LDT":     0x60,
        "TASK_IOPM":    0x64
    };

    /*
     * Initialize every Debugger module on the page (as IF there's ever going to be more than one ;-))
     */
    Web.onInit(DebuggerX86.init);

}   // endif DEBUGGER



/**
 * @copyright https://www.pcjs.org/modules/pcx86/lib/computer.js (C) Jeff Parsons 2012-2018
 */

/*
 * BUILD INSTRUCTIONS
 *
 * To build PCx86 (pcx86.js), run Google's Closure Compiler, replacing "*.js" with the input file sequence defined
 * by the "PCx86Files" property in package.json:
 *
 *      java -jar compiler.jar
 *          --compilation_level ADVANCED_OPTIMIZATIONS
 *          --define='DEBUG=false'
 *          --warning_level=VERBOSE
 *          --js *.js
 *          --js_output_file pc.js
 *
 * Google's Closure Compiler (compiler.jar) is documented at https://developers.google.com/closure/compiler/
 * and is available for download here:
 *
 *      http://closure-compiler.googlecode.com/files/compiler-latest.zip
 *
 * The PCx86 JavaScript files do have some initialization-order dependencies.  If you load the files individually,
 * it's recommended that you load them in the same order that they're compiled.
 *
 * Generally speaking, component.js should be first, computer.js should be last (of the files based on component.js),
 * and panel.js should be listed early so that the Control Panel is ready as soon as possible.
 *
 * Another recent ordering requirement is that rom.js must be loaded before ram.js; this was true before, but now
 * it's required, because I'm starting to add ROM BIOS Data Area definitions to rom.js, and since the data area
 * is in RAM, ram.js may want access to some of those definitions.
 */



/**
 * class Computer
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Computer extends Component {
    /**
     * Computer(parmsComputer, parmsMachine, fSuspended)
     *
     * The Computer component has no required (parmsComputer) properties, but it does
     * support the following:
     *
     *      autoPower: true to automatically power the computer (default), false to wait;
     *      false is honored only if a "power" button binding exists.
     *
     *      busWidth: number of memory address lines (address bits) on the computer's "bus";
     *      20 is the minimum (and the default), which implies 8086/8088 real-mode addressing,
     *      while 24 is required for 80286 protected-mode addressing.  This value is passed
     *      directly through to the Bus component; see that component for more details.
     *
     *      resume: one of the Computer.RESUME constants, which are as follows:
     *          '0' if resume disabled (default)
     *          '1' if enabled without prompting
     *          '2' if enabled with prompting
     *          '3' if enabled with prompting and auto-delete
     *          or a string containing the path of a predefined JSON-encoded state
     *
     *      state: the path to JSON-encoded state file (see details regarding 'state' below)
     *
     * The parmsMachine object, if provided, may contain any of:
     *
     *      autoMount: if set, this should override any 'autoMount' property in the FDC's
     *      parmsFDC object.
     *
     *      autoPower: if set, this should override any 'autoPower' property in the Computer's
     *      parmsComputer object.
     *
     *      messages: if set, this should override any 'messages' property in the Debugger's
     *      parmsDbg object.
     *
     *      state: if set, this should override any 'state' property in the Computer's
     *      parmsComputer object.
     *
     *      url: the location of the machine XML file
     *
     *      diagnostics: 0 for none, 1 for normal diagnostics, and 2 for diagnostics with prompting
     *
     * If a predefined state is supplied AND it's successfully loaded, then resume behavior
     * defaults to '1' (ie, resume enabled without prompting).
     *
     * This component insures that all components are ready before "powering" them.
     *
     * Different components become ready at different times, and initialization order (ie,
     * the order the scripts are combined on the page) only partially determines readiness.
     * This is because components like ROM and Video must finish loading their resource files
     * before they are ready.  Other components become ready after we call their initBus()
     * function, because they have a Bus or CPU dependency, such as access to memory management
     * functions.  And other components, like CPU and Panel, are ready as soon as their
     * constructor finishes.
     *
     * Once a component has indicated it's ready, we call its powerUp() notification
     * function (if it has one--it's optional).  We call the CPU's powerUp() function last,
     * so that the CPU is assured that all other components are ready and "powered".
     *
     * @this {Computer}
     * @param {Object} parmsComputer
     * @param {Object} [parmsMachine]
     * @param {boolean} [fSuspended]
     */
    constructor(parmsComputer, parmsMachine, fSuspended)
    {
        super("Computer", parmsComputer, Messages.COMPUTER);

        let cmp = this;
        this.setMachineParms(parmsMachine);

        this.fAutoPower = this.getMachineParm('autoPower', parmsComputer);
        this.nDiagnostics = +this.getMachineParm('diagnostics', parmsComputer);
        if (!(this.nDiagnostics >= 0 && this.nDiagnostics <= 2)) this.nDiagnostics = 1;

        /*
         * nPowerChange is 0 while the power state is stable, 1 while power is transitioning
         * to "on", and -1 while power is transitioning to "off".
         */
        this.nPowerChange = 0;

        /*
         * TODO: Deprecate 'buswidth' (it should have always used camelCase)
         */
        this.nBusWidth = parmsComputer['busWidth'] || parmsComputer['buswidth'];

        this.resume = Computer.RESUME_NONE;
        this.sStateData = null;
        this.fStateData = false;            // remembers if sStateData was loaded
        this.fServerState = false;

        this.url = this.getMachineParm('url') || "";

        /*
         * Generate a random number x (where 0 <= x < 1), add 0.1 so that it's guaranteed to be
         * non-zero, convert to base 36, and chop off the leading digit and "decimal" point.
         */
        this.sMachineID = (Math.random() + 0.1).toString(36).substr(2,12);
        this.sUserID = this.queryUserID();

        /*
         * Find the appropriate CPU (and Debugger and Control Panel, if any)
         *
         * CLOSURE COMPILER TIP: To override the type of a right-hand expression (as we need to do here,
         * where we know getComponentByType() will only return an CPUX86 object or null), wrap the expression
         * in parentheses.  I never knew this until I stumbled across it in "Closure: The Definitive Guide".
         */
        this.cpu = /** @type {CPUX86} */ (Component.getComponentByType("CPU", this.id));
        if (!this.cpu) {
            Component.error("Unable to find CPU component");
            return;
        }
        this.dbg = /** @type {DebuggerX86} */ (Component.getComponentByType("Debugger", this.id));

        /*
         * Enumerate all the Video components for diagnostic displays, focus changes, and updateStatus() calls.
         */
        this.aVideo = [];
        for (let video = null; (video = this.getMachineComponent("Video", video));) {
            this.aVideo.push(video);
        }

        /*
         * Initialize the Bus component
         */
        this.bus = new Bus({'id': this.idMachine + '.bus', 'busWidth': this.nBusWidth}, this.cpu, this.dbg);

        /*
         * Iterate through all the components and override their notice() and println() methods
         * so that their output can be rerouted to a Diagnostic Display or Control Panel, if any.
         */
        let iComponent, component;
        let aComponents = Component.getComponents(this.id);

        this.panel = /** @type {Panel} */ (Component.getComponentByType("Panel", this.id));
        this.controlPanel = this.panel && this.panel.bindings['print'];

        this.noticeComputer = this.notice;
        this.printComputer = this.print;
        this.printlnComputer = this.println;
        if (this.controlPanel) {
            this.noticeComputer = this.panel.notice;
            this.printComputer = this.panel.print;
            this.printlnComputer = this.panel.println;
        }

        for (iComponent = 0; iComponent < aComponents.length; iComponent++) {
            component = aComponents[iComponent];
            component.notice = function noticeComputer(s, fPrintOnly, id) {
                cmp.outputDiagnostics(s);
                return cmp.noticeComputer.call(this, s, fPrintOnly, id);
            }.bind(component);
            component.print = function printComputer(s) {
                return cmp.printComputer.call(this, s);
            }.bind(component);
            component.println = function printlnComputer(s, type, id) {
                cmp.outputDiagnostics(s, type);
                return cmp.printlnComputer.call(this, s, type, id);
            }.bind(component);
        }

        this.cDiagnosticScreens = 0;
        if (!this.controlPanel && this.nDiagnostics) {
            this.enableDiagnostics();
        }

        this.println(PCX86.APPNAME + " v" + (XMLVERSION || PCX86.APPVERSION) + "\n" + COPYRIGHT + "\n" + LICENSE);

        if (DEBUG && this.messageEnabled()) this.printMessage("PREFETCH: " + PREFETCH + ", TYPEDARRAYS: " + TYPEDARRAYS);

        /*
         * Iterate through all the components again and call their initBus() handler, if any
         */
        for (iComponent = 0; iComponent < aComponents.length; iComponent++) {
            component = aComponents[iComponent];
            if (component.initBus) component.initBus(this, this.bus, this.cpu, this.dbg);
        }

        /*
         * This timer replaces the CPU's old dedicated STATUS_UPDATES_PER_SECOND logic; periodic updateStatus()
         * calls are now our own responsibility.
         */
        this.cpu.addTimer(this.id, function updateStatusTimer() {
            cmp.updateStatus();
        }, 1000 / Computer.UPDATES_PER_SECOND);

        let sStatePath = null;
        let sResume = this.getMachineParm('resume');
        if (sResume !== undefined) {
            /*
             * Decide whether the 'resume' property is a number or the path of a state file to resume.
             */
            if (sResume.length > 1) {
                sStatePath = this.sResumePath = sResume;
            } else {
                this.resume = parseInt(sResume, 10);
            }
        }

        /*
         * The Computer 'state' property allows a state file to be specified independent of the 'resume' feature;
         * previously, you could only use 'resume' to load a state file -- which we still support, but loading a state
         * file that way prevents the machine's state from being saved, since we always resume from the 'resume' file.
         *
         * The other wrinkle is on the restore side: we need to IGNORE the 'state' property if a saved state now exists.
         * So we have to peek at localStorage, and unfortunately, the only way to "peek" is to actually load the data,
         * but we're not ready to use it yet, so powerUp() has been changed to use any existing stateComputer that we've
         * already loaded.
         *
         * However, there's now a wrinkle to the wrinkle: if a 'state' parameter has been passed via the URL, then that
         * OVERRIDES everything; it overrides any 'state' Computer parameter AND it disables resume of any saved state in
         * localStorage (in other words, it prevents fAllowResume from being true, and forcing resume off).
         */
        let fAllowResume = false;
        let sState = Web.getURLParm('state');
        if (!sState) {
            fAllowResume = true;
            sState = this.getMachineParm('state', parmsComputer);
        }
        if (sState) {
            sStatePath = this.sStatePath = sState;
            if (!fAllowResume) {
                this.fServerState = true;
                this.resume = Computer.RESUME_NONE;
            }
            if (this.resume) {
                this.stateComputer = new State(this, PCX86.APPVERSION);
                if (this.stateComputer.load()) {
                    sStatePath = null;
                } else {
                    delete this.stateComputer;
                }
            }
        }

        /*
         * If sStatePath is set, we must use it.  But if there's no sStatePath AND resume is set,
         * then we have the option of resuming from a server-side state, assuming a valid USERID.
         */
        if (!sStatePath && this.resume) {
            sStatePath = this.getServerStatePath();
            if (sStatePath) this.fServerState = true;
        }

        this.sStateURL = sStatePath;

        if (!this.sStateURL) {
            this.setReady();
        } else {
            let sProgress = "Loading " + this.sStateURL + "...";
            Web.getResource(this.sStateURL, null, true, function(sURL, sResource, nErrorCode) {
                cmp.doneLoad(sURL, sResource, nErrorCode);
            }, function(nState) {
                cmp.println(sProgress, Component.PRINT.PROGRESS);
            });
        }

        if (!this.bindings["power"]) this.fAutoPower = true;

        /*
         * Power on the computer, giving every component the opportunity to reset or restore itself.
         */
        if (!fSuspended && this.fAutoPower) this.wait(this.powerOn);
    }

    /**
     * clearPanel()
     *
     * @this {Computer}
     */
    clearPanel()
    {
        if (this.controlPanel) {
            this.controlPanel.value = "";
        }
    }

    /**
     * enableDiagnostics()
     *
     * @this {Computer}
     */
    enableDiagnostics()
    {
        if (!this.cDiagnosticScreens) {
            for (let i = 0; i < this.aVideo.length; i++) {
                let video = this.aVideo[i];
                if (video) {
                    let control = video.getTextArea();
                    if (control) {
                        /*
                         * By default, the Video textarea overlay has opacity and lineHeight styles set to "0"
                         * to make the overall textarea and its blinking caret invisible (respectively), so in order
                         * to use it as a diagnostic display, we must temporarily set both those styles to "1".
                         */
                        control.style.opacity = "1";
                        control.style.lineHeight = "1";
                        // control.style.fontSize = "1.5vw";    // this is a nice idea, but it doesn't work well with side-by-side machines
                        this.cDiagnosticScreens++;
                    }
                }
            }
        }
    }

    /**
     * disableDiagnostics()
     *
     * @this {Computer}
     * @return {boolean} (true if diagnostics were, or already are, disabled; false if they remain enabled)
     */
    disableDiagnostics()
    {
        if (this.cDiagnosticScreens) {
            if (this.nDiagnostics == 2) {
                this.nDiagnostics++;
                this.println("Press any key to continue...");
                return false;
            }
            for (let i = 0; i < this.aVideo.length; i++) {
                let video = this.aVideo[i];
                if (video) {
                    let control = video.getTextArea();
                    if (control) {
                        /*
                         * Return the Video textarea overlay's opacity and lineHeight styles to their original values.
                         */
                        control.style.opacity = "0";
                        control.style.lineHeight = "0";
                        /*
                         * Setting lineHeight in IE isn't sufficient to hide the caret; we must also set fontSize to "0",
                         * and we make the change IE-specific because it can have weird side-effects in other browsers (eg,
                         * it makes Safari on iOS over-zoom whenever the textarea receives focus).
                         */
                        if (Web.isUserAgent("MSIE")) control.style.fontSize = "0";
                        control.value = "";
                    }
                }
            }
            this.cDiagnosticScreens = 0;
        }
        this.nDiagnostics = 0;
        return true;
    }

    /**
     * outputDiagnostics(sMessage, sType)
     *
     * @this {Computer}
     * @param {string} sMessage
     * @param {string} [sType]
     */
    outputDiagnostics(sMessage, sType)
    {
        if (this.cDiagnosticScreens) {
            for (let i = 0; i < this.aVideo.length; i++) {
                let video = this.aVideo[i];
                if (video) {
                    let control = video.getTextArea();
                    if (control) {
                        if (sType != Component.PRINT.PROGRESS || sMessage.slice(-3) != "...") {
                            Component.appendControl(control, sMessage + '\n');
                        } else {
                            Component.replaceControl(control, sMessage, sMessage + '.');
                        }
                    }
                }
            }
        }
    }

    /**
     * notifyKbdEvent(event, fDown)
     *
     * This is called by the Keyboard component for all key presses, and it is effectively a no-op except
     * in the one special case where disableDiagnostics() has delayed powerOn until a key is pressed.
     *
     * @this {Computer}
     * @param {Object} [event]
     * @param {boolean} [fDown] is true for a keyDown event, false for a keyUp event
     * @return {boolean} (true if diagnostics disabled, false if enabled -- at the time of the call)
     */
    notifyKbdEvent(event, fDown)
    {
        let nDiagnostics = this.nDiagnostics;
        if (this.nDiagnostics == 3) {
            this.nDiagnostics++;
            this.setReady();    // this may trigger a call to disableDiagnostics(), which is why we snapshot nDiagnostics
        }
        return !nDiagnostics;
    }

    /**
     * getMachineID()
     *
     * @this {Computer}
     * @return {string}
     */
    getMachineID()
    {
        return this.sMachineID;
    }

    /**
     * setMachineParms(parmsMachine)
     *
     * If no explicit machine parms were provided, then we check for 'parms' in the bundled resources (if any).
     *
     * @this {Computer}
     * @param {Object} [parmsMachine]
     */
    setMachineParms(parmsMachine)
    {
        if (!parmsMachine) {
            let sParms;
            if (typeof resources == 'object' && (sParms = resources['parms'])) {
                try {
                    parmsMachine = /** @type {Object} */ (eval("(" + sParms + ")"));    // jshint ignore:line
                } catch(err) {
                    Component.error(err.message + " (" + sParms + ")");
                }
            }
        }
        this.parmsMachine = parmsMachine;
    }

    /**
     * getMachineBoolean(sParm, fDefault)
     *
     * Boolean-specific version of getMachineParm().
     *
     * @this {Computer}
     * @param {string} sParm
     * @param {boolean} fDefault
     * @return {boolean}
     */
    getMachineBoolean(sParm, fDefault)
    {
        let f = fDefault;
        let s = this.getMachineParm(sParm);
        if (s != undefined) {
            f = (s == "true"? true : (s == "false"? false : !!s));
        }
        return f;
    }

    /**
     * getMachineParm(sParm, parmsComponent)
     *
     * If the machine parameter doesn't exist, we check for a matching component parameter (if parmsComponent
     * is provided), and failing that, we check the bundled resources (if any).
     *
     * At the moment, the only bundled resource request we expect to encounter is 'state'; if it exists, then
     * we return 'state' back to the caller (ie, the name of the resource), so that the caller will then attempt
     * to load the 'state' resource to obtain the actual state.
     *
     * TODO: This function could (and perhaps should) be modified to accept an optional type parameter (ie,
     * one of the values in Component.TYPE), so that parms like autoMount could be eval'ed here rather than by
     * the caller (eg, FDC.parseConfig()).  The downside is that this function would have to return multiple types,
     * so every call would have to be cast to the expected type.
     *
     * @this {Computer}
     * @param {string} sParm
     * @param {Object} [parmsComponent] (eg, this.parms)
     * @return {string|undefined}
     */
    getMachineParm(sParm, parmsComponent)
    {
        let value = Web.getURLParm(sParm);
        if (value) {
            try {
                /*
                 * Ideally, we could simply use strings as-is, but unfortunately, we need to convert all
                 * supported escape sequences to their underlying characters, and using eval() is the simplest
                 * way to deal with them; eg:
                 *
                 *      \', \", \r, \n, \t, and \xNN
                 *
                 * When a string containing the above sequences is passed as a machine or component parameter
                 * (ie, as an embedPC() machine parameter or as XML component attribute), that conversion happens
                 * automatically, either by virtue of implicit script evaluation, or by explicit eval() in
                 * getComponentParms().  But when they're passed as a URL parameter, any backslashes are passed
                 * through as-is.
                 *
                 * The complete list of backslash sequences supported by JavaScript:
                 *
                 *      \0  \'  \"  \\  \n  \r  \v  \t  \b  \f  \uXXXX \xXX
                 *                      ^J  ^M  ^K  ^I  ^H  ^L
                 *
                 * and of course, eval() will convert them all, but there's no expectation of any but those I've
                 * listed above, in part because of Jekyll limitations in some of our templates; eg:
                 *
                 *      https://github.com/jeffpar/pcjs/blob/jekyll/_includes/machine-engines.html
                 *
                 * which could be overcome, but there's really no need to support more, since \xNN can be used to
                 * represent anything else.
                 *
                 * Finally, while the user should escape any quotation characters, just to be safe, we will try to
                 * choose the safest quoting character for the overall string.
                 */
                let ch = value.indexOf("'") >= 0? '"' : "'";
                value = /** @type {string} */ (eval(ch + value + ch));      // jshint ignore:line
            } catch(err) {
                Component.error(err.message + " (" + value + ")");
                value = undefined;
            }
        }
        if (value === undefined && this.parmsMachine) {
            value = this.parmsMachine[sParm];
        }
        if (value === undefined && parmsComponent) {
            value = parmsComponent[sParm];
        }
        if (value === undefined && typeof resources == 'object' && resources[sParm]) {
            value = sParm;
        }
        return value;
    }

    /**
     * saveMachineParms()
     *
     * @this {Computer}
     * @return {string|null}
     */
    saveMachineParms()
    {
        return this.parmsMachine? JSON.stringify(this.parmsMachine) : null;
    }

    /**
     * getUserID()
     *
     * @this {Computer}
     * @return {string}
     */
    getUserID()
    {
        return this.sUserID || "";
    }

    /**
     * doneLoad(sURL, sStateData, nErrorCode)
     *
     * @this {Computer}
     * @param {string} sURL
     * @param {string} sStateData
     * @param {number} nErrorCode
     */
    doneLoad(sURL, sStateData, nErrorCode)
    {
        if (!nErrorCode) {
            this.sStateData = sStateData;
            this.fStateData = true;
            if (DEBUG && this.messageEnabled()) {
                this.printMessage("loaded state file " + sURL.replace(this.sUserID || "xxx", "xxx"));
            }
        } else {
            this.sResumePath = null;
            this.fServerState = false;
            this.notice('Unable to load machine state from server (error ' + nErrorCode + (sStateData? ': ' + Str.trim(sStateData) : '') + ')');
        }
        this.setReady();
    }

    /**
     * wait(fn, parms)
     *
     * wait() waits until every component is ready (including ourselves, the last component we check), then calls the
     * specified Computer method.
     *
     * TODO: The Closure Compiler makes it difficult for us to define a function type for "fn" that works in all cases;
     * sometimes we want to pass a function that takes only a "number", and other times we want to pass a function that
     * takes only an "Array" (the type will mirror that of the "parms" parameter).  However, the Closure Compiler insists
     * that both functions must be declared as accepting both types of parameters.  So once again, we must use an untyped
     * function declaration, instead of something stricter like:
     *
     *      param {function(this:Computer, (number|Array|undefined)): undefined} fn
     *
     * @this {Computer}
     * @param {function(...)} fn
     * @param {number|Array} [parms] optional parameters
     */
    wait(fn, parms)
    {
        let computer = this;
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent <= aComponents.length; iComponent++) {
            let component = (iComponent < aComponents.length? aComponents[iComponent] : this);
            if (!component.isReady()) {
                component.isReady(function onComponentReady() {
                    computer.wait(fn, parms);
                });
                return;
            }
        }
        if (DEBUG && this.messageEnabled()) this.printMessage("Computer.wait(ready)");
        fn.call(this, parms);
    }

    /**
     * validateState(stateComputer)
     *
     * NOTE: We clear() stateValidate only when there's no stateComputer.
     *
     * @this {Computer}
     * @param {State|null} [stateComputer]
     * @return {boolean} true if state passes validation, false if not
     */
    validateState(stateComputer)
    {
        let fValid = true;
        let stateValidate = new State(this, PCX86.APPVERSION, Computer.STATE_VALIDATE);
        if (stateValidate.load() && stateValidate.parse()) {
            let sTimestampValidate = stateValidate.get(Computer.STATE_TIMESTAMP);
            let sTimestampComputer = stateComputer ? stateComputer.get(Computer.STATE_TIMESTAMP) : "unknown";
            if (sTimestampValidate != sTimestampComputer) {
                this.notice("Machine state may be out-of-date\n(" + sTimestampValidate + " vs. " + sTimestampComputer + ")\nCheck your browser's local storage limits");
                fValid = false;
                if (!stateComputer) stateValidate.clear();
            } else {
                if (DEBUG && this.messageEnabled()) {
                    this.printMessage("Last state: " + sTimestampComputer + " (validate: " + sTimestampValidate + ")");
                }
            }
        }
        return fValid;
    }

    /**
     * powerOn(resume)
     *
     * Power every component "up", applying any previously available state information.
     *
     * @this {Computer}
     * @param {number} [resume] is a valid RESUME value; default is this.resume
     */
    powerOn(resume)
    {
        if (resume === undefined) {
            resume = this.resume || (this.sStateData? Computer.RESUME_AUTO : Computer.RESUME_NONE);
        }

        if (DEBUG && this.messageEnabled()) {
            this.printMessage("Computer.powerOn(" + (resume == Computer.RESUME_REPOWER ? "repower" : (resume ? "resume" : "")) + ")");
        }

        if (this.nPowerChange) {
            return;
        }
        this.nPowerChange++;

        let fRepower = false;
        let fRestore = false;
        this.fRestoreError = false;
        let stateComputer = this.stateComputer || new State(this, PCX86.APPVERSION);

        if (resume == Computer.RESUME_REPOWER) {
            fRepower = true;
        }
        else if (resume > Computer.RESUME_NONE) {
            if (stateComputer.load(this.sStateData)) {
                /*
                 * Since we're resuming something (either a predefined state or a state from localStorage), let's
                 * create a "failsafe" checkpoint in localStorage, and destroy it at the end of a successful powerOn().
                 * Which means, of course, that if a previous "failsafe" checkpoint already exists, something bad
                 * may have happened the last time around.
                 */
                this.stateFailSafe = new State(this, PCX86.APPVERSION, Computer.STATE_FAILSAFE);

                if (this.stateFailSafe.load()) {
                    if (resume != Computer.RESUME_AUTO && this.powerReport(stateComputer)) {
                        /*
                         * Prompt the user; if they decline to restore, the state will be removed.
                         */
                        resume = Computer.RESUME_PROMPT;
                    }
                    /*
                     * To ensure that the set() below succeeds, we need to call unload(), otherwise it may fail
                     * with a "read only" error (eg, "TypeError: Cannot assign to read only property 'timestamp'").
                     */
                    this.stateFailSafe.unload();
                }

                this.stateFailSafe.set(Computer.STATE_TIMESTAMP, Usr.getTimestamp());
                this.stateFailSafe.store();

                let fValidate = this.resume && !this.fServerState;
                if (resume == Computer.RESUME_AUTO || Component.confirmUser("Click OK to restore the previous " + PCX86.APPNAME + " machine state.")) {
                    fRestore = stateComputer.parse();
                    if (fRestore) {
                        let sCode = stateComputer.get(UserAPI.RES.CODE);
                        let sData = stateComputer.get(UserAPI.RES.DATA);
                        if (sCode) {
                            if (sCode == UserAPI.CODE.OK) {
                                stateComputer.load(/** @type {string} */ (sData));
                            } else {
                                /*
                                 * A missing (or not yet created) state file is no cause for alarm, but other errors might be
                                 */
                                if (sCode == UserAPI.CODE.FAIL && sData != UserAPI.FAIL.NOSTATE) {
                                    this.notice("Error: " + sData);
                                    if (sData == UserAPI.FAIL.VERIFY) this.resetUserID();
                                } else {
                                    this.println(sCode + ": " + sData);
                                }
                                /*
                                 * Try falling back to the state that we should have saved in localStorage, as a backup to the
                                 * server-side state.
                                 */
                                stateComputer.unload();     // discard the invalid server-side state first
                                if (stateComputer.load()) {
                                    fRestore = stateComputer.parse();
                                    fValidate = true;
                                } else {
                                    fRestore = false;       // hmmm, there was nothing in localStorage either
                                }
                            }
                        }
                    }
                    /*
                     * If the load/parse was successful, and it was from localStorage (not sStateData),
                     * then we should to try verify that localStorage snapshot is current.  One reason it may
                     * NOT be current is if localStorage was full and we got a quota error during the last
                     * powerOff().
                     */
                    if (fValidate) this.validateState(fRestore? stateComputer : null);
                } else {
                    /*
                     * RESUME_PROMPT indicates we should delete the state if they clicked Cancel to confirm() above.
                     */
                    if (resume == Computer.RESUME_PROMPT) stateComputer.clear();
                }
            } else {
                /*
                 * If there's no state, then there should also be no validation timestamp; if there is, then once again,
                 * we're probably dealing with a quota error.
                 */
                this.validateState();
            }
            delete this.sStateData;
            delete this.stateComputer;
        }

        /*
         * Start powering all components, including any data they may need to restore their state;
         * we restore power to the CPU last.
         */
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component !== this && component != this.cpu) {
                try {
                    fRestore = this.powerRestore(component, stateComputer, fRepower, fRestore);
                } catch(err) {
                    Component.error(component.type + " restore failure: " + err.message);
                }
            }
        }

        /*
         * Assuming this is not a repower, we must perform another wait, because some components may
         * have marked themselves as "not ready" again (eg, the FDC component, if the restore forced it
         * to mount one or more additional disk images).
         */
        let aParms = [stateComputer, resume, fRestore];

        if (resume != Computer.RESUME_REPOWER) {
            this.wait(this.donePowerOn, aParms);
            return;
        }
        this.donePowerOn(aParms);
    }

    /**
     * powerRestore(component, stateComputer, fRepower, fRestore)
     *
     * @this {Computer}
     * @param {Component} component
     * @param {State} stateComputer
     * @param {boolean} fRepower
     * @param {boolean} fRestore
     * @return {boolean} true if restore should continue, false if not
     */
    powerRestore(component, stateComputer, fRepower, fRestore)
    {
        if (!component.flags.powered) {

            component.flags.powered = true;

            if (component.powerUp) {

                let data = null;
                if (fRestore) {
                    data = stateComputer.get(component.id);
                    if (!data) {
                        /*
                         * This is a hack that makes it possible for a machine whose ID has been
                         * supplemented with a hyphenated numeric suffix to find object IDs in states
                         * created from a machine without such a suffix.
                         *
                         * For example, if a state file was created from a machine with ID "ibm5160"
                         * but the current machine is "ibm5160-1", this attempts a second lookup with
                         * "ibm5160", enabling us to find objects that match the original machine ID
                         * (eg, "ibm5160.romEGA").
                         *
                         * See /devices/pcx86/machine/5160/ega/640kb/array for examples of this.
                         */
                        data = stateComputer.get(component.id.replace(/-[0-9]+\./i, '.'));
                    }
                }

                /*
                 * State.get() will return whatever was originally passed to State.set() (eg, an
                 * Object or a string), but components are supposed to store only Objects, so if a
                 * string comes back, something went wrong.  By explicitly eliminating "string" data,
                 * the Closure Compiler stops complaining that we might be passing strings to our
                 * powerUp() functions (even though we know we're not).  We could also add @type
                 * overrides to the data assignments, but this seems like a useful runtime check.
                 */
                if (typeof data === "string") data = null;

                /*
                 * If computer is null, this is simply a repower notification, which most components
                 * don't do anything with.  Exceptions include: CPU (since it may be halted) and Video
                 * (since its screen may be "turned off").
                 */
                if (!component.powerUp(data, fRepower) && data) {

                    if (component.notice("Unable to restore hardware state")) {
                        /*
                         * If this is a resume error for a machine that also has a predefined state
                         * AND we're not restoring from that state, then throw away the current state,
                         * prevent any new state from being created, and then force a reload, which will
                         * hopefully restore us to the functioning predefined state.
                         *
                         * TODO: Considering doing this in ALL cases, not just in situations where a
                         * 'state' exists but we're not actually resuming from it.
                         */
                        if (this.sStatePath && !this.fStateData) {
                            stateComputer.clear();
                            this.resume = Computer.RESUME_NONE;
                            Web.reloadPage();
                        } else {
                            /*
                             * In all other cases, we set fRestoreError, which should trigger a call to
                             * powerReport() and then delete the offending state.
                             */
                            this.fRestoreError = true;
                        }
                    }

                    /*
                     * Any failure triggers an automatic to call powerUp() again, without any state,
                     * in the hopes that the component can recover by performing a reset.
                     */
                    component.powerUp(null);
                    /*
                     * We also disable the rest of the restore operation, because it's not clear
                     * the remaining state information can be trusted;  the machine is already in an
                     * inconsistent state, so we're not likely to make things worse, and the only
                     * alternative (starting over and performing a state-less reset) isn't likely to make
                     * the user any happier.  But, we'll see... we need some experience with the code.
                     */
                    fRestore = false;
                }
            }

            component.flags.initDone = true;

            if (!fRepower && component.comment) {
                let asComments = component.comment.split("|");
                for (let i = 0; i < asComments.length; i++) {
                    component.status(asComments[i]);
                }
            }
        }
        return fRestore;
    }

    /**
     * donePowerOn(aParms)
     *
     * This is nothing more than a continuation of powerOn(), giving us the option of calling wait() one more time.
     *
     * @this {Computer}
     * @param {Array} aParms containing [stateComputer, resume, fRestore]
     */
    donePowerOn(aParms)
    {
        if (!this.flags.initDone) {
            if (!this.disableDiagnostics()) {
                this.setReady(false);
                this.wait(this.donePowerOn, aParms);
                return;
            }
            this.flags.initDone = true;
        }

        if (DEBUG && this.flags.powered && this.messageEnabled()) {
            this.printMessage("Computer.donePowerOn(): redundant");
        }

        let stateComputer = aParms[0];
        let fRepower = (aParms[1] < 0);
        let fRestore = aParms[2];

        let controlPower = this.bindings["power"];
        if (controlPower) controlPower.textContent = "Shutdown";

        this.flags.powered = true;

        /*
         * Once we get to this point, we're guaranteed that all components are ready, so it's safe to power the CPU;
         * the CPU should begin executing immediately, unless a debugger is attached.
         */
        if (this.cpu) {
            /*
             * TODO: Do we not care about the return value here? (ie, is checking fRestoreError sufficient)?
             */
            this.powerRestore(this.cpu, stateComputer, fRepower, fRestore);
            this.cpu.autoStart();
        }

        /*
         * If the state was bad, offer to report it and then delete it.  Deleting may be moot, since invariably a new
         * state will be created on powerOff() before the next powerOn(), but it seems like good paranoia all the same.
         */
        if (this.fRestoreError) {
            this.powerReport(stateComputer);
            stateComputer.clear();
        }

        if (!fRepower && this.stateFailSafe) {
            this.stateFailSafe.clear();
            delete this.stateFailSafe;
        }

        this.nPowerChange = 0;

        Component.processScript(this.idMachine, this.getMachineParm('autoScript'));
    }

    /**
     * checkPower()
     *
     * @this {Computer}
     * @return {boolean} true if the computer is fully powered, false otherwise
     */
    checkPower()
    {
        if (this.flags.unloading) {
            /*
             * We happen to know that we're currently only called by the CPU's onClickRun() function, so
             * if the unloading flag is set, then we've somehow gotten into a weird state where the machine
             * thinks it's being (or has been) unloaded by the browser, but in fact, it has not.
             *
             * The only time I've seen this happen is when the user clicks a link on a page that the browser
             * decided to treat as a download operation, instead of loading a new page.  The proper way to
             * resolve that confusion is to set the "download" attribute on the link (which will prevent the
             * page's "onbeforeunload" handler from being called in the first place), but we cannot guarantee
             * that all such links will have their "download" attribute properly set.
             *
             * Hence, this code: we do the same thing that the show() function does, which is to attempt a
             * REPOWER operation.  If that doesn't result in the powered flag getting turned back on, well,
             * then we're probably screwed.
             */
            this.flags.unloading = false;
            if (this.flags.initDone && !this.flags.powered) {
                this.powerOn(Computer.RESUME_REPOWER);
            }
        }

        if (this.flags.powered) return true;

        let component = null, iComponent;
        let aComponents = Component.getComponents(this.id);
        for (iComponent = 0; iComponent < aComponents.length; iComponent++) {
            component = aComponents[iComponent];
            if (component !== this && !component.flags.ready) break;
        }
        if (iComponent == aComponents.length) {
            for (iComponent = 0; iComponent < aComponents.length; iComponent++) {
                component = aComponents[iComponent];
                if (component !== this && !component.flags.powered) break;
            }
        }
        if (iComponent == aComponents.length) component = this;
        let s = "The " + component.type + " component (" + component.id + ") is not " + (!component.flags.ready? "ready yet" + (component.fnReady? " (waiting for notification)" : "") : "powered yet") + ".";
        Component.alertUser(s);
        return false;
    }

    /**
     * powerReport(stateComputer)
     *
     * TODO: Ever since I migrated the PCjs website from a Node-based web server on AWS to a GitHub Pages-based site,
     * the sendReport() API has been a bit-bucket.  To be honest though, even before that change, I never really had
     * the time (or desire) to look through all the anonymous machine states that were being posted.  Most of them were
     * probably due to the user switching away from a page before it finished loading anyway, leaving the machine in
     * an incomplete state.  That said, there should be SOME automated way for people to share their machine states
     * when there's a more serious problem -- not this misleading prompt.
     *
     * In the meantime, to help reduce those kind of useless alerts, there's the new 'unloading' flag.  However, I'm
     * not sure how reliably that's being set, so additionally, the default 'resume' setting (RESUME_AUTO) tries to be
     * MUCH more automatic now; this function, for example, shouldn't even be called now when RESUME_AUTO is in effect.
     * Another 'resume' setting (eg, RESUME_PROMPT) must be selected instead.
     *
     * @this {Computer}
     * @param {State} stateComputer
     * @return {boolean}
     */
    powerReport(stateComputer)
    {
        if (!this.flags.unloading) {
            //
            // This is all we can realistically do for now.
            //
            Web.onError("There may be a problem with your " + PCX86.APPNAME + " machine.");
            //
            // if (Component.confirmUser("There may be a problem with your " + PCX86.APPNAME + " machine.\n\nTo help us diagnose it, click OK to send this " + PCX86.APPNAME + " machine state to " + SITEURL + ".")) {
            //     Web.sendReport(PCX86.APPNAME, PCX86.APPVERSION, this.url, this.getUserID(), ReportAPI.TYPE.BUG, stateComputer.toString());
            // }
            //
            return true;
        }
        return false;
    }

    /**
     * powerOff(fSave, fShutdown)
     *
     * Power every component "down" and optionally save the machine state.
     *
     * There's one scenario that powerOff() isn't currently able to deal with very effectively: what to do when
     * the user switches away while it's still being restored, causing Disk getResource() calls to fail.  The
     * Disk component calls notify() when that happens -- see Disk.mount() -- but the FDC and HDC controllers don't
     * notify *us* of those problems, so Computer assumes that the restore was completely successful, when in fact
     * it was only partially successful.
     *
     * Then we immediately arrive here to perform a save, following that incomplete restore.  It would be wrong to
     * deal with that incomplete restore by setting fRestoreError, because we don't want to trigger a powerReport()
     * and the deletion of the previous state, because the state itself was presumably OK.  Unfortunately, the new
     * state we now save will no longer include manually mounted disk images whose remounts were interrupted, so future
     * restores won't remount them either.
     *
     * We could perhaps solve this by having the Disk component notify us in those situations, set a new flag
     * (fRestoreIncomplete?), and set fSave to false if that's ever set.  Be careful though: when fSave is false,
     * that means MORE than not saving; it also means deleting any previous state, which is NOT what you'd want to
     * do in a "fRestoreIncomplete" situation.  Also, we have to worry about Disk operations that fail for other reasons,
     * making sure those failures don't interfere with the save process in the same way.
     *
     * As it stands, the worst that happens is any manually mounted disk images might have to be manually remounted,
     * which doesn't seem like a huge problem.
     *
     * @this {Computer}
     * @param {boolean} [fSave] is true to request a saved state
     * @param {boolean} [fShutdown] is true if the machine is being shut down
     * @return {string|null} string representing the saved state (or null if error)
     */
    powerOff(fSave, fShutdown)
    {
        let data;
        let sState = "none";

        if (DEBUG && this.messageEnabled()) {
            this.printMessage("Computer.powerOff(" + (fSave ? "save" : "nosave") + (fShutdown ? ",shutdown" : "") + ")");
        }

        if (this.nPowerChange) {
            return null;
        }
        this.nPowerChange--;

        let stateComputer = new State(this, PCX86.APPVERSION);
        let stateValidate = new State(this, PCX86.APPVERSION, Computer.STATE_VALIDATE);

        let sTimestamp = Usr.getTimestamp();
        stateValidate.set(Computer.STATE_TIMESTAMP, sTimestamp);
        stateComputer.set(Computer.STATE_TIMESTAMP, sTimestamp);
        stateComputer.set(Computer.STATE_VERSION, APPVERSION);
        stateComputer.set(Computer.STATE_HOSTURL, Web.getHostURL());
        stateComputer.set(Computer.STATE_BROWSER, Web.getUserAgent());

        /*
         * Always power the CPU "down" first, just to help insure it doesn't ask other components to do anything
         * after they're no longer ready.
         */
        if (this.cpu && this.cpu.powerDown) {
            data = this.cpu.powerDown(fSave, fShutdown);
            if (typeof data === "object") stateComputer.set(this.cpu.id, data);
            if (fShutdown) {
                this.cpu.flags.powered = false;
                if (data === false) sState = null;
            }
        }

        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component.flags.powered) {
                if (component.powerDown) {
                    data = component.powerDown(fSave, fShutdown);
                    if (typeof data === "object") stateComputer.set(component.id, data);
                }
                if (fShutdown) {
                    component.flags.powered = false;
                    if (data === false) sState = null;
                }
            }
        }

        if (sState) {
            if (fShutdown) {
                let fClear = false;
                let fClearAll = false;
                if (fSave) {
                    if (this.sUserID) {
                        this.saveServerState(this.sUserID, stateComputer.toString());
                    }
                    if (!stateValidate.store() || !stateComputer.store()) {
                        sState = null;
                        /*
                         * New behavior as of v1.13.2:  if it appears that localStorage is full, we blow it ALL away.
                         * Dedicated server-side storage is the only way we'll ever be able to reliably preserve a
                         * particular machine's state.  Historically, attempting to limp along with whatever localStorage
                         * is left just generates the same useless and annoying warnings over and over.
                         */
                        fClear = fClearAll = true;
                    }
                }
                else {
                    /*
                     * I used to ALWAYS clear (ie, delete) any associated computer state, but now I do this only if the
                     * current machine is "resumable", because there are situations where I have two configurations
                     * for the same machine -- one resumable and one not -- and I don't want the latter throwing away the
                     * state of the former.
                     *
                     * So this code is here now strictly for callers to delete the state of a "resumable" machine, not as
                     * some paranoid clean-up operation.
                     *
                     * An undocumented feature of this operation is that if your configuration uses the special 'resume="3"'
                     * value, and you click the "Reset" button, and then you click OK to reset the everything, this will
                     * actually reset EVERYTHING (ie, all localStorage for ALL configs will be reclaimed).
                     */
                    if (this.resume) {
                        fClear = true;
                        fClearAll = (this.resume == Computer.RESUME_DELETE);
                    }
                }
                if (fClear) {
                    stateComputer.clear(fClearAll);
                }
            } else {
                sState = stateComputer.toString();
            }
        }

        if (fShutdown) {
            this.flags.powered = false;
            let controlPower = this.bindings["power"];
            if (controlPower) controlPower.textContent = "Power";
        }

        this.nPowerChange = 0;

        return sState;
    }

    /**
     * reset()
     *
     * Notify all (other) components with a reset() method that the Computer is being reset.
     *
     * NOTE: We'd like to reset the Bus first (due to the importance of the A20 line), but since we
     * allocated the Bus object ourselves, after all the other components were allocated, it ends
     * up near the end of Component's list of components.  Hence the special case for this.bus below.
     *
     * @this {Computer}
     */
    reset()
    {
        if (this.bus && this.bus.reset) {
            this.printMessage("Resetting " + this.bus.type);
            this.bus.reset();
        }
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component !== this && component !== this.bus && component.reset) {
                this.printMessage("Resetting " + component.type);
                component.reset();
            }
        }
    }

    /**
     * start(ms, nCycles)
     *
     * Notify all (other) components with a start() method that the CPU has started.
     *
     * Note that we're called by startCPU(), which is why we exclude the CPU component,
     * as well as ourselves.
     *
     * @this {Computer}
     * @param {number} ms
     * @param {number} nCycles
     */
    start(ms, nCycles)
    {
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component.type == "CPU" || component === this) continue;
            if (component.start) {
                component.start(ms, nCycles);
            }
        }
    }

    /**
     * stop(ms, nCycles)
     *
     * Notify all (other) components with a stop() method that the CPU has stopped.
     *
     * Note that we're called by stopCPU(), which is why we exclude the CPU component,
     * as well as ourselves.
     *
     * @this {Computer}
     * @param {number} ms
     * @param {number} nCycles
     */
    stop(ms, nCycles)
    {
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component.type == "CPU" || component === this) continue;
            if (component.stop) {
                component.stop(ms, nCycles);
            }
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {Computer}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "reset")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @return {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let computer = this;

        switch (sBinding) {
        case "power":
            this.bindings[sBinding] = control;
            control.onclick = function onClickPower() {
                computer.onPower();
            };
            return true;

        case "reset":
            this.bindings[sBinding] = control;
            control.onclick = function onClickReset() {
                computer.onReset();
            };
            return true;

        /*
         * Technically, this binding should now be called "saveState", to clearly distinguish it from
         * the "Save Machine" control that's normally bound to the savePC() function in save.js.  Saving
         * an entire machine includes everything needed to start/restore the machine; eg, the machine
         * XML configuration file(s) *and* the JSON-encoded machine state.
         */
        case "save":
            /*
             * Since this feature depends on the server supporting the PCjs User API (see userapi.js),
             * and since pcjs.org is no longer running a Node web server, we disable the feature for that
             * particular host.
             */
            if (Str.endsWith(Web.getHostName(), "pcjs.org")) {
                if (DEBUG) this.log("Remote user API not available");
                /*
                 * We could also simply hide the control; eg:
                 *
                 *      control.style.display = "none";
                 *
                 * but removing the control altogether seems better.
                 */
                control.parentNode.removeChild(/** @type {Node} */ (control));
                return false;
            }
            this.bindings[sBinding] = control;
            control.onclick = function onClickSave() {
                let sUserID = computer.queryUserID(true);
                if (sUserID) {
                    /*
                     * I modified the test to include a check for sStatePath so that I could save new states
                     * for machines with existing states; otherwise, I'd have no (easy) way of capturing and
                     * updating their state.  Making the machine (even temporarily) resumable would have been
                     * one work-around, but it's not appropriate for some machines, as their state is simply
                     * too large (for localStorage anyway, which is the default storage solution).
                     */
                    let fSave = !!(computer.resume && !computer.sResumePath || computer.sStatePath);
                    let sState = computer.powerOff(fSave);
                    if (fSave) {
                        computer.saveServerState(sUserID, sState);
                    } else {
                        computer.notice("Resume disabled, machine state not saved");
                    }
                }
                /*
                 * This seemed like a handy alternative, but it turned out to be a no-go, at least for large states:
                 *
                 *      let sState = computer.powerOff(true);
                 *      if (sState) {
                 *          sState = "data:text/json;charset=utf-8," + encodeURIComponent(sState);
                 *          window.open(sState);
                 *      }
                 *
                 * Perhaps if I embedded the data in a link on the current page instead; eg:
                 *
                 *      $('<a href="' + sState + '" download="state.json">Download</a>').appendTo('#container');
                 */
            };
            return true;

        default:
            break;
        }
        return false;
    }

    /**
     * resetUserID()
     *
     * @this {Computer}
     */
    resetUserID()
    {
        Web.setLocalStorageItem(Computer.STATE_USERID, "");
        this.sUserID = null;
    }

    /**
     * queryUserID(fPrompt)
     *
     * @this {Computer}
     * @param {boolean} [fPrompt]
     * @returns {string|null|undefined}
     */
    queryUserID(fPrompt)
    {
        let sUserID = this.sUserID;
        if (!sUserID) {
            sUserID = Web.getLocalStorageItem(Computer.STATE_USERID);
            if (sUserID !== undefined) {
                if (!sUserID && fPrompt) {
                    /*
                     * NOTE: Warning the user here that "Save" operations are not currently supported by pcjs.org is
                     * merely a precaution, because ordinarily, setBinding() should have already determined if we are
                     * running from pcjs.org and disabled any "Save" button.
                     */
                    sUserID = Component.promptUser("Saving machine states on the pcjs.org server is currently unsupported.\n\nIf you're running your own server, enter your user ID below.");
                    if (sUserID) {
                        sUserID = this.verifyUserID(sUserID);
                        if (!sUserID) this.notice("The user ID is invalid.");
                    }
                }
            } else if (fPrompt) {
                this.notice("Browser local storage is not available");
            }
        }
        return sUserID;
    }

    /**
     * verifyUserID(sUserID)
     *
     * @this {Computer}
     * @param {string} sUserID
     * @return {string} validated user ID, or null if error
     */
    verifyUserID(sUserID)
    {
        this.sUserID = null;
        let fMessages = DEBUG && this.messageEnabled();
        if (fMessages) this.printMessage("verifyUserID(" + sUserID + ")");
        let sRequest = Web.getHostOrigin() + UserAPI.ENDPOINT + '?' + UserAPI.QUERY.REQ + '=' + UserAPI.REQ.VERIFY + '&' + UserAPI.QUERY.USER + '=' + sUserID;
        let response = Web.getResource(sRequest);
        let nErrorCode = response[0];
        let sResponse = response[1];
        if (!nErrorCode && sResponse) {
            try {
                response = eval("(" + sResponse + ")"); // jshint ignore:line
                if (response.code && response.code == UserAPI.CODE.OK) {
                    Web.setLocalStorageItem(Computer.STATE_USERID, response.data);
                    if (fMessages) this.printMessage(Computer.STATE_USERID + " updated: " + response.data);
                    this.sUserID = response.data;
                } else {
                    if (fMessages) this.printMessage(response.code + ": " + response.data);
                }
            } catch(err) {
                Component.error(err.message + " (" + sResponse + ")");
            }
        } else {
            if (fMessages) this.printMessage("invalid response (error " + nErrorCode + ")");
        }
        return this.sUserID;
    }

    /**
     * getServerStatePath()
     *
     * @this {Computer}
     * @return {string|null} sStatePath (null if no localStorage or no USERID stored in localStorage)
     */
    getServerStatePath()
    {
        let sStatePath = null;
        if (this.sUserID) {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage(Computer.STATE_USERID + " for load: " + this.sUserID);
            }
            sStatePath = Web.getHostOrigin() + UserAPI.ENDPOINT + '?' + UserAPI.QUERY.REQ + '=' + UserAPI.REQ.LOAD + '&' + UserAPI.QUERY.USER + '=' + this.sUserID + '&' + UserAPI.QUERY.STATE + '=' + State.getKey(this, PCX86.APPVERSION);
        } else {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage(Computer.STATE_USERID + " unavailable");
            }
        }
        return sStatePath;
    }

    /**
     * saveServerState(sUserID, sState)
     *
     * @this {Computer}
     * @param {string} sUserID
     * @param {string|null} sState
     */
    saveServerState(sUserID, sState)
    {
        /*
         * We must pass fSync == true, because (as I understand it) browsers will blow off any async
         * requests when a page is being closed.  Since our request is synchronous, storeServerState()
         * should also return a result, but there's not much we can do with it, since browsers ALSO
         * tend to blow off alerts() and the like when closing down.
         */
        if (sState) {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage("size of server state: " + sState.length + " bytes");
            }
            let response = this.storeServerState(sUserID, sState, true);
            if (response && response[UserAPI.RES.CODE] == UserAPI.CODE.OK) {
                this.notice("Machine state saved to server");
            } else if (sState) {
                let sError = (response && response[UserAPI.RES.DATA]) || UserAPI.FAIL.BADSTORE;
                if (response[UserAPI.RES.CODE] == UserAPI.CODE.FAIL) {
                    sError = "Error: " + sError;
                } else {
                    sError = "Error " + response[UserAPI.RES.CODE] + ": " + sError;
                }
                this.notice(sError);
                this.resetUserID();
            }
        } else {
            if (DEBUG && this.messageEnabled()) {
                this.printMessage("no state to store");
            }
        }
    }

    /**
     * storeServerState(sUserID, sState, fSync)
     *
     * @this {Computer}
     * @param {string} sUserID
     * @param {string} sState
     * @param {boolean} [fSync] is true if we're powering down and should perform a synchronous request (default is async)
     * @return {*} server response if fSync is true and a response was received; otherwise null
     */
    storeServerState(sUserID, sState, fSync)
    {
        if (DEBUG && this.messageEnabled()) {
            this.printMessage(Computer.STATE_USERID + " for store: " + sUserID);
        }
        /*
         * TODO: Determine whether or not any browsers cancel our request if we're called during a browser "shutdown" event,
         * and whether or not it matters if we do an async request (currently, we're not, to try to ensure the request goes through).
         */
        let dataPost = {};
        dataPost[UserAPI.QUERY.REQ] = UserAPI.REQ.STORE;
        dataPost[UserAPI.QUERY.USER] = sUserID;
        dataPost[UserAPI.QUERY.STATE] = State.getKey(this, PCX86.APPVERSION);
        dataPost[UserAPI.QUERY.DATA] = sState;
        let sRequest = Web.getHostOrigin() + UserAPI.ENDPOINT;
        if (!fSync) {
            Web.getResource(sRequest, dataPost, true);
        } else {
            let response = Web.getResource(sRequest, dataPost);
            let sResponse = response[0];
            if (response[1]) {
                if (sResponse) {
                    let i = sResponse.indexOf('\n');
                    if (i > 0) sResponse = sResponse.substr(0, i);
                    if (!sResponse.indexOf("Error: ")) sResponse = sResponse.substr(7);
                }
                sResponse = '{"' + UserAPI.RES.CODE + '":' + response[1] + ',"' + UserAPI.RES.DATA + '":"' + sResponse + '"}';
            }
            if (DEBUG && this.messageEnabled()) this.printMessage(sResponse);
            return JSON.parse(sResponse);
        }
        return null;
    }

    /**
     * onPower()
     *
     * This handles UI requests to toggle the computer's power (eg, see the "power" button binding).
     *
     * @this {Computer}
     */
    onPower()
    {
        if (!this.nPowerChange) {
            if (!this.flags.powered) {
                this.wait(this.powerOn);
            } else {
                this.powerOff(false, true);
            }
        }
    }

    /**
     * onReset()
     *
     * This handles UI requests to reset the computer's state (eg, see the "reset" button binding).
     *
     * @this {Computer}
     */
    onReset()
    {
        /*
         * I'm going to start with the presumption that it makes little sense for an "unpowered" computer to be "reset";
         * ditto if the power state is currently being changed.
         */
        if (!this.flags.powered || this.nPowerChange) return;

        /*
         * Whether or not we autoStart on reset should depend at least in part on whether we were running originally.
         */
        if (this.cpu) {
            this.cpu.flags.autoStart = this.cpu.flags.running;
        }
        /*
         * If this is a "resumable" machine (and it's not using a predefined state), then we overload the reset
         * operation to offer an explicit "save or discard" option first.  This is currently the only UI we offer to
         * discard a machine's state, including any disk changes.  The traditional "reset" operation is still available
         * for non-resumable machines.
         *
         * TODO: Break this behavior out into a separate "discard" operation, in case the designer of the machine really
         * wants to clutter the UI with confusing options. ;-)
         */
        if (this.resume && !this.sResumePath) {
            /*
             * I used to bypass the prompt if this.resume == Computer.RESUME_AUTO, setting fSave to true automatically,
             * but that gives the user no means of resetting a resumable machine that contains errors in its resume state.
             */
            let fSave = (/* this.resume == Computer.RESUME_AUTO || */ this.flags.unloading || !Component.confirmUser("Click OK to reset this " + PCX86.APPNAME + " machine and discard all disk modifications."));
            this.powerOff(fSave, true);
            /*
             * Forcing the page to reload is an expedient option, but ugly. It's preferable to call powerOn()
             * and rely on all the components to reset themselves to their default state.  The components with
             * the greatest burden here are FDC and HDC, which must rely on the fReload flag to determine whether
             * or not to unload/reload all their original auto-mounted disk images.
             *
             * However, if we started with a predefined state (ie, sStatePath is set), we take this shortcut, because
             * we don't (yet) have code in place to gracefully reload the initial state (requires calling getResource()
             * again); alternatively, we could avoid throwing that state away, but it seems better to save the memory.
             *
             * TODO: Make this more graceful, so that we can stop using the reloadPage() sledgehammer.
             */
            if (!fSave && this.sStatePath) {
                Web.reloadPage();
                return;
            }
            if (!fSave) this.fReload = true;
            this.powerOn(Computer.RESUME_NONE);
            this.fReload = false;
        } else {
            this.reset();
            if (this.cpu) this.cpu.autoStart();
        }
        this.updateFocus(true);
    }

    /**
     * getMachineComponent(sType, componentPrev)
     *
     * @this {Computer}
     * @param {string} sType
     * @param {Component|null} [componentPrev] of previously returned component, if any
     * @return {Component|null}
     */
    getMachineComponent(sType, componentPrev)
    {
        let componentLast = componentPrev;
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (componentPrev) {
                if (componentPrev == component) componentPrev = null;
                continue;
            }
            if (component.type == sType) return component;
        }
        if (!componentLast && sType != "FPU") {
            Component.log("Machine component type '" + sType + "' not found", "warning");
        }
        return null;
    }

    /**
     * updateFocus(fScroll)
     *
     * NOTE: When soft keyboard buttons call us to return focus to the machine (and away from the button),
     * the browser's default behavior is to scroll the element into view, which can be annoying, especially on iOS,
     * where the display is more constrained, so we no longer do it by default (fScroll must be true).
     *
     * @this {Computer}
     * @param {boolean} [fScroll] (true if you really want the control scrolled into view)
     */
    updateFocus(fScroll)
    {
        if (this.aVideo.length) {
            /*
             * This seems to be recommended work-around to prevent the browser from scrolling the focused element
             * into view.  The CPU is not a visual component, so when the CPU wants to set focus, the primary intent
             * is to ensure that keyboard input is fielded properly.
             */
            let x = 0, y = 0;
            if (!fScroll && window) {
                x = window.scrollX;
                y = window.scrollY;
            }

            /*
             * TODO: We need a mechanism to determine the "active" display, instead of hard-coding this to aVideo[0].
             */
            this.aVideo[0].setFocus(fScroll);

            if (!fScroll && window) {
                window.scrollTo(x, y);
            }
        }
    }

    /**
     * updateStatus(fForce)
     *
     * If any DOM controls were bound to the CPU, then we need to call its updateStatus() handler; if there are no
     * such bindings, then cpu.updateStatus() does nothing.
     *
     * Similarly, if there's a Panel, then we need to call its updateStatus() handler, in case it created its own canvas
     * and implemented its own register display (eg, dumpRegisters()); if not, then panel.updateStatus() also does nothing.
     *
     * In practice, there will *either* be a Panel with a custom canvas *or* a set of DOM controls bound to the CPU *or*
     * neither.  In theory, there could be BOTH, but that would be unusual.
     *
     * TODO: Consider alternate approaches to these largely register-oriented display updates.  Ordinarily, we like to
     * separate logic from presentation, and currently the CPUX86 contains both, since it's the component that intimately
     * knows the names, number, sizes, etc, of all the active registers.  The Panel component is the logical candidate,
     * but Panel is an optional component; generally, only machines that include Debugger also include Panel.
     *
     * @this {Computer}
     * @param {boolean} [fForce] (true will display registers even if the CPU is running and "live" registers are not enabled)
      */
    updateStatus(fForce)
    {
        /*
         * fForce is generally set to true whenever the CPU is transitioning to/from a running state, in which case
         * cpu.updateStatus() will definitely want to hide/show register contents; however, at other times, when the
         * CPU is running, constantly updating the DOM controls too frequently can adversely impact overall performance.
         *
         * So fForce serves as a hint to help cpu.updateStatus() make a more informed decision.  panel.updateStatus()
         * currently doesn't care, on the theory that canvas updates should be significantly faster than DOM updates,
         * but we still pass fForce on.
         */
        if (this.cpu) this.cpu.updateStatus(fForce);
        if (this.panel) this.panel.updateStatus(fForce);
        /*
         * When called by our own timer for relatively infrequent DOM (see Computer.UPDATES_PER_SECOND), fForce is
         * explicitly set to false, and in those cases, we should avoid performing screen updates, because it may
         * subtly interfere with the Video component's normal refresh rate.
         */
        if (fForce !== undefined) {
            for (let i = 0; i < this.aVideo.length; i++) {
                this.aVideo[i].updateScreen(fForce);
            }
        }
    }

    /**
     * Computer.init()
     *
     * For every machine represented by an HTML element of class "pcx86-machine", this function
     * locates the HTML element of class "computer", extracting the JSON-encoded parameters for the
     * Computer constructor from the element's "data-value" attribute, invoking the constructor to
     * create a Computer component, and then binding any associated HTML controls to the new component.
     */
    static init()
    {
        /*
         * In non-COMPILED builds, embedMachine() may have set XMLVERSION.
         */
        if (!COMPILED && XMLVERSION) PCX86.APPVERSION = XMLVERSION;

        let aeMachines = Component.getElementsByClass(document, PCX86.APPCLASS + "-machine");

        for (let iMachine = 0; iMachine < aeMachines.length; iMachine++) {

            let eMachine = aeMachines[iMachine];
            let parmsMachine = Component.getComponentParms(eMachine);

            let aeComputers = Component.getElementsByClass(eMachine, PCX86.APPCLASS, "computer");

            for (let iComputer = 0; iComputer < aeComputers.length; iComputer++) {

                let eComputer = aeComputers[iComputer];
                let parmsComputer = Component.getComponentParms(eComputer);

                /*
                 * We set fSuspended in the Computer constructor because we want to "power up" the
                 * computer ourselves, after any/all bindings are in place.
                 */
                let computer = new Computer(parmsComputer, parmsMachine, true);

                if (DEBUG && computer.messageEnabled()) {
                    computer.printMessage("onInit(" + computer.flags.powered + ")");
                }

                /*
                 * Bind any "power", "reset" and "save" buttons.  An "erase" button was also considered,
                 * but "reset" now provides a way to force the machine to start from scratch again, so "erase"
                 * may be redundant now.
                 */
                Component.bindComponentControls(computer, eComputer, PCX86.APPCLASS);

                /*
                 * Power on the computer, giving every component the opportunity to reset or restore itself.
                 */
                if (computer.fAutoPower) computer.wait(computer.powerOn);
            }
        }
    }

    /**
     * Computer.show()
     *
     * When exit() is using an "onbeforeunload" handler, this "onpageshow" handler allows us to repower everything,
     * without either resetting or restoring.  We call powerOn() with a special resume value (RESUME_REPOWER) if the
     * computer is already marked as "ready", meaning the browser didn't change anything.  This "repower" process
     * should be very quick, essentially just marking all components as powered again (so that, for example, the Video
     * component will start drawing again) and firing the CPU up again.
     */
    static show()
    {
        let aeComputers = Component.getElementsByClass(document, PCX86.APPCLASS, "computer");
        for (let iComputer = 0; iComputer < aeComputers.length; iComputer++) {
            let eComputer = aeComputers[iComputer];
            let parmsComputer = Component.getComponentParms(eComputer);
            let computer = /** @type {Computer} */ (Component.getComponentByType("Computer", parmsComputer['id']));
            if (computer) {

                /*
                 * Clear new flag that Component functions (eg, notice()) should check before alerting the user.
                 */
                computer.flags.unloading = false;

                if (DEBUG && computer.messageEnabled()) {
                    computer.printMessage("onShow(" + computer.flags.initDone + "," + computer.flags.powered + ")");
                }

                if (computer.flags.initDone && !computer.flags.powered) {
                    /*
                     * Repower the computer, notifying every component to continue running as-is.
                     */
                    computer.powerOn(Computer.RESUME_REPOWER);
                }
            }
        }
    }

    /**
     * Computer.exit()
     *
     * The Computer is currently the only component that uses an "exit" handler, which Web.onExit() defines as
     * either an "unload" or "onbeforeunload" handler.  This gives us the opportunity to save the machine state,
     * using our powerOff() function, before the page goes away.
     *
     * It's worth noting that "onbeforeunload" offers one nice feature when used instead of "onload": the entire
     * page (and therefore this entire application) is retained in its current state by the browser (well, some
     * browsers), so that if you go to a new URL, either by entering a new URL in the same window/tab, or by pressing
     * the FORWARD button, and then you press the BACK button, the page is immediately restored to its previous state.
     *
     * In fact, that's how some browsers operate whether you have an "onbeforeunload" handler or not; in other words,
     * an "onbeforeunload" handler doesn't change the page retention behavior of the browser.  By contrast, the mere
     * presence of an "onunload" handler generally causes a browser to throw the page away once the handler returns.
     *
     * However, in order to safely use "onbeforeunload", we must add yet another handler ("onpageshow") to repower
     * everything, without either resetting or restoring.  Hence, the Computer.show() function, which calls powerOn()
     * with a special resume value (RESUME_REPOWER) if the computer is already marked as "ready", meaning the browser
     * didn't change anything.  This "repower" process should be very quick, essentially just marking all components as
     * powered again (so that, for example, the Video component will start drawing again) and firing the CPU up again.
     *
     * Reportedly, some browsers (eg, Opera) don't support "onbeforeunload", in which case Component will have to use
     * "unload" instead.  But even when the page must be rebuilt from scratch, the combination of browser cache and
     * localStorage means the simulation should be restored and become operational almost immediately.
     */
    static exit()
    {
        let aeComputers = Component.getElementsByClass(document, PCX86.APPCLASS, "computer");
        for (let iComputer = 0; iComputer < aeComputers.length; iComputer++) {
            let eComputer = aeComputers[iComputer];
            let parmsComputer = Component.getComponentParms(eComputer);
            let computer = /** @type {Computer} */ (Component.getComponentByType("Computer", parmsComputer['id']));
            if (computer) {

                /*
                 * Set new flag that Component functions (eg, notice()) should check before alerting the user.
                 */
                computer.flags.unloading = true;

                if (DEBUG && computer.messageEnabled()) {
                    computer.printMessage("onExit(" + computer.flags.powered + ")");
                }

                if (computer.flags.powered) {
                    /**
                     * Power off the computer, giving every component an opportunity to save its state,
                     * but only if 'resume' has been set AND there is no valid resume path (because if a valid resume
                     * path exists, we'll always load our state from there, and not from whatever we save here).
                     */
                    computer.powerOff(!!(computer.resume && !computer.sResumePath), true);
                }
            }
        }
    }
}

Computer.STATE_FAILSAFE  = "failsafe";
Computer.STATE_VALIDATE  = "validate";
Computer.STATE_TIMESTAMP = "timestamp";
Computer.STATE_VERSION   = "version";
Computer.STATE_HOSTURL   = "url";
Computer.STATE_BROWSER   = "browser";
Computer.STATE_USERID    = "user";

/*
 * The following constants define all the resume options.  Negative values (eg, RESUME_REPOWER) are for
 * internal use only, and RESUME_DELETE is not documented (it provides a way of deleting ALL saved states
 * whenever a resume is declined).  As a result, the only "end-user" values are 0, 1 and 2.
 */
Computer.RESUME_REPOWER  = -1;  // resume without changing any state (for internal use only)
Computer.RESUME_NONE     =  0;  // default (no resume)
Computer.RESUME_AUTO     =  1;  // automatically save/restore state
Computer.RESUME_PROMPT   =  2;  // automatically save but conditionally restore (WARNING: if restore is declined, any state is discarded)
Computer.RESUME_DELETE   =  3;  // same as RESUME_PROMPT but discards ALL machines states whenever ANY machine restore is declined (undocumented)

Computer.UPDATES_PER_SECOND = 2;

/*
 * Initialize every Computer on the page.
 */
Web.onInit(Computer.init);
Web.onShow(Computer.show);
Web.onExit(Computer.exit);



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/state.js (C) Jeff Parsons 2012-2018
 */


class State {
    /**
     * State(component, sVersion, sSuffix)
     *
     * State objects are used by components to save/restore their state.
     *
     * During a save operation, components add data to a State object via set(), and then return
     * the resulting data using data().
     *
     * During a restore operation, the Computer component passes the results of each data() call
     * back to the originating component.
     *
     * WARNING: Since State objects are low-level objects that have no UI requirements, they do not
     * inherit from the Component class, so you should only use class methods of Component, such as
     * Component.assert() (or Debugger methods if the Debugger is available).
     *
     * NOTE: 1.01 is the first version to provide limited save/restore support using localStorage.
     * From that point on, care must be taken to insure that any new version that's incompatible with
     * previous localStorage data be released with a version number that is at least 1 greater,
     * since we're tagging the localStorage data with the integer portion of the version string.
     *
     * @param {Component} component
     * @param {string} [sVersion] is used to append a major version number to the key
     * @param {string} [sSuffix] is used to append any additional suffixes to the key
     */
    constructor(component, sVersion, sSuffix)
    {
        this.id = component.id;
        this.dbg = component.dbg;
        this.json = "";
        this.state = {};
        this.fLoaded = this.fParsed = false;
        this.key = State.getKey(component, sVersion, sSuffix);
        this.unload(component.parms);
    }

    /**
     * set(id, data)
     *
     * @this {State}
     * @param {number|string} id
     * @param {Object|string} data
     */
    set(id, data)
    {
        try {
            this.state[id] = data;
        } catch(e) {
            Component.log(e.message);
        }
    }

    /**
     * get(id)
     *
     * @this {State}
     * @param {number|string} id
     * @return {Object|string|null}
     */
    get(id)
    {
        return this.state[id] || null;
    }

    /**
     * data()
     *
     * @this {State}
     * @return {Object}
     */
    data()
    {
        return this.state;
    }

    /**
     * load(json)
     *
     * WARNING: Make sure you follow this call with either a call to parse() or unload(),
     * because any stringified data that we've loaded isn't usable until it's been parsed.
     *
     * @this {State}
     * @param {string|null} [json]
     * @return {boolean} true if state exists in localStorage, false if not
     */
    load(json)
    {
        if (json) {
            this.json = json;
            this.fLoaded = true;
            this.fParsed = false;
            return true;
        }
        if (this.fLoaded) {
            /*
             * This is assumed to be a redundant load().
             */
            return true;
        }
        if (Web.hasLocalStorage()) {
            let s = Web.getLocalStorageItem(this.key);
            if (s) {
                this.json = s;
                this.fLoaded = true;
                if (DEBUG) Component.log("localStorage(" + this.key + "): " + s.length + " bytes loaded");
                return true;
            }
        }
        return false;
    }

    /**
     * parse()
     *
     * This completes the load() operation, by parsing what was loaded, on the assumption there
     * might be some benefit to deferring parsing until we've given the user a chance to confirm.
     * Otherwise, load() could have just as easily done this, too.
     *
     * @this {State}
     * @return {boolean} true if successful, false if error
     */
    parse()
    {
        let fSuccess = true;
        if (!this.fParsed) {
            try {
                this.state = JSON.parse(this.json);
                this.fParsed = true;
            } catch (e) {
                Component.error(e.message || e);
                fSuccess = false;
            }
        }
        return fSuccess;
    }

    /**
     * store()
     *
     * @this {State}
     * @return {boolean} true if successful, false if error
     */
    store()
    {
        let fSuccess = true;
        if (Web.hasLocalStorage()) {
            let s = JSON.stringify(this.state);
            if (Web.setLocalStorageItem(this.key, s)) {
                if (DEBUG) Component.log("localStorage(" + this.key + "): " + s.length + " bytes stored");
            } else {
                /*
                 * WARNING: Because browsers tend to disable all alerts() during an "unload" operation,
                 * it's unlikely anyone will ever see the "quota" errors that occur at this point.  Need to
                 * think of some way to notify the user that there's a problem, and offer a way of cleaning
                 * up old states.
                 */
                Component.error("Unable to store " + s.length + " bytes in browser local storage");
                fSuccess = false;
            }
        }
        return fSuccess;
    }

    /**
     * toString()
     *
     * @this {State}
     * @return {string} JSON-encoded state
     */
    toString()
    {
        return this.state? JSON.stringify(this.state) : this.json;
    }

    /**
     * unload(parms)
     *
     * This discards any data saved via set() or loaded via load(), creating an empty State object.
     * Note that you have to follow this call with an explicit call to store() if you want to remove
     * the state from localStorage as well.
     *
     * @this {State}
     * @param {Object} [parms]
     */
    unload(parms)
    {
        this.json = "";
        this.state = {};
        this.fLoaded = this.fParsed = false;
        if (parms) this.set("parms", parms);
    }

    /**
     * clear(fAll)
     *
     * This unloads the current state, and then clears ALL localStorage for the current machine,
     * independent of version, to reduce the chance of orphaned states wasting part of our limited allocation.
     *
     * @this {State}
     * @param {boolean} [fAll] true to unconditionally clear ALL localStorage for the current domain
     */
    clear(fAll)
    {
        this.unload();
        let aKeys = Web.getLocalStorageKeys();
        for (let i = 0; i < aKeys.length; i++) {
            let sKey = aKeys[i];
            if (sKey && (fAll || sKey.substr(0, this.key.length) == this.key)) {
                Web.removeLocalStorageItem(sKey);
                if (DEBUG) Component.log("localStorage(" + sKey + ") removed");
                aKeys.splice(i, 1);
                i = 0;
            }
        }
    }

    /**
     * State.getKey(component, sVersion, sSuffix)
     *
     * This encapsulates the key generation code.
     *
     * @param {Component} component
     * @param {string} [sVersion] is used to append a major version number to the key
     * @param {string} [sSuffix] is used to append any additional suffixes to the key
     * @return {string} key
     */
    static getKey(component, sVersion, sSuffix)
    {
        let key = component.id;
        if (sVersion) {
            let i = sVersion.indexOf('.');
            if (i > 0) key += ".v" + sVersion.substr(0, i);
        }
        if (sSuffix) {
            key += "." + sSuffix;
        }
        return key;
    }

    /**
     * State.compress(aSrc)
     *
     * @param {Array.<number>|null} aSrc
     * @return {Array.<number>|null} is either the original array (aSrc), or a smaller array of "count, value" pairs (aComp)
     */
    static compress(aSrc)
    {
        if (aSrc) {
            let iSrc = 0;
            let iComp = 0;
            let aComp = [];
            while (iSrc < aSrc.length) {
                let n = aSrc[iSrc];

                let iCompare = iSrc + 1;
                while (iCompare < aSrc.length && aSrc[iCompare] === n) iCompare++;
                aComp[iComp++] = iCompare - iSrc;
                aComp[iComp++] = n;
                iSrc = iCompare;
            }
            if (aComp.length < aSrc.length) return aComp;
        }
        return aSrc;
    }

    /**
     * State.decompress(aComp)
     *
     * @param {Array.<number>} aComp
     * @param {number} [nLength] (expected length of decompressed data)
     * @return {Array.<number>}
     */
    static decompress(aComp, nLength)
    {
        let iDst = 0;
        let aDst = nLength? new Array(nLength) : [];
        let iComp = 0;
        while (iComp < aComp.length - 1) {
            let c = aComp[iComp++];
            let n = aComp[iComp++];
            while (c--) aDst[iDst++] = n;
        }

        return aDst;
    }

    /**
     * State.compressEvenOdd(aSrc)
     *
     * This is a very simple variation on compress() that compresses all the EVEN elements of aSrc first,
     * followed by all the ODD elements.  This tends to work better on EGA video memory, because when odd/even
     * addressing is enabled (eg, for text modes), the DWORD values tend to alternate, which is the worst case
     * for compress(), but the best case for compressEvenOdd().
     *
     * One wrinkle we support: if the first element is uninitialized, then we assume the entire array is undefined,
     * and return an empty compressed array.  Conversely, decompressEvenOdd() will take an empty compressed array
     * and return an uninitialized array.
     *
     * @param {Array.<number>|null} aSrc
     * @return {Array.<number>|null} is either the original array (aSrc), or a smaller array of "count, value" pairs (aComp)
     */
    static compressEvenOdd(aSrc)
    {
        if (aSrc) {
            let iComp = 0, aComp = [];
            if (aSrc[0] !== undefined) {
                for (let off = 0; off < 2; off++) {
                    let iSrc = off;
                    while (iSrc < aSrc.length) {
                        let n = aSrc[iSrc];
                        let iCompare = iSrc + 2;
                        while (iCompare < aSrc.length && aSrc[iCompare] === n) iCompare += 2;
                        aComp[iComp++] = (iCompare - iSrc) >> 1;
                        aComp[iComp++] = n;
                        iSrc = iCompare;
                    }
                }
            }
            if (aComp.length < aSrc.length) return aComp;
        }
        return aSrc;
    }

    /**
     * State.decompressEvenOdd(aComp, nLength)
     *
     * This is the counterpart to compressEvenOdd().  Note that because there's nothing in the compressed sequence
     * that differentiates a compress() sequence from a compressEvenOdd() sequence, you simply have to be consistent:
     * if you used even/odd compression, then you must use even/odd decompression.
     *
     * @param {Array.<number>} aComp
     * @param {number} nLength is expected length of decompressed data
     * @return {Array.<number>}
     */
    static decompressEvenOdd(aComp, nLength)
    {
        let iDst = 0;
        let aDst = new Array(nLength);
        let iComp = 0;
        while (iComp < aComp.length - 1) {
            let c = aComp[iComp++];
            let n = aComp[iComp++];
            while (c--) {
                aDst[iDst] = n;
                iDst += 2;
            }
            /*
             * The output of a "count,value" pair will never exceed the end of the output array, so as soon as we reach it
             * the first time, we know it's time to switch to ODD elements, and as soon as we reach it again, we should be
             * done.
             */

            if (iDst == nLength) iDst = 1;
        }

        return aDst;
    }
}



/**
 * @copyright https://www.pcjs.org/modules/shared/lib/embed.js (C) Jeff Parsons 2012-2018
 */


/*
 * We now support asynchronous XML and XSL file loads; simply set fAsync (below) to true.
 *
 * NOTE: For that support to work, we have to keep track of the number of machines on the page
 * (ie, how many embedMachine() calls were issued), reduce the count as each machine XML file
 * is fully transformed into HTML, and when the count finally returns to zero, notify all the
 * machine component init() handlers.
 *
 * Also, to prevent those init() handlers from running prematurely, we must disable all page
 * notification events at the start of the embedding process (Web.enablePageEvents(false)) and
 * re-enable them at the end (Web.enablePageEvents(true)).
 */
var fAsync = true;
var cAsyncMachines = 0;

/**
 * loadXML(sFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)
 *
 * This is the preferred way to load all XML and XSL files. It uses getResource()
 * to load them as strings, which parseXML() can massage before parsing/transforming them.
 *
 * For example, since I've been unable to get the XSLT document() function to work inside any
 * XSL document loaded by JavaScript's XSLT processor, that has prevented me from dynamically
 * loading any XML machine file that uses the "ref" attribute to refer to and incorporate
 * another XML document.
 *
 * To solve that, I've added an fResolve parameter that tells parseXML() to fetch any
 * referenced documents ITSELF and insert them into the XML string prior to parsing, instead
 * of relying on the XSLT template to pull them in.  That fetching is handled by resolveXML(),
 * which iterates over the XML until all "refs" have been resolved (including any nested
 * references).
 *
 * Also, XSL files with a <!DOCTYPE [...]> cause MSIE's Microsoft.XMLDOM.loadXML() function
 * to choke, so I strip that out prior to parsing as well.
 *
 * TODO: Figure out why the XSLT document() function works great when the web browser loads an
 * XML file (and the associated XSL file) itself, but does not work when loading documents via
 * JavaScript XSLT support. Is it broken, is it a security issue, or am I just calling it wrong?
 *
 * @param {string} sXMLFile
 * @param {string} idMachine
 * @param {string} sAppName
 * @param {string} sAppClass
 * @param {string} sParms (machine parameters, if any)
 * @param {string} sClass (an optional machine class name used to style the machine)
 * @param {boolean} fResolve is true to resolve any "ref" attributes
 * @param {function(string)} display
 * @param {function(string,Object)} done (string contains the unparsed XML string data, and Object contains a parsed XML object)
 */
function loadXML(sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)
{
    let doneLoadXML = function(sURLName, sXML, nErrorCode) {
        if (nErrorCode) {
            if (!sXML) sXML = "unable to load " + sXMLFile + " (" + nErrorCode + ")";
            done(sXML, null);
            return;
        }
        parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done);
    };
    display("Loading " + sXMLFile + "...");
    Web.getResource(sXMLFile, null, fAsync, doneLoadXML);
}

/**
 * parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)
 *
 * Generates an XML document from an XML string. This function also provides a work-around for XSLT's
 * lack of support for the document() function (at least on some browsers), by replacing every reference
 * tag (ie, a tag with a "ref" attribute) with the contents of the referenced file.
 *
 * @param {string} sXML
 * @param {string} sXMLFile
 * @param {string} idMachine
 * @param {string} sAppName
 * @param {string} sAppClass
 * @param {string} sParms (machine parameters, if any)
 * @param {string} sClass (an optional machine class name used to style the machine)
 * @param {boolean} fResolve is true to resolve any "ref" attributes; default is false
 * @param {function(string)} display
 * @param {function(string,Object)} done (string contains the unparsed XML string data, and Object contains a parsed XML object)
 */
function parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)
{
    let buildXML = function(sXML, sError) {
        if (sError) {
            done(sError, null);
            return;
        }
        if (idMachine) {

            /*
             * A more sensible place to record the machine XML would be embedMachine(), like we do for the
             * XSL file, but since we're about to modify the original machine XML, it's best to record it now.
             */
            Component.addMachineResource(idMachine, sXMLFile, sXML);

            let sURL = sXMLFile;
            if (sURL && sURL.indexOf('/') < 0 && window.location.pathname.slice(-1) == '/') {
                sURL = window.location.pathname + sURL;
            }
            /*
             * We embed the URL of the XML file both as a separate "xml" attribute for easy access from the
             * XSL file, and as part of the "parms" attribute for easy access from machines (see getMachineParm()).
             */
            if (!sParms) {
                sParms = '{';
            } else if (sParms.slice(-1) == '}') {
                sParms = sParms.slice(0, -1);
                if (sParms.length > 1) sParms += ',';
            } else {            // sParms must just be a "state" file, so encode it as a "state" property
                sParms = '{state:"' + sParms + '",';
            }
            sParms += 'url:"' + sURL + '"}';
            /*
             * Note that while we no longer generate a machine XML file with a "state" attribute (because it's
             * encoded inside the "parms" attribute), the XSL file must still cope with "state" attributes inside
             * other XML files; for example, manifest XML files like /apps/pcx86/1981/visicalc/manifest.xml contain
             * machine elements with "state" attributes that must still be passed down to the computer element
             * "the old fashioned way".
             *
             * Until/unless that changes, components.xsl cannot be simplified as much as I might have hoped.
             */
            if (typeof resources == 'object') sURL = null;      // turn off URL inclusion if we have embedded resources
            sParms = sParms.replace(/\$/g, "$$$$");
            if (sClass) {
                /*
                 * If there's no hard-coded "class" attribute in the machine tag, then we can set one in the final
                 * replacement below, just like we do for sParms and sURL.  However, if a "class" attribute already
                 * exists, we need alter it and then zap the sClass variable.
                 */
                let match = sXML.match(/(<machine[^>]*\sclass=)(['"])(.*?)(\2.*?>)/);
                if (match) {
                    sXML = sXML.replace(match[0], match[1] + match[2] + sClass + match[4]);
                    sClass = "";
                }
            }
            sXML = sXML.replace(/(<machine[^>]*\sid=)(['"]).*?\2/, "$1$2" + idMachine + "$2" + (sClass? ' class="' + sClass + '"' : '') + (sParms? " parms='" + sParms + "'" : "") + (sURL? ' url="' + sURL + '"' : ''));
        }

        if (!fResolve) {
            /*
             * I'm trying to switch to a shared components.xsl (at least for all PC-class machines),
             * but in the interim, that means hacking the XSL file on the fly to reflect the actual class.
             */
            sXML = sXML.replace(/(<xsl:variable name="APPNAME">).*?(<\/xsl:variable>)/, "$1" + sAppName + "$2");
            sXML = sXML.replace(/(<xsl:variable name="APPCLASS">).*?(<\/xsl:variable>)/, "$1" + sAppClass + "$2");

            /*
             * Non-COMPILED kludge to replace the version number template in the XSL file (which we assume we're reading,
             * since fResolve is false) with whatever XMLVERSION we extracted from the XML file (see corresponding kludge below).
             *
             * ES6 ALERT: Template strings.
             */
            if (!COMPILED && XMLVERSION) {
                sXML = sXML.replace(/<xsl:variable name="APPVERSION"(\/>|><\/xsl:variable>)/, `<xsl:variable name="APPVERSION">${XMLVERSION}</xsl:variable>`);
            }
        }

        /*
         * If the resource we requested is not really an XML file (or the file didn't exist and the server simply returned
         * a message like "Cannot GET /devices/pc/machine/5150/cga/64kb/donkey/machine.xml"), we'd like to display a more
         * meaningful message, because the XML DOM parsers will blithely return a document that contains nothing useful; eg:
         *
         *      This page contains the following errors:error on line 1 at column 1:
         *      Document is empty Below is a rendering of the page up to the first error.
         *
         * Supposedly, the IE XML DOM parser will throw an exception, but I haven't tested that, and unless all other
         * browsers do that, that's not helpful.
         *
         * The best I can do at this stage (assuming Web.getResource() didn't drop any error information on the floor)
         * is verify that the requested resource "looks like" valid XML (in other words, it begins with a '<').
         */
        let xmlDoc = null;
        if (sXML.charAt(0) == '<') {
            try {
                /*
                 * Another hack for MSIE, which fails to load XSL documents containing a <!DOCTYPE [...]> tag.
                 *
                 * This is also why the XSLTProcessor 'transformToFragment' method in Microsoft Edge silently failed,
                 * so I had pull this hack out of the "ActiveXObject" code.  And rather than add yet-another Microsoft
                 * browser check, I'm going to try doing this across the board, and hope that none of the other XSLT
                 * processors fail *without* the DOCTYPE tag.
                 */
                if (!fResolve) {
                    sXML = sXML.replace(/<!DOCTYPE(.|[\r\n])*]>\s*/g, "");
                }
                /*
                 * Beginning with Microsoft Edge and the corresponding release of Windows 10, all the
                 * 'ActiveXObject' crud has gone away; but of course, this code must remain in place if
                 * we want to continue supporting older Internet Explorer browsers (ie, back to IE9).
                 */
                /** @namespace window.ActiveXObject */
                if (window.ActiveXObject || 'ActiveXObject' in window) {        // second test is required for IE11 on Windows 8.1
                    xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = false;
                    xmlDoc['loadXML'](sXML);
                } else {
                    /** @namespace window.DOMParser */
                    xmlDoc = (new window.DOMParser()).parseFromString(sXML, "text/xml");
                }
            } catch(e) {
                xmlDoc = null;
                sXML = e.message;
            }
        } else {
            sXML = "unrecognized XML: " + (sXML.length > 255? sXML.substr(0, 255) + "..." : sXML);
        }
        done(sXML, xmlDoc);
    };
    if (sXML) {
        if (PRIVATE) sXML = sXML.replace(/\/library.xml/, "/private/library.xml");
        if (fResolve) {
            resolveXML(sXML, display, buildXML);
            return;
        }
        buildXML(sXML, "");
        return;
    }
    done("no data" + (sXMLFile? " for file: " + sXMLFile : ""), null);
}

/**
 * resolveXML(sXML, display, done)
 *
 * Replaces every tag with a "ref" attribute with the contents of the corresponding file.
 *
 * TODO: Fix some of the limitations of this code, such as: 1) requiring the "ref" attribute
 * to appear as the tag's first attribute, 2) requiring the "ref" attribute to be double-quoted,
 * and 3) requiring the "ref" tag to be self-closing.
 *
 * @param {string} sXML
 * @param {function(string)} display
 * @param {function(string,string)} done (the first string contains the resolved XML data, the second is for any error message)
 */
function resolveXML(sXML, display, done)
{
    let matchRef;
    let reRef = /<([a-z]+)\s+ref="(.*?)"(.*?)\/>/g;

    if ((matchRef = reRef.exec(sXML))) {

        let sRefFile = matchRef[2];

        let doneReadXML = function(sURLName, sXMLRef, nErrorCode) {
            if (nErrorCode || !sXMLRef) {
                done(sXML, "unable to resolve XML reference: " + matchRef[0] + " (" + nErrorCode + ")");
                return;
            }
            /*
             * If there are additional attributes in the "referring" XML tag, we want to insert them
             * into the "referred" XML tag; attributes that don't exist in the referred tag should be
             * appended, and attributes that DO exist should be overwritten.
             */
            let sRefAttrs = matchRef[3];
            if (sRefAttrs) {
                let aXMLRefTag = sXMLRef.match(new RegExp("<" + matchRef[1] + "[^>]*>"));
                if (aXMLRefTag) {
                    let sXMLNewTag = aXMLRefTag[0];
                    /*
                     * Iterate over all the attributes in the "referring" XML tag (sRefAttrs)
                     */
                    let matchAttr;
                    let reAttr = /( [a-z]+=)(['"])(.*?)\2/gi;
                    while ((matchAttr = reAttr.exec(sRefAttrs))) {
                        if (sXMLNewTag.toLowerCase().indexOf(matchAttr[1].toLowerCase()) < 0) {
                            /*
                             * This is the append case....
                             */
                            sXMLNewTag = sXMLNewTag.replace(">", matchAttr[0] + ">");
                        } else {
                            /*
                             * This is the overwrite case....
                             */
                            sXMLNewTag = sXMLNewTag.replace(new RegExp(matchAttr[1] + "(['\"])(.*?)\\1"), matchAttr[0]);
                        }
                    }
                    if (aXMLRefTag[0] != sXMLNewTag) {
                        sXMLRef = sXMLRef.replace(aXMLRefTag[0], sXMLNewTag);
                    }
                } else {
                    done(sXML, "missing <" + matchRef[1] + "> in " + sRefFile);
                    return;
                }
            }

            /*
             * Apparently when a Windows Azure server delivers one of my XML files, it may modify the first line:
             *
             *      <?xml version="1.0" encoding="UTF-8"?>\n
             *
             * I didn't determine exactly what it was doing at this point (probably just changing the \n to \r\n),
             * but in any case, relaxing the following replace() solved it.
             */
            sXMLRef = sXMLRef.replace(/<\?xml[^>]*>[\r\n]*/, "");

            sXML = sXML.replace(matchRef[0], sXMLRef);

            resolveXML(sXML, display, done);
        };

        display("Loading " + sRefFile + "...");
        Web.getResource(sRefFile, null, fAsync, doneReadXML);
        return;
    }
    done(sXML, "");
}

/**
 * embedMachine(sAppName, sAppClass, sVersion, idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * This allows to you embed a machine on a web page, by transforming the machine XML into HTML.
 *
 * @param {string} sAppName is the app name (eg, "PCx86")
 * @param {string} sAppClass is the app class (eg, "pcx86"); also known as the machine class
 * @param {string} sVersion is the app version (eg, "1.15.7")
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms] (machine parameters, if any)
 * @param {string} [sClass] (an optional machine class name used to style the machine)
 * @return {boolean} true if successful, false if error
 */
function embedMachine(sAppName, sAppClass, sVersion, idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    let eMachine, eWarning, fSuccess = true;

    if (!sXMLFile) {
        sXMLFile = "machine.xml";
        if (!sXSLFile) sXSLFile = "components.xsl";
    }

    cAsyncMachines++;
    Component.addMachine(idMachine);

    let doneMachine = function() {

        if (!--cAsyncMachines) {
            if (fAsync) Web.enablePageEvents(true);
        }
    };

    let displayError = function(sError) {
        Component.log(sError);
        displayMessage("Error: " + sError);
        if (fSuccess) doneMachine();
        fSuccess = false;
    };

    let displayMessage = function(sMessage) {
        if (eWarning === undefined) {
            /*
             * Our MarkOut module (in convertMDMachineLinks()) creates machine containers that look like:
             *
             *      <div id="' + sMachineID + '" class="machine-placeholder"><p>Embedded PC</p><p class="machine-warning">...</p></div>
             *
             * with the "machine-warning" paragraph pre-populated with a warning message that the user will
             * see if nothing at all happens.  But hopefully, in the normal case (and especially the error case),
             * *something* will have happened.
             *
             * Note that it is the HTMLOut module (in processMachines()) that ultimately decides which scripts to
             * include and then generates the embedXXX() call.
             */
            let aeWarning = (eMachine && Component.getElementsByClass(eMachine, "machine-warning"));
            eWarning = (aeWarning && aeWarning[0]) || eMachine;
        }
        if (eWarning) eWarning.innerHTML = Str.escapeHTML(sMessage);
    };

    try {
        eMachine = document.getElementById(idMachine);
        if (eMachine) {

            /*
             * If we have a 'css' resource, add it to the page first.
             */
            let css;
            if (typeof resources == "object" && (css = resources['css'])) {
                let head = document.head || document.getElementsByTagName('head')[0];
                let style = document.createElement('style');
                style.type = 'text/css';
                // noinspection JSDeprecatedSymbols
                if (style.styleSheet) {
                    // noinspection JSDeprecatedSymbols
                    style.styleSheet.cssText = css;
                } else {
                    style.appendChild(document.createTextNode(css));
                }
                head.appendChild(style);
            }

            if (!sXSLFile) {
                /*
                 * Now that PCjs is an open-source project, we can make the following test more flexible,
                 * and revert to the internal template if DEBUG *or* internal version (instead of *and*).
                 *
                 * Third-party sites that don't use the PCjs server will ALWAYS want to specify a fully-qualified
                 * path to the XSL file, unless they choose to mirror our folder structure.
                 */
                let sAppFolder = sAppClass;
                if (DEBUG || !sVersion) {
                    if (sAppClass != "c1pjs") sAppFolder = "shared";
                    sXSLFile = "/modules/" + sAppFolder + "/templates/components.xsl";
                } else {
                    if (sAppClass.substr(0, 3) == "pdp") sAppFolder = "pdpjs";
                    sXSLFile = "/versions/" + sAppFolder + "/" + sVersion + "/components.xsl";
                }
            }

            let processXML = function(sXML, xml) {
                if (!xml) {
                    displayError(sXML);
                    return;
                }

                /*
                 * Non-COMPILED kludge to extract the version number from the stylesheet path in the machine XML file;
                 * we don't need this code in COMPILED (non-DEBUG) releases, because APPVERSION is hard-coded into them.
                 */
                if (!COMPILED) {
                    let aMatch = sXML.match(/<\?xml-stylesheet[^>]* href=(['"])[^'"]*?\/([0-9.]*)\/([^'"]*)\1/);
                    if (aMatch) {
                        XMLVERSION = aMatch[2];
                    }
                }

                let transformXML = function(sXSL, xsl) {
                    if (!xsl) {
                        displayError(sXSL);
                        return;
                    }

                    /*
                     * Record the XSL file, in case someone wants to save the entire machine later.
                     *
                     * NOTE: sXSLFile will never be undefined by this point, but apparently the Closure Compiler doesn't realize that.
                     */
                    Component.addMachineResource(idMachine, sXSLFile || "", sXSL);

                    /*
                     * The <machine> template in components.xsl now generates a "machine div" that makes
                     * the div we required the caller of embedMachine() to provide redundant, so instead
                     * of appending this fragment to the caller's node, we REPLACE the caller's node.
                     * This works only because because we ALSO inject the caller's "machine div" ID into
                     * the fragment's ID during parseXML().
                     *
                     *      eMachine.innerHTML = sFragment;
                     *
                     * Also, if the transform function fails, make sure you're using the appropriate
                     * "components.xsl" and not a "machine.xsl", because the latter will not produce valid
                     * embeddable HTML (and is the most common cause of failure at this final stage).
                     */
                    displayMessage("Processing " + sXMLFile + "...");

                    /*
                     * Beginning with Microsoft Edge and the corresponding release of Windows 10, all the
                     * 'ActiveXObject' crud has gone away; but of course, this code must remain in place if
                     * we want to continue supporting older Internet Explorer browsers (ie, back to IE9).
                     */
                    if (window.ActiveXObject || 'ActiveXObject' in window) {        // second test is required for IE11 on Windows 8.1
                        let sFragment = xml['transformNode'](xsl);
                        if (sFragment) {
                            eMachine.outerHTML = sFragment;
                            doneMachine();
                        } else {
                            displayError("transformNodeToObject failed");
                        }
                    }
                    else if (document.implementation && document.implementation.createDocument) {
                        let xsltProcessor = new XSLTProcessor();
                        xsltProcessor['importStylesheet'](xsl);
                        let eFragment = xsltProcessor['transformToFragment'](xml, document);
                        if (eFragment) {
                            /*
                             * This fails in Microsoft Edge...
                             *
                             *      let machine = eFragment.getElementById(idMachine);
                             *      if (!machine) {
                             *          displayError("machine generation failed: " + idMachine);
                             *      }
                             */
                            let element = eMachine.parentNode;
                            if (element) {

                                let x = 0, y = 0;
                                let rectOld = eMachine.getBoundingClientRect();
                                if (rectOld.bottom < 0) {
                                    x = window.scrollX;
                                    y = window.scrollY;
                                }

                                element.replaceChild(eFragment, eMachine);

                                eMachine = document.getElementById(idMachine);
                                if (eMachine && rectOld.bottom < 0) {
                                    let rectNew = eMachine.getBoundingClientRect();
                                    if (window.performance && window.performance.navigation.type == window.performance.navigation.TYPE_RELOAD) {
                                        /*
                                         * TODO: I'm not sure what to do in this case, because the browser tries to be clever
                                         * on a reload and preserve the original scroll position, but there are multiple variables
                                         * (ie, the presence of a hash ID in the URL, and the fact that we just inserted an HTML
                                         * fragment) that can cause the browser to do the wrong thing.  I could look up any hash
                                         * element and call scrollIntoView(), but that addresses only one scenario.
                                         *
                                         * If I do nothing, then each successive reload simply causes the scroll position to creep
                                         * farther and farther down the page.  So, I'm electing to go to the top of the page instead.
                                         */
                                        y = 0;
                                    } else {
                                        y += Math.ceil(rectNew.height - rectOld.height);
                                    }
                                    window.scrollTo(x, y);
                                }
                                doneMachine();
                            } else {
                                /*
                                 * NOTE: This error can occur if our Node web server, when processing a folder with
                                 * both a manifest.xml with a machine.xml reference AND a README.md containing a
                                 * machine link, generates duplicate embedXXX() calls for the same machine; if the
                                 * first embedXXX() call finds its target, subsequent calls for the same target will
                                 * fail.
                                 *
                                 * Technically, such a folder is in a misconfigured state, but it happens, in part
                                 * because when we switched to the Jekyll web server, we had to add machine links to
                                 * all README.md files where we had previously relied on manifest.xml or machine.xml
                                 * processing.  This is because the Jekyll web server currently doesn't process XML
                                 * files, nor is support for that likely to be added any time soon; it was a nice
                                 * feature of the Node web server, but it's not clear that it's worth doing for Jekyll.
                                 */
                                displayError("invalid machine element: " + idMachine);
                            }
                        } else {
                            displayError("transformToFragment failed");
                        }
                    } else {
                        /*
                         * Perhaps I should have performed this test at the outset; on the other hand, I'm
                         * not aware of any browsers don't support one or both of the above XSLT transformation
                         * methods, so treat this as a bug.
                         */
                        displayError("unable to transform XML: unsupported browser");
                    }
                };
                /*
                 * NOTE: sXSLFile will never be undefined by this point, but apparently the Closure Compiler doesn't realize that.
                 */
                loadXML(sXSLFile || "", "", sAppName, sAppClass, "", "", false, displayMessage, transformXML);
            };

            if (sXMLFile.charAt(0) != '<') {
                loadXML(sXMLFile, idMachine, sAppName, sAppClass, sParms || "", sClass || "", true, displayMessage, processXML);
            } else {
                parseXML(sXMLFile, "", idMachine, sAppName, sAppClass, sParms || "", sClass || "", false, displayMessage, processXML);
            }
        } else {
            displayError("missing machine element: " + idMachine);
        }
    } catch(e) {
        displayError(e.message);
    }
    return fSuccess;
}

/**
 * embedC1P(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @return {boolean} true if successful, false if error
 */
function embedC1P(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) Web.enablePageEvents(false);
    return embedMachine("C1Pjs", "c1pjs", APPVERSION, idMachine, sXMLFile, sXSLFile, undefined, sClass);
}

/**
 * embedPCx86(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @return {boolean} true if successful, false if error
 */
function embedPCx86(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) Web.enablePageEvents(false);
    return embedMachine("PCx86", "pcx86", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms, sClass);
}

/**
 * embedPC8080(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @return {boolean} true if successful, false if error
 */
function embedPC8080(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) Web.enablePageEvents(false);
    return embedMachine("PC8080", "pc8080", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms, sClass);
}

/**
 * embedPDP10(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @return {boolean} true if successful, false if error
 */
function embedPDP10(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) Web.enablePageEvents(false);
    return embedMachine("PDPjs", "pdp10", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms, sClass);
}

/**
 * embedPDP11(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @return {boolean} true if successful, false if error
 */
function embedPDP11(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) Web.enablePageEvents(false);
    return embedMachine("PDPjs", "pdp11", APPVERSION, idMachine, sXMLFile, sXSLFile, sParms, sClass);
}

/**
 * findMachineComponent(idMachine, sType)
 *
 * @param {string} idMachine
 * @param {string} sType
 * @return {Component|null}
 */
function findMachineComponent(idMachine, sType)
{
    return Component.getComponentByType(sType, idMachine + ".machine");
}

/**
 * commandMachine(control, fSingle, idMachine, sComponent, sCommand, sValue)
 *
 * Use Component methods to find the requested component for a specific machine, and if the component is found,
 * then check its 'exports' table for an entry matching the specified command string, and if an entry is found, then
 * the corresponding function is called with the specified data.
 *
 * @param {Object} control
 * @param {boolean} fSingle
 * @param {string} idMachine
 * @param {string} sComponent
 * @param {string} sCommand
 * @param {string} [sValue]
 * @return {boolean}
 */
function commandMachine(control, fSingle, idMachine, sComponent, sCommand, sValue)
{
    if (sCommand == "script") {
        if (Component.processScript(idMachine, sValue)) {
            if (fSingle) control.disabled = true;
            return true;
        }
        return false;
    }
    if (sComponent) {
        let component = Component.getComponentByType(sComponent, idMachine + ".machine");
        if (component) {
            let exports = component['exports'];
            if (exports) {
                let fnCommand = exports[sCommand];
                if (fnCommand) {
                    if (fnCommand.call(component, sValue)) {
                        if (fSingle) control.disabled = true;
                        return true;
                    }
                    return false;
                }
            }
        }
    }
    console.log("unimplemented: commandMachine('" + idMachine + "','" + sComponent + "','" + sCommand + "','" + sValue + "')");
    return false;
}

/**
 * Prevent the Closure Compiler from renaming functions we want to export, by adding them as global properties.
 *
 * TODO: Consider making all these functions properties on a single global object (eg, 'PCjs'), to minimize global
 * pollution and risk of name collision.
 */
if (APPNAME == "C1Pjs") {
    window['embedC1P']    = embedC1P;
}
if (APPNAME == "PCx86") {
    window['embedPC']     = embedPCx86;         // WARNING: embedPC() deprecated as of v1.23.0
    window['embedPCx86']  = embedPCx86;
}
if (APPNAME == "PC8080") {
    window['embedPC8080'] = embedPC8080;
}
if (APPNAME == "PDPjs") {
    window['embedPDP10']  = embedPDP10;
    window['embedPDP11']  = embedPDP11;
}

window['commandMachine'] = commandMachine;

window['enableEvents'] = Web.enablePageEvents;
window['sendEvent']    = Web.sendPageEvent;

/**
 * @copyright https://www.pcjs.org/modules/shared/lib/save.js (C) Jeff Parsons 2012-2018
 */


/**
 * savePC(idMachine, sPCJSFile, callback)
 *
 * @param {string} idMachine
 * @param {string} sPCJSFile
 * @param {function(Object)} [callback]
 * @return {boolean} true if successful, false if error
 */
function savePC(idMachine, sPCJSFile, callback)
{
    let cmp = /** @type {Computer} */ (Component.getComponentByType("Computer", idMachine));
    let dbg = false; // /** @type {Debugger} */ (Component.getComponentByType("Debugger", idMachine));
    if (cmp) {
        let sState = cmp.powerOff(true);
        let sParms = cmp.saveMachineParms();
        if (!sPCJSFile) {
            if (DEBUG) {
                sPCJSFile = "/versions/pcx86/" + (XMLVERSION || APPVERSION) + "/pcx86-uncompiled.js"
            } else {
                sPCJSFile = "/versions/pcx86/" + (XMLVERSION || APPVERSION) + "/pcx86" + (dbg? "-dbg" : "") + ".js";
            }
        }
        if (callback && callback({ state: sState, parms: sParms })) return true;
        Web.getResource(sPCJSFile, null, true, function(sURL, sResponse, nErrorCode) {
            downloadCSS(sURL, sResponse, nErrorCode, [idMachine, Str.getBaseName(sPCJSFile, true), sParms, sState]);
        });
        return true;
    }
    Component.alertUser("Unable to identify machine '" + idMachine + "'");
    return false;
}

/**
 * downloadCSS(sURL, sPCJS, nErrorCode, aMachineInfo)
 *
 * @param {string} sURL
 * @param {string} sPCJS
 * @param {number} nErrorCode
 * @param {Array} aMachineInfo ([0] = idMachine, [1] = sScript, [2] = sParms, [3] = sState)
 */
function downloadCSS(sURL, sPCJS, nErrorCode, aMachineInfo)
{
    if (!nErrorCode && sPCJS) {
        aMachineInfo.push(sPCJS);
        let res = Component.getMachineResources(aMachineInfo[0]);
        let sCSSFile = null;
        for (let sName in res) {
            if (Str.endsWith(sName, "components.xsl")) {
                sCSSFile = sName.replace(".xsl", ".css");
                break;
            }
        }
        if (!sCSSFile) {
            /*
             * This is probably a bad idea (ie, allowing downloadPC() to proceed with our stylesheet)...
             */
            downloadPC(sURL, "", 0, aMachineInfo);
        } else {
            Web.getResource(sCSSFile, null, true, function(sURL, sResponse, nErrorCode) {
                downloadPC(sURL, sResponse, nErrorCode, aMachineInfo);
            });
        }
        return;
    }
    Component.alertUser("Error (" + nErrorCode + ") requesting " + sURL);
}

/**
 * downloadPC(sURL, sCSS, nErrorCode, aMachineInfo)
 *
 * @param {string} sURL
 * @param {string} sCSS
 * @param {number} nErrorCode
 * @param {Array} aMachineInfo ([0] = idMachine, [1] = sScript, [2] = sParms, [3] = sState, [4] = sPCJS)
 */
function downloadPC(sURL, sCSS, nErrorCode, aMachineInfo)
{
    let matchScript, sXMLFile, sXSLFile;
    let idMachine = aMachineInfo[0], sScript = aMachineInfo[1], sPCJS = aMachineInfo[4];

    /*
     * sPCJS is supposed to contain the entire PCjs script, which has been wrapped with:
     *
     *      (function(){...
     *
     * at the top and:
     *
     *      ...})();
     *
     * at the bottom, thanks to the following Closure Compiler option:
     *
     *      --output_wrapper "(function(){%output%})();"
     *
     * NOTE: There may also be a source map comment appended to the script, which we now ignore; eg:
     *
     *      //# sourceMappingURL=/versions/pcx86/1.36.1/pcx86.map
     *
     * Immediately inside that wrapping, we want to embed all the specified machine's resources, using:
     *
     *      var resources = {"xml": "...", "xsl": "...", ...};
     *
     * Note that the "resources" variable has been added to our externs.js, to prevent it from being renamed
     * by the Closure Compiler.
     */
    matchScript = sPCJS.match(/^(\s*\(function\(\){)([\s\S]*)(}\)\(\);)/);
    if (!matchScript) {
        /*
         * If the match failed, we assume that a DEBUG (uncompiled) script is being used,
         * so we'll provide a fake match that should work with whatever script was provided.
         */
        if (DEBUG) {
            matchScript = [sPCJS, "", sPCJS, ""];
        } else {
            Component.alertUser("Unsupported script");
            return;
        }
    }

    let resOld = Component.getMachineResources(idMachine), resNew = {}, sName;
    for (sName in resOld) {
        let data = resOld[sName];
        let sExt = Str.getExtension(sName);
        if (sExt == "xml") {
            /*
             * Look through this resource for <disk> entries whose paths do not appear as one of the
             * other machine resources, and remove those entries.
             */
            let matchDisk, reDisk = /[ \t]*<disk [^>]*path=(['"])(.*?)\1.*?<\/disk>\n?/g;
            while (matchDisk = reDisk.exec(resOld[sName])) {
                let path = matchDisk[2];
                if (path) {
                    if (resOld[path]) {
                        Component.log("recording disk: '" + path + "'");
                    } else {
                        data = data.replace(matchDisk[0], "");
                    }
                }
            }
            sXMLFile = sName = Str.getBaseName(sName);
        }
        else if (sExt == "xsl") {
            sXSLFile = sName = Str.getBaseName(sName);
        }
        Component.log("saving resource: '" + sName + "' (" + data.length + " bytes)");
        resNew[sName] = data;
    }

    if (sCSS) {
        resNew[sName = 'css'] = sCSS;
        Component.log("saving resource: '" + sName + "' (" + sCSS.length + " bytes)");
    }

    if (aMachineInfo[2]) {
        let sParms = resNew[sName = 'parms'] = aMachineInfo[2];
        Component.log("saving resource: '" + sName + "' (" + sParms.length + " bytes)");
    }

    if (aMachineInfo[3]) {
        let sState = resNew[sName = 'state'] = aMachineInfo[3];
        Component.log("saving resource: '" + sName + "' (" + sState.length + " bytes)");
    }

    if (sXMLFile && sXSLFile) {
        let sResources = JSON.stringify(resNew);

        sScript += ".js";
        sPCJS = matchScript[1] + "var resources=" + sResources + ";" + matchScript[2] + matchScript[3];
        Component.log("saving machine: '" + idMachine + "' (" + sPCJS.length + " bytes)");

        /*
         * I don't recall exactly why I did this, because I just tested FireFox with copyright symbols intact,
         * and it seems to work fine.  And unfortunately, if we print any copyright strings containing the HTML
         * entity, the entity doesn't get translated prior to output.  So if it turns out we DO need this,
         * it's better to replace with the old-fashioned ASCII version.
         *
         *      sPCJS = sPCJS.replace(/\u00A9/g, "(C)");    // "&#xA9;" or "&copy;"
         */

        let sAlert = Web.downloadFile(sPCJS, "javascript", false, sScript);

        sAlert += ', copy it to your web server as "' + sScript + '", and then add the following to your web page:\n\n';
        sAlert += '<div id="' + idMachine + '"></div>\n';
        sAlert += '...\n';
        sAlert += '<script src="' + sScript + '"></script>\n';

        /*
         * I've updated embedMachine() in embed.js to use these defaults whenever the XML file is omitted, so if our
         * values match those defaults, we can omit both the XML and XSL file parameters and display a simplified call.
         */
        if (sXMLFile == "machine.xml" && sXSLFile == "components.xsl") {
            sXMLFile = sXSLFile = "";
        } else {
            sXMLFile = ',"' + sXMLFile + '"';
            sXSLFile = ',"' + sXSLFile + '"';
        }

        sAlert += '<script>embedPCx86("' + idMachine + '"' + sXMLFile + sXSLFile + ');</script>\n\n';
        sAlert += 'The machine should appear where the <div> is located.';
        Component.alertUser(sAlert);
        return;
    }
    Component.alertUser("Missing XML/XSL resources");
}

/**
 * Prevent the Closure Compiler from renaming functions we want to export, by adding them
 * as (named) properties of a global object.
 */
window['savePC'] = savePC;

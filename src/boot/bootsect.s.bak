; C-OS Single-Stage Bootloader
;
; The C-OS bootloader is fairly simple.
;   * Identify boot drive
;   * Setup stack
;   * Print boot messages
;   * Bring the kernel (and all the kernel needs to bootstrap) into memory
;   * Provide the kernel with the information it needs to work correctly
;   * Transfer control to the kernel
;

[org 0x7c00]                    ; bootsector loads at offset 0x7c00

; -----------------------------------------------------------------------------
; Bootloader constants
; -----------------------------------------------------------------------------
BOOT_SEGMENT    equ 0x0000
BOOT_OFFSET     equ 0x7C00
; Set the stack segment to the top of our bootloader
STACK_SEGMENT   equ ((BOOT_OFFSET + 512) / 16)
STACK_OFFSET    equ 4096        ; Give a 4k stack size
DATA_SEGMENT    equ BOOT_SEGMENT ; Set data segment to where we're loaded so we
                                 ; can implicitly access all 64K
; NOTE - KERNEL_SEGMENT:KERNEL_OFFSET must match value used with linker
KERNEL_SEGMENT  equ 0x0050      ; Segement used to load kernel
KERNEL_OFFSET   equ 0x0000      ; Offset used to load kernel
KERNEL_SIZE     equ 0x78FF      ; 30975 bytes of kernel

DISK_RETRIES    equ 3

; Disk Geometries
; https://www.syslinux.org/wiki/index.php?title=MEMDISK
;-------------------------------------------------------------------------------
;     163,840 bytes  (160K) c=40 h=1 s=8     5.25" SSSD
;     184,320 bytes  (180K) c=40 h=1 s=9     5.25" SSSD
;     327,680 bytes  (320K) c=40 h=2 s=8     5.25" DSDD
;     368,640 bytes  (360K) c=40 h=2 s=9     5.25" DSDD
;     655,360 bytes  (640K) c=80 h=2 s=8     3.5"  DSDD
;     737,280 bytes  (720K) c=80 h=2 s=9     3.5"  DSDD
;   1,222,800 bytes (1200K) c=80 h=2 s=15    5.25" DSHD
;   1,474,560 bytes (1440K) c=80 h=2 s=18    3.5"  DSHD
;   1,638,400 bytes (1600K) c=80 h=2 s=20    3.5"  DSHD (extended)
;   1,720,320 bytes (1680K) c=80 h=2 s=21    3.5"  DSHD (extended)
;   1,763,328 bytes (1722K) c=82 h=2 s=21    3.5"  DSHD (extended)
;   1,784,832 bytes (1743K) c=83 h=2 s=21    3.5"  DSHD (extended)
;   1,802,240 bytes (1760K) c=80 h=2 s=22    3.5"  DSHD (extended)
;   1,884,160 bytes (1840K) c=80 h=2 s=23    3.5"  DSHD (extended)
;   1,966,080 bytes (1920K) c=80 h=2 s=24    3.5"  DSHD (extended)
;   2,949,120 bytes (2880K) c=80 h=2 s=36    3.5"  DSED
;   3,194,880 bytes (3120K) c=80 h=2 s=39    3.5"  DSED (extended)
;   3,276,800 bytes (3200K) c=80 h=2 s=40    3.5"  DSED (extended)
;   3,604,480 bytes (3520K) c=80 h=2 s=44    3.5"  DSED (extended)
;   3,932,160 bytes (3840K) c=80 h=2 s=48    3.5"  DSED (extended)

; 160K Disk Size (See table for CHS values of different disk sizes)
DISK_CYLINDERS    equ 40
DISK_HEADS        equ 1
DISK_SECTORS      equ 8
DISK_SECTOR_SIZE  equ 512
DISK_BUFFER       equ KERNEL_OFFSET
DISK_TRACK_BYTES  equ (DISK_SECTORS * DISK_SECTOR_SIZE)
DISK_BUFFER_END   equ DISK_BUFFER + KERNEL_SIZE

; -----------------------------------------------------------------------------
; Bootloader
; -----------------------------------------------------------------------------

; Canonicalize CS:IP
jmp  BOOT_SEGMENT:canonicalized
canonicalized:

; Save the boot drive set by the bios on boot
mov  [disk_drive], dl

; Set segment registers. These values are only for the bootloader.
cli                             ; Clear interrupts
mov  ax, STACK_SEGMENT          ; Set the stack segment and offset
mov  ss, ax
mov  bp, STACK_OFFSET
mov  sp, bp
mov  ax, DATA_SEGMENT           ; Set the data segment
mov  ds, ax
mov  ax, KERNEL_SEGMENT         ; Set the kernel segment
mov  es, ax
sti

; Print bootloader message
call b_clrscr
mov  ax, msg_boot               ; Print the boot message
call b_print

; TODO: Print the available memory

; Load kernel
mov  ax, msg_load_kernel
call b_print
mov  bx, KERNEL_OFFSET          ; Read from disk and store in 0x1000
call disk_load
call KERNEL_SEGMENT:KERNEL_OFFSET ; Give control to the kernel
jmp  suspend                    ; suspend if the kernel returns control to us

; -----------------------------------------------------------------------------
; load 'dh' sectors from drive 'dl' into ES:BX
;
; Note: Since this OS is for PC/XT systems we can't use Disk functions > 05h as
; those functions are only available for ATs. This makes things difficult.
;
; PARAMETERS:
;   BX - Memory location to write to (ES:BX)
; RETURN:
;   none
; -----------------------------------------------------------------------------
disk_load:
  push ax
  push cx
  push dx

  mov ax, DISK_SECTORS          ; initialize sectors to read_data
  mov [sectors_to_read], ax
  mov  cx, DISK_RETRIES         ; countdown of read attempts
  readloop:
    ; Print loading dot
    ;mov  ah, 0x0E
    ;mov  al, 0x2E
    mov  ax, 0x2E0E             ; Print func (0x0E) Period character (0x2E)
    mov  bx, 0x0001
    int  0x10

    push cx                     ; save retry count

    ; Reset disk (dl - boot device is passed in)
    mov  ah, 0                  ; 'reset' function
    stc                         ; set carry bit, needed for some BIOS'
    int  0x13

    ; Read sectors
    mov  ah, 0x02
    mov  al, [sectors_to_read]
    ; mov  ax, (0x0200 | DISK_SECTORS)
    mov  cx, [chs_sector]       ; move packed cylinder/sector to CX
    mov  dx, [disk_drive]       ; move packed head/drive to DX
    mov  bx, [disk_dest_offset] ; move current offset to BX
    stc                         ; set carry bit, needed for some BIOS'
    int  0x13
    pop  cx                     ; restore retry count
    jnc  disk_load_continue     ; if not error (stored in the carry bit)
    loop readloop               ; if there's an error try again, up to 3 times
    jc   disk_error             ; finally, if error print message

  disk_load_continue:
    ; TODO: Fix sectors read check
    ;cmp  al, dh         ; are the read sectors reported what we expect?
    ;jne  sectors_error

    mov  cx, DISK_RETRIES       ; Reset disk retries
    mov  byte [chs_sector], 1   ; After the first cylinder/head begin reading
                                ; sectors from the begining of the track
    add  [disk_dest_offset], word DISK_TRACK_BYTES
    ; If we passed the end of the kernel then update the number of
    ; sectors to copy
    cmp  word [disk_dest_offset], DISK_BUFFER_END
    jb   not_above_kernel_end
    ; Recalculate the number of sectors to copy
    push ax
    push cx
    mov  ax, word [disk_dest_offset]
    sub  ax, KERNEL_SIZE        ; Find the # of bytes until end of kernel
    mov  cx, DISK_SECTOR_SIZE   ; Divide those bytes by sector size to get the
    div  cx                     ; number of sectors left
    mov  byte [sectors_to_read], al
    pop cx
    pop ax

  not_above_kernel_end:
    %if DISK_HEADS > 1
    xor  [chs_head], byte 1
    jnz  readloop
    %endif
    inc  byte [chs_cylinder]
    jmp  readloop

  load_done:
    pop cx
    pop ax
    ret

  disk_error:
    mov  ax, msg_disk_error
    call b_print
    call b_printnl
    mov  dh, ah             ; ah = error code, dl = disk drive of error
    call b_print_hex
    jmp  suspend
  sectors_error:
    mov  bx, msg_sectors_error
    call b_print
    jmp  suspend

%include 'vid_bios_funcs.s'

suspend:
    cli
    hlt
    jmp  suspend

; -----------------------------------------------------------------------------
; Data
; -----------------------------------------------------------------------------
; Order matters. Cylinder/sector and head/drive are packed into words together.
sectors_to_read  db 0x00
chs_sector:      db 0x02
chs_cylinder:    db 0x00
disk_drive:      db 0x00
chs_head:        db 0x00
disk_dest_offset dw KERNEL_OFFSET

msg_disk_error:      db "Disk read error", LF, CR, EOL
msg_sectors_error:   db "Incorrect number of sectors read", LF, CR, EOL
msg_load_kernel: db "Loading the kernel...", LF, CR, EOL
msg_boot:
    db LF, CR
    db 'C-OS-86 0.1 07-15-2018', LF, CR
    db 'Copyright (C) 2018, Chad Rempp', CR, LF
    db LF, CR, LF, CR, EOL

; -----------------------------------------------------------------------------
; Padding and magic number
; -----------------------------------------------------------------------------
times 510-($-$$) db 0
dw 0xaa55                       ; Magic number identifing this as a boot sector
